
.vsteensy/build/mtp-logger_T35.elf:     file format elf32-littlearm

SYMBOL TABLE:
00000000 l    d  .text	00000000 .text
00014c68 l    d  .fini	00000000 .fini
00014c6c l    d  .ARM.exidx	00000000 .ARM.exidx
1fff0000 l    d  .usbdescriptortable	00000000 .usbdescriptortable
1fff0200 l    d  .dmabuffers	00000000 .dmabuffers
1fff0398 l    d  .usbbuffers	00000000 .usbbuffers
1fff0938 l    d  .data	00000000 .data
1fff1490 l    d  .bss	00000000 .bss
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 mk20dx128.c
0000d910 l     F .text	0000000c startup_default_early_hook
0000d91c l     F .text	00000002 startup_default_late_hook
00000000 l    df *ABS*	00000000 crtstuff.c
00000410 l     F .text	00000000 __do_global_dtors_aux
1fff1490 l       .bss	00000000 completed.8605
00000434 l     F .text	00000000 frame_dummy
1fff1494 l       .bss	00000000 object.8610
00014c5c l     O .text	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 mtp-logger.ino
000005d4 l     F .text	00000002 __tcf_0
00000884 l     F .text	00000080 logg(unsigned long, char const*) [clone .part.53]
00001d00 l     F .text	00000154 _GLOBAL__sub_I__Z17usb_mtp_configurev
1fff18c0 l     O .bss	00000200 acq_rx_buffer
1fff1bc4 l     O .bss	00000002 front_
1fff1bc8 l     O .bss	00001000 tdm_rx_buffer
1fff0948 l     O .data	00000014 mfile
1fff614e l     O .bss	00000002 rear_
1fff6158 l     O .bss	00000004 check_filing(short)::to
1fff615c l     O .bss	00000004 logg(unsigned long, char const*)::to
00000000 l    df *ABS*	00000000 Storage.cpp
000020b0 l     F .text	000000a0 File::invalidate() [clone .isra.1]
00002644 l     F .text	00000084 MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]
00003acc l     F .text	00000036 MTPStorage_SD::ScanAll(unsigned long) [clone .part.7] [clone .constprop.12]
00003b04 l     F .text	00000030 MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long) [clone .part.8] [clone .constprop.13]
00004330 l     F .text	000000b2 MTPStorage_SD::DeleteObject(unsigned long) [clone .part.9] [clone .constprop.11]
00004ee0 l     F .text	00000a4c mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]
00000000 l    df *ABS*	00000000 MTP.cpp
00005b80 l     F .text	00000064 MTPD::write(char const*, int) [clone .part.2]
00005c8c l     F .text	000000bc MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]
00006e90 l     F .text	0000002c MTPD::setObjectPropValue(unsigned long, unsigned long) [clone .part.6]
00014424 l     O .text	00000028 supported_op
0001444c l     O .text	00000010 propertyList
000144ac l     O .text	00000008 supported_events
00000000 l    df *ABS*	00000000 SPI.cpp
00007780 l     F .text	000001f8 SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]
00000000 l    df *ABS*	00000000 Time.cpp
00008008 l     F .text	00000018 refreshCache(long) [clone .part.0]
1fff6168 l     O .bss	00000004 cacheTime
1fff616c l     O .bss	00000007 tm
1fff6174 l     O .bss	00000004 sysTime
1fff6178 l     O .bss	00000001 Status
1fff6180 l     O .bss	00000004 prevMillis
1fff09d0 l     O .data	00000004 syncInterval
00014668 l     O .text	0000000c monthDays
1fff6184 l     O .bss	00000004 nextSyncTime
00000000 l    df *ABS*	00000000 FsCache.cpp
000081a0 l     F .text	00000046 FsCache::sync() [clone .part.0]
00000000 l    df *ABS*	00000000 ExFatFile.cpp
00000000 l    df *ABS*	00000000 ExFatPartition.cpp
00008c0c l     F .text	00000034 ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]
00008c40 l     F .text	0000002a ExFatPartition::fatPut(unsigned long, unsigned long) [clone .part.4]
00000000 l    df *ABS*	00000000 upcase.cpp
00000000 l    df *ABS*	00000000 ExFatFileWrite.cpp
00000000 l    df *ABS*	00000000 FatFile.cpp
00009abc l     F .text	00000032 FatFile::openRoot(FatVolume*) [clone .part.38]
00009bdc l     F .text	00000094 FatFile::sync() [clone .part.42]
00000000 l    df *ABS*	00000000 FatPartition.cpp
00000000 l    df *ABS*	00000000 FatFileLFN.cpp
0000abc4 l     F .text	00000028 lfnGetChar(DirLfn_t*, unsigned char)
00000000 l    df *ABS*	00000000 FatFileSFN.cpp
00000000 l    df *ABS*	00000000 FsFile.cpp
00000000 l    df *ABS*	00000000 FsVolume.cpp
00000000 l    df *ABS*	00000000 FsNew.cpp
00000000 l    df *ABS*	00000000 SdSpiCard.cpp
0000b804 l     F .text	00000018 SdSpiCard::spiStart() [clone .part.6] [clone .constprop.26]
0000b81c l     F .text	00000022 SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]
00000000 l    df *ABS*	00000000 SdioTeensy.cpp
0000c10c l     F .text	00000030 sdIrs()
0000c13c l     F .text	00000018 isBusyCommandComplete()
0000c154 l     F .text	00000010 isBusyCommandInhibit()
0000c164 l     F .text	00000014 isBusyDat()
0000c178 l     F .text	0000000c isBusyDMA()
0000c184 l     F .text	00000014 isBusyFifoRead()
0000c198 l     F .text	00000014 isBusyFifoWrite()
0000c1ac l     F .text	00000018 isBusyTransferComplete()
0000c1c4 l     F .text	000000cc setSdclk(unsigned long)
0000c2f4 l     F .text	00000028 waitTimeout(bool (*)())
0000c31c l     F .text	0000004c yieldTimeout(bool (*)())
0000c398 l     F .text	0000005c cardCommand(unsigned long, unsigned long)
0000c3f4 l     F .text	0000002c isBusyCMD13()
0000c440 l     F .text	00000064 readReg16(unsigned long, void*)
0000c4a4 l     F .text	00000020 waitDmaStatus() [clone .part.4]
0000c4c4 l     F .text	000000b4 rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)
0000c6d0 l     F .text	00000058 waitTransferComplete() [clone .part.8]
0000caa4 l     F .text	000000ac cardCMD6(unsigned long, unsigned char*)
1fff6198 l     O .bss	00000001 m_version2
1fff619c l     O .bss	00000010 m_cid
1fff61ac l     O .bss	00000004 m_busyFcn
1fff61b0 l     O .bss	00000001 m_highCapacity
1fff61b4 l     O .bss	00000004 m_ocr
1fff61b8 l     O .bss	00000004 m_rca
1fff61bc l     O .bss	00000001 m_transferActive
1fff61c0 l     O .bss	00000004 m_irqstat
1fff09d4 l     O .data	00000001 m_errorCode
1fff61c4 l     O .bss	00000001 m_initDone
1fff61c8 l     O .bss	00000010 m_csd
1fff61d8 l     O .bss	00000001 m_dmaBusy
1fff61dc l     O .bss	00000004 m_sdClkKhz
1fff61e0 l     O .bss	00000004 m_errorLine
00000000 l    df *ABS*	00000000 SdSpiTeensy3.cpp
00000000 l    df *ABS*	00000000 SdSpiChipSelect.cpp
00000000 l    df *ABS*	00000000 SD.cpp
0000d3e0 l     F .text	00000064 _GLOBAL__sub_I_SD
00000000 l    df *ABS*	00000000 memcpy-armv7m.o
00000000 l    df *ABS*	00000000 usb_serial.c
1fff669d l     O .bss	00000001 tx_noautoflush
1fff66a0 l     O .bss	00000004 tx_packet
1fff66a4 l     O .bss	00000001 transmit_previous_timeout
1fff66a8 l     O .bss	00000004 rx_packet
00000000 l    df *ABS*	00000000 usb_desc.c
1fff09dc l     O .data	00000012 device_descriptor
1fff0a08 l     O .data	00000069 config_descriptor
00000000 l    df *ABS*	00000000 nonstd.c
00000000 l    df *ABS*	00000000 pins_teensy.c
0000dd6c l     F .text	0000004c digitalWrite.part.1
0000ddb8 l     F .text	00000078 pinMode.part.2
00000000 l    df *ABS*	00000000 usb_mem.c
1fff0ac8 l     O .data	00000004 usb_buffer_available
00000000 l    df *ABS*	00000000 usb_dev.c
1fff66b4 l     O .bss	00000004 ep0_tx_ptr
1fff66b8 l     O .bss	00000018 rx_last
1fff66d0 l     O .bss	00000002 ep0_tx_len
1fff66d4 l     O .bss	00000040 ep0_rx0_buf
1fff6714 l     O .bss	00000018 rx_first
1fff672c l     O .bss	00000001 ep0_tx_data_toggle
1fff6730 l     O .bss	00000040 ep0_rx1_buf
1fff6770 l     O .bss	00000018 tx_first
1fff0000 l     O .usbdescriptortable	000000e0 table
1fff6788 l     O .bss	00000018 tx_last
1fff67a0 l     O .bss	00000008 setup
1fff67a8 l     O .bss	00000001 ep0_tx_bdt_bank
1fff67ac l     O .bss	00000008 reply_buffer
1fff67b8 l     O .bss	00000006 tx_state
00000000 l    df *ABS*	00000000 yield.cpp
1fff67be l     O .bss	00000001 yield::running
00000000 l    df *ABS*	00000000 DMAChannel.cpp
00000000 l    df *ABS*	00000000 EventResponder.cpp
00000000 l    df *ABS*	00000000 usb_inst.cpp
00000000 l    df *ABS*	00000000 Print.cpp
00000000 l    df *ABS*	00000000 main.cpp
00000000 l    df *ABS*	00000000 serialEvent.cpp
00000000 l    df *ABS*	00000000 new.cpp
00000000 l    df *ABS*	00000000 analog.c
1fff67f1 l     O .bss	00000001 calibrating
1fff0ae1 l     O .data	00000001 analog_config_bits
1fff67f2 l     O .bss	00000001 analog_reference_internal
1fff0ae2 l     O .data	00000001 analog_num_average
00000000 l    df *ABS*	00000000 atexit_arm.cc
00000000 l    df *ABS*	00000000 _arm_addsubdf3.o
00000000 l    df *ABS*	00000000 _arm_muldivdf3.o
00000000 l    df *ABS*	00000000 _arm_cmpdf2.o
00000000 l    df *ABS*	00000000 _arm_unorddf2.o
00000000 l    df *ABS*	00000000 _arm_fixdfsi.o
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 cxa_atexit.c
00000000 l    df *ABS*	00000000 efgcvt.c
00000000 l    df *ABS*	00000000 errno.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 lib_a-memchr.o
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 strlcat.c
00000000 l    df *ABS*	00000000 strlcpy.c
00000000 l    df *ABS*	00000000 lib_a-strlen.o
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 vfprintf.c
000149dc l     O .text	00000010 zeroes.7258
00014a2c l     O .text	00000010 blanks.7257
00000000 l    df *ABS*	00000000 vdprintf.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
000125b4 l     F .text	00000014 register_fini
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 dtoa.c
000125d4 l     F .text	00000128 quorem
00000000 l    df *ABS*	00000000 ecvtbuf.c
00000000 l    df *ABS*	00000000 fini.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 localeconv.c
00000000 l    df *ABS*	00000000 mprec.c
00014c40 l     O .text	0000000c p05.6087
00000000 l    df *ABS*	00000000 vfprintf.c
00000000 l    df *ABS*	00000000 vasnprintf.c
00000000 l    df *ABS*	00000000 impure.c
1fff0ae8 l     O .data	00000428 impure_data
00000000 l    df *ABS*	00000000 locale.c
00000000 l    df *ABS*	00000000 ctype_.c
00000000 l    df *ABS*	00000000 c:/users/zimme/documents/arduino-1.8.15/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/crti.o
00000000 l    df *ABS*	00000000 c:/users/zimme/documents/arduino-1.8.15/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/crtn.o
00000000 l    df *ABS*	00000000 FsDateTime.cpp
00000000 l    df *ABS*	00000000 ExFatVolume.cpp
00000000 l    df *ABS*	00000000 FatVolume.cpp
00000000 l    df *ABS*	00000000 avr_emulation.cpp
00000000 l    df *ABS*	00000000 HardwareSerial.cpp
00000000 l    df *ABS*	00000000 reent.c
00000000 l    df *ABS*	00000000 
1fff1490 l       .bss	00000000 __bss_start__
1fff6844 l       .bss	00000000 __bss_end__
00000000 l       *UND*	00000000 software_init_hook
00000000 l       *UND*	00000000 hardware_init_hook
00000000 l       *UND*	00000000 __stack
0000d908  w    F .text	00000006 adc0_isr
000024e8 g     F .text	0000015c MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)
000013b8 g     F .text	00000060 pushData(unsigned long*)
0000f990 g     F .text	0000002c .hidden __aeabi_dcmpun
0000d664 g     F .text	0000001c usb_serial_available
0000f954 g     F .text	00000012 .hidden __aeabi_dcmple
00010a90 g     F .text	000000ba strcpy
0000f890 g     F .text	0000007a .hidden __cmpdf2
0000ca1c g     F .text	00000088 SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)
0000ebc4  w    F .text	000000ec yield
1fff6154 g     O .bss	00000004 acq_miss
0000a648 g     F .text	00000218 FatFile::write(void const*, unsigned int)
0000f890 g     F .text	0000007a .hidden __eqdf2
0000b7f0  w    F .text	00000002 SdSpiCard::~SdSpiCard()
0000ef28 g     F .text	000000ba Print::printNumber64(unsigned long long, unsigned char, unsigned char)
000086e0 g     F .text	000003dc ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)
1fff1ac0 g     O .bss	00000104 storage
1fff09f0 g     O .data	00000018 usb_string_manufacturer_name_default
1fff6164 g     O .bss	00000004 tx_event_packet
0000a5d0 g     F .text	00000076 FatFile::truncate()
00001418 g     F .text	00000064 acq_isr()
00002938 g     F .text	0000003c MTPStorage_SD::GetObjectInfo(unsigned long, char*, unsigned long*, unsigned long*, unsigned short*)
0000f400 g     F .text	0000005a .hidden __floatdidf
1fff14b0 g     O .bss	00000008 dma
0000d8c0  w    F .text	00000048 hard_fault_isr
0000d908  w    F .text	00000006 dma_ch6_isr
0000194c g     F .text	000000b4 do_logger(unsigned short, short)
1fff6188 g     O .bss	00000004 FsDateTime::callback
0000eedc g     F .text	00000020 Print::println()
0000d908  w    F .text	00000006 uart0_lon_isr
000085e0 g     F .text	000000fe ExFatFile::seekSet(unsigned long long)
00013534 g     F .text	00000100 fcvtbuf
0000e184 g     F .text	00000084 usb_rx_memory
0000b7d4  w    F .text	00000004 SdSpiCard::errorCode() const
000004b0  w    F .text	0000000c File::flush()
000076e0 g     F .text	00000018 usb_init_events
0000d908  w    F .text	00000006 dma_ch8_isr
0001063c g     F .text	00000002 __malloc_unlock
00000630  w    F .text	000000c0 SDFile::openNextFile(unsigned char)
1fff6194 g     O .bss	00000004 FsVolume::m_cwv
00009ea4 g     F .text	000000be FatFile::open(FatFile*, char const*, int)
0000f000 g     F .text	000000e0 analog_init
0000e208 g     F .text	00000084 usb_tx
0000d908  w    F .text	00000006 portcd_isr
00012464 g     F .text	0000004a _vdprintf_r
00007da0 g     F .text	000000b0 SPIClass::setSCK(unsigned char)
00014134  w    O .text	00000060 vtable for SDFile
000104d4 g     F .text	000000c6 memmove
00003b34 g     F .text	00000046 MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long)
0000d114 g     F .text	00000068 SdioCard::stopTransmission(bool)
000138e4 g     F .text	0000004c _Balloc
0000d908  w    F .text	00000006 can1_rx_warn_isr
00007730 g     F .text	0000002c MTPD::send_Event(unsigned short)
00001e70  w    F .text	00000004 MTPStorage_SD::get_FSCount()
00014c74 g       .ARM.exidx	00000000 __exidx_end
0000d908  w    F .text	00000006 dma_error_isr
0000a9bc g     F .text	0000003c FatPartition::freeChain(unsigned long)
1fff67d4 g     O .bss	00000001 EventResponder::runningFromYield
0000d328 g     F .text	0000001a SdSpiArduinoDriver::receive()
0000b9c8 g     F .text	00000096 SdSpiCard::cardCommand(unsigned char, unsigned long)
1fff614c g     O .bss	00000002 maxCount
0000d908  w    F .text	00000006 i2c0_isr
0000eeb0 g     F .text	0000002c Print::write(unsigned char const*, unsigned int)
0000f880 g     F .text	0000008a .hidden __gtdf2
0000abec g     F .text	00000024 FatFile::lfnChecksum(unsigned char*)
0000fdb4 g     F .text	0000000c __errno
00000ca0  w    F .text	00000026 SDFile::isDirectory()
0000d908  w    F .text	00000006 portd_isr
0000d908  w    F .text	00000006 enet_error_isr
00001638 g     F .text	00000088 makeFilename(char*)
00000eb0  w    F .text	00000028 File::~File()
1fff67c4 g     O .bss	00000004 EventResponder::firstInterrupt
0000602c g     F .text	0000006e MTPD::GetObjectHandles(unsigned long, unsigned long)
0000b7f4  w    F .text	0000000e SdSpiCard::~SdSpiCard()
0000b560 g     F .text	00000078 FsBaseFile::FsBaseFile(FsBaseFile const&)
0000d908  w    F .text	00000006 tpm1_isr
0000909c g     F .text	00000018 ExFatPartition::rootLength()
0000b7d8  w    F .text	00000004 SdSpiCard::errorData() const
0000eea0  w    F .text	00000008 usb_serial_class::write(unsigned char const*, unsigned int)
0001479c g     O .text	00000200 digital_pin_to_info_PGM
1fff6840 g     O .bss	00000004 errno
0000bc74 g     F .text	0000004c SdSpiCard::readOCR(unsigned long*)
0000d344 g     F .text	00000020 SdSpiArduinoDriver::receive(unsigned char*, unsigned int)
0000b158 g     F .text	00000390 FatFile::open(FatFile*, fname_t*, int)
00008e90 g     F .text	00000012 ExFatPartition::fatGet(unsigned long, unsigned long*)
00014c74 g       .ARM.exidx	00000000 _etext
00007aac g     F .text	00000134 _spi_dma_rxISR0()
1fff1490 g       .bss	00000000 _sbss
0000d3d0 g     F .text	00000006 sdCsInit(unsigned char)
0000f91c g     F .text	00000010 .hidden __aeabi_cdcmple
0000c29c g     F .text	0000000c SdioCard::errorData() const
00001e84 g     F .text	0000000c MTPStorage_SD::totalSize(unsigned long)
00004ca0 g     F .text	000000fe MTPStorage_SD::copy(unsigned long, unsigned long, unsigned long)
0000c94c g     F .text	000000d0 SdioCard::writeSector(unsigned long, unsigned char const*)
0000d908  w    F .text	00000006 porte_isr
00001a00 g     F .text	000000a0 loop
0000d908  w    F .text	00000006 portb_isr
0000d908  w    F .text	00000006 spi1_isr
00006518 g     F .text	00000144 MTPD::GetStorageInfo(unsigned long)
0000d908  w    F .text	00000006 uart3_status_isr
00008344 g     F .text	000000c4 ExFatFile::parsePathName(char const*, ExName_t*, char const**)
0000d908  w    F .text	00000006 mcm_isr
0000cee4 g     F .text	000000cc SdioCard::readData(unsigned char*)
0000b90c g     F .text	00000080 SdSpiCard::readData(unsigned char*, unsigned int)
1fff67c8 g     O .bss	00000004 EventResponder::lastInterrupt
0000d908  w    F .text	00000006 uart1_status_isr
0000b5d8 g     F .text	00000028 FsBaseFile::close()
0000d444 g     F .text	000001a6 memcpy
0000d908  w    F .text	00000006 randnum_isr
0000f90c g     F .text	00000020 .hidden __aeabi_cdrcmple
00000494  w    F .text	0000000c File::available()
00003b7c g     F .text	000007b4 MTPStorage_SD::removeFile(unsigned long, char*)
000032b4 g     F .text	00000816 MTPStorage_SD::ScanDir(unsigned long, unsigned long)
0000154c g     F .text	00000048 file_writeHeader()
00008ec8 g     F .text	00000080 ExFatPartition::freeChain(unsigned long)
00002c3c g     F .text	0000046c MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)
0000a120 g     F .text	0000002a FatFile::peek()
00010d80 g     F .text	000016e4 _svfprintf_r
0000f390 g     F .text	00000022 .hidden __floatsidf
00000600  w    F .text	00000014 SDFile::whoami()
1fff14ac  w    O .bss	00000001 SDFile::name()::zeroterm
1fff66b0 g     O .bss	00000004 systick_millis_count
0000f888 g     F .text	00000082 .hidden __ltdf2
000096c8 g     F .text	000000aa ExFatFile::rename(ExFatFile*, char const*)
0000d8c0  w    F .text	00000048 bus_fault_isr
000009b4  w    F .text	00000044 SDFile::truncate(unsigned long long)
00007068 g     F .text	00000678 MTPD::loop()
0000d908  w    F .text	00000006 watchdog_isr
0000fa0c g     F .text	00000000 .hidden __aeabi_uldivmod
0000d908  w    F .text	00000006 i2c1_isr
1fff67b4 g     O .bss	00000001 usb_configuration
0000d908  w    F .text	00000006 dma_ch11_isr
00000474  w    F .text	00000006 SdCardInterface::status()
0000d1fc g     F .text	0000002c SdioCard::syncDevice()
0000c7b4 g     F .text	0000009c SdioCard::writeData(unsigned char const*)
00000000  w      *UND*	00000000 __fini_array_end
1fff67d5 g     O .bss	00000001 SPCRemulation::pinout
00000dd4  w    F .text	00000058 StreamFile<FsBaseFile, unsigned long long>::available()
0000a14c g     F .text	00000040 FatFile::readDirCache(bool)
0000d908  w    F .text	00000006 i2c2_isr
1fff6150 g     O .bss	00000004 loop_count
1fff09f0  w    O .data	00000018 usb_string_manufacturer_name
1fff6834 g     O .bss	0000000c usb_rx_byte_count_data
0000d908  w    F .text	00000006 pit1_isr
1fff0a74 g     O .data	00000008 usb_string_mtp
0000fe10 g     F .text	00000010 malloc
0000d908  w    F .text	00000006 dma_ch4_isr
0000d908  w    F .text	00000006 software_isr
000014d4 g     F .text	00000078 do_menu(short)
000140b0  w    O .text	00000024 vtable for FsFile
0000d908  w    F .text	00000006 dma_ch7_isr
00007764  w    F .text	0000001c EventResponder::triggerEvent(int, void*)
00014b50 g     O .text	000000c8 __mprec_tens
0000eb00 g     F .text	000000c4 usb_init
1fff6160 g     O .bss	00000004 sessionID_
0000b7ec  w    F .text	00000004 SdSpiCard::type() const
0000d908  w    F .text	00000006 lptmr_isr
00000e2c  w    F .text	00000084 SDFile::seek(unsigned long long, int)
1fff67fc g     O .bss	00000004 __malloc_top_pad
0000de4c g     F .text	00000024 rtc_set
1fff0998 g     O .data	00000038 SPI1
0000b840 g     F .text	0000007a SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)
00009774 g     F .text	000000e2 ExFatFile::truncate()
1fff0938 g     O .data	00000000 .hidden __dso_handle
0000f370 g     F .text	0000001e .hidden __aeabi_ui2d
000138c8 g     F .text	0000001c _localeconv_r
1fff0940 g     O .data	00000008 sd_str
0000de30 g     F .text	00000010 attachInterruptVector
0000d2f0 g     F .text	00000038 SdSpiArduinoDriver::deactivate()
00013a60 g     F .text	00000012 __i2b
1fff0938 g       .data	00000000 _sdata
1fff093c g     O .data	00000004 t_on
0000050c  w    F .text	0000000c File::operator bool()
0000fa3c g     F .text	000002e2 .hidden __udivmoddi4
0000635c g     F .text	000001bc MTPD::getObjectPropValue(unsigned long, unsigned long)
0000f0ec g     F .text	00000000 .hidden __aeabi_drsub
00009af0 g     F .text	00000034 FatFile::addCluster()
00010a20 g     F .text	00000024 _sbrk_r
0000bcc0 g     F .text	0000003e SdSpiCard::readRegister(unsigned char, void*)
0000c378 g     F .text	00000020 SdioCard::type() const
00000488  w    F .text	0000000c File::write(void const*, unsigned int)
00000198 g     F .text	000001e4 ResetHandler
0000d5ec g     F .text	00000048 usb_serial_getchar
0000d908  w    F .text	00000006 can1_bus_off_isr
0000d908  w    F .text	00000006 ftm2_isr
00000968  w    F .text	0000004c SDFile::name()
1fff6828 g     O .bss	00000008 usb_cdc_line_coding
0000de70 g     F .text	0000000a digitalWrite
1fff67cc g     O .bss	00000004 EventResponder::lastYield
0000d908  w    F .text	00000006 uart5_status_isr
0000d908  w    F .text	00000006 lpuart0_status_isr
0000831c g     F .text	00000028 ExFatFile::openRoot(ExFatVolume*)
0001472c g     O .text	00000006 usb_endpoint_config_table
0000d908  w    F .text	00000006 dma_ch9_isr
00000804  w    F .text	00000038 StreamFile<FsBaseFile, unsigned long long>::read()
0000d908  w    F .text	00000006 pit2_isr
0000f940 g     F .text	00000012 .hidden __aeabi_dcmplt
0001460c g     O .text	0000005c SPISettings::ctar_clock_table
1fff67f8 g     O .bss	00000004 __malloc_max_sbrked_mem
00000c04  w    F .text	0000001a SDFile::position()
0000de7c g     F .text	0000000a pinMode
0000bfc0 g     F .text	00000042 SdSpiCard::writeStop()
000030a8 g     F .text	00000160 MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)
0000e0d0 g     F .text	0000004c usb_free
0000d908  w    F .text	00000006 i2c3_isr
0000f3b4 g     F .text	0000003a .hidden __extendsfdf2
0000f6b0 g     F .text	000001d0 .hidden __aeabi_ddiv
0000f0f8 g     F .text	00000276 .hidden __adddf3
000062f0 g     F .text	0000006c MTPD::getObjectPropsSupported(unsigned long)
00005be4 g     F .text	000000a8 MTPD::writestring(char const*)
0000c058 g     F .text	00000032 SdSpiCard::writeData(unsigned char const*)
000004a0  w    F .text	00000010 File::peek()
0000a9f8 g     F .text	000000b0 FatPartition::freeClusterCount()
00000cc8  w    F .text	000000d0 SDClass::open(char const*, unsigned char)
00014c6c g       .ARM.exidx	00000000 __exidx_start
0000f45c g     F .text	00000254 .hidden __aeabi_dmul
00000788  w    F .text	0000000c DMAChannel::~DMAChannel()
0000beb8 g     F .text	00000050 SdSpiCard::writeStart(unsigned long)
0000d908  w    F .text	00000006 pit0_isr
1fff67d0 g     O .bss	00000004 EventResponder::firstYield
000149c8 g     O .text	00000004 _global_impure_ptr
00001e9c g     F .text	00000080 MTPStorage_SD::write(char const*, unsigned long)
0000d908  w    F .text	00000006 can1_error_isr
00000850  w    F .text	00000034 StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)
00010640 g     F .text	000003de _realloc_r
00000c3c  w    F .text	00000018 SDFile::read(void*, unsigned int)
0000fdc0 g     F .text	00000050 __libc_init_array
1fff6844 g       .bss	00000000 __bss_end
0000da18 g     F .text	00000354 dtostrf
00000a94  w    F .text	00000044 SDFile::rewindDirectory()
0000d908  w    F .text	00000006 can0_wakeup_isr
00008bbc g     F .text	0000000e ExFatFile::open(ExFatVolume*, char const*, int)
0000c2a8 g     F .text	0000001c SdioCard::readCID(CID*)
000094ac g     F .text	000000e6 ExFatFile::addDirCluster()
0000d908  w    F .text	00000006 flash_cmd_isr
00004eac g     F .text	00000034 mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*)
0000c004 g     F .text	00000052 SdSpiCard::writeData(unsigned char, unsigned char const*)
00014c18 g     O .text	00000028 __mprec_bigtens
0000ee88  w    F .text	00000004 usb_serial_class::clear()
0000f370 g     F .text	0000001e .hidden __floatunsidf
0000d908  w    F .text	00000006 uart2_status_isr
0000d920 g     F .text	0000002c _sbrk
00013cf4 g     F .text	00000042 __mcmp
000043f8 g     F .text	000008a8 mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)
00014194  w    O .text	00000028 vtable for SDClass
000005c0  w    F .text	00000012 SDFile::operator bool()
1fff09d8 g     O .data	00000004 __brkval
1fff66ac g     O .bss	00000001 usb_cdc_line_rtsdtr
00001aa0 g     F .text	0000019c acq_init(long)
0000d878 g     F .text	00000048 usb_serial_flush_callback
00014c4c g     F .text	00000000 _init
00009bbc g     F .text	0000001e FatFile::cacheDirEntry(unsigned char)
1fff1bc6 g     O .bss	00000002 state
0000d908  w    F .text	00000006 svcall_isr
00000904  w    F .text	00000062 SDClass::remove(char const*)
00000614  w    F .text	0000001c SDFile::close()
0000d908  w    F .text	00000006 dma_ch15_isr
00000fe4  w    F .text	0000005c SDFile::~SDFile()
00008120 g     F .text	00000020 day()
0000d908  w    F .text	00000006 uart1_error_isr
00013634 g     F .text	00000028 __libc_fini_array
0000d908  w    F .text	00000006 usbhs_phy_isr
0000d2a0 g     F .text	00000050 SdSpiArduinoDriver::begin(SdSpiConfig)
1fff6844 g       .bss	00000000 _ebss
0000c8c4 g     F .text	00000088 SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)
00005d48 g     F .text	0000027c MTPD::WriteDescriptor()
1fff095c g     O .data	00000004 propertyListNum
00000d98  w    F .text	00000014 StreamFile<FsBaseFile, unsigned long long>::flush()
000139c4 g     F .text	00000040 __hi0bits
0000f9bc g     F .text	0000004e .hidden __fixdfsi
00009594 g     F .text	0000005a ExFatFile::mkdir(ExFatFile*, ExName_t*)
0000d908 g     F .text	00000006 unused_isr
00005fc4 g     F .text	00000068 MTPD::WriteStorageIDs()
0000d908  w    F .text	00000006 spi0_isr
0000d908  w    F .text	00000006 dma_ch3_isr
0000d3dc  w    F .text	00000002 SDClass::~SDClass()
0000592c g     F .text	00000214 MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)
00000788  w    F .text	0000000c DMAChannel::~DMAChannel()
1fff16bc g     O .bss	00000200 diskBuffer
1fff2bc8 g     O .bss	00000970 sdx
00000eb0  w    F .text	00000028 File::~File()
00001040 g     F .text	00000378 storage_configure()
00008160 g     F .text	00000024 year()
0000effc g     F .text	00000004 operator delete(void*, unsigned int)
0000d908  w    F .text	00000006 flash_error_isr
0000f0f8 g     F .text	00000276 .hidden __aeabi_dadd
0000f888 g     F .text	00000082 .hidden __ledf2
0000d908  w    F .text	00000006 uart5_error_isr
0000d908  w    F .text	00000006 rtc_seconds_isr
00014578 g     O .text	00000094 SPIClass::spi0_hardware
0000d908  w    F .text	00000006 pdb_isr
00013ba4 g     F .text	000000a0 __pow5mult
0000a360 g     F .text	0000005c FatFile::rmdir()
0000f3f0 g     F .text	0000006a .hidden __aeabi_ul2d
0000d8c0  w    F .text	00000048 usage_fault_isr
0000d908  w    F .text	00000006 dac1_isr
00000000 g     O .text	00000198 _VectorsFlash
0000a938 g     F .text	00000082 FatPartition::allocateCluster(unsigned long, unsigned long*)
0000d908  w    F .text	00000006 dma_ch14_isr
00000a48  w    F .text	0000004c SDClass::exists(char const*)
00000000  w      *UND*	00000000 __deregister_frame_info
1fff6830 g     O .bss	00000004 usb_cdc_line_rtsdtr_millis
0000ee78 g     F .text	00000010 systick_isr
0000d908  w    F .text	00000006 rtc_alarm_isr
0000052c  w    F .text	0000000c File::isDirectory()
0000b4e8 g     F .text	00000076 FatFile::getSFN(char*)
0000bdf8 g     F .text	0000006c SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)
0000d908  w    F .text	00000006 dma_ch2_isr
1fff0ad0 g     O .data	00000010 Serial
0000d908  w    F .text	00000006 ftm1_isr
000004c8  w    F .text	00000016 File::seek(unsigned long long, int)
0000eea8  w    F .text	00000006 usb_serial_class::write(unsigned char)
0000b680 g     F .text	0000005e FsBaseFile::openNext(FsBaseFile*, int)
0000d910  w    F .text	0000000c startup_early_hook
0000c08c g     F .text	00000064 SdSpiCard::writeSingle(unsigned long, unsigned char const*)
0000d908  w    F .text	00000006 dma_ch13_isr
00009148 g     F .text	0000008c ExFatFile::addCluster()
000140d4  w    O .text	00000060 vtable for File
0000d908  w    F .text	00000006 uart2_error_isr
00000bb0  w    F .text	00000052 SDClass::usedSize()
0000d634 g     F .text	00000030 usb_serial_peekchar
0000f97c g     F .text	00000012 .hidden __aeabi_dcmpgt
00002150 g     F .text	00000002 mtp_yield()
000103d0 g     F .text	00000000 memchr
0000a8d0 g     F .text	00000066 FatPartition::fatPut(unsigned long, unsigned long)
1fff0ab0 g     O .data	00000016 usb_string_serial_number_default
0000d8c0 g     F .text	00000048 fault_isr
000136f8 g     F .text	000001d0 _free_r
0000c728 g     F .text	0000008c SdioCard::readStop()
000081e8 g     F .text	00000060 FsCache::get(unsigned long, unsigned char)
0000f968 g     F .text	00000012 .hidden __aeabi_dcmpge
0000d908  w    F .text	00000006 usb_charge_isr
00004da0 g     F .text	0000010a MTPStorage_SD::CopyFiles(unsigned long, unsigned long, unsigned long)
0000ee98  w    F .text	00000004 usb_serial_class::flush()
0000d908  w    F .text	00000006 cmt_isr
0000f0f4 g     F .text	0000027a .hidden __aeabi_dsub
0000aaa8 g     F .text	0000011a FatPartition::init(BlockDeviceInterface*, unsigned char)
0000d908  w    F .text	00000006 usbhs_isr
00009c90 g     F .text	0000014e FatFile::mkdir(FatFile*, fname_t*)
1fff148c g     O .data	00000004 __malloc_sbrk_base
0000ee90  w    F .text	00000004 usb_serial_class::read()
0000d908  w    F .text	00000006 ftm3_isr
00000570  w    F .text	0000000c File::rewindDirectory()
0000d908  w    F .text	00000006 tsi0_isr
0000af78 g     F .text	00000128 FatFile::remove()
0000f3f0 g     F .text	0000006a .hidden __floatundidf
0000d94c  w    F .text	00000002 __cxa_pure_virtual
00013c44 g     F .text	000000ae __lshift
00009de0 g     F .text	000000c2 FatFile::mkdir(FatFile*, char const*, bool)
0000d908  w    F .text	00000006 spi2_isr
000090b4 g     F .text	00000058 exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)
00013f08 g     F .text	00000100 __ssprint_r
00014008 g     F .text	0000005e _vasnprintf_r
0000eff4  w    F .text	00000002 serialEvent()
1fff672d g     O .bss	00000001 usb_reboot_timer
00012510 g     F .text	000000a4 __register_exitproc
00008abc g     F .text	000000fe ExFatFile::open(ExFatFile*, char const*, int)
00010ba0 g     F .text	0000002c strlcpy
00008184 g     F .text	0000001c setSyncProvider(long (*)())
00010cdc g     F .text	000000a0 strncmp
000016c0 g     F .text	00000148 checkPath(unsigned short, char*)
000095f0 g     F .text	000000d6 ExFatFile::mkdir(ExFatFile*, char const*, bool)
0000d680 g     F .text	00000038 usb_serial_flush_input
00008f48 g     F .text	00000072 ExFatPartition::freeClusterCount()
00002b28 g     F .text	00000064 MTPStorage_SD::ConstructFilename(int, char*, int)
00013a74 g     F .text	00000130 __multiply
1fff18bc g     O .bss	00000004 acq_count
0000d7c0 g     F .text	00000018 usb_serial_putchar
0000001f g       *ABS*	00000000 _teensy_model_identifier
1fff6800 g     O .bss	00000028 __malloc_current_mallinfo
00013e4c g     F .text	000000ba __d2b
1fff67d8 g     O .bss	00000018 HardwareSerial::s_serials_with_serial_events
0000d908  w    F .text	00000006 can0_bus_off_isr
0000c368  w    F .text	0000000e SdioCard::~SdioCard()
00001e74  w    F .text	00000008 MTPStorage_SD::get_FSName(unsigned long)
0000826c g     F .text	000000ae ExFatFile::getName(char*, unsigned int)
000015f4 g     F .text	00000044 printTimestamp(unsigned long)
1fff67a9 g     O .bss	00000001 usb_rx_memory_needed
0000c850 g     F .text	00000074 SdioCard::writeStart(unsigned long)
0000e28c g     F .text	00000874 usb_isr
0000fd84 g     F .text	0000000c __cxa_atexit
00008408 g     F .text	000001a8 ExFatFile::read(void*, unsigned int)
0000f390 g     F .text	00000022 .hidden __aeabi_i2d
00000c54  w    F .text	00000018 SDFile::peek()
00008248 g     F .text	0000000e FsCache::sync()
1fff0960 g     O .data	00000038 SPI
00010470 g     F .text	00000062 memcmp
0001499c  w    O .text	00000028 vtable for usb_serial_class
0000d364 g     F .text	00000016 SdSpiArduinoDriver::send(unsigned char)
0000d908  w    F .text	00000006 uart3_error_isr
00006d60 g     F .text	0000007c MTPD::GetObject(unsigned long)
0000d3d8 g     F .text	00000004 sdCsWrite(unsigned char, bool)
0000fd20  w    F .text	00000002 .hidden __aeabi_ldiv0
000092ac g     F .text	0000005a ExFatFile::rmdir()
0000d908  w    F .text	00000006 porta_isr
0000665c g     F .text	000006e6 MTPD::getObjectPropDesc(unsigned long, unsigned long)
0000f6b0 g     F .text	000001d0 .hidden __divdf3
1fff0398 g     O .usbbuffers	000005a0 usb_buffer_memory
0000bd10 g     F .text	00000098 SdSpiCard::sectorCount()
0000d908  w    F .text	00000006 low_voltage_isr
00001e80 g     F .text	00000004 MTPStorage_SD::has_directories(unsigned long)
1fff1080 g     O .data	00000408 __malloc_av_
0000d908  w    F .text	00000006 can0_error_isr
0000df68 g     F .text	00000128 _init_Teensyduino_internal_
0000083c  w    F .text	00000014 SDFile::flush()
0000f45c g     F .text	00000254 .hidden __muldf3
0000d820 g     F .text	00000058 usb_serial_flush_output
0000d908  w    F .text	00000006 dma_ch12_isr
00010638 g     F .text	00000002 __malloc_lock
00000000  w      *UND*	00000000 __fini_array_start
0000ad2c g     F .text	0000024c FatFile::parsePathName(char const*, fname_t*, char const**)
0000d908  w    F .text	00000006 can1_wakeup_isr
000076f8 g     F .text	00000038 usb_mtp_sendEvent
1fff0200 g     O .dmabuffers	00000198 _VectorsRam
0000d37c g     F .text	00000052 SdSpiArduinoDriver::send(unsigned char const*, unsigned int)
0000fd24 g     F .text	0000005e _calloc_r
0000d908  w    F .text	00000006 pit3_isr
00007be0 g     F .text	0000007c SPIClass::begin()
00006ddc g     F .text	0000006e MTPD::read(char*, unsigned long)
1fff617c g     O .bss	00000004 getTimePtr
00001594 g     F .text	00000038 file_writeData(void*, unsigned long)
1fff0acc g     O .data	00000001 yield_active_check_flags
0000d908  w    F .text	00000006 enet_rx_isr
0000944c g     F .text	0000005e ExFatFile::sync()
0000a18c g     F .text	000001d4 FatFile::rename(FatFile*, char const*)
0000d17c g     F .text	00000080 SdioCard::isBusy()
0000d908  w    F .text	00000006 portc_isr
0000be64 g     F .text	00000038 SdSpiCard::readStop()
0001059c g     F .text	0000009a memset
0000efe4 g     F .text	00000010 main
1fff67f4 g     O .bss	00000004 __malloc_max_total_mem
00008c6c g     F .text	000000b4 ExFatPartition::bitmapFind(unsigned long, unsigned long)
00008020 g     F .text	000000a0 now()
00009858 g     F .text	00000264 ExFatFile::write(void const*, unsigned int)
00014364 g     O .text	00000060 vtable for MTPStorage_SD
00006ebc g     F .text	00000132 MTPD::SendObjectInfo(unsigned long, unsigned long)
00010b4c g     F .text	00000052 strlcat
0000d8c0  w    F .text	00000048 memmanage_fault_isr
00000794  w    F .text	00000058 SDFile::available()
00000500  w    F .text	0000000c File::close()
0000d950 g     F .text	0000007c usb_init_serialnumber
00014c68 g       .text	00000000 __init_array_end
00012700 g     F .text	00000e34 _dtoa_r
0000fe30 g     F .text	00000570 _malloc_r
1fff67f0 g     O .bss	00000001 HardwareSerial::s_count_serials_with_serial_events
0000d908  w    F .text	00000006 debugmonitor_isr
000124c8 g     F .text	0000001a __ascii_wctomb
0000b560 g     F .text	00000078 FsBaseFile::FsBaseFile(FsBaseFile const&)
0000f400 g     F .text	0000005a .hidden __aeabi_l2d
1fff6190 g     O .bss	00000004 FatVolume::m_cwv
0000edb0 g     F .text	00000080 EventResponder::triggerEventNotImmediate()
00007e50 g     F .text	00000008 SPIClass::transfer(void const*, void*, unsigned int)
60d46df8 g       *ABS*	00000000 __rtc_localtime
0000de88 g     F .text	00000044 micros
00000000  w      *UND*	00000000 __libc_fini
00000538  w    F .text	00000038 File::openNextFile(unsigned char)
0000d908  w    F .text	00000006 cmp1_isr
0000d908  w    F .text	00000006 ftm0_isr
00009308 g     F .text	00000144 ExFatFile::syncDir()
0001365c g     F .text	0000009c _malloc_trim_r
1fff0aac g     O .data	00000004 string0
0000d6b8 g     F .text	00000108 usb_serial_write
00001e54  w    F .text	0000001a MTPStorage_SD::addFilesystem(FS&, char const*)
0000d91c  w    F .text	00000002 startup_late_hook
0000ee94  w    F .text	00000004 usb_serial_class::available()
1fff0ae0 g     O .data	00000001 _serialEvent_default
00006e4c g     F .text	00000044 MTPD::readstring(char*)
0000a5c4 g     F .text	0000000c FatFile::sync()
000009f8  w    F .text	00000050 SDClass::mkdir(char const*)
1fff0a7c  w    O .data	0000002e usb_string_product_name
00005b40 g     F .text	00000028 MTPD::GetNumObjects(unsigned long, unsigned long)
0000decc g     F .text	0000009c delay
0000f890 g     F .text	0000007a .hidden __nedf2
0000d908  w    F .text	00000006 tpm0_isr
1fff67c0 g     O .bss	00000002 dma_channel_allocated_mask
00001f98 g     F .text	00000118 MTPStorage_SD::CloseIndex()
00014c68 g     F .fini	00000000 _fini
00005b68 g     F .text	00000018 MTPD::get_buffer()
00000518  w    F .text	00000014 File::name()
00008140 g     F .text	00000020 month()
00014548 g     O .text	0000002e SPISettings::ctar_div_table
0000bda8 g     F .text	00000050 SdSpiCard::readStart(unsigned long)
00008bcc g     F .text	00000040 ExFatFile::openNext(ExFatFile*, int)
00010a44 g     F .text	0000004c sprintf
0000ef0c g     F .text	0000001c Print::printf(char const*, ...)
0000d908  w    F .text	00000006 i2s0_rx_isr
0000d908  w    F .text	00000006 uart4_error_isr
00009c70 g     F .text	0000001e FatFile::close()
000004e0  w    F .text	00000010 File::position()
00000ed8  w    F .text	00000064 SDFile::~SDFile()
000125c8 g     F .text	0000000c atexit
0000c2f0  w    F .text	00000002 SdioCard::~SdioCard()
000007ec  w    F .text	00000018 StreamFile<FsBaseFile, unsigned long long>::peek()
000005a8  w    F .text	00000018 File::write(unsigned char)
000124e4 g     F .text	0000002c _write_r
1fff61e4 g     O .bss	000004b8 SD
0000c5e4 g     F .text	000000ec SdioCard::erase(unsigned long, unsigned long)
0000d908  w    F .text	00000006 can0_message_isr
00007c5c g     F .text	000000a4 SPIClass::setMOSI(unsigned char)
1fff0f10 g     O .data	00000004 _impure_ptr
00014068  w    O .text	00000024 vtable for Stream
0000d908  w    F .text	00000006 can1_message_isr
000085b0 g     F .text	0000002e ExFatFile::peek()
0001408c  w    O .text	00000024 vtable for StreamFile<FsBaseFile, unsigned long long>
0000d908  w    F .text	00000006 nmi_isr
0000b0a0 g     F .text	000000b6 FatFile::lfnUniqueSfn(fname_t*)
00000dac  w    F .text	00000014 SDFile::write(void const*, unsigned int)
0000b7a8 g     F .text	00000028 FsVolume::open(char const*, int)
0000c290 g     F .text	0000000c SdioCard::errorCode() const
00009f64 g     F .text	0000000e FatFile::open(FatVolume*, char const*, int)
00000dc0  w    F .text	00000014 StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)
00014c58 g       .text	00000000 __preinit_array_end
000006f0 g     F .text	00000098 dateTime(unsigned short*, unsigned short*, unsigned char*)
0000b7f0  w    F .text	00000002 SdSpiCard::~SdSpiCard()
0000d908  w    F .text	00000006 sdhc_isr
000080e0 g     F .text	00000020 minute()
00008fbc g     F .text	000000e0 ExFatPartition::init(BlockDeviceInterface*, unsigned char)
00008e04 g     F .text	00000034 ExFatPartition::dirCache(DirPos_t*, unsigned char)
0000bf08 g     F .text	000000b8 SdSpiCard::erase(unsigned long, unsigned long)
000043e4 g     F .text	00000012 MTPStorage_SD::DeleteObject(unsigned long)
000103a0 g     F .text	0000002a __ascii_mbtowc
0000b8bc g     F .text	0000004e SdSpiCard::isBusy()
0001467c g     O .text	00000058 vtable for SdSpiCard
1fff14bc g     O .bss	00000200 header
0000bd08  w    F .text	00000008 SdSpiCard::readCID(CID*)
00001c3c g     F .text	000000c4 setup
00014734 g     O .text	00000060 usb_descriptor_list
0000e11c g     F .text	0000003c usb_rx
0000c420 g     F .text	00000020 SdioCard::status()
00001f1c g     F .text	0000007c MTPStorage_SD::ResetIndex()
0000d908  w    F .text	00000006 dma_ch10_isr
00000470  w    F .text	00000002 Print::flush()
0000d908  w    F .text	00000006 uart0_error_isr
000004f0  w    F .text	00000010 File::size()
00000ad8  w    F .text	00000062 SDClass::rmdir(char const*)
00001808 g     F .text	00000144 file_open(unsigned short)
0000e090 g     F .text	00000040 usb_malloc
00009f80 g     F .text	0000019e FatFile::read(void*, unsigned int)
0000d908  w    F .text	00000006 i2s0_isr
00009f74 g     F .text	0000000c FatFile::openRoot(FatVolume*)
1fff618c g     O .bss	00000004 ExFatVolume::m_cwv
2002fff8 g       .bss	00000000 _estack
0000b7d0 g     F .text	00000004 operator new(unsigned int, unsigned long*)
0000bd00  w    F .text	00000008 SdSpiCard::readCSD(csd_t*)
0000ed78 g     F .text	00000038 DMAChannel::release()
0000057c  w    F .text	0000002c File::read()
0000d7d8 g     F .text	00000048 usb_serial_write_buffer_free
0000b98c g     F .text	0000003c SdSpiCard::waitNotBusy(unsigned short)
0000d908  w    F .text	00000006 enet_timer_isr
0000f92c g     F .text	00000012 .hidden __aeabi_dcmpeq
00000f3c  w    F .text	00000030 File::~File()
0000eefc  w    F .text	0000000e _write
1fff14b8 g     O .bss	00000004 maxDel
1fff1490 g       .data	00000000 _edata
00008ea4 g     F .text	00000024 ExFatPartition::fatPut(unsigned long, unsigned long)
0000609c g     F .text	00000254 MTPD::GetObjectInfo(unsigned long)
0000c2f0  w    F .text	00000002 SdioCard::~SdioCard()
0000d908  w    F .text	00000006 i2s0_tx_isr
0000d908  w    F .text	00000006 adc1_isr
0000be9c g     F .text	0000001c SdSpiCard::syncDevice()
00009b24 g     F .text	00000098 FatFile::addDirCluster()
0000047c  w    F .text	0000000c File::read(void*, unsigned int)
0000ee9c  w    F .text	00000004 usb_serial_class::availableForWrite()
0000d908  w    F .text	00000006 cmp0_isr
000004bc  w    F .text	0000000c File::truncate(unsigned long long)
0000d9cc g     F .text	0000004c ultoa
0000d3dc  w    F .text	00000002 SDClass::~SDClass()
0000ba60 g     F .text	00000214 SdSpiCard::begin(SdSpiConfig)
00008100 g     F .text	00000020 second()
0000b600 g     F .text	00000080 FsBaseFile::open(FsVolume*, char const*, int)
000026c8 g     F .text	00000210 MTPStorage_SD::ReadIndexRecord(unsigned long)
0000eff8 g     F .text	00000004 operator new(unsigned int)
0000ee30 g     F .text	00000044 EventResponder::runFromInterrupt()
1fff1488 g     O .data	00000004 __malloc_trim_threshold
0000ee8c  w    F .text	00000004 usb_serial_class::peek()
0000fd90 g     F .text	00000024 fcvtf
000028d8 g     F .text	0000005e MTPStorage_SD::GetNextObjectHandle(unsigned long)
00000f6c  w    F .text	00000078 MTPStorage_SD::~MTPStorage_SD()
1fff6138 g     O .bss	00000014 mtpd
00013d38 g     F .text	00000114 __mdiff
0000c2e0 g     F .text	00000010 SdioCard::readOCR(unsigned long*)
0000f9bc g     F .text	0000004e .hidden __aeabi_d2iz
00003208 g     F .text	000000aa MTPStorage_SD::Create(unsigned long, unsigned long, bool, char const*)
00008e38 g     F .text	00000058 ExFatPartition::dirSeek(DirPos_t*, unsigned long)
1fff669c g     O .bss	00000001 usb_cdc_transmit_flush_timer
00007978 g     F .text	00000134 _spi_dma_rxISR1()
0000d908  w    F .text	00000006 pit_isr
000080c0 g     F .text	00000020 hour()
0000c728 g     F .text	0000008c SdioCard::writeStop()
0000c0f0  w    F .text	0000001c SdSpiCard::writeSector(unsigned long, unsigned char const*)
00008258 g     F .text	00000014 ExFatFile::close()
00014a3c g     O .text	00000101 _ctype_
0000d908  w    F .text	00000006 dac0_isr
0000b7dc  w    F .text	00000010 SdSpiCard::readSector(unsigned long, unsigned char*)
00014c58 g       .text	00000000 __init_array_start
0000fd20  w    F .text	00000002 .hidden __aeabi_idiv0
0000d908  w    F .text	00000006 can1_tx_warn_isr
00002154 g     F .text	00000394 MTPStorage_SD::OpenIndex()
0000f990 g     F .text	0000002c .hidden __unorddf2
00000b3c  w    F .text	00000074 SDClass::rename(char const*, char const*)
0000d908  w    F .text	00000006 uart0_status_isr
0000d908  w    F .text	00000006 mcg_isr
00000400 g     O .text	00000010 flashconfigbytes
0000ecb0 g     F .text	000000c8 DMAChannel::begin(bool)
00010c00 g     F .text	000000dc strlen
0000ac10 g     F .text	0000002e FatFile::openCluster(FatFile*)
000144b4 g     O .text	00000094 SPIClass::spi1_hardware
0000f91c g     F .text	00000010 .hidden __aeabi_cdcmpeq
0000f880 g     F .text	0000008a .hidden __gedf2
0000a3bc g     F .text	000000b0 FatFile::seekSet(unsigned long)
1fff0a7c g     O .data	0000002e usb_string_product_name_default
000124b0 g     F .text	00000018 vdprintf
0000d908  w    F .text	00000006 dma_ch1_isr
0000c578 g     F .text	0000006c SdioCard::sectorCount()
0000b6e0 g     F .text	000000c8 FsVolume::begin(BlockDeviceInterface*)
0000775c g     F .text	00000008 MTPD::send_DeviceResetEvent()
0000e158 g     F .text	0000002c usb_tx_packet_count
0000a544 g     F .text	00000080 FatFile::openNext(FatFile*, int)
000146d4 g     O .text	00000058 vtable for SdioCard
0000f3b4 g     F .text	0000003a .hidden __aeabi_f2d
0000d908  w    F .text	00000006 dma_ch5_isr
0000298c g     F .text	0000019c MTPStorage_SD::close()
0000ac40 g     F .text	000000ec FatFile::getName(char*, unsigned int)
0000d908  w    F .text	00000006 can0_rx_warn_isr
00000f6c  w    F .text	00000078 MTPStorage_SD::~MTPStorage_SD()
00002b8c g     F .text	000000b0 MTPStorage_SD::rename(unsigned long, char const*)
0000d908  w    F .text	00000006 can0_tx_warn_isr
0000d908  w    F .text	00000006 uart4_status_isr
0000cfb0 g     F .text	00000074 SdioCard::readStart(unsigned long)
00000000  w      *UND*	00000000 _Jv_RegisterClasses
0000d228 g     F .text	00000078 SdSpiArduinoDriver::activate()
00001e7c g     F .text	00000004 MTPStorage_SD::readonly(unsigned long)
0000f0f4 g     F .text	0000027a .hidden __subdf3
0000147c g     F .text	00000058 pullData(unsigned long*, unsigned long)
00014c58 g       .text	00000000 __preinit_array_start
00008d20 g     F .text	000000a6 ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)
00002974 g     F .text	00000016 MTPStorage_SD::GetSize(unsigned long)
000005d8  w    F .text	00000028 File::whoami()
1fff3538 g     O .bss	00002c00 data_buffer
00013a04 g     F .text	0000005a __lo0bits
00008dc8 g     F .text	0000003a ExFatPartition::chainSize(unsigned long)
0000a46c g     F .text	000000d6 FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)
0000f0e0 g     F .text	0000000a __aeabi_atexit
00006d44 g     F .text	0000001a MTPD::receive_buffer()
00000000  w      *UND*	00000000 __register_frame_info
0000de40 g     F .text	0000000c rtc_get
000091d4 g     F .text	000000d6 ExFatFile::remove()
0000d908  w    F .text	00000006 cmp2_isr
0000ee74 g     F .text	00000004 pendablesrvreq_isr
00000c6c  w    F .text	00000034 SDClass::totalSize()
00006ff0 g     F .text	00000076 MTPD::SendObject()
00001e90 g     F .text	0000000c MTPStorage_SD::usedSize(unsigned long)
0000046c  w    F .text	00000004 Print::availableForWrite()
1fff0f14 g     O .data	0000016c __global_locale
0000d908  w    F .text	00000006 wakeup_isr
00007d00 g     F .text	000000a0 SPIClass::setMISO(unsigned char)
000015cc g     F .text	00000028 file_close()
0000cb50 g     F .text	00000394 SdioCard::begin(SdioConfig)
0000d908  w    F .text	00000006 cmp3_isr
00007e58 g     F .text	000001b0 breakTime(long, tmElements_t&)
0000a860 g     F .text	0000006e FatPartition::fatGet(unsigned long, unsigned long*)
0000fe20 g     F .text	00000010 free
0000d908  w    F .text	00000006 tpm2_isr
00013944 g     F .text	00000080 __multadd
00013930 g     F .text	00000012 _Bfree
00000c20  w    F .text	0000001a SDFile::size()
0000d908  w    F .text	00000006 dma_ch0_isr
00000fe4  w    F .text	0000005c SDFile::~SDFile()
1fff0ab0  w    O .data	00000016 usb_string_serial_number
0000d908  w    F .text	00000006 enet_tx_isr
0000910c g     F .text	0000003a exFatHashName(char const*, unsigned int, unsigned short)
0000d024 g     F .text	000000f0 SdioCard::readSector(unsigned long, unsigned char*)
0000c2c4 g     F .text	0000001c SdioCard::readCSD(csd_t*)



Disassembly of section .text:

00000000 <_VectorsFlash>:
  str = fsFmtField(str, 2*(time & 31) + (sec100 < 100 ? 0 : 1), 0);
  *--str = ':';
  return fsFmtTime(str, time);
}
//------------------------------------------------------------------------------
char* fsFmtTimeZone(char* str, int8_t tz) {
       0:	... ............
    } else {
      sign = '+';
      tz &= 0X7F;
    }
    if (tz) {
      str = fsFmtField(str, 15*(tz%4), 0);
      10:	................
//------------------------------------------------------------------------------
static char* fsFmtField(char* str, uint16_t n, char sep) {
  if (sep) {
    *--str = sep;
  }
  str = fmtBase10(str, n);
      20:	................
      sign = '+';
      tz &= 0X7F;
    }
    if (tz) {
      str = fsFmtField(str, 15*(tz%4), 0);
      str = fsFmtField(str, tz/4, ':');
      30:	........u...y...
  }
}  // namespace FsDateTime
//------------------------------------------------------------------------------
static char* fsFmtField(char* str, uint16_t n, char sep) {
  if (sep) {
    *--str = sep;
      40:	................
  }
  str = fmtBase10(str, n);
  if (n < 10) {
    *--str = '0';
      50:	................
      tz = -tz;
    } else {
      sign = '+';
      tz &= 0X7F;
    }
    if (tz) {
      60:	................
      str = fsFmtField(str, 15*(tz%4), 0);
      str = fsFmtField(str, tz/4, ':');
      *--str = sign;
    }
    *--str = 'C';
    *--str = 'T';
      70:	................
    } else {
      sign = '+';
      tz &= 0X7F;
    }
    if (tz) {
      str = fsFmtField(str, 15*(tz%4), 0);
      80:	................
      90:	................
      a0:	................
      b0:	................
      c0:	................
      d0:	................
      e0:	................
      f0:	................
     100:	................
     110:	................
     120:	................
     130:	................
     140:	................
     150:	................
     160:	................
     170:	................
     180:	................
     190:	........

00000198 <ResetHandler>:
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     198:	ldr	r3, [pc, #352]	; (2fc <ResetHandler+0x164>)
     19a:	movw	r2, #50464	; 0xc520
#else
// hopefully all others fit into startup section (below 0x400)
__attribute__ ((section(".startup"),optimize("-Os")))
#endif
void ResetHandler(void)
{
     19e:	push	{r4, lr}
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1a0:	strh	r2, [r3, #0]
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ2;
     1a2:	movw	r2, #55592	; 0xd928
     1a6:	strh	r2, [r3, #0]
	__asm__ volatile ("nop");
     1a8:	nop
	__asm__ volatile ("nop");
     1aa:	nop
#endif
	// programs using the watchdog timer or needing to initialize hardware as
	// early as possible can implement startup_early_hook()
	startup_early_hook();
     1ac:	bl	d910 <startup_early_hook>
#elif defined(__MK20DX256__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2 | SIM_SCGC3_FTM3;
     1b0:	ldr	r3, [pc, #332]	; (300 <ResetHandler+0x168>)
     1b2:	mov.w	r2, #184549376	; 0xb000000
     1b6:	str	r2, [r3, #0]
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
     1b8:	ldr	r2, [pc, #328]	; (304 <ResetHandler+0x16c>)
     1ba:	str	r2, [r3, #8]
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
     1bc:	ldr	r2, [pc, #328]	; (308 <ResetHandler+0x170>)
     1be:	str	r2, [r3, #12]
	SIM_SCGC4 = SIM_SCGC4_USBOTG | 0xF0000030;
	SIM_SCGC5 = 0x00003F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_ADC0 | SIM_SCGC6_TPM0 | SIM_SCGC6_TPM1 | SIM_SCGC6_TPM2 | SIM_SCGC6_FTFL;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SCB_CPACR = 0x00F00000;
     1c0:	ldr	r3, [pc, #328]	; (30c <ResetHandler+0x174>)
     1c2:	mov.w	r2, #15728640	; 0xf00000
     1c6:	str	r2, [r3, #0]
#endif
#if defined(KINETISK) && !defined(__MK66FX1M0__)
	// If the RTC oscillator isn't enabled, get it started early.
	// But don't do this early on Teensy 3.6 - RTC_CR depends on 3.3V+VBAT
	// which may be ~0.4V "behind" 3.3V if the power ramps up slowly.
	if (!(RTC_CR & RTC_CR_OSCE)) {
     1c8:	ldr	r2, [pc, #324]	; (310 <ResetHandler+0x178>)
     1ca:	ldr	r3, [r2, #0]
     1cc:	ands.w	r3, r3, #256	; 0x100
     1d0:	bne.n	1dc <ResetHandler+0x44>
		RTC_SR = 0;
     1d2:	ldr	r1, [pc, #320]	; (314 <ResetHandler+0x17c>)
     1d4:	str	r3, [r1, #0]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
     1d6:	mov.w	r3, #5376	; 0x1500
     1da:	str	r3, [r2, #0]
	}
#endif
	// release I/O pins hold, if we woke up from VLLS mode
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;
     1dc:	ldr	r3, [pc, #312]	; (318 <ResetHandler+0x180>)
     1de:	ldrb	r2, [r3, #0]
     1e0:	lsls	r1, r2, #28
     1e2:	bpl.n	1ec <ResetHandler+0x54>
     1e4:	ldrb	r2, [r3, #0]
     1e6:	orr.w	r2, r2, #8
     1ea:	strb	r2, [r3, #0]
    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     1ec:	ldr	r3, [pc, #300]	; (31c <ResetHandler+0x184>)
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     1ee:	ldr	r1, [pc, #304]	; (320 <ResetHandler+0x188>)
    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     1f0:	movs	r2, #42	; 0x2a
     1f2:	strb	r2, [r3, #0]
     1f4:	ldr	r2, [pc, #300]	; (324 <ResetHandler+0x18c>)
     1f6:	ldr	r3, [pc, #304]	; (328 <ResetHandler+0x190>)
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     1f8:	cmp	r3, r1
     1fa:	bcs.n	206 <ResetHandler+0x6e>
     1fc:	ldr.w	r0, [r2, #4]!
     200:	str.w	r0, [r3], #4
     204:	b.n	1f8 <ResetHandler+0x60>
     206:	ldr	r3, [pc, #292]	; (32c <ResetHandler+0x194>)
	dest = &_sbss;
	while (dest < &_ebss) *dest++ = 0;
     208:	ldr	r1, [pc, #292]	; (330 <ResetHandler+0x198>)
     20a:	movs	r2, #0
     20c:	cmp	r3, r1
     20e:	bcs.n	216 <ResetHandler+0x7e>
     210:	str.w	r2, [r3], #4
     214:	b.n	20c <ResetHandler+0x74>

	// default all interrupts to medium priority level
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = _VectorsFlash[i];
     216:	ldr	r1, [pc, #284]	; (334 <ResetHandler+0x19c>)
     218:	ldr	r2, [pc, #284]	; (338 <ResetHandler+0x1a0>)
     21a:	movs	r3, #0
     21c:	ldr.w	r0, [r2, r3, lsl #2]
     220:	str.w	r0, [r1, r3, lsl #2]
     224:	adds	r3, #1
     226:	cmp	r3, #102	; 0x66
     228:	bne.n	21c <ResetHandler+0x84>
     22a:	ldr	r3, [pc, #272]	; (33c <ResetHandler+0x1a4>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
     22c:	ldr	r2, [pc, #272]	; (340 <ResetHandler+0x1a8>)
     22e:	movs	r1, #128	; 0x80
     230:	strb.w	r1, [r3], #1
     234:	cmp	r3, r2
     236:	bne.n	230 <ResetHandler+0x98>
	SCB_VTOR = (uint32_t)_VectorsRam;	// use vector table in RAM
     238:	ldr	r3, [pc, #264]	; (344 <ResetHandler+0x1ac>)
     23a:	ldr	r2, [pc, #248]	; (334 <ResetHandler+0x19c>)
     23c:	str	r2, [r3, #0]
	//  C6[PLLS] bit is written to 0
	//  C2[LP] bit is written to 1
#else
    #if defined(KINETISK)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
     23e:	ldr	r3, [pc, #264]	; (348 <ResetHandler+0x1b0>)
     240:	movs	r2, #138	; 0x8a
     242:	strb	r2, [r3, #0]
    #elif defined(KINETISL)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
    #endif
	// enable osc, 8-32 MHz range, low power mode
	MCG_C2 = MCG_C2_RANGE0(2) | MCG_C2_EREFS;
     244:	sub.w	r3, r3, #4096	; 0x1000
     248:	movs	r2, #36	; 0x24
     24a:	strb	r2, [r3, #1]
	// switch to crystal as clock source, FLL input = 16 MHz / 512
	MCG_C1 =  MCG_C1_CLKS(2) | MCG_C1_FRDIV(4);
     24c:	movs	r2, #160	; 0xa0
     24e:	strb	r2, [r3, #0]
	// wait for crystal oscillator to begin
	while ((MCG_S & MCG_S_OSCINIT0) == 0) ;
     250:	ldrb	r2, [r3, #6]
     252:	lsls	r2, r2, #30
     254:	bpl.n	250 <ResetHandler+0xb8>
	// wait for FLL to use oscillator
	while ((MCG_S & MCG_S_IREFST) != 0) ;
     256:	ldrb	r2, [r3, #6]
     258:	lsls	r4, r2, #27
     25a:	bmi.n	256 <ResetHandler+0xbe>
	// wait for MCGOUT to use oscillator
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2)) ;
     25c:	ldr	r2, [pc, #236]	; (34c <ResetHandler+0x1b4>)
     25e:	ldrb	r3, [r2, #6]
     260:	and.w	r3, r3, #12
     264:	cmp	r3, #8
     266:	ldr	r3, [pc, #228]	; (34c <ResetHandler+0x1b4>)
     268:	bne.n	25e <ResetHandler+0xc6>
    #endif
   #else
    #if F_CPU == 72000000
	MCG_C5 = MCG_C5_PRDIV0(5);		 // config PLL input for 16 MHz Crystal / 6 = 2.667 Hz
    #else
	MCG_C5 = MCG_C5_PRDIV0(3);		 // config PLL input for 16 MHz Crystal / 4 = 4 MHz
     26a:	movs	r2, #3
     26c:	strb	r2, [r3, #4]
    #elif F_CPU == 120000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(6); // config PLL for 120 MHz output
    #elif F_CPU == 72000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(3); // config PLL for 72 MHz output
    #elif F_CPU == 96000000 || F_CPU == 48000000 || F_CPU == 24000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(0); // config PLL for 96 MHz output
     26e:	movs	r2, #64	; 0x40
     270:	strb	r2, [r3, #5]
    #error "This clock speed isn't supported..."
    #endif
   #endif

	// wait for PLL to start using xtal as its input
	while (!(MCG_S & MCG_S_PLLST)) ;
     272:	ldrb	r2, [r3, #6]
     274:	lsls	r0, r2, #26
     276:	bpl.n	272 <ResetHandler+0xda>
	// wait for PLL to lock
	while (!(MCG_S & MCG_S_LOCK0)) ;
     278:	ldr	r2, [pc, #208]	; (34c <ResetHandler+0x1b4>)
     27a:	ldrb	r1, [r2, #6]
     27c:	ldr	r3, [pc, #204]	; (34c <ResetHandler+0x1b4>)
     27e:	lsls	r1, r1, #25
     280:	bpl.n	27a <ResetHandler+0xe2>
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(4) | SIM_CLKDIV2_USBFRAC;
#elif F_CPU == 96000000
	// config divisors: 96 MHz core, 48 MHz bus, 24 MHz flash, USB = 96 / 2
	#if F_BUS == 48000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(1) | SIM_CLKDIV1_OUTDIV4(3);
     282:	ldr	r2, [pc, #204]	; (350 <ResetHandler+0x1b8>)
     284:	ldr	r1, [pc, #204]	; (354 <ResetHandler+0x1bc>)
     286:	str	r1, [r2, #0]
	#elif F_BUS == 96000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(0) | SIM_CLKDIV1_OUTDIV4(3);
	#else
	#error "This F_CPU & F_BUS combination is not supported"
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(1);
     288:	movs	r1, #2
     28a:	str	r1, [r2, #4]
#error "Error, F_CPU must be 256, 240, 216, 192, 180, 168, 144, 120, 96, 72, 48, 24, 16, 8, 4, or 2 MHz"
#endif

#if F_CPU > 16000000
	// switch to PLL as clock source, FLL input = 16 MHz / 512
	MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);
     28c:	movs	r2, #32
     28e:	strb	r2, [r3, #0]
	// wait for PLL clock to be used
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;
     290:	ldrb	r2, [r3, #6]
     292:	and.w	r2, r2, #12
     296:	cmp	r2, #12
     298:	bne.n	290 <ResetHandler+0xf8>
	#if F_CPU == 256000000 || F_CPU == 216000000 || F_CPU == 180000000
	// USB uses IRC48
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_IRC48SEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
	#else
	// USB uses PLL clock
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
     29a:	ldr	r3, [pc, #188]	; (358 <ResetHandler+0x1c0>)
     29c:	ldr	r2, [pc, #188]	; (35c <ResetHandler+0x1c4>)
     29e:	str	r2, [r3, #0]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif

	// initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
     2a0:	ldr	r3, [pc, #188]	; (360 <ResetHandler+0x1c8>)
     2a2:	ldr	r2, [pc, #192]	; (364 <ResetHandler+0x1cc>)
     2a4:	str	r2, [r3, #0]
	SYST_CVR = 0;
     2a6:	movs	r2, #0
     2a8:	str	r2, [r3, #4]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
     2aa:	movs	r2, #7
     2ac:	str.w	r2, [r3, #-4]
	SCB_SHPR3 = 0x20200000;  // Systick = priority 32
     2b0:	ldr	r2, [pc, #180]	; (368 <ResetHandler+0x1d0>)
     2b2:	str.w	r2, [r3, #3340]	; 0xd0c

	//init_pins();
	__enable_irq();
     2b6:	cpsie	i

	_init_Teensyduino_internal_();
     2b8:	bl	df68 <_init_Teensyduino_internal_>

#if defined(KINETISK)
	// RTC initialization
	if (RTC_SR & RTC_SR_TIF) {
     2bc:	ldr	r3, [pc, #84]	; (314 <ResetHandler+0x17c>)
     2be:	ldr	r3, [r3, #0]
     2c0:	lsls	r2, r3, #31
     2c2:	bpl.n	2d0 <ResetHandler+0x138>
		// compiled-in time will be stale.  Write a special
		// flag into the VBAT register file indicating the
		// RTC is set with known-stale time and should be
		// updated when fresh time is known.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     2c4:	ldr	r0, [pc, #164]	; (36c <ResetHandler+0x1d4>)
     2c6:	bl	de4c <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0x5A94C3A5;
     2ca:	ldr	r3, [pc, #164]	; (370 <ResetHandler+0x1d8>)
     2cc:	ldr	r2, [pc, #164]	; (374 <ResetHandler+0x1dc>)
     2ce:	str	r2, [r3, #0]
	}
	if ((RCM_SRS0 & RCM_SRS0_PIN) && (*(uint32_t *)0x4003E01C == 0x5A94C3A5)) {
     2d0:	ldr	r3, [pc, #164]	; (378 <ResetHandler+0x1e0>)
     2d2:	ldrb	r3, [r3, #0]
     2d4:	lsls	r3, r3, #25
     2d6:	bpl.n	2ec <ResetHandler+0x154>
     2d8:	ldr	r4, [pc, #148]	; (370 <ResetHandler+0x1d8>)
     2da:	ldr	r3, [pc, #152]	; (374 <ResetHandler+0x1dc>)
     2dc:	ldr	r2, [r4, #0]
     2de:	cmp	r2, r3
     2e0:	bne.n	2ec <ResetHandler+0x154>
		// Our compiled-in time will be very fresh, so set
		// the RTC with this, and clear the VBAT resister file
		// data so we don't mess with the time after it's been
		// set well.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     2e2:	ldr	r0, [pc, #136]	; (36c <ResetHandler+0x1d4>)
     2e4:	bl	de4c <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0;
     2e8:	movs	r3, #0
     2ea:	str	r3, [r4, #0]
	}
#endif

	__libc_init_array();
     2ec:	bl	fdc0 <__libc_init_array>

	startup_late_hook();
     2f0:	bl	d91c <startup_late_hook>
	main();
     2f4:	bl	efe4 <main>
     2f8:	b.n	2f8 <ResetHandler+0x160>
     2fa:	nop
     2fc:	.word	0x4005200e
     300:	.word	0x40048030
     304:	.word	0x00043f82
     308:	.word	0x2b000001
     30c:	.word	0xe000ed88
     310:	.word	0x4003d010
     314:	.word	0x4003d014
     318:	.word	0x4007d002
     31c:	.word	0x4007e000
     320:	.word	0x1fff1490
     324:	.word	0x00014c70
     328:	.word	0x1fff0938
     32c:	.word	0x1fff1490
     330:	.word	0x1fff6844
     334:	.word	0x1fff0200
     338:	.word	0x00000000
     33c:	.word	0xe000e400
     340:	.word	0xe000e456
     344:	.word	0xe000ed08
     348:	.word	0x40065000
     34c:	.word	0x40064000
     350:	.word	0x40048044
     354:	.word	0x01030000
     358:	.word	0x40048004
     35c:	.word	0x000510c0
     360:	.word	0xe000e014
     364:	.word	0x000176ff
     368:	.word	0x20200000
     36c:	.word	0x60d46df8
     370:	.word	0x4003e01c
     374:	.word	0x5a94c3a5
     378:	.word	0x4007f000
     37c:	.word	0xffffffff
     380:	.word	0xffffffff
     384:	.word	0xffffffff
     388:	.word	0xffffffff
     38c:	.word	0xffffffff
     390:	.word	0xffffffff
     394:	.word	0xffffffff
     398:	.word	0xffffffff
     39c:	.word	0xffffffff
     3a0:	.word	0xffffffff
     3a4:	.word	0xffffffff
     3a8:	.word	0xffffffff
     3ac:	.word	0xffffffff
     3b0:	.word	0xffffffff
     3b4:	.word	0xffffffff
     3b8:	.word	0xffffffff
     3bc:	.word	0xffffffff
     3c0:	.word	0xffffffff
     3c4:	.word	0xffffffff
     3c8:	.word	0xffffffff
     3cc:	.word	0xffffffff
     3d0:	.word	0xffffffff
     3d4:	.word	0xffffffff
     3d8:	.word	0xffffffff
     3dc:	.word	0xffffffff
     3e0:	.word	0xffffffff
     3e4:	.word	0xffffffff
     3e8:	.word	0xffffffff
     3ec:	.word	0xffffffff
     3f0:	.word	0xffffffff
     3f4:	.word	0xffffffff
     3f8:	.word	0xffffffff
     3fc:	.word	0xffffffff

00000400 <flashconfigbytes>:
     400:	................

00000410 <__do_global_dtors_aux>:
     410:	push	{r4, lr}
     412:	ldr	r4, [pc, #20]	; (428 <__do_global_dtors_aux+0x18>)
     414:	ldrb	r3, [r4, #0]
     416:	cbnz	r3, 426 <__do_global_dtors_aux+0x16>
     418:	ldr	r3, [pc, #16]	; (42c <__do_global_dtors_aux+0x1c>)
     41a:	cbz	r3, 422 <__do_global_dtors_aux+0x12>
     41c:	ldr	r0, [pc, #16]	; (430 <__do_global_dtors_aux+0x20>)
     41e:	nop.w
     422:	movs	r3, #1
     424:	strb	r3, [r4, #0]
     426:	pop	{r4, pc}
     428:	.word	0x1fff1490
     42c:	.word	0x00000000
     430:	.word	0x00014c6c

00000434 <frame_dummy>:
     434:	ldr	r3, [pc, #32]	; (458 <frame_dummy+0x24>)
     436:	push	{r4, lr}
     438:	cbz	r3, 442 <frame_dummy+0xe>
     43a:	ldr	r1, [pc, #32]	; (45c <frame_dummy+0x28>)
     43c:	ldr	r0, [pc, #32]	; (460 <frame_dummy+0x2c>)
     43e:	nop.w
     442:	ldr	r0, [pc, #32]	; (464 <frame_dummy+0x30>)
     444:	ldr	r3, [r0, #0]
     446:	cbnz	r3, 44a <frame_dummy+0x16>
     448:	pop	{r4, pc}
     44a:	ldr	r3, [pc, #28]	; (468 <frame_dummy+0x34>)
     44c:	cmp	r3, #0
     44e:	beq.n	448 <frame_dummy+0x14>
     450:	ldmia.w	sp!, {r4, lr}
     454:	bx	r3
     456:	nop
     458:	.word	0x00000000
     45c:	.word	0x1fff1494
     460:	.word	0x00014c6c
     464:	.word	0x1fff1490
     468:	.word	0x00000000

0000046c <Print::availableForWrite()>:
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
	virtual size_t write(const uint8_t *buffer, size_t size);
	virtual int availableForWrite(void)		{ return 0; }
     46c:	movs	r0, #0
     46e:	bx	lr

00000470 <Print::flush()>:
	virtual void flush()				{ }
     470:	bx	lr
     472:	nop

00000474 <SdCardInterface::status()>:
   * \return The number of 512 byte data sectors in the card
   *         or zero if an error occurs.
   */
  virtual uint32_t sectorCount() = 0;
  /** \return card status. */
  virtual uint32_t status() {return 0XFFFFFFFF;}
     474:	mov.w	r0, #4294967295
     478:	bx	lr
     47a:	nop

0000047c <File::read(void*, unsigned int)>:
	unsigned int getRefcount() { // testing only
		return refcount;
	}
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
     47c:	ldr	r0, [r0, #16]
     47e:	cbz	r0, 486 <File::read(void*, unsigned int)+0xa>
     480:	ldr	r3, [r0, #0]
     482:	ldr	r3, [r3, #40]	; 0x28
     484:	bx	r3
	}
     486:	bx	lr

00000488 <File::write(void const*, unsigned int)>:
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
     488:	ldr	r0, [r0, #16]
     48a:	cbz	r0, 492 <File::write(void const*, unsigned int)+0xa>
     48c:	ldr	r3, [r0, #0]
     48e:	ldr	r3, [r3, #44]	; 0x2c
     490:	bx	r3
	}
     492:	bx	lr

00000494 <File::available()>:
	virtual int available() {
		return (f) ? f->available() : 0;
     494:	ldr	r0, [r0, #16]
     496:	cbz	r0, 49e <File::available()+0xa>
     498:	ldr	r3, [r0, #0]
     49a:	ldr	r3, [r3, #16]
     49c:	bx	r3
	}
     49e:	bx	lr

000004a0 <File::peek()>:
	virtual int peek() {
		return (f) ? f->peek() : -1;
     4a0:	ldr	r0, [r0, #16]
     4a2:	cbz	r0, 4aa <File::peek()+0xa>
     4a4:	ldr	r3, [r0, #0]
     4a6:	ldr	r3, [r3, #24]
     4a8:	bx	r3
	}
     4aa:	mov.w	r0, #4294967295
     4ae:	bx	lr

000004b0 <File::flush()>:
	virtual void flush() {
		if (f) f->flush();
     4b0:	ldr	r0, [r0, #16]
     4b2:	cbz	r0, 4ba <File::flush()+0xa>
     4b4:	ldr	r3, [r0, #0]
     4b6:	ldr	r3, [r3, #12]
     4b8:	bx	r3
     4ba:	bx	lr

000004bc <File::truncate(unsigned long long)>:
	}
	virtual bool truncate(uint64_t size=0) {
		return (f) ? f->truncate(size) : false;
     4bc:	ldr	r0, [r0, #16]
     4be:	cbz	r0, 4c6 <File::truncate(unsigned long long)+0xa>
     4c0:	ldr	r1, [r0, #0]
     4c2:	ldr	r1, [r1, #48]	; 0x30
     4c4:	bx	r1
	}
     4c6:	bx	lr

000004c8 <File::seek(unsigned long long, int)>:
	virtual bool seek(uint64_t pos, int mode) {
     4c8:	push	{r4}
		return (f) ? f->seek(pos, mode) : false;
     4ca:	ldr	r0, [r0, #16]
     4cc:	cbz	r0, 4d8 <File::seek(unsigned long long, int)+0x10>
     4ce:	ldr	r4, [r0, #0]
     4d0:	ldr	r1, [r4, #52]	; 0x34
	}
     4d2:	ldr.w	r4, [sp], #4
	}
	virtual bool truncate(uint64_t size=0) {
		return (f) ? f->truncate(size) : false;
	}
	virtual bool seek(uint64_t pos, int mode) {
		return (f) ? f->seek(pos, mode) : false;
     4d6:	bx	r1
	}
     4d8:	ldr.w	r4, [sp], #4
     4dc:	bx	lr
     4de:	nop

000004e0 <File::position()>:
	virtual uint64_t position() {
		return (f) ? f->position() : 0;
     4e0:	ldr	r0, [r0, #16]
     4e2:	cbz	r0, 4ea <File::position()+0xa>
     4e4:	ldr	r3, [r0, #0]
     4e6:	ldr	r3, [r3, #56]	; 0x38
     4e8:	bx	r3
	}
     4ea:	movs	r0, #0
     4ec:	movs	r1, #0
     4ee:	bx	lr

000004f0 <File::size()>:
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
     4f0:	ldr	r0, [r0, #16]
     4f2:	cbz	r0, 4fa <File::size()+0xa>
     4f4:	ldr	r3, [r0, #0]
     4f6:	ldr	r3, [r3, #60]	; 0x3c
     4f8:	bx	r3
	}
     4fa:	movs	r0, #0
     4fc:	movs	r1, #0
     4fe:	bx	lr

00000500 <File::close()>:
	virtual void close() {
		if (f) f->close();
     500:	ldr	r0, [r0, #16]
     502:	cbz	r0, 50a <File::close()+0xa>
     504:	ldr	r3, [r0, #0]
     506:	ldr	r3, [r3, #64]	; 0x40
     508:	bx	r3
     50a:	bx	lr

0000050c <File::operator bool()>:
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
     50c:	ldr	r0, [r0, #16]
     50e:	cbz	r0, 516 <File::operator bool()+0xa>
     510:	ldr	r3, [r0, #0]
     512:	ldr	r3, [r3, #68]	; 0x44
     514:	bx	r3
	}
     516:	bx	lr

00000518 <File::name()>:
	virtual const char* name() {
		return (f) ? f->name() : "";
     518:	ldr	r0, [r0, #16]
     51a:	cbz	r0, 522 <File::name()+0xa>
     51c:	ldr	r3, [r0, #0]
     51e:	ldr	r3, [r3, #72]	; 0x48
     520:	bx	r3
	}
     522:	ldr	r0, [pc, #4]	; (528 <File::name()+0x10>)
     524:	bx	lr
     526:	nop
     528:	.word	0x000142d0

0000052c <File::isDirectory()>:
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
     52c:	ldr	r0, [r0, #16]
     52e:	cbz	r0, 536 <File::isDirectory()+0xa>
     530:	ldr	r3, [r0, #0]
     532:	ldr	r3, [r3, #76]	; 0x4c
     534:	bx	r3
	}
     536:	bx	lr

00000538 <File::openNextFile(unsigned char)>:
	virtual File openNextFile(uint8_t mode=0) {
     538:	push	{r3, r4, r5, lr}
		return (f) ? f->openNextFile(mode) : *this;
     53a:	ldr	r3, [r1, #16]
		return (f) ? f->name() : "";
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
	}
	virtual File openNextFile(uint8_t mode=0) {
     53c:	mov	r4, r0
		return (f) ? f->openNextFile(mode) : *this;
     53e:	cbz	r3, 54c <File::openNextFile(unsigned char)+0x14>
     540:	ldr	r5, [r3, #0]
     542:	mov	r1, r3
     544:	ldr	r3, [r5, #80]	; 0x50
     546:	blx	r3
	}
     548:	mov	r0, r4
     54a:	pop	{r3, r4, r5, pc}
#include "Print.h"

class Stream : public Print
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
     54c:	mov.w	r0, #1000	; 0x3e8
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
	}
	File(const File &file) {
     550:	ldr	r2, [pc, #24]	; (56c <File::openNextFile(unsigned char)+0x34>)
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
     552:	strb	r3, [r4, #4]
     554:	strb	r3, [r4, #12]
     556:	str	r0, [r4, #8]
     558:	str	r2, [r4, #0]
		//Serial.println("File copy constructor");
		//static int copycount=0;
		//if (++copycount > 20) while (1) ;
		f = file.f;
     55a:	ldr	r3, [r1, #16]
     55c:	str	r3, [r4, #16]
		if (f) f->refcount++;
     55e:	cmp	r3, #0
     560:	beq.n	548 <File::openNextFile(unsigned char)+0x10>
     562:	ldr	r2, [r3, #16]
     564:	adds	r2, #1
     566:	str	r2, [r3, #16]
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
	}
	virtual File openNextFile(uint8_t mode=0) {
		return (f) ? f->openNextFile(mode) : *this;
	}
     568:	mov	r0, r4
     56a:	pop	{r3, r4, r5, pc}
     56c:	.word	0x000140dc

00000570 <File::rewindDirectory()>:
	virtual void rewindDirectory(void) {
		if (f) f->rewindDirectory();
     570:	ldr	r0, [r0, #16]
     572:	cbz	r0, 57a <File::rewindDirectory()+0xa>
     574:	ldr	r3, [r0, #0]
     576:	ldr	r3, [r3, #84]	; 0x54
     578:	bx	r3
     57a:	bx	lr

0000057c <File::read()>:
	}
	bool seek(uint64_t pos) {
		return seek(pos, SeekSet);
	}
	int read() {
		if (!f) return -1;
     57c:	ldr	r0, [r0, #16]
     57e:	cbz	r0, 5a2 <File::read()+0x26>
		if (f) f->rewindDirectory();
	}
	bool seek(uint64_t pos) {
		return seek(pos, SeekSet);
	}
	int read() {
     580:	push	{lr}
		if (!f) return -1;
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
     582:	ldr	r3, [r0, #0]
		if (f) f->rewindDirectory();
	}
	bool seek(uint64_t pos) {
		return seek(pos, SeekSet);
	}
	int read() {
     584:	sub	sp, #12
		if (!f) return -1;
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
     586:	ldr	r3, [r3, #40]	; 0x28
     588:	movs	r2, #1
     58a:	add.w	r1, sp, #7
     58e:	blx	r3
     590:	cbz	r0, 59c <File::read()+0x20>
		return b;
     592:	ldrb.w	r0, [sp, #7]
	}
     596:	add	sp, #12
     598:	ldr.w	pc, [sp], #4
	}
	bool seek(uint64_t pos) {
		return seek(pos, SeekSet);
	}
	int read() {
		if (!f) return -1;
     59c:	mov.w	r0, #4294967295
     5a0:	b.n	596 <File::read()+0x1a>
     5a2:	mov.w	r0, #4294967295
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
		return b;
	}
     5a6:	bx	lr

000005a8 <File::write(unsigned char)>:
	size_t write(uint8_t b) {
     5a8:	push	{r4, lr}
     5aa:	sub	sp, #8
     5ac:	add	r3, sp, #8
		return write(&b, 1);
     5ae:	ldr	r2, [r0, #0]
		if (!f) return -1;
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
		return b;
	}
	size_t write(uint8_t b) {
     5b0:	strb.w	r1, [r3, #-1]!
		return write(&b, 1);
     5b4:	ldr	r4, [r2, #44]	; 0x2c
     5b6:	mov	r1, r3
     5b8:	movs	r2, #1
     5ba:	blx	r4
	}
     5bc:	add	sp, #8
     5be:	pop	{r4, pc}

000005c0 <SDFile::operator bool()>:
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     5c0:	ldr	r3, [r0, #92]	; 0x5c
     5c2:	cbz	r3, 5c8 <SDFile::operator bool()+0x8>
     5c4:	movs	r0, #1
		}
		sdfatfile.close();
	}
	virtual operator bool() {
		return sdfatfile.isOpen();
	}
     5c6:	bx	lr
     5c8:	ldr	r0, [r0, #96]	; 0x60
     5ca:	adds	r0, #0
     5cc:	it	ne
     5ce:	movne	r0, #1
     5d0:	bx	lr
     5d2:	nop

000005d4 <__tcf_0>:
  return state;
}

/************ Basic File System Interface *************************/
#include "SD.h"
extern SDClass sdx[];
     5d4:	bx	lr
     5d6:	nop

000005d8 <File::whoami()>:
	}
	virtual ~File() {
		invalidate();
	}
#ifdef FILE_WHOAMI
	virtual void whoami() { // testing only
     5d8:	push	{r4, lr}
     5da:	mov	r4, r0
		Serial.printf("  File    this=%x, f=%x\n", (int)this, (int)f);
     5dc:	mov	r2, r0
     5de:	ldr	r3, [r0, #16]
     5e0:	ldr	r1, [pc, #20]	; (5f8 <File::whoami()+0x20>)
     5e2:	ldr	r0, [pc, #24]	; (5fc <File::whoami()+0x24>)
     5e4:	bl	ef0c <Print::printf(char const*, ...)>
		if (f) f->whoami();
     5e8:	ldr	r0, [r4, #16]
     5ea:	cbz	r0, 5f6 <File::whoami()+0x1e>
     5ec:	ldr	r3, [r0, #0]
	}
     5ee:	ldmia.w	sp!, {r4, lr}
		invalidate();
	}
#ifdef FILE_WHOAMI
	virtual void whoami() { // testing only
		Serial.printf("  File    this=%x, f=%x\n", (int)this, (int)f);
		if (f) f->whoami();
     5f2:	ldr	r3, [r3, #36]	; 0x24
     5f4:	bx	r3
     5f6:	pop	{r4, pc}
     5f8:	.word	0x000141bc
     5fc:	.word	0x1fff0ad0

00000600 <SDFile::whoami()>:
		if (filename) free(filename);
	}
#ifdef FILE_WHOAMI
	virtual void whoami() {
		Serial.printf("   SDFile this=%x, refcount=%u\n",
			(int)this, getRefcount());
     600:	mov	r2, r0
     602:	ldr	r3, [r0, #16]
     604:	ldr	r1, [pc, #4]	; (60c <SDFile::whoami()+0xc>)
     606:	ldr	r0, [pc, #8]	; (610 <SDFile::whoami()+0x10>)
     608:	b.w	ef0c <Print::printf(char const*, ...)>
     60c:	.word	0x000141d8
     610:	.word	0x1fff0ad0

00000614 <SDFile::close()>:
		return sdfatfile.curPosition();
	}
	virtual uint64_t size() {
		return sdfatfile.size();
	}
	virtual void close() {
     614:	push	{r4, lr}
     616:	mov	r4, r0
		if (filename) {
     618:	ldr	r0, [r0, #100]	; 0x64
     61a:	cbz	r0, 624 <SDFile::close()+0x10>
			free(filename);
     61c:	bl	fe20 <free>
			filename = nullptr;
     620:	movs	r3, #0
     622:	str	r3, [r4, #100]	; 0x64
		}
		sdfatfile.close();
     624:	add.w	r0, r4, #36	; 0x24
	}
     628:	ldmia.w	sp!, {r4, lr}
	virtual void close() {
		if (filename) {
			free(filename);
			filename = nullptr;
		}
		sdfatfile.close();
     62c:	b.w	b5d8 <FsBaseFile::close()>

00000630 <SDFile::openNextFile(unsigned char)>:
		return filename;
	}
	virtual boolean isDirectory(void) {
		return sdfatfile.isDirectory();
	}
	virtual File openNextFile(uint8_t mode=0) {
     630:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     634:	movs	r3, #0
     636:	sub	sp, #80	; 0x50
   * \param[in] oflag open flags.
   * \return a FatStream object.
   */
  FsFile openNextFile(oflag_t oflag = O_RDONLY) {
    FsFile tmpFile;
    tmpFile.openNext(this, oflag);
     638:	mov	r2, r3
     63a:	mov	r5, r0
     63c:	adds	r1, #36	; 0x24
     63e:	add	r0, sp, #16
     640:	mov.w	r4, #1000	; 0x3e8
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
     644:	ldr	r7, [pc, #148]	; (6dc <SDFile::openNextFile(unsigned char)+0xac>)
     646:	strb.w	r3, [sp, #4]
     64a:	strb.w	r3, [sp, #12]
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  /** Create an instance. */
  FsBaseFile() {}
     64e:	str	r3, [sp, #72]	; 0x48
     650:	str	r3, [sp, #76]	; 0x4c
     652:	str	r4, [sp, #8]
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
     654:	str	r7, [sp, #0]
   * \param[in] oflag open flags.
   * \return a FatStream object.
   */
  FsFile openNextFile(oflag_t oflag = O_RDONLY) {
    FsFile tmpFile;
    tmpFile.openNext(this, oflag);
     656:	bl	b680 <FsBaseFile::openNext(FsBaseFile*, int)>
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     65a:	ldr	r3, [sp, #72]	; 0x48
     65c:	cmp	r3, #0
     65e:	beq.n	6c6 <SDFile::openNextFile(unsigned char)+0x96>
		SDFAT_FILE file = sdfatfile.openNextFile();
		if (file) return File(new SDFile(file));
     660:	movs	r0, #104	; 0x68
     662:	bl	eff8 <operator new(unsigned int)>
     666:	mov	r4, r0
//#define BYTE 0
//#endif

class __FlashStringHelper;

class Print
     668:	ldrb.w	r6, [sp, #4]
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
     66c:	ldr	r2, [sp, #8]
     66e:	ldrb.w	r3, [sp, #12]
	// Classes derived from File are never meant to be constructed
	// anywhere other than open() in the parent FS class and
	// openNextFile() while traversing a directory.
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
     672:	ldr	r0, [pc, #108]	; (6e0 <SDFile::openNextFile(unsigned char)+0xb0>)
     674:	ldr	r1, [pc, #108]	; (6e4 <SDFile::openNextFile(unsigned char)+0xb4>)
     676:	strb	r6, [r4, #24]
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
     678:	mov.w	r8, #1000	; 0x3e8
{
  public:
	constexpr Print() : write_error(0) {}
     67c:	movs	r6, #0
     67e:	str	r0, [r4, #0]
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
     680:	str	r1, [r4, #20]
     682:	str	r2, [r4, #28]
     684:	strb.w	r3, [r4, #32]
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
     688:	add.w	r0, r4, #36	; 0x24
     68c:	add	r1, sp, #16
     68e:	strb	r6, [r4, #4]
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
     690:	strb	r6, [r4, #12]

#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
     692:	str	r6, [r4, #16]
     694:	str.w	r8, [r4, #8]
     698:	bl	b560 <FsBaseFile::FsBaseFile(FsBaseFile const&)>
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
     69c:	ldr	r3, [r4, #16]
#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
	File(File *file) {
     69e:	ldr	r2, [pc, #72]	; (6e8 <SDFile::openNextFile(unsigned char)+0xb8>)
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
     6a0:	str	r7, [r4, #20]
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
     6a2:	adds	r3, #1
     6a4:	str	r6, [r4, #100]	; 0x64
     6a6:	strb	r6, [r5, #4]
     6a8:	str.w	r8, [r5, #8]
     6ac:	strb	r6, [r5, #12]
		// can we use is_same or is_polymorphic with static_assert?
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
     6ae:	str	r4, [r5, #16]
		if (f) f->refcount++;
     6b0:	str	r3, [r4, #16]
#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
	File(File *file) {
     6b2:	str	r2, [r5, #0]
     6b4:	ldr	r3, [pc, #52]	; (6ec <SDFile::openNextFile(unsigned char)+0xbc>)
     6b6:	str	r3, [sp, #0]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
     6b8:	add	r0, sp, #16
     6ba:	bl	b5d8 <FsBaseFile::close()>
	}
	virtual File openNextFile(uint8_t mode=0) {
		SDFAT_FILE file = sdfatfile.openNextFile();
		if (file) return File(new SDFile(file));
		return File();
	}
     6be:	mov	r0, r5
     6c0:	add	sp, #80	; 0x50
     6c2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     6c6:	ldr	r3, [sp, #76]	; 0x4c
     6c8:	cmp	r3, #0
     6ca:	bne.n	660 <SDFile::openNextFile(unsigned char)+0x30>

#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
     6cc:	ldr	r2, [pc, #24]	; (6e8 <SDFile::openNextFile(unsigned char)+0xb8>)
     6ce:	strb	r3, [r5, #4]
     6d0:	str	r4, [r5, #8]
     6d2:	strb	r3, [r5, #12]
     6d4:	str	r3, [r5, #16]
     6d6:	str	r2, [r5, #0]
     6d8:	b.n	6b4 <SDFile::openNextFile(unsigned char)+0x84>
     6da:	nop
     6dc:	.word	0x000140b8
     6e0:	.word	0x0001413c
     6e4:	.word	0x00014070
     6e8:	.word	0x000140dc
     6ec:	.word	0x00014094

000006f0 <dateTime(unsigned short*, unsigned short*, unsigned char*)>:

/****************** File Utilities *****************************/
  #if USE_SD==1
    // Call back for file timestamps.  Only called for file create and sync()
    void dateTime(uint16_t* date, uint16_t* time, uint8_t* ms10) 
    { *date = FS_DATE(year(), month(), day());
     6f0:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     6f4:	mov	r7, r1
     6f6:	mov	r6, r2
     6f8:	mov	r8, r0
     6fa:	bl	8160 <year()>
     6fe:	mov	r4, r0
     700:	bl	8140 <month()>
     704:	mov	r5, r0
     706:	bl	8120 <day()>
 * \param[in] day [1,31]
 *
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
     70a:	subw	r3, r4, #1980	; 0x7bc
     70e:	uxth	r3, r3
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
     710:	cmp	r3, #127	; 0x7f
     712:	bhi.n	71a <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x2a>
 *
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
     714:	uxtb	r2, r5
     716:	cmp	r2, #12
     718:	bls.n	772 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x82>
         year << 9 | month << 5 | day;
     71a:	movs	r3, #0
     71c:	strh.w	r3, [r8]
      *time = FS_TIME(hour(), minute(), second());
     720:	bl	80c0 <hour()>
     724:	mov	r4, r0
     726:	bl	80e0 <minute()>
     72a:	mov	r5, r0
     72c:	bl	8100 <second()>
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
     730:	uxtb	r3, r4
     732:	cmp	r3, #23
     734:	bhi.n	73c <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x4c>
 * \param[in] second [0,59]
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
     736:	uxtb	r3, r5
     738:	cmp	r3, #59	; 0x3b
     73a:	bls.n	754 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x64>
         hour << 11 | minute << 5 | second >> 1;
     73c:	movs	r3, #0
     73e:	strh	r3, [r7, #0]
      *ms10 = second() & 1 ? 100 : 0;
     740:	bl	8100 <second()>
     744:	tst.w	r0, #1
     748:	ite	ne
     74a:	movne	r3, #100	; 0x64
     74c:	moveq	r3, #0
     74e:	strb	r3, [r6, #0]
     750:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 * \param[in] second [0,59]
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
     754:	uxtb	r3, r0
     756:	cmp	r3, #59	; 0x3b
     758:	bhi.n	73c <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x4c>
         hour << 11 | minute << 5 | second >> 1;
     75a:	lsls	r4, r4, #11
     75c:	lsls	r3, r5, #5
     75e:	and.w	r4, r4, #522240	; 0x7f800
     762:	and.w	r3, r3, #8160	; 0x1fe0
     766:	orrs	r3, r4
     768:	ubfx	r0, r0, #1, #7
     76c:	orrs	r3, r0
     76e:	uxth	r3, r3
     770:	b.n	73e <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x4e>

/****************** File Utilities *****************************/
  #if USE_SD==1
    // Call back for file timestamps.  Only called for file create and sync()
    void dateTime(uint16_t* date, uint16_t* time, uint8_t* ms10) 
    { *date = FS_DATE(year(), month(), day());
     772:	uxtb	r0, r0
 *
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
     774:	cmp	r0, #31
     776:	bhi.n	71a <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x2a>
         year << 9 | month << 5 | day;
     778:	lsls	r5, r5, #5
     77a:	and.w	r5, r5, #8160	; 0x1fe0
     77e:	orrs	r0, r5
     780:	orr.w	r3, r0, r3, lsl #9
     784:	uxth	r3, r3
     786:	b.n	71c <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x2c>

00000788 <DMAChannel::~DMAChannel()>:
	}
	DMAChannel & operator = (const DMASetting &rhs) {
		copy_tcd(TCD, rhs.TCD);
		return *this;
	}
	~DMAChannel() {
     788:	push	{r4, lr}
     78a:	mov	r4, r0
		release();
     78c:	bl	ed78 <DMAChannel::release()>
	}
     790:	mov	r0, r4
     792:	pop	{r4, pc}

00000794 <SDFile::available()>:
		return sdfatfile.write(buf, size);
	}
	virtual int peek() {
		return sdfatfile.peek();
	}
	virtual int available() {
     794:	ldr	r2, [r0, #92]	; 0x5c
  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() const {
    return m_fFile ? m_fFile->available() :
           m_xFile ? m_xFile->available() : 0;
     796:	cbz	r2, 7b2 <SDFile::available()+0x1e>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint32_t available32() const {
    return isFile() ? fileSize() - curPosition() : 0;
     798:	ldrb	r3, [r2, #0]
     79a:	and.w	r3, r3, #8
     79e:	and.w	r0, r3, #255	; 0xff
     7a2:	cbz	r3, 7e6 <SDFile::available()+0x52>
   * Zero is returned for directory files.
   *
   */
  int available() const {
    uint32_t n = available32();
    return n > INT_MAX ? INT_MAX : n;
     7a4:	ldr	r3, [r2, #28]
     7a6:	ldr	r0, [r2, #20]
     7a8:	subs	r0, r3, r0
     7aa:	it	mi
     7ac:	mvnmi.w	r0, #2147483648	; 0x80000000
     7b0:	bx	lr
     7b2:	ldr	r1, [r0, #96]	; 0x60
     7b4:	cbz	r1, 7e8 <SDFile::available()+0x54>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint64_t available64() {
    return isFile() ? fileSize() - curPosition() : 0;
     7b6:	ldrb.w	r3, [r1, #49]	; 0x31
     7ba:	and.w	r3, r3, #8
     7be:	and.w	r0, r3, #255	; 0xff
     7c2:	cbz	r3, 7e6 <SDFile::available()+0x52>
     7c4:	ldrd	r2, r3, [r1, #16]
     7c8:	ldrd	r0, r1, [r1]
     7cc:	subs	r0, r2, r0
     7ce:	push	{r4, r5}
     7d0:	sbc.w	r1, r3, r1
     7d4:	movs	r5, #0
     7d6:	mvn.w	r4, #2147483648	; 0x80000000
     7da:	cmp	r5, r1
     7dc:	it	eq
     7de:	cmpeq	r4, r0
     7e0:	bcs.n	7e4 <SDFile::available()+0x50>
     7e2:	mov	r0, r4
		return sdfatfile.available();
	}
     7e4:	pop	{r4, r5}
     7e6:	bx	lr
     7e8:	mov	r0, r1
     7ea:	bx	lr

000007ec <StreamFile<FsBaseFile, unsigned long long>::peek()>:
  const char* name() const {return "use getName()";}
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
     7ec:	ldr	r3, [r0, #72]	; 0x48
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
    return m_fFile ? m_fFile->peek() :
           m_xFile ? m_xFile->peek() : -1;
     7ee:	cbz	r3, 7f6 <StreamFile<FsBaseFile, unsigned long long>::peek()+0xa>
     7f0:	mov	r0, r3
     7f2:	b.w	a120 <FatFile::peek()>
     7f6:	ldr	r0, [r0, #76]	; 0x4c
     7f8:	cbz	r0, 7fe <StreamFile<FsBaseFile, unsigned long long>::peek()+0x12>
     7fa:	b.w	85b0 <ExFatFile::peek()>
    return BaseFile::peek();
  }
     7fe:	mov.w	r0, #4294967295
     802:	bx	lr

00000804 <StreamFile<FsBaseFile, unsigned long long>::read()>:
  /** Read the next byte from a file.
   *
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
     804:	push	{lr}
     806:	ldr	r3, [r0, #72]	; 0x48
     808:	sub	sp, #12
   * read() called before a file has been opened, corrupt file system
   * or an I/O error occurred.
   */
  int read(void* buf, size_t count) {
    return m_fFile ? m_fFile->read(buf, count) :
           m_xFile ? m_xFile->read(buf, count) : -1;
     80a:	cbz	r3, 826 <StreamFile<FsBaseFile, unsigned long long>::read()+0x22>
     80c:	mov	r0, r3
     80e:	movs	r2, #1
     810:	add.w	r1, sp, #7
     814:	bl	9f80 <FatFile::read(void*, unsigned int)>
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
     818:	cmp	r0, #1
     81a:	bne.n	836 <StreamFile<FsBaseFile, unsigned long long>::read()+0x32>
     81c:	ldrb.w	r0, [sp, #7]
    return BaseFile::read();
  }
     820:	add	sp, #12
     822:	ldr.w	pc, [sp], #4
   * read() called before a file has been opened, corrupt file system
   * or an I/O error occurred.
   */
  int read(void* buf, size_t count) {
    return m_fFile ? m_fFile->read(buf, count) :
           m_xFile ? m_xFile->read(buf, count) : -1;
     826:	ldr	r0, [r0, #76]	; 0x4c
     828:	cbz	r0, 836 <StreamFile<FsBaseFile, unsigned long long>::read()+0x32>
     82a:	movs	r2, #1
     82c:	add.w	r1, sp, #7
     830:	bl	8408 <ExFatFile::read(void*, unsigned int)>
     834:	b.n	818 <StreamFile<FsBaseFile, unsigned long long>::read()+0x14>
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
     836:	mov.w	r0, #4294967295
     83a:	b.n	820 <StreamFile<FsBaseFile, unsigned long long>::read()+0x1c>

0000083c <SDFile::flush()>:
	virtual void flush() {
     83c:	ldr	r3, [r0, #92]	; 0x5c
   *
   * \return true for success or false for failure.
   */
  bool sync() {
    return m_fFile ? m_fFile->sync() :
           m_xFile ? m_xFile->sync() : false;
     83e:	cbz	r3, 846 <SDFile::flush()+0xa>
     840:	mov	r0, r3
     842:	b.w	a5c4 <FatFile::sync()>
     846:	ldr	r0, [r0, #96]	; 0x60
     848:	cbz	r0, 84e <SDFile::flush()+0x12>
     84a:	b.w	944c <ExFatFile::sync()>
     84e:	bx	lr

00000850 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)>:
  /** Write a byte to a file. Required by the Arduino Print class.
   * \param[in] b the byte to be written.
   * Use getWriteError to check for errors.
   * \return 1 for success and 0 for failure.
   */
  size_t write(uint8_t b) {
     850:	push	{lr}
     852:	ldr	r3, [r0, #72]	; 0x48
     854:	sub	sp, #12
     856:	strb.w	r1, [sp, #7]
   * for a read-only file, device is full, a corrupt file system or an
   * I/O error.
   */
  size_t write(const void* buf, size_t count) {
    return m_fFile ? m_fFile->write(buf, count) :
           m_xFile ? m_xFile->write(buf, count) : 0;
     85a:	cbz	r3, 86e <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)+0x1e>
     85c:	mov	r0, r3
     85e:	movs	r2, #1
     860:	add.w	r1, sp, #7
     864:	bl	a648 <FatFile::write(void const*, unsigned int)>
    return BaseFile::write(b);
  }
     868:	add	sp, #12
     86a:	ldr.w	pc, [sp], #4
     86e:	ldr	r0, [r0, #76]	; 0x4c
     870:	cmp	r0, #0
     872:	beq.n	868 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)+0x18>
     874:	movs	r2, #1
     876:	add.w	r1, sp, #7
     87a:	bl	9858 <ExFatFile::write(void const*, unsigned int)>
     87e:	add	sp, #12
     880:	ldr.w	pc, [sp], #4

00000884 <logg(unsigned long, char const*) [clone .part.53]>:
}

/**************** Online logging *******************************/
extern uint32_t loop_count, acq_count, acq_miss, maxDel;
extern uint16_t maxCount;
void logg(uint32_t del, const char *txt)
     884:	stmdb	sp!, {r4, r5, r6, r7, r9, lr}
{ static uint32_t to;
  if(millis()-to > del)
  {
    Serial.printf("%s: %6d %4d %4d %4d %4d %d\n",
     888:	ldr	r2, [pc, #80]	; (8dc <logg(unsigned long, char const*) [clone .part.53]+0x58>)
            txt,loop_count, acq_count, acq_miss,maxCount, maxDel,state); 
     88a:	ldr	r4, [pc, #84]	; (8e0 <logg(unsigned long, char const*) [clone .part.53]+0x5c>)
     88c:	ldrsh.w	r1, [r2]
extern uint16_t maxCount;
void logg(uint32_t del, const char *txt)
{ static uint32_t to;
  if(millis()-to > del)
  {
    Serial.printf("%s: %6d %4d %4d %4d %4d %d\n",
     890:	ldr	r5, [pc, #80]	; (8e4 <logg(unsigned long, char const*) [clone .part.53]+0x60>)
            txt,loop_count, acq_count, acq_miss,maxCount, maxDel,state); 
     892:	ldr	r6, [pc, #84]	; (8e8 <logg(unsigned long, char const*) [clone .part.53]+0x64>)
     894:	ldr	r7, [pc, #84]	; (8ec <logg(unsigned long, char const*) [clone .part.53]+0x68>)
     896:	ldrh	r2, [r5, #0]
     898:	ldr.w	r9, [pc, #100]	; 900 <logg(unsigned long, char const*) [clone .part.53]+0x7c>
}

/**************** Online logging *******************************/
extern uint32_t loop_count, acq_count, acq_miss, maxDel;
extern uint16_t maxCount;
void logg(uint32_t del, const char *txt)
     89c:	sub	sp, #32
{ static uint32_t to;
  if(millis()-to > del)
  {
    Serial.printf("%s: %6d %4d %4d %4d %4d %d\n",
            txt,loop_count, acq_count, acq_miss,maxCount, maxDel,state); 
     89e:	ldr.w	r3, [r9]
     8a2:	str	r1, [sp, #16]
     8a4:	ldr	r1, [r4, #0]
     8a6:	str	r1, [sp, #12]
     8a8:	ldr	r1, [r7, #0]
     8aa:	str	r2, [sp, #8]
     8ac:	mov	r2, r0
     8ae:	ldr	r0, [r6, #0]
     8b0:	str	r0, [sp, #4]
     8b2:	str	r1, [sp, #0]
     8b4:	ldr	r0, [pc, #56]	; (8f0 <logg(unsigned long, char const*) [clone .part.53]+0x6c>)
     8b6:	ldr	r1, [pc, #60]	; (8f4 <logg(unsigned long, char const*) [clone .part.53]+0x70>)
     8b8:	bl	ef0c <Print::printf(char const*, ...)>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     8bc:	ldr	r3, [pc, #56]	; (8f8 <logg(unsigned long, char const*) [clone .part.53]+0x74>)
    loop_count=0;
    acq_count=0;
    acq_miss=0;
    maxCount=0;
    maxDel=0;
    to=millis();
     8be:	ldr	r2, [pc, #60]	; (8fc <logg(unsigned long, char const*) [clone .part.53]+0x78>)
     8c0:	ldr	r3, [r3, #0]
     8c2:	str	r3, [sp, #28]
	return ret;
     8c4:	ldr	r1, [sp, #28]
     8c6:	str	r1, [r2, #0]
{ static uint32_t to;
  if(millis()-to > del)
  {
    Serial.printf("%s: %6d %4d %4d %4d %4d %d\n",
            txt,loop_count, acq_count, acq_miss,maxCount, maxDel,state); 
    loop_count=0;
     8c8:	movs	r3, #0
     8ca:	str.w	r3, [r9]
    acq_count=0;
     8ce:	str	r3, [r7, #0]
    acq_miss=0;
     8d0:	str	r3, [r6, #0]
    maxCount=0;
     8d2:	strh	r3, [r5, #0]
    maxDel=0;
     8d4:	str	r3, [r4, #0]
    to=millis();
  }
}
     8d6:	add	sp, #32
     8d8:	ldmia.w	sp!, {r4, r5, r6, r7, r9, pc}
     8dc:	.word	0x1fff1bc6
     8e0:	.word	0x1fff14b8
     8e4:	.word	0x1fff614c
     8e8:	.word	0x1fff6154
     8ec:	.word	0x1fff18bc
     8f0:	.word	0x1fff0ad0
     8f4:	.word	0x000141f8
     8f8:	.word	0x1fff66b0
     8fc:	.word	0x1fff615c
     900:	.word	0x1fff6150

00000904 <SDClass::remove(char const*)>:
		return sdfs.mkdir(filepath);
	}
	bool rename(const char *oldfilepath, const char *newfilepath) {
		return sdfs.rename(oldfilepath, newfilepath);
	}
	bool remove(const char *filepath) {
     904:	push	{r4, lr}
     906:	ldr.w	r4, [r0, #1156]	; 0x484
     90a:	sub	sp, #56	; 0x38
  *
   * \return true for success or false for failure.
  */
  bool remove(const char *path) {
    return m_fVol ? m_fVol->remove(path) :
           m_xVol ? m_xVol->remove(path) : false;
     90c:	cbz	r4, 938 <SDClass::remove(char const*)+0x34>
   *
   * \return true for success or false for failure.
   */
  bool remove(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
     90e:	mov	r2, r1
     910:	mov	r0, sp
     912:	mov	r1, r4
     914:	movs	r3, #1
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
     916:	movs	r4, #0
     918:	strb.w	r4, [sp]
     91c:	strb.w	r4, [sp, #1]
     920:	strb.w	r4, [sp, #2]
     924:	bl	9f64 <FatFile::open(FatVolume*, char const*, int)>
     928:	cbnz	r0, 92e <SDClass::remove(char const*)+0x2a>
		return sdfs.remove(filepath);
	}
     92a:	add	sp, #56	; 0x38
     92c:	pop	{r4, pc}
     92e:	mov	r0, sp
     930:	bl	af78 <FatFile::remove()>
     934:	add	sp, #56	; 0x38
     936:	pop	{r4, pc}
     938:	ldr.w	r0, [r0, #1160]	; 0x488
     93c:	cmp	r0, #0
     93e:	beq.n	92a <SDClass::remove(char const*)+0x26>
   *
   * \return true for success or false for failure.
   */
  bool remove(const ExChar_t* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
     940:	mov	r2, r1
     942:	movs	r3, #1
     944:	mov	r1, r0
     946:	mov	r0, sp
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
     948:	strb.w	r4, [sp, #49]	; 0x31
     94c:	strb.w	r4, [sp, #50]	; 0x32
     950:	strb.w	r4, [sp, #51]	; 0x33
     954:	bl	8bbc <ExFatFile::open(ExFatVolume*, char const*, int)>
     958:	cmp	r0, #0
     95a:	beq.n	92a <SDClass::remove(char const*)+0x26>
     95c:	mov	r0, sp
     95e:	bl	91d4 <ExFatFile::remove()>
     962:	add	sp, #56	; 0x38
     964:	pop	{r4, pc}
     966:	nop

00000968 <SDFile::name()>:
		sdfatfile.close();
	}
	virtual operator bool() {
		return sdfatfile.isOpen();
	}
	virtual const char * name() {
     968:	push	{r3, r4, r5, lr}
		if (!filename) {
     96a:	ldr	r4, [r0, #100]	; 0x64
     96c:	cbz	r4, 972 <SDFile::name()+0xa>
				static char zeroterm = 0;
				filename = &zeroterm;
			}
		}
		return filename;
	}
     96e:	mov	r0, r4
     970:	pop	{r3, r4, r5, pc}
     972:	mov	r5, r0
	virtual operator bool() {
		return sdfatfile.isOpen();
	}
	virtual const char * name() {
		if (!filename) {
			filename = (char *)malloc(MAX_FILENAME_LEN);
     974:	mov.w	r0, #256	; 0x100
     978:	bl	fe10 <malloc>
     97c:	mov	r1, r0
     97e:	str	r0, [r5, #100]	; 0x64
			if (filename) {
     980:	cbz	r0, 9a4 <SDFile::name()+0x3c>
   *             truncated if the file's name is too long.
   * \return The length of the returned string.
   */
  size_t getName(char* name, size_t len) {
    *name = 0;
    return m_fFile ? m_fFile->getName(name, len) :
     982:	ldr	r0, [r5, #92]	; 0x5c
   *             must be at least 13 bytes long.  The file's name will be
   *             truncated if the file's name is too long.
   * \return The length of the returned string.
   */
  size_t getName(char* name, size_t len) {
    *name = 0;
     984:	strb	r4, [r1, #0]
    return m_fFile ? m_fFile->getName(name, len) :
           m_xFile ? m_xFile->getName(name, len) : 0;
     986:	cbz	r0, 994 <SDFile::name()+0x2c>
     988:	mov.w	r2, #256	; 0x100
     98c:	bl	ac40 <FatFile::getName(char*, unsigned int)>
     990:	ldr	r4, [r5, #100]	; 0x64
     992:	b.n	96e <SDFile::name()+0x6>
     994:	ldr	r0, [r5, #96]	; 0x60
     996:	cbz	r0, 9aa <SDFile::name()+0x42>
     998:	mov.w	r2, #256	; 0x100
     99c:	bl	826c <ExFatFile::getName(char*, unsigned int)>
     9a0:	ldr	r4, [r5, #100]	; 0x64
     9a2:	b.n	96e <SDFile::name()+0x6>
				sdfatfile.getName(filename, MAX_FILENAME_LEN);
			} else {
				static char zeroterm = 0;
				filename = &zeroterm;
     9a4:	ldr	r4, [pc, #8]	; (9b0 <SDFile::name()+0x48>)
     9a6:	str	r4, [r5, #100]	; 0x64
     9a8:	b.n	96e <SDFile::name()+0x6>
     9aa:	mov	r4, r1
     9ac:	b.n	96e <SDFile::name()+0x6>
     9ae:	nop
     9b0:	.word	0x1fff14ac

000009b4 <SDFile::truncate(unsigned long long)>:
		sdfatfile.flush();
	}
	virtual size_t read(void *buf, size_t nbyte) {
		return sdfatfile.read(buf, nbyte);
	}
	virtual bool truncate(uint64_t size=0) {
     9b4:	push	{r4, r6, r7, lr}
     9b6:	ldr	r4, [r0, #92]	; 0x5c
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
           m_xFile ? m_xFile->truncate(length) : false;
     9b8:	cbz	r4, 9de <SDFile::truncate(unsigned long long)+0x2a>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
     9ba:	cmp	r3, #1
     9bc:	it	eq
     9be:	cmpeq	r2, #0
     9c0:	bcc.n	9c6 <SDFile::truncate(unsigned long long)+0x12>
     9c2:	movs	r0, #0
		return sdfatfile.truncate(size);
	}
     9c4:	pop	{r4, r6, r7, pc}
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint32_t length) {
    return seekSet(length) && truncate();
     9c6:	mov	r1, r2
     9c8:	mov	r0, r4
     9ca:	bl	a3bc <FatFile::seekSet(unsigned long)>
     9ce:	cmp	r0, #0
     9d0:	beq.n	9c2 <SDFile::truncate(unsigned long long)+0xe>
     9d2:	mov	r0, r4
     9d4:	bl	a5d0 <FatFile::truncate()>
     9d8:	cmp	r0, #0
     9da:	beq.n	9c2 <SDFile::truncate(unsigned long long)+0xe>
     9dc:	pop	{r4, r6, r7, pc}
           m_xFile ? m_xFile->truncate(length) : false;
     9de:	ldr	r4, [r0, #96]	; 0x60
     9e0:	cmp	r4, #0
     9e2:	beq.n	9c2 <SDFile::truncate(unsigned long long)+0xe>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return seekSet(length) && truncate();
     9e4:	mov	r0, r4
     9e6:	bl	85e0 <ExFatFile::seekSet(unsigned long long)>
     9ea:	cmp	r0, #0
     9ec:	beq.n	9c2 <SDFile::truncate(unsigned long long)+0xe>
     9ee:	mov	r0, r4
     9f0:	ldmia.w	sp!, {r4, r6, r7, lr}
     9f4:	b.w	9774 <ExFatFile::truncate()>

000009f8 <SDClass::mkdir(char const*)>:
		return File();
	}
	bool exists(const char *filepath) {
		return sdfs.exists(filepath);
	}
	bool mkdir(const char *filepath) {
     9f8:	push	{r4, lr}
     9fa:	ldr.w	r4, [r0, #1156]	; 0x484
     9fe:	sub	sp, #56	; 0x38
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char *path, bool pFlag = true) {
    return m_fVol ? m_fVol->mkdir(path, pFlag) :
           m_xVol ? m_xVol->mkdir(path, pFlag) : false;
     a00:	cbz	r4, a22 <SDClass::mkdir(char const*)+0x2a>
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    FatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
     a02:	mov	r2, r1
     a04:	movs	r3, #1
     a06:	addw	r1, r4, #1092	; 0x444
     a0a:	mov	r0, sp
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
     a0c:	movs	r4, #0
     a0e:	strb.w	r4, [sp]
     a12:	strb.w	r4, [sp, #1]
     a16:	strb.w	r4, [sp, #2]
     a1a:	bl	9de0 <FatFile::mkdir(FatFile*, char const*, bool)>
		return sdfs.mkdir(filepath);
	}
     a1e:	add	sp, #56	; 0x38
     a20:	pop	{r4, pc}
     a22:	ldr.w	r0, [r0, #1160]	; 0x488
     a26:	cmp	r0, #0
     a28:	beq.n	a1e <SDClass::mkdir(char const*)+0x26>
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const ExChar_t* path, bool pFlag = true) {
    ExFatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
     a2a:	mov	r2, r1
     a2c:	movs	r3, #1
     a2e:	add.w	r1, r0, #1096	; 0x448
     a32:	mov	r0, sp
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
     a34:	strb.w	r4, [sp, #49]	; 0x31
     a38:	strb.w	r4, [sp, #50]	; 0x32
     a3c:	strb.w	r4, [sp, #51]	; 0x33
     a40:	bl	95f0 <ExFatFile::mkdir(ExFatFile*, char const*, bool)>
     a44:	add	sp, #56	; 0x38
     a46:	pop	{r4, pc}

00000a48 <SDClass::exists(char const*)>:
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
		if (file) return File(new SDFile(file));
		return File();
	}
	bool exists(const char *filepath) {
     a48:	push	{r4, r5, lr}
     a4a:	ldr.w	r4, [r0, #1156]	; 0x484
     a4e:	sub	sp, #60	; 0x3c
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return m_fVol ? m_fVol->exists(path) :
           m_xVol ? m_xVol->exists(path) : false;
     a50:	cbz	r4, a70 <SDClass::exists(char const*)+0x28>
     a52:	movs	r5, #0
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_RDONLY);
     a54:	mov	r2, r1
     a56:	mov	r3, r5
     a58:	mov	r1, r4
     a5a:	mov	r0, sp
     a5c:	strb.w	r5, [sp]
     a60:	strb.w	r5, [sp, #1]
     a64:	strb.w	r5, [sp, #2]
     a68:	bl	9f64 <FatFile::open(FatVolume*, char const*, int)>
		return sdfs.exists(filepath);
	}
     a6c:	add	sp, #60	; 0x3c
     a6e:	pop	{r4, r5, pc}
     a70:	ldr.w	r0, [r0, #1160]	; 0x488
     a74:	cmp	r0, #0
     a76:	beq.n	a6c <SDClass::exists(char const*)+0x24>
   *
   * \return true if the file exists else false.
   */
  bool exists(const ExChar_t* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_RDONLY);
     a78:	mov	r2, r1
     a7a:	mov	r3, r4
     a7c:	mov	r1, r0
     a7e:	mov	r0, sp
     a80:	strb.w	r4, [sp, #49]	; 0x31
     a84:	strb.w	r4, [sp, #50]	; 0x32
     a88:	strb.w	r4, [sp, #51]	; 0x33
     a8c:	bl	8bbc <ExFatFile::open(ExFatVolume*, char const*, int)>
     a90:	add	sp, #60	; 0x3c
     a92:	pop	{r4, r5, pc}

00000a94 <SDFile::rewindDirectory()>:
	virtual File openNextFile(uint8_t mode=0) {
		SDFAT_FILE file = sdfatfile.openNextFile();
		if (file) return File(new SDFile(file));
		return File();
	}
	virtual void rewindDirectory(void) {
     a94:	ldr	r3, [r0, #92]	; 0x5c
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  }
  /** \return True if this is a directory else false. */
  bool isDir() const {
    return m_fFile ? m_fFile->isDir() :
           m_xFile ? m_xFile->isDir() : false;
     a96:	cbz	r3, ac0 <SDFile::rewindDirectory()+0x2c>
  int read() {
    return BaseFile::read();
  }
  /** Rewind a file if it is a directory */
  void rewindDirectory() {
    if (BaseFile::isDir()) {
     a98:	ldrb	r2, [r3, #0]
     a9a:	tst.w	r2, #112	; 0x70
     a9e:	bne.n	aa2 <SDFile::rewindDirectory()+0xe>
     aa0:	bx	lr
     aa2:	push	{r4, lr}
     aa4:	mov	r4, r0
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
     aa6:	movs	r1, #0
     aa8:	mov	r0, r3
     aaa:	bl	a3bc <FatFile::seekSet(unsigned long)>
     aae:	ldr	r0, [r4, #96]	; 0x60
           m_xFile ? m_xFile->rename(dirFile->m_xFile, newPath) : false;
  }
  /** Set the file's current position to zero. */
  void rewind() {
    if (m_fFile) m_fFile->rewind();
    if (m_xFile) m_xFile->rewind();
     ab0:	cbz	r0, abe <SDFile::rewindDirectory()+0x2a>
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const ExChar_t* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
     ab2:	movs	r2, #0
     ab4:	movs	r3, #0
		sdfatfile.rewindDirectory();
	}
     ab6:	ldmia.w	sp!, {r4, lr}
     aba:	b.w	85e0 <ExFatFile::seekSet(unsigned long long)>
     abe:	pop	{r4, pc}
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  }
  /** \return True if this is a directory else false. */
  bool isDir() const {
    return m_fFile ? m_fFile->isDir() :
           m_xFile ? m_xFile->isDir() : false;
     ac0:	ldr	r0, [r0, #96]	; 0x60
     ac2:	cmp	r0, #0
     ac4:	beq.n	aa0 <SDFile::rewindDirectory()+0xc>
     ac6:	ldrb.w	r3, [r0, #49]	; 0x31
     aca:	tst.w	r3, #80	; 0x50
     ace:	beq.n	aa0 <SDFile::rewindDirectory()+0xc>
     ad0:	movs	r2, #0
     ad2:	movs	r3, #0
     ad4:	b.w	85e0 <ExFatFile::seekSet(unsigned long long)>

00000ad8 <SDClass::rmdir(char const*)>:
		return sdfs.rename(oldfilepath, newfilepath);
	}
	bool remove(const char *filepath) {
		return sdfs.remove(filepath);
	}
	bool rmdir(const char *filepath) {
     ad8:	push	{r4, r5, lr}
     ada:	ldr.w	r4, [r0, #1156]	; 0x484
     ade:	sub	sp, #60	; 0x3c
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char *path) {
    return m_fVol ? m_fVol->rmdir(path) :
           m_xVol ? m_xVol->rmdir(path) : false;
     ae0:	cbz	r4, b0c <SDClass::rmdir(char const*)+0x34>
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
     ae2:	movs	r5, #0
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char* path) {
    FatFile sub;
    return sub.open(this, path, O_RDONLY) && sub.rmdir();
     ae4:	mov	r2, r1
     ae6:	mov	r3, r5
     ae8:	mov	r1, r4
     aea:	mov	r0, sp
     aec:	strb.w	r5, [sp]
     af0:	strb.w	r5, [sp, #1]
     af4:	strb.w	r5, [sp, #2]
     af8:	bl	9f64 <FatFile::open(FatVolume*, char const*, int)>
     afc:	cbnz	r0, b02 <SDClass::rmdir(char const*)+0x2a>
		return sdfs.rmdir(filepath);
	}
     afe:	add	sp, #60	; 0x3c
     b00:	pop	{r4, r5, pc}
     b02:	mov	r0, sp
     b04:	bl	a360 <FatFile::rmdir()>
     b08:	add	sp, #60	; 0x3c
     b0a:	pop	{r4, r5, pc}
     b0c:	ldr.w	r0, [r0, #1160]	; 0x488
     b10:	cmp	r0, #0
     b12:	beq.n	afe <SDClass::rmdir(char const*)+0x26>
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const ExChar_t* path) {
    ExFatFile sub;
    return sub.open(this, path, O_RDONLY) && sub.rmdir();
     b14:	mov	r2, r1
     b16:	mov	r3, r4
     b18:	mov	r1, r0
     b1a:	mov	r0, sp
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
     b1c:	strb.w	r4, [sp, #49]	; 0x31
     b20:	strb.w	r4, [sp, #50]	; 0x32
     b24:	strb.w	r4, [sp, #51]	; 0x33
     b28:	bl	8bbc <ExFatFile::open(ExFatVolume*, char const*, int)>
     b2c:	cmp	r0, #0
     b2e:	beq.n	afe <SDClass::rmdir(char const*)+0x26>
     b30:	mov	r0, sp
     b32:	bl	92ac <ExFatFile::rmdir()>
     b36:	add	sp, #60	; 0x3c
     b38:	pop	{r4, r5, pc}
     b3a:	nop

00000b3c <SDClass::rename(char const*, char const*)>:
		return sdfs.exists(filepath);
	}
	bool mkdir(const char *filepath) {
		return sdfs.mkdir(filepath);
	}
	bool rename(const char *oldfilepath, const char *newfilepath) {
     b3c:	push	{r4, r5, r6, lr}
     b3e:	ldr.w	r4, [r0, #1156]	; 0x484
     b42:	sub	sp, #56	; 0x38
     b44:	mov	r6, r2
   *
   * \return true for success or false for failure.
   */
  bool rename(const char *oldPath, const char *newPath) {
    return m_fVol ? m_fVol->rename(oldPath, newPath) :
           m_xVol ? m_xVol->rename(oldPath, newPath) : false;
     b46:	cbz	r4, b7a <SDClass::rename(char const*, char const*)+0x3e>
     b48:	movs	r5, #0
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend FatFile;
  static FatVolume* cwv() {return m_cwv;}
  FatFile* vwd() {return &m_vwd;}
     b4a:	addw	r4, r4, #1092	; 0x444
   *
   * \return true for success or false for failure.
   */
  bool rename(const char *oldPath, const char *newPath) {
    FatFile file;
    return file.open(vwd(), oldPath, O_RDONLY) && file.rename(vwd(), newPath);
     b4e:	mov	r2, r1
     b50:	mov	r3, r5
     b52:	mov	r1, r4
     b54:	mov	r0, sp
     b56:	strb.w	r5, [sp]
     b5a:	strb.w	r5, [sp, #1]
     b5e:	strb.w	r5, [sp, #2]
     b62:	bl	9ea4 <FatFile::open(FatFile*, char const*, int)>
     b66:	cbnz	r0, b6c <SDClass::rename(char const*, char const*)+0x30>
		return sdfs.rename(oldfilepath, newfilepath);
	}
     b68:	add	sp, #56	; 0x38
     b6a:	pop	{r4, r5, r6, pc}
     b6c:	mov	r2, r6
     b6e:	mov	r1, r4
     b70:	mov	r0, sp
     b72:	bl	a18c <FatFile::rename(FatFile*, char const*)>
     b76:	add	sp, #56	; 0x38
     b78:	pop	{r4, r5, r6, pc}
     b7a:	ldr.w	r0, [r0, #1160]	; 0x488
     b7e:	cmp	r0, #0
     b80:	beq.n	b68 <SDClass::rename(char const*, char const*)+0x2c>
#endif  //  USE_EXFAT_UNICODE_NAMES

 private:
  friend ExFatFile;
  static ExFatVolume* cwv() {return m_cwv;}
  ExFatFile* vwd() {return &m_vwd;}
     b82:	add.w	r5, r0, #1096	; 0x448
   *
   * \return true for success or false for failure.
   */
  bool rename(const ExChar_t* oldPath, const ExChar_t* newPath) {
    ExFatFile file;
    return file.open(vwd(), oldPath, O_RDONLY) && file.rename(vwd(), newPath);
     b86:	mov	r2, r1
     b88:	mov	r3, r4
     b8a:	mov	r1, r5
     b8c:	mov	r0, sp
     b8e:	strb.w	r4, [sp, #49]	; 0x31
     b92:	strb.w	r4, [sp, #50]	; 0x32
     b96:	strb.w	r4, [sp, #51]	; 0x33
     b9a:	bl	8abc <ExFatFile::open(ExFatFile*, char const*, int)>
     b9e:	cmp	r0, #0
     ba0:	beq.n	b68 <SDClass::rename(char const*, char const*)+0x2c>
     ba2:	mov	r2, r6
     ba4:	mov	r1, r5
     ba6:	mov	r0, sp
     ba8:	bl	96c8 <ExFatFile::rename(ExFatFile*, char const*)>
     bac:	add	sp, #56	; 0x38
     bae:	pop	{r4, r5, r6, pc}

00000bb0 <SDClass::usedSize()>:
		return sdfs.remove(filepath);
	}
	bool rmdir(const char *filepath) {
		return sdfs.rmdir(filepath);
	}
	uint64_t usedSize() {
     bb0:	push	{r3, r4, r5, lr}
     bb2:	mov	r5, r0
     bb4:	ldr.w	r0, [r0, #1156]	; 0x484
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
     bb8:	cbz	r0, bec <SDClass::usedSize()+0x3c>
  uint8_t* cacheClear() {
    return m_cache.clear();
  }
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_lastCluster - 1;
     bba:	ldr	r4, [r0, #28]
     bbc:	subs	r4, #1
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
     bbe:	bl	a9f8 <FatPartition::freeClusterCount()>
     bc2:	ldr.w	r3, [r5, #1156]	; 0x484
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
     bc6:	subs	r4, r4, r0
  uint32_t blocksPerCluster() __attribute__ ((deprecated)) {return sectorsPerCluster();} //NOLINT
#endif  // DOXYGEN_SHOULD_SKIP_THIS
  /** \return the number of bytes in a cluster. */
  uint32_t bytesPerCluster() const {
    return m_fVol ? m_fVol->bytesPerCluster() :
           m_xVol ? m_xVol->bytesPerCluster() : 0;
     bc8:	cbz	r3, bdc <SDClass::usedSize()+0x2c>
     bca:	ldrb	r0, [r3, #6]
     bcc:	mov.w	r3, #512	; 0x200
     bd0:	lsl.w	r0, r3, r0
     bd4:	uxth	r0, r0
     bd6:	umull	r0, r1, r0, r4
     bda:	pop	{r3, r4, r5, pc}
     bdc:	ldr.w	r3, [r5, #1160]	; 0x488
     be0:	cbz	r3, bfc <SDClass::usedSize()+0x4c>
     be2:	ldr.w	r0, [r3, #1084]	; 0x43c
     be6:	umull	r0, r1, r0, r4
     bea:	pop	{r3, r4, r5, pc}
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
     bec:	ldr.w	r0, [r5, #1160]	; 0x488
     bf0:	cbz	r0, bfc <SDClass::usedSize()+0x4c>
     bf2:	ldr.w	r4, [r0, #1072]	; 0x430
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
           m_xVol ? m_xVol->freeClusterCount() : 0;
     bf6:	bl	8f48 <ExFatPartition::freeClusterCount()>
     bfa:	b.n	bc2 <SDClass::usedSize()+0x12>
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
     bfc:	movs	r0, #0
     bfe:	movs	r1, #0
		  * (uint64_t)sdfs.bytesPerCluster();
	}
     c00:	pop	{r3, r4, r5, pc}
     c02:	nop

00000c04 <SDFile::position()>:
		if (mode == SeekSet) return sdfatfile.seekSet(pos);
		if (mode == SeekCur) return sdfatfile.seekCur(pos);
		if (mode == SeekEnd) return sdfatfile.seekEnd(pos);
		return false;
	}
	virtual uint64_t position() {
     c04:	ldr	r3, [r0, #92]	; 0x5c
           m_xFile ? m_xFile->contiguousRange(bgnSector, endSector) : false;
  }
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {
    return m_fFile ? m_fFile->curPosition() :
           m_xFile ? m_xFile->curPosition() : 0;
     c06:	cbz	r3, c0e <SDFile::position()+0xa>
     c08:	ldr	r0, [r3, #20]
     c0a:	movs	r1, #0
     c0c:	bx	lr
     c0e:	ldr	r3, [r0, #96]	; 0x60
     c10:	cbz	r3, c18 <SDFile::position()+0x14>
     c12:	ldmia.w	r3, {r0, r1}
     c16:	bx	lr
     c18:	mov	r0, r3
     c1a:	mov	r1, r3
		return sdfatfile.curPosition();
	}
     c1c:	bx	lr
     c1e:	nop

00000c20 <SDFile::size()>:
	virtual uint64_t size() {
     c20:	ldr	r3, [r0, #92]	; 0x5c
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
           m_xFile ? m_xFile->fileSize() : 0;
     c22:	cbz	r3, c2a <SDFile::size()+0xa>
     c24:	ldr	r0, [r3, #28]
     c26:	movs	r1, #0
     c28:	bx	lr
     c2a:	ldr	r3, [r0, #96]	; 0x60
     c2c:	cbz	r3, c34 <SDFile::size()+0x14>
     c2e:	ldr	r0, [r3, #16]
     c30:	ldr	r1, [r3, #20]
     c32:	bx	lr
     c34:	mov	r0, r3
     c36:	mov	r1, r3
		return sdfatfile.size();
	}
     c38:	bx	lr
     c3a:	nop

00000c3c <SDFile::read(void*, unsigned int)>:
		return sdfatfile.available();
	}
	virtual void flush() {
		sdfatfile.flush();
	}
	virtual size_t read(void *buf, size_t nbyte) {
     c3c:	ldr	r3, [r0, #92]	; 0x5c
   * read() called before a file has been opened, corrupt file system
   * or an I/O error occurred.
   */
  int read(void* buf, size_t count) {
    return m_fFile ? m_fFile->read(buf, count) :
           m_xFile ? m_xFile->read(buf, count) : -1;
     c3e:	cbz	r3, c46 <SDFile::read(void*, unsigned int)+0xa>
     c40:	mov	r0, r3
     c42:	b.w	9f80 <FatFile::read(void*, unsigned int)>
     c46:	ldr	r0, [r0, #96]	; 0x60
     c48:	cbz	r0, c4e <SDFile::read(void*, unsigned int)+0x12>
     c4a:	b.w	8408 <ExFatFile::read(void*, unsigned int)>
		return sdfatfile.read(buf, nbyte);
	}
     c4e:	mov.w	r0, #4294967295
     c52:	bx	lr

00000c54 <SDFile::peek()>:
	}
#endif
	virtual size_t write(const void *buf, size_t size) {
		return sdfatfile.write(buf, size);
	}
	virtual int peek() {
     c54:	ldr	r3, [r0, #92]	; 0x5c
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
    return m_fFile ? m_fFile->peek() :
           m_xFile ? m_xFile->peek() : -1;
     c56:	cbz	r3, c5e <SDFile::peek()+0xa>
     c58:	mov	r0, r3
     c5a:	b.w	a120 <FatFile::peek()>
     c5e:	ldr	r0, [r0, #96]	; 0x60
     c60:	cbz	r0, c66 <SDFile::peek()+0x12>
     c62:	b.w	85b0 <ExFatFile::peek()>
		return sdfatfile.peek();
	}
     c66:	mov.w	r0, #4294967295
     c6a:	bx	lr

00000c6c <SDClass::totalSize()>:
	}
	uint64_t usedSize() {
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
		  * (uint64_t)sdfs.bytesPerCluster();
	}
	uint64_t totalSize() {
     c6c:	ldr.w	r2, [r0, #1156]	; 0x484
     c70:	cbz	r2, c86 <SDClass::totalSize()+0x1a>
     c72:	ldrb	r1, [r2, #6]
     c74:	ldr	r0, [r2, #28]
     c76:	mov.w	r3, #512	; 0x200
     c7a:	lsls	r3, r1
     c7c:	uxth	r3, r3
     c7e:	subs	r0, #1
     c80:	umull	r0, r1, r3, r0
     c84:	bx	lr
     c86:	ldr.w	r2, [r0, #1160]	; 0x488
     c8a:	cbz	r2, c9a <SDClass::totalSize()+0x2e>
     c8c:	ldr.w	r3, [r2, #1072]	; 0x430
     c90:	ldr.w	r0, [r2, #1084]	; 0x43c
     c94:	umull	r0, r1, r3, r0
     c98:	bx	lr
     c9a:	movs	r0, #0
     c9c:	movs	r1, #0
		return (uint64_t)sdfs.clusterCount() * (uint64_t)sdfs.bytesPerCluster();
	}
     c9e:	bx	lr

00000ca0 <SDFile::isDirectory()>:
				filename = &zeroterm;
			}
		}
		return filename;
	}
	virtual boolean isDirectory(void) {
     ca0:	ldr	r3, [r0, #92]	; 0x5c
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  }
  /** \return True if this is a directory else false. */
  bool isDir() const {
    return m_fFile ? m_fFile->isDir() :
           m_xFile ? m_xFile->isDir() : false;
     ca2:	cbz	r3, cb2 <SDFile::isDirectory()+0x12>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
    /** \return True if the file is contiguous. */
  bool isContiguous() const {return m_flags & FILE_FLAG_CONTIGUOUS;}
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  /** \return True if this is a directory. */
  bool isDir() const {return m_attributes & FILE_ATTR_DIR;}
     ca4:	ldrb	r3, [r3, #0]
     ca6:	tst.w	r3, #112	; 0x70
     caa:	ite	ne
     cac:	movne	r0, #1
     cae:	moveq	r0, #0
     cb0:	bx	lr
     cb2:	ldr	r0, [r0, #96]	; 0x60
     cb4:	cbz	r0, cc4 <SDFile::isDirectory()+0x24>
   */
  bool isBusy();
  /** \return True if the file is contiguous. */
  bool isContiguous() const {return m_flags & FILE_FLAG_CONTIGUOUS;}
  /** \return True if this is a directory. */
  bool isDir() const  {return m_attributes & FILE_ATTR_DIR;}
     cb6:	ldrb.w	r3, [r0, #49]	; 0x31
     cba:	tst.w	r3, #80	; 0x50
     cbe:	ite	ne
     cc0:	movne	r0, #1
     cc2:	moveq	r0, #0
		return sdfatfile.isDirectory();
	}
     cc4:	bx	lr
     cc6:	nop

00000cc8 <SDClass::open(char const*, unsigned char)>:
		}
#endif
		return sdfs.begin(SdSpiConfig(csPin, SHARED_SPI, SD_SCK_MHZ(16)));
		//return sdfs.begin(csPin, SD_SCK_MHZ(24));
	}
	File open(const char *filepath, uint8_t mode = FILE_READ) {
     cc8:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
     ccc:	cmp	r3, #1
		}
#endif
		return sdfs.begin(SdSpiConfig(csPin, SHARED_SPI, SD_SCK_MHZ(16)));
		//return sdfs.begin(csPin, SD_SCK_MHZ(24));
	}
	File open(const char *filepath, uint8_t mode = FILE_READ) {
     cce:	sub	sp, #80	; 0x50
     cd0:	mov	r5, r0
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
     cd2:	beq.n	d58 <SDClass::open(char const*, unsigned char)+0x90>
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
     cd4:	cmp	r3, #2
		SDFAT_FILE file = sdfs.open(filepath, flags);
     cd6:	add.w	r1, r1, #4
		//return sdfs.begin(csPin, SD_SCK_MHZ(24));
	}
	File open(const char *filepath, uint8_t mode = FILE_READ) {
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
     cda:	movw	r3, #514	; 0x202
		SDFAT_FILE file = sdfs.open(filepath, flags);
     cde:	mov	r0, sp
		//return sdfs.begin(csPin, SD_SCK_MHZ(24));
	}
	File open(const char *filepath, uint8_t mode = FILE_READ) {
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
     ce0:	it	ne
     ce2:	movne	r3, #0
		SDFAT_FILE file = sdfs.open(filepath, flags);
     ce4:	bl	b7a8 <FsVolume::open(char const*, int)>
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     ce8:	ldr	r3, [sp, #72]	; 0x48
     cea:	cmp	r3, #0
     cec:	beq.n	d6a <SDClass::open(char const*, unsigned char)+0xa2>
		if (file) return File(new SDFile(file));
     cee:	movs	r0, #104	; 0x68
     cf0:	bl	eff8 <operator new(unsigned int)>
     cf4:	mov	r4, r0
//#define BYTE 0
//#endif

class __FlashStringHelper;

class Print
     cf6:	ldrb.w	r6, [sp, #4]
	// Classes derived from File are never meant to be constructed
	// anywhere other than open() in the parent FS class and
	// openNextFile() while traversing a directory.
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
     cfa:	ldr	r0, [pc, #136]	; (d84 <SDClass::open(char const*, unsigned char)+0xbc>)
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
     cfc:	ldr	r1, [pc, #136]	; (d88 <SDClass::open(char const*, unsigned char)+0xc0>)
     cfe:	ldr	r2, [sp, #8]
     d00:	ldrb.w	r3, [sp, #12]
     d04:	str	r0, [r4, #0]
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
     d06:	add	r7, sp, #16
     d08:	strb	r6, [r4, #24]
     d0a:	str	r1, [r4, #20]
{
  public:
	constexpr Print() : write_error(0) {}
     d0c:	movs	r6, #0
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
     d0e:	mov.w	r8, #1000	; 0x3e8
     d12:	mov	r1, r7
     d14:	add.w	r0, r4, #36	; 0x24
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
     d18:	str	r2, [r4, #28]
     d1a:	strb.w	r3, [r4, #32]
     d1e:	strb	r6, [r4, #4]
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
     d20:	strb	r6, [r4, #12]
     d22:	str	r6, [r4, #16]
     d24:	str.w	r8, [r4, #8]
     d28:	bl	b560 <FsBaseFile::FsBaseFile(FsBaseFile const&)>
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
     d2c:	ldr	r3, [r4, #16]
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
     d2e:	ldr	r1, [pc, #92]	; (d8c <SDClass::open(char const*, unsigned char)+0xc4>)
#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
	File(File *file) {
     d30:	ldr	r2, [pc, #92]	; (d90 <SDClass::open(char const*, unsigned char)+0xc8>)
     d32:	str	r6, [r4, #100]	; 0x64
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
     d34:	adds	r3, #1
     d36:	strb	r6, [r5, #4]
     d38:	str.w	r8, [r5, #8]
     d3c:	strb	r6, [r5, #12]
		// can we use is_same or is_polymorphic with static_assert?
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
     d3e:	str	r4, [r5, #16]
     d40:	str	r1, [r4, #20]
		if (f) f->refcount++;
     d42:	str	r3, [r4, #16]
#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
	File(File *file) {
     d44:	str	r2, [r5, #0]
     d46:	ldr	r3, [pc, #76]	; (d94 <SDClass::open(char const*, unsigned char)+0xcc>)
     d48:	str	r3, [sp, #0]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
     d4a:	mov	r0, r7
     d4c:	bl	b5d8 <FsBaseFile::close()>
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
		if (file) return File(new SDFile(file));
		return File();
	}
     d50:	mov	r0, r5
     d52:	add	sp, #80	; 0x50
     d54:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return sdfs.begin(SdSpiConfig(csPin, SHARED_SPI, SD_SCK_MHZ(16)));
		//return sdfs.begin(csPin, SD_SCK_MHZ(24));
	}
	File open(const char *filepath, uint8_t mode = FILE_READ) {
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
     d58:	movw	r3, #16898	; 0x4202
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
     d5c:	adds	r1, #4
     d5e:	mov	r0, sp
     d60:	bl	b7a8 <FsVolume::open(char const*, int)>
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     d64:	ldr	r3, [sp, #72]	; 0x48
     d66:	cmp	r3, #0
     d68:	bne.n	cee <SDClass::open(char const*, unsigned char)+0x26>
     d6a:	ldr	r3, [sp, #76]	; 0x4c
     d6c:	cmp	r3, #0
     d6e:	bne.n	cee <SDClass::open(char const*, unsigned char)+0x26>
     d70:	mov.w	r1, #1000	; 0x3e8

#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
     d74:	ldr	r2, [pc, #24]	; (d90 <SDClass::open(char const*, unsigned char)+0xc8>)
     d76:	strb	r3, [r5, #4]
     d78:	strb	r3, [r5, #12]
     d7a:	str	r3, [r5, #16]
     d7c:	str	r1, [r5, #8]
     d7e:	str	r2, [r5, #0]
     d80:	add	r7, sp, #16
     d82:	b.n	d46 <SDClass::open(char const*, unsigned char)+0x7e>
     d84:	.word	0x0001413c
     d88:	.word	0x00014070
     d8c:	.word	0x000140b8
     d90:	.word	0x000140dc
     d94:	.word	0x00014094

00000d98 <StreamFile<FsBaseFile, unsigned long long>::flush()>:
   */
  int available() {
    return BaseFile::available();
  }
  /** Ensure that any bytes written to the file are saved to the SD card. */
  void flush() {
     d98:	ldr	r3, [r0, #72]	; 0x48
   *
   * \return true for success or false for failure.
   */
  bool sync() {
    return m_fFile ? m_fFile->sync() :
           m_xFile ? m_xFile->sync() : false;
     d9a:	cbz	r3, da2 <StreamFile<FsBaseFile, unsigned long long>::flush()+0xa>
     d9c:	mov	r0, r3
     d9e:	b.w	a5c4 <FatFile::sync()>
     da2:	ldr	r0, [r0, #76]	; 0x4c
     da4:	cbz	r0, daa <StreamFile<FsBaseFile, unsigned long long>::flush()+0x12>
     da6:	b.w	944c <ExFatFile::sync()>
     daa:	bx	lr

00000dac <SDFile::write(void const*, unsigned int)>:
	virtual void whoami() {
		Serial.printf("   SDFile this=%x, refcount=%u\n",
			(int)this, getRefcount());
	}
#endif
	virtual size_t write(const void *buf, size_t size) {
     dac:	ldr	r3, [r0, #92]	; 0x5c
   * for a read-only file, device is full, a corrupt file system or an
   * I/O error.
   */
  size_t write(const void* buf, size_t count) {
    return m_fFile ? m_fFile->write(buf, count) :
           m_xFile ? m_xFile->write(buf, count) : 0;
     dae:	cbz	r3, db6 <SDFile::write(void const*, unsigned int)+0xa>
     db0:	mov	r0, r3
     db2:	b.w	a648 <FatFile::write(void const*, unsigned int)>
     db6:	ldr	r0, [r0, #96]	; 0x60
     db8:	cbz	r0, dbe <SDFile::write(void const*, unsigned int)+0x12>
     dba:	b.w	9858 <ExFatFile::write(void const*, unsigned int)>
		return sdfatfile.write(buf, size);
	}
     dbe:	bx	lr

00000dc0 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)>:
   * \param[in] size Number of bytes to write.
   *
   * \return For success write() returns the number of bytes written, always
   * \a size.
   */
  size_t write(const uint8_t* buffer, size_t size) {
     dc0:	ldr	r3, [r0, #72]	; 0x48
     dc2:	cbz	r3, dca <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)+0xa>
     dc4:	mov	r0, r3
     dc6:	b.w	a648 <FatFile::write(void const*, unsigned int)>
     dca:	ldr	r0, [r0, #76]	; 0x4c
     dcc:	cbz	r0, dd2 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)+0x12>
     dce:	b.w	9858 <ExFatFile::write(void const*, unsigned int)>
    return BaseFile::write(buffer, size);
  }
     dd2:	bx	lr

00000dd4 <StreamFile<FsBaseFile, unsigned long long>::available()>:
  StreamFile() {}

  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() {
     dd4:	ldr	r2, [r0, #72]	; 0x48
  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() const {
    return m_fFile ? m_fFile->available() :
           m_xFile ? m_xFile->available() : 0;
     dd6:	cbz	r2, df2 <StreamFile<FsBaseFile, unsigned long long>::available()+0x1e>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint32_t available32() const {
    return isFile() ? fileSize() - curPosition() : 0;
     dd8:	ldrb	r3, [r2, #0]
     dda:	and.w	r3, r3, #8
     dde:	and.w	r0, r3, #255	; 0xff
     de2:	cbz	r3, e26 <StreamFile<FsBaseFile, unsigned long long>::available()+0x52>
   * Zero is returned for directory files.
   *
   */
  int available() const {
    uint32_t n = available32();
    return n > INT_MAX ? INT_MAX : n;
     de4:	ldr	r3, [r2, #28]
     de6:	ldr	r0, [r2, #20]
     de8:	subs	r0, r3, r0
     dea:	it	mi
     dec:	mvnmi.w	r0, #2147483648	; 0x80000000
     df0:	bx	lr
     df2:	ldr	r1, [r0, #76]	; 0x4c
     df4:	cbz	r1, e28 <StreamFile<FsBaseFile, unsigned long long>::available()+0x54>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint64_t available64() {
    return isFile() ? fileSize() - curPosition() : 0;
     df6:	ldrb.w	r3, [r1, #49]	; 0x31
     dfa:	and.w	r3, r3, #8
     dfe:	and.w	r0, r3, #255	; 0xff
     e02:	cbz	r3, e26 <StreamFile<FsBaseFile, unsigned long long>::available()+0x52>
     e04:	ldrd	r2, r3, [r1, #16]
     e08:	ldrd	r0, r1, [r1]
     e0c:	subs	r0, r2, r0
     e0e:	push	{r4, r5}
     e10:	sbc.w	r1, r3, r1
     e14:	movs	r5, #0
     e16:	mvn.w	r4, #2147483648	; 0x80000000
     e1a:	cmp	r5, r1
     e1c:	it	eq
     e1e:	cmpeq	r4, r0
     e20:	bcs.n	e24 <StreamFile<FsBaseFile, unsigned long long>::available()+0x50>
     e22:	mov	r0, r4
    return BaseFile::available();
  }
     e24:	pop	{r4, r5}
     e26:	bx	lr
     e28:	mov	r0, r1
     e2a:	bx	lr

00000e2c <SDFile::seek(unsigned long long, int)>:
		return sdfatfile.read(buf, nbyte);
	}
	virtual bool truncate(uint64_t size=0) {
		return sdfatfile.truncate(size);
	}
	virtual bool seek(uint64_t pos, int mode = SeekSet) {
     e2c:	push	{r4, r6, r7}
     e2e:	ldr	r4, [sp, #12]
     e30:	mov	r6, r2
     e32:	mov	r7, r3
		if (mode == SeekSet) return sdfatfile.seekSet(pos);
     e34:	cbz	r4, e44 <SDFile::seek(unsigned long long, int)+0x18>
		if (mode == SeekCur) return sdfatfile.seekCur(pos);
     e36:	cmp	r4, #1
     e38:	beq.n	e78 <SDFile::seek(unsigned long long, int)+0x4c>
		if (mode == SeekEnd) return sdfatfile.seekEnd(pos);
     e3a:	cmp	r4, #2
     e3c:	beq.n	e5a <SDFile::seek(unsigned long long, int)+0x2e>
		return false;
	}
     e3e:	movs	r0, #0
     e40:	pop	{r4, r6, r7}
     e42:	bx	lr
     e44:	ldr	r4, [r0, #92]	; 0x5c
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
     e46:	cbz	r4, e80 <SDFile::seek(unsigned long long, int)+0x54>
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     e48:	cmp	r3, #1
     e4a:	it	eq
     e4c:	cmpeq	r2, #0
     e4e:	bcs.n	e3e <SDFile::seek(unsigned long long, int)+0x12>
     e50:	mov	r0, r4
     e52:	mov	r1, r2
     e54:	pop	{r4, r6, r7}
     e56:	b.w	a3bc <FatFile::seekSet(unsigned long)>
     e5a:	ldr	r3, [r0, #92]	; 0x5c
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
           m_xFile ? m_xFile->fileSize() : 0;
     e5c:	cbz	r3, e8c <SDFile::seek(unsigned long long, int)+0x60>
   * Can't be used for directory files since file size is not defined.
   * \param[in] offset The new position in bytes from end-of-file.
   * \return true for success or false for failure.
   */
  bool seekEnd(int64_t offset = 0) {
    return seekSet(fileSize() + offset);
     e5e:	ldr	r2, [r3, #28]
     e60:	adds	r6, r6, r2
     e62:	adc.w	r7, r7, #0
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     e66:	cmp	r7, #1
     e68:	it	eq
     e6a:	cmpeq	r6, #0
     e6c:	bcs.n	e3e <SDFile::seek(unsigned long long, int)+0x12>
     e6e:	mov	r1, r6
     e70:	mov	r0, r3
     e72:	pop	{r4, r6, r7}
     e74:	b.w	a3bc <FatFile::seekSet(unsigned long)>
     e78:	ldr	r3, [r0, #92]	; 0x5c
           m_xFile ? m_xFile->contiguousRange(bgnSector, endSector) : false;
  }
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {
    return m_fFile ? m_fFile->curPosition() :
           m_xFile ? m_xFile->curPosition() : 0;
     e7a:	cbz	r3, ea0 <SDFile::seek(unsigned long long, int)+0x74>
  /** Set the files position to current position + \a pos. See seekSet().
   * \param[in] offset The new position in bytes from the current position.
   * \return true for success or false for failure.
   */
  bool seekCur(int64_t offset) {
    return seekSet(curPosition() + offset);
     e7c:	ldr	r2, [r3, #20]
     e7e:	b.n	e60 <SDFile::seek(unsigned long long, int)+0x34>
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
     e80:	ldr	r0, [r0, #96]	; 0x60
     e82:	cmp	r0, #0
     e84:	beq.n	e3e <SDFile::seek(unsigned long long, int)+0x12>
     e86:	pop	{r4, r6, r7}
     e88:	b.w	85e0 <ExFatFile::seekSet(unsigned long long)>
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
           m_xFile ? m_xFile->fileSize() : 0;
     e8c:	ldr	r0, [r0, #96]	; 0x60
     e8e:	cmp	r0, #0
     e90:	beq.n	e3e <SDFile::seek(unsigned long long, int)+0x12>
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
     e92:	ldrd	r2, r3, [r0, #16]
     e96:	adds	r2, r2, r6
     e98:	adcs	r3, r7
     e9a:	pop	{r4, r6, r7}
     e9c:	b.w	85e0 <ExFatFile::seekSet(unsigned long long)>
           m_xFile ? m_xFile->contiguousRange(bgnSector, endSector) : false;
  }
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {
    return m_fFile ? m_fFile->curPosition() :
           m_xFile ? m_xFile->curPosition() : 0;
     ea0:	ldr	r0, [r0, #96]	; 0x60
     ea2:	cmp	r0, #0
     ea4:	beq.n	e3e <SDFile::seek(unsigned long long, int)+0x12>
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
     ea6:	ldrd	r2, r3, [r0]
     eaa:	adds	r2, r2, r6
     eac:	adcs	r3, r7
     eae:	b.n	e86 <SDFile::seek(unsigned long long, int)+0x5a>

00000eb0 <File::~File()>:
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     eb0:	ldr	r2, [r0, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
     eb2:	ldr	r3, [pc, #32]	; (ed4 <File::~File()+0x24>)
     eb4:	push	{r4, lr}
     eb6:	mov	r4, r0
     eb8:	str	r3, [r0, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     eba:	cbz	r2, ece <File::~File()+0x1e>
     ebc:	ldr	r3, [r2, #16]
     ebe:	subs	r3, #1
     ec0:	str	r3, [r2, #16]
     ec2:	cbnz	r3, ece <File::~File()+0x1e>
     ec4:	ldr	r0, [r0, #16]
     ec6:	cbz	r0, ece <File::~File()+0x1e>
     ec8:	ldr	r3, [r0, #0]
     eca:	ldr	r3, [r3, #32]
     ecc:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
     ece:	mov	r0, r4
     ed0:	pop	{r4, pc}
     ed2:	nop
     ed4:	.word	0x000140dc

00000ed8 <SDFile::~SDFile()>:
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
	friend class SDClass;
public:
	virtual ~SDFile(void) {
     ed8:	push	{r3, r4, r5, lr}
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     eda:	ldr	r3, [r0, #92]	; 0x5c
     edc:	ldr	r2, [pc, #80]	; (f30 <SDFile::~SDFile()+0x58>)
     ede:	str	r2, [r0, #0]
     ee0:	mov	r4, r0
		if (sdfatfile) sdfatfile.close();
     ee2:	add.w	r5, r0, #36	; 0x24
     ee6:	cbz	r3, f26 <SDFile::~SDFile()+0x4e>
     ee8:	mov	r0, r5
     eea:	bl	b5d8 <FsBaseFile::close()>
		if (filename) free(filename);
     eee:	ldr	r0, [r4, #100]	; 0x64
     ef0:	cbz	r0, ef6 <SDFile::~SDFile()+0x1e>
     ef2:	bl	fe20 <free>
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
     ef6:	ldr	r3, [pc, #60]	; (f34 <SDFile::~SDFile()+0x5c>)
     ef8:	str	r3, [r4, #20]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
     efa:	mov	r0, r5
     efc:	bl	b5d8 <FsBaseFile::close()>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     f00:	ldr	r2, [r4, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
     f02:	ldr	r3, [pc, #52]	; (f38 <SDFile::~SDFile()+0x60>)
     f04:	str	r3, [r4, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     f06:	cbz	r2, f1a <SDFile::~SDFile()+0x42>
     f08:	ldr	r3, [r2, #16]
     f0a:	subs	r3, #1
     f0c:	str	r3, [r2, #16]
     f0e:	cbnz	r3, f1a <SDFile::~SDFile()+0x42>
     f10:	ldr	r0, [r4, #16]
     f12:	cbz	r0, f1a <SDFile::~SDFile()+0x42>
     f14:	ldr	r3, [r0, #0]
     f16:	ldr	r3, [r3, #32]
     f18:	blx	r3
	}
     f1a:	mov	r0, r4
     f1c:	movs	r1, #104	; 0x68
     f1e:	bl	effc <operator delete(void*, unsigned int)>
     f22:	mov	r0, r4
     f24:	pop	{r3, r4, r5, pc}
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     f26:	ldr	r3, [r0, #96]	; 0x60
     f28:	cmp	r3, #0
     f2a:	bne.n	ee8 <SDFile::~SDFile()+0x10>
     f2c:	b.n	eee <SDFile::~SDFile()+0x16>
     f2e:	nop
     f30:	.word	0x0001413c
     f34:	.word	0x00014094
     f38:	.word	0x000140dc

00000f3c <File::~File()>:
     f3c:	ldr	r2, [r0, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
     f3e:	ldr	r3, [pc, #40]	; (f68 <File::~File()+0x2c>)
     f40:	push	{r4, lr}
     f42:	mov	r4, r0
     f44:	str	r3, [r0, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     f46:	cbz	r2, f5a <File::~File()+0x1e>
     f48:	ldr	r3, [r2, #16]
     f4a:	subs	r3, #1
     f4c:	str	r3, [r2, #16]
     f4e:	cbnz	r3, f5a <File::~File()+0x1e>
     f50:	ldr	r0, [r0, #16]
     f52:	cbz	r0, f5a <File::~File()+0x1e>
     f54:	ldr	r3, [r0, #0]
     f56:	ldr	r3, [r3, #32]
     f58:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
     f5a:	mov	r0, r4
     f5c:	movs	r1, #20
     f5e:	bl	effc <operator delete(void*, unsigned int)>
     f62:	mov	r0, r4
     f64:	pop	{r4, pc}
     f66:	nop
     f68:	.word	0x000140dc

00000f6c <MTPStorage_SD::~MTPStorage_SD()>:
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     f6c:	ldr.w	r2, [r0, #224]	; 0xe0

  void mtp_yield(void);


// Storage implementation for SD. SD needs to be already initialized.
class MTPStorage_SD : public MTPStorageInterface, mSD_Base
     f70:	push	{r3, r4, r5, lr}
     f72:	ldr	r3, [pc, #104]	; (fdc <MTPStorage_SD::~MTPStorage_SD()+0x70>)
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
     f74:	ldr	r5, [pc, #104]	; (fe0 <MTPStorage_SD::~MTPStorage_SD()+0x74>)
     f76:	str	r3, [r0, #0]
     f78:	mov	r4, r0
     f7a:	str.w	r5, [r0, #208]	; 0xd0
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     f7e:	cbz	r2, f88 <MTPStorage_SD::~MTPStorage_SD()+0x1c>
     f80:	ldr	r3, [r2, #16]
     f82:	subs	r3, #1
     f84:	str	r3, [r2, #16]
     f86:	cbz	r3, fbc <MTPStorage_SD::~MTPStorage_SD()+0x50>
     f88:	ldr.w	r2, [r4, #204]	; 0xcc
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
     f8c:	str.w	r5, [r4, #188]	; 0xbc
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     f90:	cbz	r2, f9a <MTPStorage_SD::~MTPStorage_SD()+0x2e>
     f92:	ldr	r3, [r2, #16]
     f94:	subs	r3, #1
     f96:	str	r3, [r2, #16]
     f98:	cbz	r3, fcc <MTPStorage_SD::~MTPStorage_SD()+0x60>
     f9a:	ldr.w	r2, [r4, #184]	; 0xb8
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
     f9e:	str.w	r5, [r4, #168]	; 0xa8
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
     fa2:	cbz	r2, fb8 <MTPStorage_SD::~MTPStorage_SD()+0x4c>
     fa4:	ldr	r3, [r2, #16]
     fa6:	subs	r3, #1
     fa8:	str	r3, [r2, #16]
     faa:	cbnz	r3, fb8 <MTPStorage_SD::~MTPStorage_SD()+0x4c>
     fac:	ldr.w	r0, [r4, #184]	; 0xb8
     fb0:	cbz	r0, fb8 <MTPStorage_SD::~MTPStorage_SD()+0x4c>
     fb2:	ldr	r3, [r0, #0]
     fb4:	ldr	r3, [r3, #32]
     fb6:	blx	r3
     fb8:	mov	r0, r4
     fba:	pop	{r3, r4, r5, pc}
     fbc:	ldr.w	r0, [r0, #224]	; 0xe0
     fc0:	cmp	r0, #0
     fc2:	beq.n	f88 <MTPStorage_SD::~MTPStorage_SD()+0x1c>
     fc4:	ldr	r3, [r0, #0]
     fc6:	ldr	r3, [r3, #32]
     fc8:	blx	r3
     fca:	b.n	f88 <MTPStorage_SD::~MTPStorage_SD()+0x1c>
     fcc:	ldr.w	r0, [r4, #204]	; 0xcc
     fd0:	cmp	r0, #0
     fd2:	beq.n	f9a <MTPStorage_SD::~MTPStorage_SD()+0x2e>
     fd4:	ldr	r3, [r0, #0]
     fd6:	ldr	r3, [r3, #32]
     fd8:	blx	r3
     fda:	b.n	f9a <MTPStorage_SD::~MTPStorage_SD()+0x2e>
     fdc:	.word	0x0001436c
     fe0:	.word	0x000140dc

00000fe4 <SDFile::~SDFile()>:
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
	friend class SDClass;
public:
	virtual ~SDFile(void) {
     fe4:	push	{r3, r4, r5, lr}
     fe6:	ldr	r3, [r0, #92]	; 0x5c
     fe8:	ldr	r2, [pc, #72]	; (1034 <SDFile::~SDFile()+0x50>)
     fea:	str	r2, [r0, #0]
     fec:	mov	r4, r0
		if (sdfatfile) sdfatfile.close();
     fee:	add.w	r5, r0, #36	; 0x24
     ff2:	cbz	r3, 102a <SDFile::~SDFile()+0x46>
     ff4:	mov	r0, r5
     ff6:	bl	b5d8 <FsBaseFile::close()>
		if (filename) free(filename);
     ffa:	ldr	r0, [r4, #100]	; 0x64
     ffc:	cbz	r0, 1002 <SDFile::~SDFile()+0x1e>
     ffe:	bl	fe20 <free>
    1002:	ldr	r3, [pc, #52]	; (1038 <SDFile::~SDFile()+0x54>)
    1004:	str	r3, [r4, #20]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
    1006:	mov	r0, r5
    1008:	bl	b5d8 <FsBaseFile::close()>
    100c:	ldr	r2, [r4, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    100e:	ldr	r3, [pc, #44]	; (103c <SDFile::~SDFile()+0x58>)
    1010:	str	r3, [r4, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    1012:	cbz	r2, 1026 <SDFile::~SDFile()+0x42>
    1014:	ldr	r3, [r2, #16]
    1016:	subs	r3, #1
    1018:	str	r3, [r2, #16]
    101a:	cbnz	r3, 1026 <SDFile::~SDFile()+0x42>
    101c:	ldr	r0, [r4, #16]
    101e:	cbz	r0, 1026 <SDFile::~SDFile()+0x42>
    1020:	ldr	r3, [r0, #0]
    1022:	ldr	r3, [r3, #32]
    1024:	blx	r3
	}
    1026:	mov	r0, r4
    1028:	pop	{r3, r4, r5, pc}
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
    102a:	ldr	r3, [r0, #96]	; 0x60
    102c:	cmp	r3, #0
    102e:	bne.n	ff4 <SDFile::~SDFile()+0x10>
    1030:	b.n	ffa <SDFile::~SDFile()+0x16>
    1032:	nop
    1034:	.word	0x0001413c
    1038:	.word	0x00014094
    103c:	.word	0x000140dc

00001040 <storage_configure()>:
MTPStorage_SD storage;
MTPD       mtpd(&storage);


void storage_configure()
{
    1040:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
  #if USE_SD==1
    #if defined SD_SCK
      SPI.setMOSI(SD_MOSI);
    1044:	movs	r1, #11
MTPStorage_SD storage;
MTPD       mtpd(&storage);


void storage_configure()
{
    1046:	sub	sp, #64	; 0x40
  #if USE_SD==1
    #if defined SD_SCK
      SPI.setMOSI(SD_MOSI);
    1048:	ldr	r0, [pc, #740]	; (1330 <storage_configure()+0x2f0>)
    104a:	ldr	r4, [pc, #744]	; (1334 <storage_configure()+0x2f4>)
    104c:	ldr	r6, [pc, #744]	; (1338 <storage_configure()+0x2f8>)
    104e:	ldr.w	fp, [pc, #784]	; 1360 <storage_configure()+0x320>
    mSD_Base() {
      fsCount = 0;
    }

    void sd_addFilesystem(FS &fs, const char *name) {
      if (fsCount < MTPD_MAX_FILESYSTEMS) {
    1052:	ldr.w	r9, [pc, #784]	; 1364 <storage_configure()+0x324>
    1056:	bl	7c5c <SPIClass::setMOSI(unsigned char)>
      SPI.setMISO(SD_MISO);
    105a:	movs	r1, #12
    105c:	ldr	r0, [pc, #720]	; (1330 <storage_configure()+0x2f0>)
    105e:	bl	7d00 <SPIClass::setMISO(unsigned char)>
    1062:	addw	r7, r4, #1172	; 0x494
      SPI.setSCK(SD_SCK);
    1066:	movs	r1, #13
    1068:	ldr	r0, [pc, #708]	; (1330 <storage_configure()+0x2f0>)
    106a:	bl	7da0 <SPIClass::setSCK(unsigned char)>
   * \param[in] config SDIO configuration.
   * \return generic card pointer or nullptr if SDIO is not supported.
   */
  SdCard* newCard(SdioConfig config) {
#if HAS_SDIO_CLASS
    m_sdioCard.begin(config);
    106e:	mov	r0, r7
    1070:	mov.w	r1, #0
    1074:	bl	cb50 <SdioCard::begin(SdioConfig)>
    #endif

    for(int ii=0; ii<nsd; ii++)
    1078:	movs	r5, #0
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdioConfig sdioConfig) {
    m_card = m_cardFactory.newCard(sdioConfig);
    107a:	str.w	r7, [r4, #1168]	; 0x490
    return m_card && !m_card->errorCode();
    107e:	cbz	r7, 108a <storage_configure()+0x4a>
    1080:	mov	r0, r7
    1082:	bl	c290 <SdioCard::errorCode() const>
    1086:	cmp	r0, #0
    1088:	beq.n	1146 <storage_configure()+0x106>
    { 
      #if defined(BUILTIN_SDCARD)
        if(cs[ii] == BUILTIN_SDCARD)
        {
          if(!sdx[ii].sdfs.begin(SdioConfig(FIFO_SDIO))) 
          { Serial.printf("SDIO Storage %d %d %s failed or missing",ii,cs[ii],sd_str[ii]);  Serial.println();
    108a:	ldr	r3, [r6, #0]
    108c:	str	r3, [sp, #0]
    108e:	mov	r2, r5
    1090:	movs	r3, #254	; 0xfe
    1092:	ldr	r1, [pc, #680]	; (133c <storage_configure()+0x2fc>)
    1094:	ldr	r0, [pc, #680]	; (1340 <storage_configure()+0x300>)
    1096:	bl	ef0c <Print::printf(char const*, ...)>
    109a:	ldr	r0, [pc, #676]	; (1340 <storage_configure()+0x300>)
    109c:	bl	eedc <Print::println()>
      SPI.setMOSI(SD_MOSI);
      SPI.setMISO(SD_MISO);
      SPI.setSCK(SD_SCK);
    #endif

    for(int ii=0; ii<nsd; ii++)
    10a0:	adds	r5, #1
    10a2:	cmp	r5, #2
    10a4:	add.w	r6, r6, #4
    10a8:	add.w	r4, r4, #1208	; 0x4b8
    10ac:	beq.n	1140 <storage_configure()+0x100>
    10ae:	movs	r7, #10
          }
        }
        else if(cs[ii]<BUILTIN_SDCARD)
      #endif
      {
        pinMode(cs[ii],OUTPUT); digitalWriteFast(cs[ii],HIGH);
    10b0:	uxtb.w	r8, r7
    10b4:	mov	r0, r8
    10b6:	movs	r1, #1
    10b8:	bl	de7c <pinMode>
    10bc:	mov.w	lr, #0
    10c0:	strb.w	r8, [sp, #28]
    10c4:	str.w	fp, [sp, #32]
    10c8:	strb.w	lr, [sp, #29]
    10cc:	str.w	lr, [sp, #36]	; 0x24
    10d0:	add	r3, sp, #28
    10d2:	ldmia.w	r3, {r0, r1, r2}
    10d6:	add	r3, sp, #40	; 0x28
    10d8:	stmia.w	r3, {r0, r1, r2}
    10dc:	strb.w	r8, [sp, #40]	; 0x28
    10e0:	strb.w	lr, [sp, #41]	; 0x29
    10e4:	str.w	lr, [sp, #48]	; 0x30
    10e8:	str.w	fp, [sp, #44]	; 0x2c
    10ec:	ldmia.w	r3, {r0, r1, r2}
    10f0:	add	r3, sp, #52	; 0x34
    10f2:	stmia.w	r3, {r0, r1, r2}
			}
			#endif
		}
	} else {
		if (val) {
			*portSetRegister(pin) = digitalPinToBitMask(pin);
    10f6:	ldr	r2, [pc, #588]	; (1344 <storage_configure()+0x304>)
    10f8:	ldr.w	r2, [r2, r8, lsl #3]
    10fc:	movs	r1, #1
    10fe:	add.w	r8, r4, #1184	; 0x4a0
    1102:	strb.w	r1, [r2, #128]	; 0x80
   *
   * \param[in] config SPI configuration.
   * \return generic card pointer.
   */
  SdCard* newCard(SdSpiConfig config) {
    m_spiCard.begin(config);
    1106:	mov	r0, r8
    1108:	ldmia	r3, {r1, r2, r3}
    110a:	bl	ba60 <SdSpiCard::begin(SdSpiConfig)>
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdSpiConfig spiConfig) {
    m_card = m_cardFactory.newCard(spiConfig);
    return m_card && !m_card->errorCode();
    110e:	ldrb.w	r3, [r4, #1203]	; 0x4b3
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdSpiConfig spiConfig) {
    m_card = m_cardFactory.newCard(spiConfig);
    1112:	str.w	r8, [r4, #1168]	; 0x490
    1116:	adds	r0, r4, #4
    return m_card && !m_card->errorCode();
    1118:	cmp	r3, #0
    111a:	beq.n	1218 <storage_configure()+0x1d8>
        if(!sdx[ii].sdfs.begin(SdSpiConfig(cs[ii], SHARED_SPI, SPI_SPEED))) 
        { Serial.printf("SD Storage %d %d %s failed or missing",ii,cs[ii],sd_str[ii]);  Serial.println();
    111c:	ldr	r3, [r6, #0]
    111e:	str	r3, [sp, #0]
    1120:	mov	r2, r5
    1122:	mov	r3, r7
    1124:	ldr	r1, [pc, #544]	; (1348 <storage_configure()+0x308>)
    1126:	ldr	r0, [pc, #536]	; (1340 <storage_configure()+0x300>)
    1128:	bl	ef0c <Print::printf(char const*, ...)>
      SPI.setMOSI(SD_MOSI);
      SPI.setMISO(SD_MISO);
      SPI.setSCK(SD_SCK);
    #endif

    for(int ii=0; ii<nsd; ii++)
    112c:	adds	r5, #1
        else if(cs[ii]<BUILTIN_SDCARD)
      #endif
      {
        pinMode(cs[ii],OUTPUT); digitalWriteFast(cs[ii],HIGH);
        if(!sdx[ii].sdfs.begin(SdSpiConfig(cs[ii], SHARED_SPI, SPI_SPEED))) 
        { Serial.printf("SD Storage %d %d %s failed or missing",ii,cs[ii],sd_str[ii]);  Serial.println();
    112e:	ldr	r0, [pc, #528]	; (1340 <storage_configure()+0x300>)
    1130:	bl	eedc <Print::println()>
      SPI.setMOSI(SD_MOSI);
      SPI.setMISO(SD_MISO);
      SPI.setSCK(SD_SCK);
    #endif

    for(int ii=0; ii<nsd; ii++)
    1134:	cmp	r5, #2
    1136:	add.w	r6, r6, #4
    113a:	add.w	r4, r4, #1208	; 0x4b8
    113e:	bne.n	10ae <storage_configure()+0x6e>
      uint64_t usedSize  = ramfs[ii].usedSize();
      Serial.printf("Storage %d %s ",ii,lfs_str[ii]); Serial.print(totalSize); Serial.print(" "); Serial.println(usedSize);

    }
    #endif
}
    1140:	add	sp, #64	; 0x40
    1142:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, pc}
    1146:	add.w	r8, r4, #4
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    return cardBegin(sdioConfig) && Vol::begin(m_card);
    114a:	mov	r0, r8
    114c:	ldr.w	r1, [r4, #1168]	; 0x490
    1150:	bl	b6e0 <FsVolume::begin(BlockDeviceInterface*)>
    1154:	cmp	r0, #0
    1156:	beq.n	108a <storage_configure()+0x4a>
    1158:	ldr.w	r3, [r9, #4]
    115c:	cmp	r3, #19
    115e:	bgt.n	1170 <storage_configure()+0x130>
        sd_name[fsCount] = name;
    1160:	add.w	r1, r9, r3, lsl #2
    1164:	ldr	r0, [r6, #0]
    1166:	str	r0, [r1, #8]
        sdx[fsCount++] = &fs;
    1168:	adds	r3, #1
    116a:	str	r4, [r1, #88]	; 0x58
    116c:	str.w	r3, [r9, #4]
          { Serial.printf("SDIO Storage %d %d %s failed or missing",ii,cs[ii],sd_str[ii]);  Serial.println();
          }
          else
          {
            storage.addFilesystem(sdx[ii], sd_str[ii]);
            uint64_t totalSize = sdx[ii].totalSize();
    1170:	ldr	r1, [r4, #0]
    1172:	ldr	r2, [pc, #472]	; (134c <storage_configure()+0x30c>)
    1174:	ldr	r3, [r1, #28]
    1176:	cmp	r3, r2
    1178:	bne.w	130c <storage_configure()+0x2cc>
    117c:	ldr.w	r0, [r4, #1156]	; 0x484
    1180:	cmp	r0, #0
    1182:	beq.w	1368 <storage_configure()+0x328>
    1186:	ldrb	r7, [r0, #6]
    1188:	ldr	r2, [r0, #28]
    118a:	mov.w	r3, #512	; 0x200
    118e:	lsls	r3, r7
    1190:	subs	r2, #1
    1192:	uxth	r3, r3
    1194:	umull	r2, r3, r3, r2
  uint8_t bytesPerClusterShift() const {
    return m_sectorsPerClusterShift + m_bytesPerSectorShift;
  }
  /** \return Number of bytes in a cluster. */
  uint16_t bytesPerCluster() const {
    return m_bytesPerSector << m_sectorsPerClusterShift;
    1198:	strd	r2, r3, [sp, #8]
            uint64_t usedSize  = sdx[ii].usedSize();
    119c:	ldr	r3, [r1, #24]
    119e:	ldr	r2, [pc, #432]	; (1350 <storage_configure()+0x310>)
    11a0:	cmp	r3, r2
    11a2:	bne.w	1302 <storage_configure()+0x2c2>
    11a6:	ldr.w	r0, [r4, #1156]	; 0x484
    11aa:	cmp	r0, #0
    11ac:	beq.w	1380 <storage_configure()+0x340>
  uint8_t* cacheClear() {
    return m_cache.clear();
  }
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_lastCluster - 1;
    11b0:	ldr	r7, [r0, #28]
    11b2:	subs	r7, #1
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
    11b4:	bl	a9f8 <FatPartition::freeClusterCount()>
    11b8:	ldr.w	r3, [r4, #1156]	; 0x484
	}
	bool rmdir(const char *filepath) {
		return sdfs.rmdir(filepath);
	}
	uint64_t usedSize() {
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
    11bc:	subs	r7, r7, r0
  uint32_t blocksPerCluster() __attribute__ ((deprecated)) {return sectorsPerCluster();} //NOLINT
#endif  // DOXYGEN_SHOULD_SKIP_THIS
  /** \return the number of bytes in a cluster. */
  uint32_t bytesPerCluster() const {
    return m_fVol ? m_fVol->bytesPerCluster() :
           m_xVol ? m_xVol->bytesPerCluster() : 0;
    11be:	cmp	r3, #0
    11c0:	beq.w	1318 <storage_configure()+0x2d8>
    11c4:	ldrb	r2, [r3, #6]
    11c6:	mov.w	r3, #512	; 0x200
    11ca:	lsls	r3, r2
    11cc:	uxth	r3, r3
    11ce:	umull	r2, r3, r3, r7
  uint8_t bytesPerClusterShift() const {
    return m_sectorsPerClusterShift + m_bytesPerSectorShift;
  }
  /** \return Number of bytes in a cluster. */
  uint16_t bytesPerCluster() const {
    return m_bytesPerSector << m_sectorsPerClusterShift;
    11d2:	strd	r2, r3, [sp, #16]
            Serial.printf("SDIO Storage %d %d %s ",ii,cs[ii],sd_str[ii]); 
    11d6:	ldr	r3, [r6, #0]
    11d8:	ldr	r1, [pc, #376]	; (1354 <storage_configure()+0x314>)
    11da:	str	r3, [sp, #0]
    11dc:	mov	r2, r5
    11de:	movs	r3, #254	; 0xfe
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
	size_t print(int64_t n);
	size_t print(uint64_t n)			{ return printNumber64(n, 10, 0); }
    11e0:	mov.w	r8, #0
    11e4:	movs	r7, #10
        else
        {
          storage.addFilesystem(sdx[ii], sd_str[ii]);
          uint64_t totalSize = sdx[ii].totalSize();
          uint64_t usedSize  = sdx[ii].usedSize();
          Serial.printf("SD Storage %d %d %s ",ii,cs[ii],sd_str[ii]); 
    11e6:	ldr	r0, [pc, #344]	; (1340 <storage_configure()+0x300>)
    11e8:	bl	ef0c <Print::printf(char const*, ...)>
    11ec:	ldrd	r2, r3, [sp, #8]
    11f0:	stmia.w	sp, {r7, r8}
    11f4:	ldr	r0, [pc, #328]	; (1340 <storage_configure()+0x300>)
    11f6:	bl	ef28 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    11fa:	movs	r1, #1
    11fc:	ldr	r0, [pc, #344]	; (1358 <storage_configure()+0x318>)
    11fe:	bl	d6b8 <usb_serial_write>
    1202:	stmia.w	sp, {r7, r8}
    1206:	ldrd	r2, r3, [sp, #16]
    120a:	ldr	r0, [pc, #308]	; (1340 <storage_configure()+0x300>)
    120c:	bl	ef28 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>
	size_t println(int n)				{ return print(n) + println(); }
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
	size_t println(int64_t n)			{ return print(n) + println(); }
	size_t println(uint64_t n)			{ return print(n) + println(); }
    1210:	ldr	r0, [pc, #300]	; (1340 <storage_configure()+0x300>)
    1212:	bl	eedc <Print::println()>
    1216:	b.n	10a0 <storage_configure()+0x60>
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdSpiConfig spiConfig) {
    return cardBegin(spiConfig) && Vol::begin(m_card);
    1218:	mov	r1, r8
    121a:	bl	b6e0 <FsVolume::begin(BlockDeviceInterface*)>
    121e:	cmp	r0, #0
    1220:	beq.w	111c <storage_configure()+0xdc>
    mSD_Base() {
      fsCount = 0;
    }

    void sd_addFilesystem(FS &fs, const char *name) {
      if (fsCount < MTPD_MAX_FILESYSTEMS) {
    1224:	ldr.w	r3, [r9, #4]
    1228:	cmp	r3, #19
    122a:	bgt.n	123c <storage_configure()+0x1fc>
        sd_name[fsCount] = name;
    122c:	add.w	r1, r9, r3, lsl #2
    1230:	ldr	r0, [r6, #0]
    1232:	str	r0, [r1, #8]
        sdx[fsCount++] = &fs;
    1234:	adds	r3, #1
    1236:	str	r4, [r1, #88]	; 0x58
    1238:	str.w	r3, [r9, #4]
        { Serial.printf("SD Storage %d %d %s failed or missing",ii,cs[ii],sd_str[ii]);  Serial.println();
        }
        else
        {
          storage.addFilesystem(sdx[ii], sd_str[ii]);
          uint64_t totalSize = sdx[ii].totalSize();
    123c:	ldr	r1, [r4, #0]
    123e:	ldr	r2, [pc, #268]	; (134c <storage_configure()+0x30c>)
    1240:	ldr	r3, [r1, #28]
    1242:	cmp	r3, r2
    1244:	bne.n	12aa <storage_configure()+0x26a>
    1246:	ldr.w	r0, [r4, #1156]	; 0x484
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
    124a:	cmp	r0, #0
    124c:	beq.n	12d6 <storage_configure()+0x296>
    124e:	ldrb.w	lr, [r0, #6]
    1252:	ldr	r2, [r0, #28]
    1254:	mov.w	r3, #512	; 0x200
    1258:	lsl.w	r3, r3, lr
    125c:	subs	r2, #1
    125e:	uxth	r3, r3
    1260:	umull	r2, r3, r3, r2
    1264:	strd	r2, r3, [sp, #8]
          uint64_t usedSize  = sdx[ii].usedSize();
    1268:	ldr	r3, [r1, #24]
    126a:	ldr	r2, [pc, #228]	; (1350 <storage_configure()+0x310>)
    126c:	cmp	r3, r2
    126e:	bne.n	12b6 <storage_configure()+0x276>
    1270:	ldr.w	r0, [r4, #1156]	; 0x484
    1274:	cmp	r0, #0
    1276:	beq.n	12f0 <storage_configure()+0x2b0>
  uint8_t* cacheClear() {
    return m_cache.clear();
  }
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_lastCluster - 1;
    1278:	ldr	r3, [r0, #28]
    127a:	add.w	r8, r3, #4294967295
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
    127e:	bl	a9f8 <FatPartition::freeClusterCount()>
    1282:	ldr.w	r3, [r4, #1156]	; 0x484
    1286:	rsb	r0, r0, r8
  uint32_t blocksPerCluster() __attribute__ ((deprecated)) {return sectorsPerCluster();} //NOLINT
#endif  // DOXYGEN_SHOULD_SKIP_THIS
  /** \return the number of bytes in a cluster. */
  uint32_t bytesPerCluster() const {
    return m_fVol ? m_fVol->bytesPerCluster() :
           m_xVol ? m_xVol->bytesPerCluster() : 0;
    128a:	cbz	r3, 12c0 <storage_configure()+0x280>
    128c:	ldrb	r2, [r3, #6]
    128e:	mov.w	r3, #512	; 0x200
    1292:	lsls	r3, r2
    1294:	uxth	r3, r3
    1296:	umull	r0, r1, r3, r0
  uint8_t bytesPerClusterShift() const {
    return m_sectorsPerClusterShift + m_bytesPerSectorShift;
  }
  /** \return Number of bytes in a cluster. */
  uint16_t bytesPerCluster() const {
    return m_bytesPerSector << m_sectorsPerClusterShift;
    129a:	strd	r0, r1, [sp, #16]
          Serial.printf("SD Storage %d %d %s ",ii,cs[ii],sd_str[ii]); 
    129e:	ldr	r3, [r6, #0]
    12a0:	str	r3, [sp, #0]
    12a2:	mov	r2, r5
    12a4:	mov	r3, r7
    12a6:	ldr	r1, [pc, #180]	; (135c <storage_configure()+0x31c>)
    12a8:	b.n	11e0 <storage_configure()+0x1a0>
        { Serial.printf("SD Storage %d %d %s failed or missing",ii,cs[ii],sd_str[ii]);  Serial.println();
        }
        else
        {
          storage.addFilesystem(sdx[ii], sd_str[ii]);
          uint64_t totalSize = sdx[ii].totalSize();
    12aa:	mov	r0, r4
    12ac:	blx	r3
    12ae:	strd	r0, r1, [sp, #8]
    12b2:	ldr	r1, [r4, #0]
    12b4:	b.n	1268 <storage_configure()+0x228>
          uint64_t usedSize  = sdx[ii].usedSize();
    12b6:	mov	r0, r4
    12b8:	blx	r3
    12ba:	strd	r0, r1, [sp, #16]
    12be:	b.n	129e <storage_configure()+0x25e>
    12c0:	ldr.w	r3, [r4, #1160]	; 0x488
    12c4:	cmp	r3, #0
    12c6:	beq.n	1390 <storage_configure()+0x350>
    12c8:	ldr.w	r3, [r3, #1084]	; 0x43c
    12cc:	umull	r2, r3, r0, r3
    12d0:	strd	r2, r3, [sp, #16]
    12d4:	b.n	129e <storage_configure()+0x25e>
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
    12d6:	ldr.w	r3, [r4, #1160]	; 0x488
    12da:	cmp	r3, #0
    12dc:	beq.n	139a <storage_configure()+0x35a>
    12de:	ldr.w	r2, [r3, #1072]	; 0x430
    12e2:	ldr.w	r3, [r3, #1084]	; 0x43c
    12e6:	umull	r2, r3, r2, r3
    12ea:	strd	r2, r3, [sp, #8]
    12ee:	b.n	1268 <storage_configure()+0x228>
    12f0:	ldr.w	r0, [r4, #1160]	; 0x488
    12f4:	cmp	r0, #0
    12f6:	beq.n	1390 <storage_configure()+0x350>
    12f8:	ldr.w	r8, [r0, #1072]	; 0x430
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
           m_xVol ? m_xVol->freeClusterCount() : 0;
    12fc:	bl	8f48 <ExFatPartition::freeClusterCount()>
    1300:	b.n	1282 <storage_configure()+0x242>
          }
          else
          {
            storage.addFilesystem(sdx[ii], sd_str[ii]);
            uint64_t totalSize = sdx[ii].totalSize();
            uint64_t usedSize  = sdx[ii].usedSize();
    1302:	mov	r0, r4
    1304:	blx	r3
    1306:	strd	r0, r1, [sp, #16]
    130a:	b.n	11d6 <storage_configure()+0x196>
          { Serial.printf("SDIO Storage %d %d %s failed or missing",ii,cs[ii],sd_str[ii]);  Serial.println();
          }
          else
          {
            storage.addFilesystem(sdx[ii], sd_str[ii]);
            uint64_t totalSize = sdx[ii].totalSize();
    130c:	mov	r0, r4
    130e:	blx	r3
    1310:	strd	r0, r1, [sp, #8]
    1314:	ldr	r1, [r4, #0]
    1316:	b.n	119c <storage_configure()+0x15c>
    1318:	ldr.w	r3, [r4, #1160]	; 0x488
  uint32_t blocksPerCluster() __attribute__ ((deprecated)) {return sectorsPerCluster();} //NOLINT
#endif  // DOXYGEN_SHOULD_SKIP_THIS
  /** \return the number of bytes in a cluster. */
  uint32_t bytesPerCluster() const {
    return m_fVol ? m_fVol->bytesPerCluster() :
           m_xVol ? m_xVol->bytesPerCluster() : 0;
    131c:	cmp	r3, #0
    131e:	beq.n	13a4 <storage_configure()+0x364>
    1320:	ldr.w	r3, [r3, #1084]	; 0x43c
    1324:	umull	r2, r3, r7, r3
    1328:	strd	r2, r3, [sp, #16]
    132c:	b.n	11d6 <storage_configure()+0x196>
    132e:	nop
    1330:	.word	0x1fff0960
    1334:	.word	0x1fff2bc8
    1338:	.word	0x1fff0940
    133c:	.word	0x0001426c
    1340:	.word	0x1fff0ad0
    1344:	.word	0x0001479c
    1348:	.word	0x0001422c
    134c:	.word	0x00000c6d
    1350:	.word	0x00000bb1
    1354:	.word	0x00014214
    1358:	.word	0x00014498
    135c:	.word	0x00014254
    1360:	.word	0x00f42400
    1364:	.word	0x1fff1ac0
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
    1368:	ldr.w	r3, [r4, #1160]	; 0x488
    136c:	cbz	r3, 13ae <storage_configure()+0x36e>
    136e:	ldr.w	r2, [r3, #1072]	; 0x430
    1372:	ldr.w	r3, [r3, #1084]	; 0x43c
    1376:	umull	r2, r3, r2, r3
    137a:	strd	r2, r3, [sp, #8]
    137e:	b.n	119c <storage_configure()+0x15c>
    1380:	ldr.w	r0, [r4, #1160]	; 0x488
    1384:	cbz	r0, 13a4 <storage_configure()+0x364>
    1386:	ldr.w	r7, [r0, #1072]	; 0x430
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
           m_xVol ? m_xVol->freeClusterCount() : 0;
    138a:	bl	8f48 <ExFatPartition::freeClusterCount()>
    138e:	b.n	11b8 <storage_configure()+0x178>
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
    1390:	movs	r2, #0
    1392:	movs	r3, #0
    1394:	strd	r2, r3, [sp, #16]
    1398:	b.n	129e <storage_configure()+0x25e>
    139a:	movs	r2, #0
    139c:	movs	r3, #0
    139e:	strd	r2, r3, [sp, #8]
    13a2:	b.n	1268 <storage_configure()+0x228>
    13a4:	movs	r2, #0
    13a6:	movs	r3, #0
    13a8:	strd	r2, r3, [sp, #16]
    13ac:	b.n	11d6 <storage_configure()+0x196>
    13ae:	movs	r2, #0
    13b0:	movs	r3, #0
    13b2:	strd	r2, r3, [sp, #8]
    13b6:	b.n	119c <storage_configure()+0x15c>

000013b8 <pushData(unsigned long*)>:
uint16_t maxCount=0;

void resetData(void) {  front_ = 0;  rear_ = 0; }

uint16_t pushData(uint32_t * src)
{ uint16_t f =front_ + 1;
    13b8:	push	{r4, r5, r6, lr}
    13ba:	ldr	r6, [pc, #76]	; (1408 <pushData(unsigned long*)+0x50>)
  if(f >= MAXBUF) f=0;
  if(f == rear_) return 0;
    13bc:	ldr	r3, [pc, #76]	; (140c <pushData(unsigned long*)+0x54>)
uint16_t maxCount=0;

void resetData(void) {  front_ = 0;  rear_ = 0; }

uint16_t pushData(uint32_t * src)
{ uint16_t f =front_ + 1;
    13be:	ldrh	r4, [r6, #0]
  if(f >= MAXBUF) f=0;
  if(f == rear_) return 0;
    13c0:	ldrh	r5, [r3, #0]
uint16_t maxCount=0;

void resetData(void) {  front_ = 0;  rear_ = 0; }

uint16_t pushData(uint32_t * src)
{ uint16_t f =front_ + 1;
    13c2:	adds	r4, #1
    13c4:	uxth	r4, r4
  if(f >= MAXBUF) f=0;
    13c6:	cmp	r4, #22
    13c8:	it	cs
    13ca:	movcs	r4, #0
  if(f == rear_) return 0;
    13cc:	cmp	r4, r5
    13ce:	beq.n	1402 <pushData(unsigned long*)+0x4a>
    13d0:	mov	r1, r0

  uint32_t *ptr= data_buffer+f*NBUF_ACQ;
  memcpy(ptr,src,NBUF_ACQ*4);
    13d2:	ldr	r0, [pc, #60]	; (1410 <pushData(unsigned long*)+0x58>)
    13d4:	mov.w	r2, #512	; 0x200
    13d8:	add.w	r0, r0, r4, lsl #9
    13dc:	bl	d444 <memcpy>
  front_ = f;
  //
  uint16_t count;
  count = (front_ >= rear_) ? (front_ - rear_) : front_+ (MAXBUF -rear_) ;
    13e0:	cmp	r4, r5
  if(count>maxCount) maxCount=count;
    13e2:	ldr	r3, [pc, #48]	; (1414 <pushData(unsigned long*)+0x5c>)
  if(f >= MAXBUF) f=0;
  if(f == rear_) return 0;

  uint32_t *ptr= data_buffer+f*NBUF_ACQ;
  memcpy(ptr,src,NBUF_ACQ*4);
  front_ = f;
    13e4:	strh	r4, [r6, #0]
  //
  uint16_t count;
  count = (front_ >= rear_) ? (front_ - rear_) : front_+ (MAXBUF -rear_) ;
    13e6:	itet	cc
    13e8:	rsbcc	r5, r5, #22
    13ec:	subcs	r4, r4, r5
    13ee:	addcc	r4, r4, r5
  if(count>maxCount) maxCount=count;
    13f0:	ldrh	r2, [r3, #0]
  uint32_t *ptr= data_buffer+f*NBUF_ACQ;
  memcpy(ptr,src,NBUF_ACQ*4);
  front_ = f;
  //
  uint16_t count;
  count = (front_ >= rear_) ? (front_ - rear_) : front_+ (MAXBUF -rear_) ;
    13f2:	uxth	r4, r4
  if(count>maxCount) maxCount=count;
    13f4:	cmp	r2, r4
    13f6:	bcs.n	13fe <pushData(unsigned long*)+0x46>
    13f8:	strh	r4, [r3, #0]
  //
  return 1;
    13fa:	movs	r0, #1
    13fc:	pop	{r4, r5, r6, pc}
    13fe:	movs	r0, #1
}
    1400:	pop	{r4, r5, r6, pc}
void resetData(void) {  front_ = 0;  rear_ = 0; }

uint16_t pushData(uint32_t * src)
{ uint16_t f =front_ + 1;
  if(f >= MAXBUF) f=0;
  if(f == rear_) return 0;
    1402:	movs	r0, #0
    1404:	pop	{r4, r5, r6, pc}
    1406:	nop
    1408:	.word	0x1fff1bc4
    140c:	.word	0x1fff614e
    1410:	.word	0x1fff3538
    1414:	.word	0x1fff614c

00001418 <acq_isr()>:

  uint32_t acq_count=0;
  uint32_t acq_miss=0;

    void acq_isr(void)
    {
    1418:	push	{r3, r4, r5, r6, r7, lr}
        uint32_t daddr;
        uint32_t *src;
        acq_count++;

        daddr = (uint32_t)(dma.TCD->DADDR);
    141a:	ldr	r2, [pc, #68]	; (1460 <acq_isr()+0x48>)

    void acq_isr(void)
    {
        uint32_t daddr;
        uint32_t *src;
        acq_count++;
    141c:	ldr	r4, [pc, #68]	; (1464 <acq_isr()+0x4c>)

        daddr = (uint32_t)(dma.TCD->DADDR);
    141e:	ldr	r0, [r2, #0]

    void acq_isr(void)
    {
        uint32_t daddr;
        uint32_t *src;
        acq_count++;
    1420:	ldr	r1, [r4, #0]

        daddr = (uint32_t)(dma.TCD->DADDR);
        dma.clearInterrupt();

        if (daddr < (uint32_t)tdm_rx_buffer + sizeof(tdm_rx_buffer) / 2) {
    1422:	ldr	r3, [pc, #68]	; (1468 <acq_isr()+0x50>)
    {
        uint32_t daddr;
        uint32_t *src;
        acq_count++;

        daddr = (uint32_t)(dma.TCD->DADDR);
    1424:	ldr	r7, [r0, #16]
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
    1426:	ldr	r5, [pc, #68]	; (146c <acq_isr()+0x54>)
    1428:	ldrb	r6, [r2, #4]
    142a:	ldr	r2, [pc, #68]	; (1470 <acq_isr()+0x58>)
            // need to remove data from the second half
            src = &tdm_rx_buffer[NBUF_I2S];
        } else {
            // DMA is receiving to the second half of the buffer
            // need to remove data from the first half
            src = &tdm_rx_buffer[0];
    142c:	sub.w	r0, r3, #2048	; 0x800

    void acq_isr(void)
    {
        uint32_t daddr;
        uint32_t *src;
        acq_count++;
    1430:	adds	r1, #1
    1432:	str	r1, [r4, #0]
            // need to remove data from the second half
            src = &tdm_rx_buffer[NBUF_I2S];
        } else {
            // DMA is receiving to the second half of the buffer
            // need to remove data from the first half
            src = &tdm_rx_buffer[0];
    1434:	cmp	r7, r3
    1436:	it	cc
    1438:	movcc	r0, r3
    143a:	strb	r6, [r5, #0]
    143c:	movs	r3, #0

        for(int jj=0;jj<NCH_ACQ;jj++)
        {
          for(int ii=0; ii<NBUF_ACQ;ii++)
          {
            acq_rx_buffer[jj+ii*NCH_ACQ]=src[jj+ii*NCH_I2S];
    143e:	ldr.w	r1, [r0, r3, lsl #2]
    1442:	str.w	r1, [r2, #4]!
    1446:	adds	r3, #4
            arm_dcache_delete((void*)src, sizeof(tdm_rx_buffer) / 2);
        #endif

        for(int jj=0;jj<NCH_ACQ;jj++)
        {
          for(int ii=0; ii<NBUF_ACQ;ii++)
    1448:	cmp.w	r3, #512	; 0x200
    144c:	bne.n	143e <acq_isr()+0x26>
          {
            acq_rx_buffer[jj+ii*NCH_ACQ]=src[jj+ii*NCH_I2S];
          }
        }

        if(!pushData(acq_rx_buffer)) acq_miss++;
    144e:	ldr	r0, [pc, #36]	; (1474 <acq_isr()+0x5c>)
    1450:	bl	13b8 <pushData(unsigned long*)>
    1454:	cbnz	r0, 145e <acq_isr()+0x46>
    1456:	ldr	r2, [pc, #32]	; (1478 <acq_isr()+0x60>)
    1458:	ldr	r3, [r2, #0]
    145a:	adds	r3, #1
    145c:	str	r3, [r2, #0]
    145e:	pop	{r3, r4, r5, r6, r7, pc}
    1460:	.word	0x1fff14b0
    1464:	.word	0x1fff18bc
    1468:	.word	0x1fff23c8
    146c:	.word	0x4000801f
    1470:	.word	0x1fff18bc
    1474:	.word	0x1fff18c0
    1478:	.word	0x1fff6154

0000147c <pullData(unsigned long*, unsigned long)>:
  //
  return 1;
}

uint16_t pullData(uint32_t * dst, uint32_t ndbl)
{ uint16_t r = (rear_/ndbl) ;
    147c:	push	{r3, r4, r5, lr}
    147e:	ldr	r4, [pc, #72]	; (14c8 <pullData(unsigned long*, unsigned long)+0x4c>)
  if(r == (front_/ndbl)) return 0;
    1480:	ldr	r3, [pc, #72]	; (14cc <pullData(unsigned long*, unsigned long)+0x50>)
  //
  return 1;
}

uint16_t pullData(uint32_t * dst, uint32_t ndbl)
{ uint16_t r = (rear_/ndbl) ;
    1482:	ldrh	r2, [r4, #0]
  if(r == (front_/ndbl)) return 0;
    1484:	ldrh	r3, [r3, #0]
  //
  return 1;
}

uint16_t pullData(uint32_t * dst, uint32_t ndbl)
{ uint16_t r = (rear_/ndbl) ;
    1486:	udiv	r2, r2, r1
  if(r == (front_/ndbl)) return 0;
    148a:	udiv	r5, r3, r1
    148e:	cmp	r2, r5
    1490:	beq.n	14c4 <pullData(unsigned long*, unsigned long)+0x48>
    1492:	uxth	r3, r2
  if(++r >= (MAXBUF/ndbl)) r=0;
    1494:	adds	r3, #1
    1496:	uxth	r3, r3
    1498:	movs	r2, #22
    149a:	udiv	r2, r2, r1
    149e:	cmp	r3, r2
    14a0:	bcs.n	14bc <pullData(unsigned long*, unsigned long)+0x40>
    14a2:	ldr	r5, [pc, #44]	; (14d0 <pullData(unsigned long*, unsigned long)+0x54>)
    14a4:	lsls	r2, r1, #9
    14a6:	smulbb	r1, r1, r3
    14aa:	mla	r3, r2, r3, r5
    14ae:	uxth	r5, r1
  uint32_t *ptr= data_buffer + r*ndbl*NBUF_ACQ;
  memcpy(dst,ptr,ndbl*NBUF_ACQ*4);
    14b0:	mov	r1, r3
    14b2:	bl	d444 <memcpy>
  rear_ = r*ndbl;
    14b6:	strh	r5, [r4, #0]
  return 1;
    14b8:	movs	r0, #1
    14ba:	pop	{r3, r4, r5, pc}
    14bc:	ldr	r3, [pc, #16]	; (14d0 <pullData(unsigned long*, unsigned long)+0x54>)
    14be:	lsls	r2, r1, #9
    14c0:	movs	r5, #0
    14c2:	b.n	14b0 <pullData(unsigned long*, unsigned long)+0x34>
  return 1;
}

uint16_t pullData(uint32_t * dst, uint32_t ndbl)
{ uint16_t r = (rear_/ndbl) ;
  if(r == (front_/ndbl)) return 0;
    14c4:	movs	r0, #0
  if(++r >= (MAXBUF/ndbl)) r=0;
  uint32_t *ptr= data_buffer + r*ndbl*NBUF_ACQ;
  memcpy(dst,ptr,ndbl*NBUF_ACQ*4);
  rear_ = r*ndbl;
  return 1;
}
    14c6:	pop	{r3, r4, r5, pc}
    14c8:	.word	0x1fff614e
    14cc:	.word	0x1fff1bc4
    14d0:	.word	0x1fff3538

000014d4 <do_menu(short)>:
void do_menu1(void);
void do_menu2(void);
void do_menu3(void);

int16_t do_menu(int16_t state)
{ // check Serial input
    14d4:	push	{r4, lr}
    14d6:	mov	r4, r0
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    14d8:	bl	d664 <usb_serial_available>
  if(!Serial.available()) return state;
    14dc:	cbnz	r0, 14e2 <do_menu(short)+0xe>
      break;
    default:
      break;
  }
  return state;
}
    14de:	mov	r0, r4
    14e0:	pop	{r4, pc}
        virtual int read() { return usb_serial_getchar(); }
    14e2:	bl	d5ec <usb_serial_getchar>

int16_t do_menu(int16_t state)
{ // check Serial input
  if(!Serial.available()) return state;
  char cc = Serial.read();
  switch(cc)
    14e6:	uxtb	r0, r0
    14e8:	cmp	r0, #114	; 0x72
    14ea:	beq.n	1520 <do_menu(short)+0x4c>
    14ec:	cmp	r0, #115	; 0x73
    14ee:	beq.n	150a <do_menu(short)+0x36>
    14f0:	cmp	r0, #113	; 0x71
    14f2:	bne.n	14de <do_menu(short)+0xa>
      if(state>=0) return state;
      state=0;
      Serial.println("\nStart");
      break;
    case 'q': // stop acquisition
      if(state<0) return state;
    14f4:	cmp	r4, #0
    14f6:	blt.n	14de <do_menu(short)+0xa>
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    14f8:	movs	r1, #5
    14fa:	ldr	r0, [pc, #60]	; (1538 <do_menu(short)+0x64>)
    14fc:	bl	d6b8 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    1500:	ldr	r0, [pc, #56]	; (153c <do_menu(short)+0x68>)
    1502:	bl	eedc <Print::println()>
      state=4;
    1506:	movs	r4, #4
    1508:	b.n	14de <do_menu(short)+0xa>
  if(!Serial.available()) return state;
  char cc = Serial.read();
  switch(cc)
  {
    case 's': // start acquisition
      if(state>=0) return state;
    150a:	cmp	r4, #0
    150c:	bge.n	14de <do_menu(short)+0xa>
    150e:	movs	r1, #6
    1510:	ldr	r0, [pc, #44]	; (1540 <do_menu(short)+0x6c>)
    1512:	bl	d6b8 <usb_serial_write>
    1516:	ldr	r0, [pc, #36]	; (153c <do_menu(short)+0x68>)
    1518:	bl	eedc <Print::println()>
    151c:	movs	r4, #0
    151e:	b.n	14de <do_menu(short)+0xa>
    1520:	movs	r1, #5
    1522:	ldr	r0, [pc, #32]	; (1544 <do_menu(short)+0x70>)
    1524:	bl	d6b8 <usb_serial_write>
    1528:	ldr	r0, [pc, #16]	; (153c <do_menu(short)+0x68>)
    152a:	bl	eedc <Print::println()>
      Serial.println("\nStop");
      break;
#if USE_EVENTS==1
    case 'r': 
      Serial.println("Reset");
      mtpd.send_DeviceResetEvent();
    152e:	ldr	r0, [pc, #24]	; (1548 <do_menu(short)+0x74>)
    1530:	bl	775c <MTPD::send_DeviceResetEvent()>
      break;
    1534:	b.n	14de <do_menu(short)+0xa>
    1536:	nop
    1538:	.word	0x0001429c
    153c:	.word	0x1fff0ad0
    1540:	.word	0x00014294
    1544:	.word	0x000142a4
    1548:	.word	0x1fff6138

0000154c <file_writeHeader()>:
  mfile = sdx[store].open(filename,FILE_WRITE);
  return !(!mfile);
}

int16_t file_writeHeader(void)
{ if(!mfile) return 0;
    154c:	push	{r4, lr}
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    154e:	ldr	r4, [pc, #60]	; (158c <file_writeHeader()+0x40>)
    1550:	ldr	r0, [r4, #16]
    1552:	cbz	r0, 1586 <file_writeHeader()+0x3a>
    1554:	ldr	r3, [r0, #0]
    1556:	ldr	r3, [r3, #68]	; 0x44
    1558:	blx	r3
    155a:	cbz	r0, 1586 <file_writeHeader()+0x3a>
  #endif


void makeHeader(char *header)
{
  memset(header,0,512);
    155c:	mov.w	r2, #512	; 0x200
    1560:	movs	r1, #0
    1562:	ldr	r0, [pc, #44]	; (1590 <file_writeHeader()+0x44>)
    1564:	bl	1059c <memset>
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
	}
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
    1568:	ldr	r0, [r4, #16]
    156a:	cbz	r0, 1584 <file_writeHeader()+0x38>
    156c:	ldr	r3, [r0, #0]
    156e:	ldr	r1, [pc, #32]	; (1590 <file_writeHeader()+0x44>)
    1570:	ldr	r3, [r3, #44]	; 0x2c
    1572:	mov.w	r2, #512	; 0x200
    1576:	blx	r3
    1578:	sub.w	r0, r0, #512	; 0x200
    157c:	clz	r0, r0
    1580:	lsrs	r0, r0, #5
    1582:	sxth	r0, r0
int16_t file_writeHeader(void)
{ if(!mfile) return 0;
  makeHeader(header);
  size_t nb = mfile.write(header,512);
  return (nb==512);
}
    1584:	pop	{r4, pc}
  mfile = sdx[store].open(filename,FILE_WRITE);
  return !(!mfile);
}

int16_t file_writeHeader(void)
{ if(!mfile) return 0;
    1586:	movs	r0, #0
    1588:	pop	{r4, pc}
    158a:	nop
    158c:	.word	0x1fff0948
    1590:	.word	0x1fff14bc

00001594 <file_writeData(void*, unsigned long)>:
  size_t nb = mfile.write(header,512);
  return (nb==512);
}

int16_t file_writeData(void *diskBuffer, uint32_t nd)
{ if(!mfile) return 0;
    1594:	push	{r4, r5, r6, lr}
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    1596:	ldr	r6, [pc, #48]	; (15c8 <file_writeData(void*, unsigned long)+0x34>)
    1598:	ldr	r3, [r6, #16]
    159a:	cbz	r3, 15c4 <file_writeData(void*, unsigned long)+0x30>
    159c:	ldr	r2, [r3, #0]
    159e:	mov	r5, r0
    15a0:	mov	r0, r3
    15a2:	ldr	r3, [r2, #68]	; 0x44
    15a4:	mov	r4, r1
    15a6:	blx	r3
    15a8:	cbz	r0, 15c4 <file_writeData(void*, unsigned long)+0x30>
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
	}
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
    15aa:	ldr	r0, [r6, #16]
    15ac:	cbz	r0, 15b8 <file_writeData(void*, unsigned long)+0x24>
    15ae:	ldr	r3, [r0, #0]
    15b0:	mov	r1, r5
    15b2:	ldr	r3, [r3, #44]	; 0x2c
    15b4:	mov	r2, r4
    15b6:	blx	r3
  uint32_t nb = mfile.write(diskBuffer,nd);
  return (nb==nd);
    15b8:	subs	r0, r4, r0
    15ba:	clz	r0, r0
    15be:	lsrs	r0, r0, #5
    15c0:	sxth	r0, r0
}
    15c2:	pop	{r4, r5, r6, pc}
  size_t nb = mfile.write(header,512);
  return (nb==512);
}

int16_t file_writeData(void *diskBuffer, uint32_t nd)
{ if(!mfile) return 0;
    15c4:	movs	r0, #0
    15c6:	pop	{r4, r5, r6, pc}
    15c8:	.word	0x1fff0948

000015cc <file_close()>:
  uint32_t nb = mfile.write(diskBuffer,nd);
  return (nb==nd);
}

int16_t file_close(void)
{ mfile.close();
    15cc:	push	{r4, lr}
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    15ce:	ldr	r4, [pc, #32]	; (15f0 <file_close()+0x24>)
    15d0:	ldr	r0, [r4, #16]
    15d2:	cbz	r0, 15ec <file_close()+0x20>
    15d4:	ldr	r3, [r0, #0]
    15d6:	ldr	r3, [r3, #64]	; 0x40
    15d8:	blx	r3
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    15da:	ldr	r0, [r4, #16]
    15dc:	cbz	r0, 15ec <file_close()+0x20>
    15de:	ldr	r3, [r0, #0]
    15e0:	ldr	r3, [r3, #68]	; 0x44
    15e2:	blx	r3
    15e4:	eor.w	r0, r0, #1
    15e8:	uxtb	r0, r0
  return (!mfile);
}
    15ea:	pop	{r4, pc}
  uint32_t nb = mfile.write(diskBuffer,nd);
  return (nb==nd);
}

int16_t file_close(void)
{ mfile.close();
    15ec:	movs	r0, #1
    15ee:	pop	{r4, pc}
    15f0:	.word	0x1fff0948

000015f4 <printTimestamp(unsigned long)>:
 * Custom Implementation
 * 
 */
/****************** Time Utilities *****************************/
void printTimestamp(uint32_t tt)
{
    15f4:	push	{r4, r5, lr}
    15f6:	sub	sp, #28
  tmElements_t tm;
  breakTime(tt, tm);
    15f8:	add	r1, sp, #16
    15fa:	bl	7e58 <breakTime(long, tmElements_t&)>
  Serial.printf("Now: %04d-%02d-%02d_%02d:%02d:%02d\r\n", 
                      tmYearToCalendar(tm.Year), tm.Month, tm.Day, tm.Hour, tm.Minute, tm.Second);
    15fe:	ldrb.w	r2, [sp, #22]
    1602:	ldrb.w	r0, [sp, #18]
    1606:	ldrb.w	r1, [sp, #20]
    160a:	ldrb.w	r5, [sp, #16]
    160e:	ldrb.w	r4, [sp, #17]
    1612:	str	r0, [sp, #4]
    1614:	str	r1, [sp, #0]
    1616:	ldrb.w	r3, [sp, #21]
    161a:	str	r5, [sp, #12]
    161c:	addw	r2, r2, #1970	; 0x7b2
    1620:	str	r4, [sp, #8]
    1622:	ldr	r1, [pc, #12]	; (1630 <printTimestamp(unsigned long)+0x3c>)
    1624:	ldr	r0, [pc, #12]	; (1634 <printTimestamp(unsigned long)+0x40>)
    1626:	bl	ef0c <Print::printf(char const*, ...)>
}
    162a:	add	sp, #28
    162c:	pop	{r4, r5, pc}
    162e:	nop
    1630:	.word	0x000142ac
    1634:	.word	0x1fff0ad0

00001638 <makeFilename(char*)>:
{
  memset(header,0,512);
}

int16_t makeFilename(char *filename)
{
    1638:	push	{r4, r5, r6, r7, lr}
    163a:	sub	sp, #12
    163c:	mov	r7, r0
  uint32_t tt = rtc_get();
    163e:	bl	de40 <rtc_get>
  int dd;
  ss= tt % 60; tt /= 60;
  mm= tt % 60; tt /= 60;
  hh= tt % 24; tt /= 24;
  dd= tt;
  sprintf(filename,"/%d/%02d_%02d_%02d.raw",dd,hh,mm,ss);
    1642:	ldr	r4, [pc, #100]	; (16a8 <makeFilename(char*)+0x70>)
    1644:	ldr	r3, [pc, #100]	; (16ac <makeFilename(char*)+0x74>)
    1646:	ldr	r6, [pc, #104]	; (16b0 <makeFilename(char*)+0x78>)
    1648:	ldr	r2, [pc, #104]	; (16b4 <makeFilename(char*)+0x7c>)
    164a:	ldr	r1, [pc, #108]	; (16b8 <makeFilename(char*)+0x80>)
    164c:	umull	lr, r5, r4, r0
    1650:	lsrs	r5, r5, #5
    1652:	umull	lr, r3, r3, r0
    1656:	umull	lr, r4, r4, r5
    165a:	lsrs	r3, r3, #11
    165c:	lsrs	r4, r4, #5
    165e:	umull	lr, r6, r6, r3
    1662:	rsb	r4, r4, r4, lsl #4
    1666:	sub.w	r4, r5, r4, lsl #2
    166a:	lsrs	r6, r6, #4
    166c:	rsb	r5, r5, r5, lsl #4
    1670:	sub.w	r5, r0, r5, lsl #2
    1674:	add.w	r6, r6, r6, lsl #1
    1678:	umull	r0, r2, r2, r0
    167c:	lsrs	r2, r2, #16
    167e:	sub.w	r3, r3, r6, lsl #3
    1682:	stmia.w	sp, {r4, r5}
    1686:	mov	r0, r7
    1688:	bl	10a44 <sprintf>
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    168c:	mov	r0, r7
    168e:	bl	10c00 <strlen>
    1692:	mov	r1, r0
    1694:	mov	r0, r7
    1696:	bl	d6b8 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    169a:	ldr	r0, [pc, #32]	; (16bc <makeFilename(char*)+0x84>)
    169c:	bl	eedc <Print::println()>
  Serial.println(filename);
  return 1;
}
    16a0:	movs	r0, #1
    16a2:	add	sp, #12
    16a4:	pop	{r4, r5, r6, r7, pc}
    16a6:	nop
    16a8:	.word	0x88888889
    16ac:	.word	0x91a2b3c5
    16b0:	.word	0xaaaaaaab
    16b4:	.word	0xc22e4507
    16b8:	.word	0x000142d4
    16bc:	.word	0x1fff0ad0

000016c0 <checkPath(unsigned short, char*)>:

int16_t checkPath(uint16_t store, char *filename)
{
    16c0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    16c4:	mov	r6, r0
    16c6:	sub	sp, #60	; 0x3c
  int ln=strlen(filename);
    16c8:	mov	r0, r1
  Serial.println(filename);
  return 1;
}

int16_t checkPath(uint16_t store, char *filename)
{
    16ca:	mov	r5, r1
  int ln=strlen(filename);
    16cc:	bl	10c00 <strlen>
  int i1=-1;
  for(int ii=0;ii<ln;ii++) if(filename[ii]=='/') i1=ii;
    16d0:	cmp	r0, #0
    16d2:	ble.n	17bc <checkPath(unsigned short, char*)+0xfc>
    16d4:	subs	r1, r5, #1
    16d6:	movs	r3, #0
    16d8:	mov.w	r2, #4294967295
    16dc:	ldrb.w	r4, [r1, #1]!
    16e0:	cmp	r4, #47	; 0x2f
    16e2:	it	eq
    16e4:	moveq	r2, r3
    16e6:	adds	r3, #1
    16e8:	cmp	r0, r3
    16ea:	bne.n	16dc <checkPath(unsigned short, char*)+0x1c>
  if(i1<0) return 1; // no path
    16ec:	cmp	r2, #0
    16ee:	blt.n	17bc <checkPath(unsigned short, char*)+0xfc>
  filename[i1]=0;
    16f0:	mov.w	lr, #0
  if(!sdx[store].exists(filename))
    16f4:	mov.w	r3, #1208	; 0x4b8
{
  int ln=strlen(filename);
  int i1=-1;
  for(int ii=0;ii<ln;ii++) if(filename[ii]=='/') i1=ii;
  if(i1<0) return 1; // no path
  filename[i1]=0;
    16f8:	strb.w	lr, [r5, r2]
  if(!sdx[store].exists(filename))
    16fc:	mul.w	r3, r3, r6
    1700:	ldr.w	r8, [pc, #256]	; 1804 <checkPath(unsigned short, char*)+0x144>
    1704:	ldr	r1, [pc, #240]	; (17f8 <checkPath(unsigned short, char*)+0x138>)
    1706:	ldr.w	r0, [r8, r3]
    170a:	ldr.w	r9, [r0, #4]
    170e:	cmp	r9, r1
{
  int ln=strlen(filename);
  int i1=-1;
  for(int ii=0;ii<ln;ii++) if(filename[ii]=='/') i1=ii;
  if(i1<0) return 1; // no path
  filename[i1]=0;
    1710:	add.w	r4, r5, r2
  if(!sdx[store].exists(filename))
    1714:	add.w	r7, r8, r3
    1718:	bne.n	17c4 <checkPath(unsigned short, char*)+0x104>
    171a:	ldr.w	ip, [r7, #1156]	; 0x484
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return m_fVol ? m_fVol->exists(path) :
           m_xVol ? m_xVol->exists(path) : false;
    171e:	cmp.w	ip, #0
    1722:	beq.n	174a <checkPath(unsigned short, char*)+0x8a>
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    1724:	mov	r1, ip
    1726:	mov	r3, lr
    1728:	mov	r2, r5
    172a:	mov	r0, sp
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    172c:	strb.w	lr, [sp]
    1730:	strb.w	lr, [sp, #1]
    1734:	strb.w	lr, [sp, #2]
    1738:	bl	9f64 <FatFile::open(FatVolume*, char const*, int)>
    173c:	cbz	r0, 176a <checkPath(unsigned short, char*)+0xaa>
  { Serial.println(filename); 
    if(!sdx[store].mkdir(filename)) return 0;
  }

  filename[i1]='/';
    173e:	movs	r3, #47	; 0x2f
    1740:	strb	r3, [r4, #0]
  return 1;
    1742:	movs	r0, #1
}
    1744:	add	sp, #60	; 0x3c
    1746:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    174a:	ldr.w	r1, [r7, #1160]	; 0x488
    174e:	cbz	r1, 176a <checkPath(unsigned short, char*)+0xaa>
   *
   * \return true if the file exists else false.
   */
  bool exists(const ExChar_t* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    1750:	mov	r3, ip
    1752:	mov	r2, r5
    1754:	mov	r0, sp
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    1756:	strb.w	ip, [sp, #49]	; 0x31
    175a:	strb.w	ip, [sp, #50]	; 0x32
    175e:	strb.w	ip, [sp, #51]	; 0x33
    1762:	bl	8bbc <ExFatFile::open(ExFatVolume*, char const*, int)>
  int ln=strlen(filename);
  int i1=-1;
  for(int ii=0;ii<ln;ii++) if(filename[ii]=='/') i1=ii;
  if(i1<0) return 1; // no path
  filename[i1]=0;
  if(!sdx[store].exists(filename))
    1766:	cmp	r0, #0
    1768:	bne.n	173e <checkPath(unsigned short, char*)+0x7e>
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    176a:	mov	r0, r5
    176c:	bl	10c00 <strlen>
    1770:	mov	r1, r0
    1772:	mov	r0, r5
    1774:	bl	d6b8 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    1778:	ldr	r0, [pc, #128]	; (17fc <checkPath(unsigned short, char*)+0x13c>)
    177a:	bl	eedc <Print::println()>
  { Serial.println(filename); 
    if(!sdx[store].mkdir(filename)) return 0;
    177e:	mov.w	r3, #1208	; 0x4b8
    1782:	mul.w	r6, r3, r6
    1786:	ldr	r2, [pc, #120]	; (1800 <checkPath(unsigned short, char*)+0x140>)
    1788:	ldr.w	r3, [r8, r6]
    178c:	ldr	r3, [r3, #8]
    178e:	cmp	r3, r2
    1790:	bne.n	17f0 <checkPath(unsigned short, char*)+0x130>
    1792:	ldr.w	r6, [r7, #1156]	; 0x484
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char *path, bool pFlag = true) {
    return m_fVol ? m_fVol->mkdir(path, pFlag) :
           m_xVol ? m_xVol->mkdir(path, pFlag) : false;
    1796:	cbz	r6, 17cc <checkPath(unsigned short, char*)+0x10c>
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    FatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    1798:	mov	r2, r5
    179a:	addw	r1, r6, #1092	; 0x444
    179e:	movs	r5, #0
    17a0:	movs	r3, #1
    17a2:	mov	r0, sp
    17a4:	strb.w	r5, [sp]
    17a8:	strb.w	r5, [sp, #1]
    17ac:	strb.w	r5, [sp, #2]
    17b0:	bl	9de0 <FatFile::mkdir(FatFile*, char const*, bool)>
    17b4:	cmp	r0, #0
    17b6:	bne.n	173e <checkPath(unsigned short, char*)+0x7e>
    17b8:	movs	r0, #0
    17ba:	b.n	1744 <checkPath(unsigned short, char*)+0x84>
int16_t checkPath(uint16_t store, char *filename)
{
  int ln=strlen(filename);
  int i1=-1;
  for(int ii=0;ii<ln;ii++) if(filename[ii]=='/') i1=ii;
  if(i1<0) return 1; // no path
    17bc:	movs	r0, #1
    if(!sdx[store].mkdir(filename)) return 0;
  }

  filename[i1]='/';
  return 1;
}
    17be:	add	sp, #60	; 0x3c
    17c0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  int ln=strlen(filename);
  int i1=-1;
  for(int ii=0;ii<ln;ii++) if(filename[ii]=='/') i1=ii;
  if(i1<0) return 1; // no path
  filename[i1]=0;
  if(!sdx[store].exists(filename))
    17c4:	mov	r1, r5
    17c6:	mov	r0, r7
    17c8:	blx	r9
    17ca:	b.n	173c <checkPath(unsigned short, char*)+0x7c>
    17cc:	ldr.w	r1, [r7, #1160]	; 0x488
    17d0:	cmp	r1, #0
    17d2:	beq.n	17b8 <checkPath(unsigned short, char*)+0xf8>
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const ExChar_t* path, bool pFlag = true) {
    ExFatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    17d4:	mov	r2, r5
    17d6:	add.w	r1, r1, #1096	; 0x448
    17da:	movs	r3, #1
    17dc:	mov	r0, sp
    17de:	strb.w	r6, [sp, #49]	; 0x31
    17e2:	strb.w	r6, [sp, #50]	; 0x32
    17e6:	strb.w	r6, [sp, #51]	; 0x33
    17ea:	bl	95f0 <ExFatFile::mkdir(ExFatFile*, char const*, bool)>
    17ee:	b.n	17b4 <checkPath(unsigned short, char*)+0xf4>
  { Serial.println(filename); 
    if(!sdx[store].mkdir(filename)) return 0;
    17f0:	mov	r1, r5
    17f2:	mov	r0, r7
    17f4:	blx	r3
    17f6:	b.n	17b4 <checkPath(unsigned short, char*)+0xf4>
    17f8:	.word	0x00000a49
    17fc:	.word	0x1fff0ad0
    1800:	.word	0x000009f9
    1804:	.word	0x1fff2bc8

00001808 <file_open(unsigned short)>:
void makeHeader(char *header);
int16_t makeFilename(char *filename);
int16_t checkPath(uint16_t store, char *filename);

int16_t file_open(uint16_t store)
{ char filename[80];
    1808:	push	{r4, r5, r6, r7, lr}
    180a:	sub	sp, #188	; 0xbc
    180c:	mov	r4, r0
  if(!makeFilename(filename)) return 0;
    180e:	add	r0, sp, #24
    1810:	bl	1638 <makeFilename(char*)>
    1814:	cbnz	r0, 181c <file_open(unsigned short)+0x14>
    1816:	movs	r0, #0
  if(!checkPath(store, filename)) return 0;
  mfile = sdx[store].open(filename,FILE_WRITE);
  return !(!mfile);
}
    1818:	add	sp, #188	; 0xbc
    181a:	pop	{r4, r5, r6, r7, pc}
int16_t checkPath(uint16_t store, char *filename);

int16_t file_open(uint16_t store)
{ char filename[80];
  if(!makeFilename(filename)) return 0;
  if(!checkPath(store, filename)) return 0;
    181c:	add	r1, sp, #24
    181e:	mov	r0, r4
    1820:	bl	16c0 <checkPath(unsigned short, char*)>
    1824:	cmp	r0, #0
    1826:	beq.n	1816 <file_open(unsigned short)+0xe>
  mfile = sdx[store].open(filename,FILE_WRITE);
    1828:	mov.w	r1, #1208	; 0x4b8
    182c:	mul.w	r4, r1, r4
    1830:	ldr	r1, [pc, #248]	; (192c <file_open(unsigned short)+0x124>)
    1832:	ldr	r3, [pc, #252]	; (1930 <file_open(unsigned short)+0x128>)
    1834:	ldr	r2, [r1, r4]
    1836:	ldr	r5, [r2, #0]
    1838:	cmp	r5, r3
    183a:	add	r1, r4
	}
	File open(const char *filepath, uint8_t mode = FILE_READ) {
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
    183c:	add	r2, sp, #24
    183e:	bne.n	1904 <file_open(unsigned short)+0xfc>
    1840:	movw	r3, #16898	; 0x4202
    1844:	adds	r1, #4
    1846:	add	r0, sp, #104	; 0x68
    1848:	bl	b7a8 <FsVolume::open(char const*, int)>
    184c:	ldr	r3, [sp, #176]	; 0xb0
    184e:	cmp	r3, #0
    1850:	beq.n	190c <file_open(unsigned short)+0x104>
		if (file) return File(new SDFile(file));
    1852:	movs	r0, #104	; 0x68
    1854:	bl	eff8 <operator new(unsigned int)>
    1858:	mov	r4, r0
//#define BYTE 0
//#endif

class __FlashStringHelper;

class Print
    185a:	ldrb.w	r7, [sp, #108]	; 0x6c
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
    185e:	ldr	r2, [sp, #112]	; 0x70
    1860:	ldrb.w	r3, [sp, #116]	; 0x74
	// Classes derived from File are never meant to be constructed
	// anywhere other than open() in the parent FS class and
	// openNextFile() while traversing a directory.
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
    1864:	ldr	r0, [pc, #204]	; (1934 <file_open(unsigned short)+0x12c>)
    1866:	ldr	r1, [pc, #208]	; (1938 <file_open(unsigned short)+0x130>)
    1868:	strb	r7, [r4, #24]
{
  public:
	constexpr Print() : write_error(0) {}
    186a:	movs	r5, #0
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
    186c:	mov.w	r7, #1000	; 0x3e8
    1870:	add	r6, sp, #120	; 0x78
    1872:	str	r0, [r4, #0]
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
    1874:	str	r1, [r4, #20]
    1876:	str	r2, [r4, #28]
    1878:	mov	r1, r6
    187a:	strb.w	r3, [r4, #32]
    187e:	add.w	r0, r4, #36	; 0x24
    1882:	strb	r5, [r4, #4]
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
    1884:	strb	r5, [r4, #12]

#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
    1886:	str	r5, [r4, #16]
    1888:	str	r7, [r4, #8]
    188a:	bl	b560 <FsBaseFile::FsBaseFile(FsBaseFile const&)>
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
    188e:	ldr	r3, [r4, #16]
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    1890:	ldr	r1, [pc, #168]	; (193c <file_open(unsigned short)+0x134>)
#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
	File(File *file) {
    1892:	ldr	r2, [pc, #172]	; (1940 <file_open(unsigned short)+0x138>)
    1894:	str	r5, [r4, #100]	; 0x64
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
    1896:	adds	r3, #1
    1898:	strb.w	r5, [sp, #8]
    189c:	str	r7, [sp, #12]
    189e:	strb.w	r5, [sp, #16]
		// can we use is_same or is_polymorphic with static_assert?
		// or is_base_of
		//static_assert(std::is_same<decltype(*file),File>::value,
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
    18a2:	str	r4, [sp, #20]
    18a4:	str	r1, [r4, #20]
		if (f) f->refcount++;
    18a6:	str	r3, [r4, #16]
#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
	File(File *file) {
    18a8:	str	r2, [sp, #4]
    18aa:	ldr	r3, [pc, #152]	; (1944 <file_open(unsigned short)+0x13c>)
    18ac:	str	r3, [sp, #104]	; 0x68
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
    18ae:	mov	r0, r6
    18b0:	bl	b5d8 <FsBaseFile::close()>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    18b4:	ldr	r4, [pc, #144]	; (1948 <file_open(unsigned short)+0x140>)
    18b6:	ldr	r2, [r4, #16]
    18b8:	cbz	r2, 18cc <file_open(unsigned short)+0xc4>
    18ba:	ldr	r3, [r2, #16]
    18bc:	subs	r3, #1
    18be:	str	r3, [r2, #16]
    18c0:	cbnz	r3, 18cc <file_open(unsigned short)+0xc4>
    18c2:	ldr	r0, [r4, #16]
    18c4:	cbz	r0, 18cc <file_open(unsigned short)+0xc4>
    18c6:	ldr	r3, [r0, #0]
    18c8:	ldr	r3, [r3, #32]
    18ca:	blx	r3
	File& operator = (const File &file) {
		//Serial.println("File assignment");
		//static int assigncount=0;
		//if (++assigncount > 20) while (1) ;
		invalidate();
		f = file.f;
    18cc:	ldr	r3, [sp, #20]
    18ce:	str	r3, [r4, #16]
		if (f) f->refcount++;
    18d0:	cbz	r3, 18f2 <file_open(unsigned short)+0xea>
    18d2:	ldr	r2, [r3, #16]
		return *this;
	}
	virtual ~File() {
    18d4:	ldr	r1, [pc, #104]	; (1940 <file_open(unsigned short)+0x138>)
    18d6:	str	r1, [sp, #4]
		//Serial.println("File assignment");
		//static int assigncount=0;
		//if (++assigncount > 20) while (1) ;
		invalidate();
		f = file.f;
		if (f) f->refcount++;
    18d8:	adds	r2, #1
    18da:	str	r2, [r3, #16]
    18dc:	ldr	r2, [sp, #20]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    18de:	cbz	r2, 18f2 <file_open(unsigned short)+0xea>
    18e0:	ldr	r3, [r2, #16]
    18e2:	subs	r3, #1
    18e4:	str	r3, [r2, #16]
    18e6:	cbnz	r3, 18f2 <file_open(unsigned short)+0xea>
    18e8:	ldr	r0, [sp, #20]
    18ea:	cbz	r0, 18f2 <file_open(unsigned short)+0xea>
    18ec:	ldr	r3, [r0, #0]
    18ee:	ldr	r3, [r3, #32]
    18f0:	blx	r3
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    18f2:	ldr	r0, [r4, #16]
    18f4:	cmp	r0, #0
    18f6:	beq.n	1818 <file_open(unsigned short)+0x10>
    18f8:	ldr	r3, [r0, #0]
    18fa:	ldr	r3, [r3, #68]	; 0x44
    18fc:	blx	r3
    18fe:	sxth	r0, r0
  return !(!mfile);
}
    1900:	add	sp, #188	; 0xbc
    1902:	pop	{r4, r5, r6, r7, pc}

int16_t file_open(uint16_t store)
{ char filename[80];
  if(!makeFilename(filename)) return 0;
  if(!checkPath(store, filename)) return 0;
  mfile = sdx[store].open(filename,FILE_WRITE);
    1904:	movs	r3, #1
    1906:	add	r0, sp, #4
    1908:	blx	r5
    190a:	b.n	18b4 <file_open(unsigned short)+0xac>
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
    190c:	ldr	r3, [sp, #180]	; 0xb4
    190e:	cmp	r3, #0
    1910:	bne.n	1852 <file_open(unsigned short)+0x4a>
    1912:	mov.w	r1, #1000	; 0x3e8

#define FILE_WHOAMI

class File : public Stream {
public:
	constexpr File() : f(nullptr) { }
    1916:	ldr	r2, [pc, #40]	; (1940 <file_open(unsigned short)+0x138>)
    1918:	strb.w	r3, [sp, #8]
    191c:	strb.w	r3, [sp, #16]
    1920:	str	r3, [sp, #20]
    1922:	str	r1, [sp, #12]
    1924:	str	r2, [sp, #4]
    1926:	add	r6, sp, #120	; 0x78
    1928:	b.n	18aa <file_open(unsigned short)+0xa2>
    192a:	nop
    192c:	.word	0x1fff2bc8
    1930:	.word	0x00000cc9
    1934:	.word	0x0001413c
    1938:	.word	0x00014070
    193c:	.word	0x000140b8
    1940:	.word	0x000140dc
    1944:	.word	0x00014094
    1948:	.word	0x1fff0948

0000194c <do_logger(unsigned short, short)>:
#define NBUF_DISK (NDBL*NBUF_ACQ)
uint32_t diskBuffer[NBUF_DISK];
uint32_t maxDel=0;

int16_t do_logger(uint16_t store, int16_t state)
{ uint32_t to=millis();
    194c:	push	{r4, r5, r6, r7, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    194e:	ldr	r5, [pc, #164]	; (19f4 <do_logger(unsigned short, short)+0xa8>)
    1950:	sub	sp, #12
    1952:	ldr	r3, [r5, #0]
    1954:	str	r3, [sp, #0]
    1956:	mov	r7, r0
    1958:	mov	r4, r1
  if(pullData(diskBuffer,NDBL))
    195a:	ldr	r0, [pc, #156]	; (19f8 <do_logger(unsigned short, short)+0xac>)
	return ret;
    195c:	ldr	r6, [sp, #0]
    195e:	movs	r1, #1
    1960:	bl	147c <pullData(unsigned long*, unsigned long)>
    1964:	cbz	r0, 197a <do_logger(unsigned short, short)+0x2e>
  {
    if(state==0)
    1966:	cbz	r4, 19a0 <do_logger(unsigned short, short)+0x54>
    { // acquisition is running, need to open file
      if(!file_open(store)) return -2;
      state=1;
    }
    if(state==1)
    1968:	cmp	r4, #1
    196a:	beq.n	19a8 <do_logger(unsigned short, short)+0x5c>
    { // file just opended, need to write header
      if(!file_writeHeader()) return -3;
      state=2;
      
    }
    if(state>=2)
    196c:	ble.n	197e <do_logger(unsigned short, short)+0x32>
    { // write data to disk
      if(!file_writeData(diskBuffer,NBUF_DISK*4)) return -4;
    196e:	mov.w	r1, #512	; 0x200
    1972:	ldr	r0, [pc, #132]	; (19f8 <do_logger(unsigned short, short)+0xac>)
    1974:	bl	1594 <file_writeData(void*, unsigned long)>
    1978:	cbz	r0, 19d4 <do_logger(unsigned short, short)+0x88>
    }
  }

  if(state==3)
    197a:	cmp	r4, #3
    197c:	beq.n	19be <do_logger(unsigned short, short)+0x72>
  { // close file, but continue acquisition
    if(!file_close()) return -5;
    state=0;
  }

  if(state==4)
    197e:	cmp	r4, #4
    1980:	beq.n	19c8 <do_logger(unsigned short, short)+0x7c>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1982:	ldr	r3, [r5, #0]
    1984:	str	r3, [sp, #4]
    if(!file_close()) return -6;
    state=-1;
  }

  uint32_t dt=millis()-to;
  if(dt>maxDel) maxDel=dt;
    1986:	ldr	r2, [pc, #116]	; (19fc <do_logger(unsigned short, short)+0xb0>)
	return ret;
    1988:	ldr	r3, [sp, #4]
    198a:	ldr	r1, [r2, #0]
  { // close file and stop acquisition
    if(!file_close()) return -6;
    state=-1;
  }

  uint32_t dt=millis()-to;
    198c:	subs	r3, r3, r6
  if(dt>maxDel) maxDel=dt;
    198e:	cmp	r3, r1
    1990:	bls.n	199a <do_logger(unsigned short, short)+0x4e>
    1992:	str	r3, [r2, #0]

  return state;
    1994:	mov	r0, r4
}
    1996:	add	sp, #12
    1998:	pop	{r4, r5, r6, r7, pc}
  }

  uint32_t dt=millis()-to;
  if(dt>maxDel) maxDel=dt;

  return state;
    199a:	mov	r0, r4
}
    199c:	add	sp, #12
    199e:	pop	{r4, r5, r6, r7, pc}
{ uint32_t to=millis();
  if(pullData(diskBuffer,NDBL))
  {
    if(state==0)
    { // acquisition is running, need to open file
      if(!file_open(store)) return -2;
    19a0:	mov	r0, r7
    19a2:	bl	1808 <file_open(unsigned short)>
    19a6:	cbz	r0, 19da <do_logger(unsigned short, short)+0x8e>
      state=1;
    }
    if(state==1)
    { // file just opended, need to write header
      if(!file_writeHeader()) return -3;
    19a8:	bl	154c <file_writeHeader()>
    19ac:	cbz	r0, 19e0 <do_logger(unsigned short, short)+0x94>
      state=2;
      
    }
    if(state>=2)
    { // write data to disk
      if(!file_writeData(diskBuffer,NBUF_DISK*4)) return -4;
    19ae:	mov.w	r1, #512	; 0x200
    19b2:	ldr	r0, [pc, #68]	; (19f8 <do_logger(unsigned short, short)+0xac>)
    19b4:	bl	1594 <file_writeData(void*, unsigned long)>
    19b8:	cbz	r0, 19d4 <do_logger(unsigned short, short)+0x88>
      state=1;
    }
    if(state==1)
    { // file just opended, need to write header
      if(!file_writeHeader()) return -3;
      state=2;
    19ba:	movs	r4, #2
    19bc:	b.n	1982 <do_logger(unsigned short, short)+0x36>
    }
  }

  if(state==3)
  { // close file, but continue acquisition
    if(!file_close()) return -5;
    19be:	bl	15cc <file_close()>
    19c2:	cbz	r0, 19ec <do_logger(unsigned short, short)+0xa0>
    state=0;
    19c4:	movs	r4, #0
    19c6:	b.n	1982 <do_logger(unsigned short, short)+0x36>
  }

  if(state==4)
  { // close file and stop acquisition
    if(!file_close()) return -6;
    19c8:	bl	15cc <file_close()>
    19cc:	cbz	r0, 19e6 <do_logger(unsigned short, short)+0x9a>
    state=-1;
    19ce:	mov.w	r4, #4294967295
    19d2:	b.n	1982 <do_logger(unsigned short, short)+0x36>
      state=2;
      
    }
    if(state>=2)
    { // write data to disk
      if(!file_writeData(diskBuffer,NBUF_DISK*4)) return -4;
    19d4:	mvn.w	r0, #3
    19d8:	b.n	1996 <do_logger(unsigned short, short)+0x4a>
{ uint32_t to=millis();
  if(pullData(diskBuffer,NDBL))
  {
    if(state==0)
    { // acquisition is running, need to open file
      if(!file_open(store)) return -2;
    19da:	mvn.w	r0, #1
    19de:	b.n	1996 <do_logger(unsigned short, short)+0x4a>
      state=1;
    }
    if(state==1)
    { // file just opended, need to write header
      if(!file_writeHeader()) return -3;
    19e0:	mvn.w	r0, #2
    19e4:	b.n	1996 <do_logger(unsigned short, short)+0x4a>
    state=0;
  }

  if(state==4)
  { // close file and stop acquisition
    if(!file_close()) return -6;
    19e6:	mvn.w	r0, #5
    19ea:	b.n	1996 <do_logger(unsigned short, short)+0x4a>
    }
  }

  if(state==3)
  { // close file, but continue acquisition
    if(!file_close()) return -5;
    19ec:	mvn.w	r0, #4
    19f0:	b.n	1996 <do_logger(unsigned short, short)+0x4a>
    19f2:	nop
    19f4:	.word	0x1fff66b0
    19f8:	.word	0x1fff16bc
    19fc:	.word	0x1fff14b8

00001a00 <loop>:
  Serial.flush();
}

uint32_t loop_count=0;
void loop()
{ loop_count++;
    1a00:	push	{r4, r5, r6, lr}
    1a02:	ldr	r2, [pc, #124]	; (1a80 <loop+0x80>)
  state = do_menu(state);
    1a04:	ldr	r4, [pc, #124]	; (1a84 <loop+0x84>)
  Serial.flush();
}

uint32_t loop_count=0;
void loop()
{ loop_count++;
    1a06:	ldr	r3, [r2, #0]
  state = do_menu(state);
    1a08:	ldrsh.w	r0, [r4]
  Serial.flush();
}

uint32_t loop_count=0;
void loop()
{ loop_count++;
    1a0c:	adds	r3, #1
    1a0e:	sub	sp, #16
    1a10:	str	r3, [r2, #0]
  state = do_menu(state);
    1a12:	bl	14d4 <do_menu(short)>

uint32_t t_on = 60;
int16_t check_filing(int16_t state)
{
  static uint32_t to;
  if(state==2)
    1a16:	cmp	r0, #2
}

uint32_t loop_count=0;
void loop()
{ loop_count++;
  state = do_menu(state);
    1a18:	mov	r1, r0
    1a1a:	strh	r0, [r4, #0]

uint32_t t_on = 60;
int16_t check_filing(int16_t state)
{
  static uint32_t to;
  if(state==2)
    1a1c:	beq.n	1a5c <loop+0x5c>
{ loop_count++;
  state = do_menu(state);
  state = acq_check(state);
  state = check_filing(state);
  //
  if(state<0)
    1a1e:	cmp	r0, #0
    1a20:	blt.n	1a50 <loop+0x50>
    mtpd.loop();
  else
    state=do_logger(0,state);
    1a22:	movs	r0, #0
    1a24:	bl	194c <do_logger(unsigned short, short)>
    1a28:	strh	r0, [r4, #0]

  if(state>=0) logg(1000,"loop");
    1a2a:	cmp	r0, #0
    1a2c:	blt.n	1a42 <loop+0x42>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1a2e:	ldr	r3, [pc, #88]	; (1a88 <loop+0x88>)
/**************** Online logging *******************************/
extern uint32_t loop_count, acq_count, acq_miss, maxDel;
extern uint16_t maxCount;
void logg(uint32_t del, const char *txt)
{ static uint32_t to;
  if(millis()-to > del)
    1a30:	ldr	r2, [pc, #88]	; (1a8c <loop+0x8c>)
    1a32:	ldr	r3, [r3, #0]
    1a34:	str	r3, [sp, #12]
	return ret;
    1a36:	ldr	r3, [sp, #12]
    1a38:	ldr	r2, [r2, #0]
    1a3a:	subs	r3, r3, r2
    1a3c:	cmp.w	r3, #1000	; 0x3e8
    1a40:	bhi.n	1a46 <loop+0x46>
  else
    state=do_logger(0,state);

  if(state>=0) logg(1000,"loop");
  //asm("wfi"); // may wait forever on T4.x
}
    1a42:	add	sp, #16
    1a44:	pop	{r4, r5, r6, pc}
    1a46:	ldr	r0, [pc, #72]	; (1a90 <loop+0x90>)
    1a48:	bl	884 <logg(unsigned long, char const*) [clone .part.53]>
    1a4c:	add	sp, #16
    1a4e:	pop	{r4, r5, r6, pc}
  state = do_menu(state);
  state = acq_check(state);
  state = check_filing(state);
  //
  if(state<0)
    mtpd.loop();
    1a50:	ldr	r0, [pc, #64]	; (1a94 <loop+0x94>)
    1a52:	bl	7068 <MTPD::loop()>
    1a56:	ldrsh.w	r0, [r4]
    1a5a:	b.n	1a2a <loop+0x2a>
    1a5c:	str	r0, [sp, #4]
int16_t check_filing(int16_t state)
{
  static uint32_t to;
  if(state==2)
  {
    uint32_t tt = rtc_get();
    1a5e:	bl	de40 <rtc_get>
    uint32_t dt = tt % t_on;
    1a62:	ldr	r3, [pc, #52]	; (1a98 <loop+0x98>)
    if(dt<to) state = 3;
    1a64:	ldr	r2, [pc, #52]	; (1a9c <loop+0x9c>)
{
  static uint32_t to;
  if(state==2)
  {
    uint32_t tt = rtc_get();
    uint32_t dt = tt % t_on;
    1a66:	ldr	r3, [r3, #0]
    if(dt<to) state = 3;
    1a68:	ldr	r5, [r2, #0]
    1a6a:	ldr	r1, [sp, #4]
{
  static uint32_t to;
  if(state==2)
  {
    uint32_t tt = rtc_get();
    uint32_t dt = tt % t_on;
    1a6c:	udiv	r6, r0, r3
    1a70:	mls	r0, r6, r3, r0
    if(dt<to) state = 3;
    1a74:	cmp	r0, r5
    1a76:	it	cc
    1a78:	movcc	r1, #3
uint32_t loop_count=0;
void loop()
{ loop_count++;
  state = do_menu(state);
  state = acq_check(state);
  state = check_filing(state);
    1a7a:	strh	r1, [r4, #0]
  if(state==2)
  {
    uint32_t tt = rtc_get();
    uint32_t dt = tt % t_on;
    if(dt<to) state = 3;
    to = dt;
    1a7c:	str	r0, [r2, #0]
    1a7e:	b.n	1a22 <loop+0x22>
    1a80:	.word	0x1fff6150
    1a84:	.word	0x1fff1bc6
    1a88:	.word	0x1fff66b0
    1a8c:	.word	0x1fff615c
    1a90:	.word	0x000142ec
    1a94:	.word	0x1fff6138
    1a98:	.word	0x1fff093c
    1a9c:	.word	0x1fff6158

00001aa0 <acq_init(long)>:

    const int32_t fsamp0=(((F_PLL*MCLK_MULT)/MCLK_DIV)/(2*BIT_DIV)/(NCH_I2S*32/N_ADC));


    void acq_init(int32_t fsamp)
    {
    1aa0:	push	{r3, r4, r5, r6, r7, lr}
        Serial.printf("%d %d\n",fsamp,fsamp0);
    1aa2:	mov	r2, r0
    1aa4:	ldr	r3, [pc, #280]	; (1bc0 <acq_init(long)+0x120>)
    1aa6:	ldr	r1, [pc, #284]	; (1bc4 <acq_init(long)+0x124>)
    1aa8:	ldr	r0, [pc, #284]	; (1bc8 <acq_init(long)+0x128>)
//            CORE_PIN39_CONFIG = PORT_PCR_MUX(6);  //pin39, PTA17, I2S0_MCLK
//            CORE_PIN11_CONFIG = PORT_PCR_MUX(4);  //pin11, PTC6,  I2S0_RX_BCLK
//            CORE_PIN12_CONFIG = PORT_PCR_MUX(4);  //pin12, PTC7,  I2S0_RX_FS
//            CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  //pin13, PTC5,  I2S0_RXD0
        #elif I2S_CONFIG==1
            CORE_PIN35_CONFIG = PORT_PCR_MUX(4);   // PTC8,  I2S0_MCLK
    1aaa:	ldr	r7, [pc, #288]	; (1bcc <acq_init(long)+0x12c>)
            CORE_PIN36_CONFIG = PORT_PCR_MUX(4);   // PTC9,  I2S0_RX_BCLK
    1aac:	ldr	r6, [pc, #288]	; (1bd0 <acq_init(long)+0x130>)
            CORE_PIN37_CONFIG = PORT_PCR_MUX(4);   // PTC10, I2S0_RX_FS 
    1aae:	ldr	r5, [pc, #292]	; (1bd4 <acq_init(long)+0x134>)
//            CORE_PIN36_CONFIG = PORT_PCR_MUX(4);  //pin36, PTC9,   I2S0_RX_BCLK
//            CORE_PIN37_CONFIG = PORT_PCR_MUX(4);  //pin37, PTC10,  I2S0_RX_FS
//            CORE_PIN27_CONFIG = PORT_PCR_MUX(6);  //pin27, PTA15,  I2S0_RXD0
        #endif

        I2S0_RCSR=0;
    1ab0:	ldr	r4, [pc, #292]	; (1bd8 <acq_init(long)+0x138>)
    const int32_t fsamp0=(((F_PLL*MCLK_MULT)/MCLK_DIV)/(2*BIT_DIV)/(NCH_I2S*32/N_ADC));


    void acq_init(int32_t fsamp)
    {
        Serial.printf("%d %d\n",fsamp,fsamp0);
    1ab2:	bl	ef0c <Print::printf(char const*, ...)>
        SIM_SCGC6 |= SIM_SCGC6_I2S;
    1ab6:	ldr	r3, [pc, #292]	; (1bdc <acq_init(long)+0x13c>)
        SIM_SCGC7 |= SIM_SCGC7_DMA;
    1ab8:	ldr	r1, [pc, #292]	; (1be0 <acq_init(long)+0x140>)


    void acq_init(int32_t fsamp)
    {
        Serial.printf("%d %d\n",fsamp,fsamp0);
        SIM_SCGC6 |= SIM_SCGC6_I2S;
    1aba:	ldr	r2, [r3, #0]
        #endif

        I2S0_RCSR=0;

        // enable MCLK output // MCLK = INP *((MULT)/(DIV))
        I2S0_MDR = I2S_MDR_FRACT((MCLK_MULT-1)) | I2S_MDR_DIVIDE((MCLK_DIV-1));
    1abc:	ldr	r0, [pc, #292]	; (1be4 <acq_init(long)+0x144>)


    void acq_init(int32_t fsamp)
    {
        Serial.printf("%d %d\n",fsamp,fsamp0);
        SIM_SCGC6 |= SIM_SCGC6_I2S;
    1abe:	orr.w	r2, r2, #32768	; 0x8000
    1ac2:	str	r2, [r3, #0]
        SIM_SCGC7 |= SIM_SCGC7_DMA;
    1ac4:	ldr	r2, [r1, #0]
    1ac6:	orr.w	r2, r2, #2
    1aca:	str	r2, [r1, #0]
        SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    1acc:	ldr	r2, [r3, #0]
    1ace:	orr.w	r2, r2, #2
    1ad2:	str	r2, [r3, #0]

        I2S0_RCSR=0;

        // enable MCLK output // MCLK = INP *((MULT)/(DIV))
        I2S0_MDR = I2S_MDR_FRACT((MCLK_MULT-1)) | I2S_MDR_DIVIDE((MCLK_DIV-1));
        while(I2S0_MCR & I2S_MCR_DUF);
    1ad4:	sub.w	r1, r1, #101888	; 0x18e00
//            CORE_PIN39_CONFIG = PORT_PCR_MUX(6);  //pin39, PTA17, I2S0_MCLK
//            CORE_PIN11_CONFIG = PORT_PCR_MUX(4);  //pin11, PTC6,  I2S0_RX_BCLK
//            CORE_PIN12_CONFIG = PORT_PCR_MUX(4);  //pin12, PTC7,  I2S0_RX_FS
//            CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  //pin13, PTC5,  I2S0_RXD0
        #elif I2S_CONFIG==1
            CORE_PIN35_CONFIG = PORT_PCR_MUX(4);   // PTC8,  I2S0_MCLK
    1ad8:	mov.w	r3, #1024	; 0x400
//            CORE_PIN36_CONFIG = PORT_PCR_MUX(4);  //pin36, PTC9,   I2S0_RX_BCLK
//            CORE_PIN37_CONFIG = PORT_PCR_MUX(4);  //pin37, PTC10,  I2S0_RX_FS
//            CORE_PIN27_CONFIG = PORT_PCR_MUX(6);  //pin27, PTA15,  I2S0_RXD0
        #endif

        I2S0_RCSR=0;
    1adc:	mov.w	lr, #0

        // enable MCLK output // MCLK = INP *((MULT)/(DIV))
        I2S0_MDR = I2S_MDR_FRACT((MCLK_MULT-1)) | I2S_MDR_DIVIDE((MCLK_DIV-1));
    1ae0:	movs	r2, #1
//            CORE_PIN39_CONFIG = PORT_PCR_MUX(6);  //pin39, PTA17, I2S0_MCLK
//            CORE_PIN11_CONFIG = PORT_PCR_MUX(4);  //pin11, PTC6,  I2S0_RX_BCLK
//            CORE_PIN12_CONFIG = PORT_PCR_MUX(4);  //pin12, PTC7,  I2S0_RX_FS
//            CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  //pin13, PTC5,  I2S0_RXD0
        #elif I2S_CONFIG==1
            CORE_PIN35_CONFIG = PORT_PCR_MUX(4);   // PTC8,  I2S0_MCLK
    1ae2:	str	r3, [r7, #0]

        I2S0_RCSR=0;

        // enable MCLK output // MCLK = INP *((MULT)/(DIV))
        I2S0_MDR = I2S_MDR_FRACT((MCLK_MULT-1)) | I2S_MDR_DIVIDE((MCLK_DIV-1));
        while(I2S0_MCR & I2S_MCR_DUF);
    1ae4:	sub.w	r1, r1, #320	; 0x140
//            CORE_PIN11_CONFIG = PORT_PCR_MUX(4);  //pin11, PTC6,  I2S0_RX_BCLK
//            CORE_PIN12_CONFIG = PORT_PCR_MUX(4);  //pin12, PTC7,  I2S0_RX_FS
//            CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  //pin13, PTC5,  I2S0_RXD0
        #elif I2S_CONFIG==1
            CORE_PIN35_CONFIG = PORT_PCR_MUX(4);   // PTC8,  I2S0_MCLK
            CORE_PIN36_CONFIG = PORT_PCR_MUX(4);   // PTC9,  I2S0_RX_BCLK
    1ae8:	str	r3, [r6, #0]
            CORE_PIN37_CONFIG = PORT_PCR_MUX(4);   // PTC10, I2S0_RX_FS 
    1aea:	str	r3, [r5, #0]
//            CORE_PIN36_CONFIG = PORT_PCR_MUX(4);  //pin36, PTC9,   I2S0_RX_BCLK
//            CORE_PIN37_CONFIG = PORT_PCR_MUX(4);  //pin37, PTC10,  I2S0_RX_FS
//            CORE_PIN27_CONFIG = PORT_PCR_MUX(6);  //pin27, PTA15,  I2S0_RXD0
        #endif

        I2S0_RCSR=0;
    1aec:	str.w	lr, [r4]

        // enable MCLK output // MCLK = INP *((MULT)/(DIV))
        I2S0_MDR = I2S_MDR_FRACT((MCLK_MULT-1)) | I2S_MDR_DIVIDE((MCLK_DIV-1));
    1af0:	str	r2, [r0, #0]
        while(I2S0_MCR & I2S_MCR_DUF);
    1af2:	ldr	r3, [r1, #0]
    1af4:	ldr	r2, [pc, #240]	; (1be8 <acq_init(long)+0x148>)
    1af6:	cmp	r3, #0
    1af8:	blt.n	1af2 <acq_init(long)+0x52>
        I2S0_MCR = I2S_MCR_MICS(MCLK_SRC) | I2S_MCR_MOE;
        
        I2S0_RMR=0; // enable receiver mask
    1afa:	ldr.w	lr, [pc, #316]	; 1c38 <acq_init(long)+0x198>
        I2S0_RCR1 = I2S_RCR1_RFW(3); 
    1afe:	ldr	r6, [pc, #236]	; (1bec <acq_init(long)+0x14c>)
                    | I2S_RCR4_MF;
        
        I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);


  dma.begin(true); // Allocate the DMA channel first
    1b00:	ldr	r4, [pc, #236]	; (1bf0 <acq_init(long)+0x150>)
        I2S0_RCR4 = I2S_RCR4_FRSZ((FRAME_I2S-1)) 
                    | I2S_RCR4_FSE  // frame sync early
                    | I2S_RCR4_FSD  // Frame sync in master mode
                    | I2S_RCR4_MF;
        
        I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);
    1b02:	ldr	r3, [pc, #240]	; (1bf4 <acq_init(long)+0x154>)
        I2S0_RCR1 = I2S_RCR1_RFW(3); 

        I2S0_RCR2 = I2S_RCR2_SYNC(0) 
                    | I2S_RCR2_BCP 
                    | I2S_RCR2_BCD  // Bit clock in master mode
                    | I2S_RCR2_DIV((BIT_DIV-1)); // divides MCLK down to Bitclock (BIT_DIV)*2
    1b04:	ldr	r0, [pc, #240]	; (1bf8 <acq_init(long)+0x158>)
                    
        I2S0_RCR4 = I2S_RCR4_FRSZ((FRAME_I2S-1)) 
                    | I2S_RCR4_FSE  // frame sync early
                    | I2S_RCR4_FSD  // Frame sync in master mode
                    | I2S_RCR4_MF;
    1b06:	ldr	r1, [pc, #244]	; (1bfc <acq_init(long)+0x15c>)
        I2S0_RCR1 = I2S_RCR1_RFW(3); 

        I2S0_RCR2 = I2S_RCR2_SYNC(0) 
                    | I2S_RCR2_BCP 
                    | I2S_RCR2_BCD  // Bit clock in master mode
                    | I2S_RCR2_DIV((BIT_DIV-1)); // divides MCLK down to Bitclock (BIT_DIV)*2
    1b08:	ldr	r7, [pc, #244]	; (1c00 <acq_init(long)+0x160>)
        I2S0_RCSR=0;

        // enable MCLK output // MCLK = INP *((MULT)/(DIV))
        I2S0_MDR = I2S_MDR_FRACT((MCLK_MULT-1)) | I2S_MDR_DIVIDE((MCLK_DIV-1));
        while(I2S0_MCR & I2S_MCR_DUF);
        I2S0_MCR = I2S_MCR_MICS(MCLK_SRC) | I2S_MCR_MOE;
    1b0a:	mov.w	r5, #1124073472	; 0x43000000
    1b0e:	str	r5, [r2, #0]
        
        I2S0_RMR=0; // enable receiver mask
    1b10:	movs	r5, #0
        I2S0_RCR1 = I2S_RCR1_RFW(3); 
    1b12:	movs	r2, #3
        // enable MCLK output // MCLK = INP *((MULT)/(DIV))
        I2S0_MDR = I2S_MDR_FRACT((MCLK_MULT-1)) | I2S_MDR_DIVIDE((MCLK_DIV-1));
        while(I2S0_MCR & I2S_MCR_DUF);
        I2S0_MCR = I2S_MCR_MICS(MCLK_SRC) | I2S_MCR_MOE;
        
        I2S0_RMR=0; // enable receiver mask
    1b14:	str.w	r5, [lr]
        I2S0_RCR1 = I2S_RCR1_RFW(3); 
    1b18:	str	r2, [r6, #0]
        I2S0_RCR4 = I2S_RCR4_FRSZ((FRAME_I2S-1)) 
                    | I2S_RCR4_FSE  // frame sync early
                    | I2S_RCR4_FSD  // Frame sync in master mode
                    | I2S_RCR4_MF;
        
        I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);
    1b1a:	ldr	r2, [pc, #232]	; (1c04 <acq_init(long)+0x164>)
                    | I2S_RCR2_DIV((BIT_DIV-1)); // divides MCLK down to Bitclock (BIT_DIV)*2
                    
        I2S0_RCR4 = I2S_RCR4_FRSZ((FRAME_I2S-1)) 
                    | I2S_RCR4_FSE  // frame sync early
                    | I2S_RCR4_FSD  // Frame sync in master mode
                    | I2S_RCR4_MF;
    1b1c:	ldr	r6, [pc, #232]	; (1c08 <acq_init(long)+0x168>)
        I2S0_RCR1 = I2S_RCR1_RFW(3); 

        I2S0_RCR2 = I2S_RCR2_SYNC(0) 
                    | I2S_RCR2_BCP 
                    | I2S_RCR2_BCD  // Bit clock in master mode
                    | I2S_RCR2_DIV((BIT_DIV-1)); // divides MCLK down to Bitclock (BIT_DIV)*2
    1b1e:	str	r7, [r0, #0]
                    
        I2S0_RCR4 = I2S_RCR4_FRSZ((FRAME_I2S-1)) 
                    | I2S_RCR4_FSE  // frame sync early
                    | I2S_RCR4_FSD  // Frame sync in master mode
                    | I2S_RCR4_MF;
    1b20:	str	r6, [r1, #0]
        
        I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);


  dma.begin(true); // Allocate the DMA channel first
    1b22:	mov	r0, r4
        I2S0_RCR4 = I2S_RCR4_FRSZ((FRAME_I2S-1)) 
                    | I2S_RCR4_FSE  // frame sync early
                    | I2S_RCR4_FSD  // Frame sync in master mode
                    | I2S_RCR4_MF;
        
        I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);
    1b24:	str	r2, [r3, #0]


  dma.begin(true); // Allocate the DMA channel first
    1b26:	movs	r1, #1
    1b28:	bl	ecb0 <DMAChannel::begin(bool)>
          dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
          dma.TCD->NBYTES_MLNO = 4;
          dma.TCD->SLAST = 0;
#elif N_ADC==2
          CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  // PTC5,  I2S0_RXD0
          CORE_PIN38_CONFIG = PORT_PCR_MUX(4);  // PTC11, I2S0_RXD1
    1b2c:	ldr	r7, [pc, #220]	; (1c0c <acq_init(long)+0x16c>)
          dma.TCD->SOFF = 0;
          dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
          dma.TCD->NBYTES_MLNO = 4;
          dma.TCD->SLAST = 0;
#elif N_ADC==2
          CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  // PTC5,  I2S0_RXD0
    1b2e:	ldr	r0, [pc, #224]	; (1c10 <acq_init(long)+0x170>)
          CORE_PIN38_CONFIG = PORT_PCR_MUX(4);  // PTC11, I2S0_RXD1

          I2S0_RCR3 = I2S_RCR3_RCE_2CH;
    1b30:	ldr	r1, [pc, #224]	; (1c14 <acq_init(long)+0x174>)

          dma.TCD->SADDR = &I2S0_RDR0;
    1b32:	ldr	r2, [pc, #228]	; (1c18 <acq_init(long)+0x178>)
          dma.TCD->NBYTES_MLOFFYES = DMA_TCD_NBYTES_SMLOE |
              DMA_TCD_NBYTES_MLOFFYES_MLOFF(-8) |
              DMA_TCD_NBYTES_MLOFFYES_NBYTES(8);
          dma.TCD->SLAST = -8;
#endif
          dma.TCD->DADDR = tdm_rx_buffer;
    1b34:	ldr	r6, [pc, #228]	; (1c1c <acq_init(long)+0x17c>)
          dma.TCD->SOFF = 0;
          dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
          dma.TCD->NBYTES_MLNO = 4;
          dma.TCD->SLAST = 0;
#elif N_ADC==2
          CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  // PTC5,  I2S0_RXD0
    1b36:	mov.w	r3, #1024	; 0x400
    1b3a:	str	r3, [r0, #0]
          CORE_PIN38_CONFIG = PORT_PCR_MUX(4);  // PTC11, I2S0_RXD1
    1b3c:	str	r3, [r7, #0]

          I2S0_RCR3 = I2S_RCR3_RCE_2CH;
    1b3e:	mov.w	r0, #196608	; 0x30000

          dma.TCD->SADDR = &I2S0_RDR0;
    1b42:	ldr	r3, [r4, #0]
          dma.TCD->SLAST = 0;
#elif N_ADC==2
          CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  // PTC5,  I2S0_RXD0
          CORE_PIN38_CONFIG = PORT_PCR_MUX(4);  // PTC11, I2S0_RXD1

          I2S0_RCR3 = I2S_RCR3_RCE_2CH;
    1b44:	str	r0, [r1, #0]

          dma.TCD->SADDR = &I2S0_RDR0;
          dma.TCD->SOFF = 4;
    1b46:	movs	r0, #4
          CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  // PTC5,  I2S0_RXD0
          CORE_PIN38_CONFIG = PORT_PCR_MUX(4);  // PTC11, I2S0_RXD1

          I2S0_RCR3 = I2S_RCR3_RCE_2CH;

          dma.TCD->SADDR = &I2S0_RDR0;
    1b48:	str	r2, [r3, #0]
          dma.TCD->SOFF = 4;
    1b4a:	strh	r0, [r3, #4]
	// 32 bits.  If a channel is configured for 200 transfers

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint8_t *mux;
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
    1b4c:	ldrb	r2, [r4, #4]
          dma.TCD->NBYTES_MLOFFYES = DMA_TCD_NBYTES_SMLOE |
              DMA_TCD_NBYTES_MLOFFYES_MLOFF(-8) |
              DMA_TCD_NBYTES_MLOFFYES_NBYTES(8);
          dma.TCD->SLAST = -8;
#endif
          dma.TCD->DADDR = tdm_rx_buffer;
    1b4e:	str	r6, [r3, #16]
    1b50:	add.w	r2, r2, #1073741824	; 0x40000000

          I2S0_RCR3 = I2S_RCR3_RCE_2CH;

          dma.TCD->SADDR = &I2S0_RDR0;
          dma.TCD->SOFF = 4;
          dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
    1b54:	movw	r6, #514	; 0x202
    1b58:	strh	r6, [r3, #6]
    1b5a:	add.w	r2, r2, #135168	; 0x21000
          dma.TCD->NBYTES_MLOFFYES = DMA_TCD_NBYTES_SMLOE |
              DMA_TCD_NBYTES_MLOFFYES_MLOFF(-8) |
              DMA_TCD_NBYTES_MLOFFYES_NBYTES(8);
    1b5e:	ldr	r1, [pc, #192]	; (1c20 <acq_init(long)+0x180>)
          dma.TCD->SLAST = -8;
#endif
          dma.TCD->DADDR = tdm_rx_buffer;
          dma.TCD->DOFF = 4;
          dma.TCD->CITER_ELINKNO = NBUF_I2S;
          dma.TCD->DLASTSGA = -sizeof(tdm_rx_buffer);
    1b60:	ldr	r6, [pc, #192]	; (1c24 <acq_init(long)+0x184>)
          dma.TCD->SADDR = &I2S0_RDR0;
          dma.TCD->SOFF = 4;
          dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
          dma.TCD->NBYTES_MLOFFYES = DMA_TCD_NBYTES_SMLOE |
              DMA_TCD_NBYTES_MLOFFYES_MLOFF(-8) |
              DMA_TCD_NBYTES_MLOFFYES_NBYTES(8);
    1b62:	str	r1, [r3, #8]
          dma.TCD->SLAST = -8;
    1b64:	mvn.w	r7, #7
    1b68:	str	r7, [r3, #12]
#endif
          dma.TCD->DADDR = tdm_rx_buffer;
          dma.TCD->DOFF = 4;
          dma.TCD->CITER_ELINKNO = NBUF_I2S;
          dma.TCD->DLASTSGA = -sizeof(tdm_rx_buffer);
    1b6a:	str	r6, [r3, #24]
              DMA_TCD_NBYTES_MLOFFYES_NBYTES(8);
          dma.TCD->SLAST = -8;
#endif
          dma.TCD->DADDR = tdm_rx_buffer;
          dma.TCD->DOFF = 4;
          dma.TCD->CITER_ELINKNO = NBUF_I2S;
    1b6c:	mov.w	r1, #512	; 0x200
          dma.TCD->DLASTSGA = -sizeof(tdm_rx_buffer);
          dma.TCD->BITER_ELINKNO = NBUF_I2S;
          dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
    1b70:	movs	r7, #6
		*mux = 0;
		*mux = (source & 63) | DMAMUX_ENABLE;
    1b72:	movs	r6, #140	; 0x8c
              DMA_TCD_NBYTES_MLOFFYES_NBYTES(8);
          dma.TCD->SLAST = -8;
#endif
          dma.TCD->DADDR = tdm_rx_buffer;
          dma.TCD->DOFF = 4;
          dma.TCD->CITER_ELINKNO = NBUF_I2S;
    1b74:	strh	r1, [r3, #22]
              DMA_TCD_NBYTES_MLOFFYES_MLOFF(-8) |
              DMA_TCD_NBYTES_MLOFFYES_NBYTES(8);
          dma.TCD->SLAST = -8;
#endif
          dma.TCD->DADDR = tdm_rx_buffer;
          dma.TCD->DOFF = 4;
    1b76:	strh	r0, [r3, #20]
          dma.TCD->CITER_ELINKNO = NBUF_I2S;
          dma.TCD->DLASTSGA = -sizeof(tdm_rx_buffer);
          dma.TCD->BITER_ELINKNO = NBUF_I2S;
    1b78:	strh	r1, [r3, #30]
          dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
    1b7a:	strh	r7, [r3, #28]

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint8_t *mux;
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
		*mux = 0;
    1b7c:	strb	r5, [r2, #0]
		*mux = (source & 63) | DMAMUX_ENABLE;
    1b7e:	strb	r6, [r2, #0]
    1b80:	ldrb	r2, [r4, #4]
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
    1b82:	ldr	r3, [pc, #164]	; (1c28 <acq_init(long)+0x188>)
          dma.triggerAtHardwareEvent(DMAMUX_SOURCE_I2S0_RX);
          dma.enable();

          I2S0_RCSR = I2S_RCSR_RE | I2S_RCSR_BCE | I2S_RCSR_FRDE | I2S_RCSR_FR;
    1b84:	ldr	r6, [pc, #80]	; (1bd8 <acq_init(long)+0x138>)
    1b86:	strb	r2, [r3, #0]
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void attachInterrupt(void (*isr)(void), uint8_t prio) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
    1b88:	asrs	r3, r2, #5
    1b8a:	lsls	r3, r3, #2
    1b8c:	add.w	r3, r3, #3758096384	; 0xe0000000
    1b90:	add.w	r3, r3, #57600	; 0xe100
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void attachInterrupt(void (*isr)(void), uint8_t prio) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
    1b94:	add.w	r5, r2, #16
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
    1b98:	movs	r1, #1
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void attachInterrupt(void (*isr)(void), uint8_t prio) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
    1b9a:	ldr	r0, [pc, #144]	; (1c2c <acq_init(long)+0x18c>)
    1b9c:	ldr	r7, [pc, #144]	; (1c30 <acq_init(long)+0x190>)
    1b9e:	str	r7, [r6, #0]
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
    1ba0:	and.w	r2, r2, #31
    1ba4:	lsl.w	r2, r1, r2
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void attachInterrupt(void (*isr)(void), uint8_t prio) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
    1ba8:	ldr	r1, [pc, #136]	; (1c34 <acq_init(long)+0x194>)
    1baa:	str.w	r1, [r0, r5, lsl #2]
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
    1bae:	str	r2, [r3, #0]
		NVIC_SET_PRIORITY(IRQ_DMA_CH0 + channel, prio);
    1bb0:	ldrb	r3, [r4, #4]
    1bb2:	add.w	r3, r3, #3758096384	; 0xe0000000
    1bb6:	add.w	r3, r3, #58368	; 0xe400
    1bba:	movs	r2, #96	; 0x60
    1bbc:	strb	r2, [r3, #0]
    1bbe:	pop	{r3, r4, r5, r6, r7, pc}
    1bc0:	.word	0x00016e36
    1bc4:	.word	0x000142f4
    1bc8:	.word	0x1fff0ad0
    1bcc:	.word	0x4004b020
    1bd0:	.word	0x4004b024
    1bd4:	.word	0x4004b028
    1bd8:	.word	0x4002f080
    1bdc:	.word	0x4004803c
    1be0:	.word	0x40048040
    1be4:	.word	0x4002f104
    1be8:	.word	0x4002f100
    1bec:	.word	0x4002f084
    1bf0:	.word	0x1fff14b0
    1bf4:	.word	0x4002f094
    1bf8:	.word	0x4002f088
    1bfc:	.word	0x4002f090
    1c00:	.word	0x03000003
    1c04:	.word	0x1f1f1f00
    1c08:	.word	0x00010019
    1c0c:	.word	0x4004b02c
    1c10:	.word	0x4004b014
    1c14:	.word	0x4002f08c
    1c18:	.word	0x4002f0a0
    1c1c:	.word	0x1fff1bc8
    1c20:	.word	0xbfffe008
    1c24:	.word	0xfffff000
    1c28:	.word	0x4000801b
    1c2c:	.word	0x1fff0200
    1c30:	.word	0x92000001
    1c34:	.word	0x00001419
    1c38:	.word	0x4002f0e0

00001c3c <setup>:

#include "TimeLib.h"
void printTimestamp(uint32_t tt);

void setup()
{ while(!Serial && millis()<3000); 
    1c3c:	push	{r4, r5, r6, lr}
    1c3e:	ldr	r1, [pc, #140]	; (1ccc <setup+0x90>)
    1c40:	ldr	r2, [pc, #140]	; (1cd0 <setup+0x94>)
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
    1c42:	ldr	r4, [pc, #144]	; (1cd4 <setup+0x98>)
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
    1c44:	ldr	r6, [pc, #144]	; (1cd8 <setup+0x9c>)
    1c46:	sub	sp, #8
    1c48:	movw	r0, #2999	; 0xbb7
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
    1c4c:	ldrb	r3, [r1, #0]
    1c4e:	cmp	r3, #0
    1c50:	beq.n	1cbe <setup+0x82>
    1c52:	ldrb	r3, [r4, #0]
    1c54:	lsls	r3, r3, #31
    1c56:	bpl.n	1cbe <setup+0x82>
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
    1c58:	ldr	r3, [r2, #0]
    1c5a:	ldr	r5, [r6, #0]
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
    1c5c:	subs	r3, r3, r5
    1c5e:	cmp	r3, #14
    1c60:	bls.n	1cbe <setup+0x82>
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    1c62:	movs	r1, #10
    1c64:	ldr	r0, [pc, #116]	; (1cdc <setup+0xa0>)
    1c66:	bl	d6b8 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    1c6a:	ldr	r0, [pc, #116]	; (1ce0 <setup+0xa4>)
    1c6c:	bl	eedc <Print::println()>
  Serial.println("MTP logger");
  setSyncProvider(rtc_get);
    1c70:	ldr	r0, [pc, #112]	; (1ce4 <setup+0xa8>)
    1c72:	bl	8184 <setSyncProvider(long (*)())>

  printTimestamp(rtc_get());
    1c76:	bl	de40 <rtc_get>
    1c7a:	bl	15f4 <printTimestamp(unsigned long)>

  #if USE_EVENTS==1
    usb_init_events();
    1c7e:	bl	76e0 <usb_init_events>
  #endif

  #if !__has_include("usb_mtp.h")
    usb_mtp_configure();
  #endif
  storage_configure();
    1c82:	bl	1040 <storage_configure()>

  #if USE_SD==1
  // Set Time callback // needed for SDFat
  FsDateTime::callback = dateTime;
    1c86:	ldr	r3, [pc, #96]	; (1ce8 <setup+0xac>)
    1c88:	ldr	r2, [pc, #96]	; (1cec <setup+0xb0>)
  #endif

  acq_init(93750); // is fixed for this example, to be modified below
    1c8a:	ldr	r0, [pc, #100]	; (1cf0 <setup+0xb4>)
  #endif
  storage_configure();

  #if USE_SD==1
  // Set Time callback // needed for SDFat
  FsDateTime::callback = dateTime;
    1c8c:	str	r2, [r3, #0]
  #endif

  acq_init(93750); // is fixed for this example, to be modified below
    1c8e:	bl	1aa0 <acq_init(long)>
  state=-1;
    1c92:	ldr	r3, [pc, #96]	; (1cf4 <setup+0xb8>)
    1c94:	ldr	r0, [pc, #96]	; (1cf8 <setup+0xbc>)
    1c96:	movw	r2, #65535	; 0xffff
    1c9a:	movs	r1, #10
    1c9c:	strh	r2, [r3, #0]
    1c9e:	bl	d6b8 <usb_serial_write>
    1ca2:	ldr	r0, [pc, #60]	; (1ce0 <setup+0xa4>)
    1ca4:	bl	eedc <Print::println()>
    1ca8:	movs	r1, #67	; 0x43
    1caa:	ldr	r0, [pc, #80]	; (1cfc <setup+0xc0>)
    1cac:	bl	d6b8 <usb_serial_write>
    1cb0:	ldr	r0, [pc, #44]	; (1ce0 <setup+0xa4>)
    1cb2:	bl	eedc <Print::println()>
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    1cb6:	bl	d820 <usb_serial_flush_output>

  Serial.println("Setup done");
  Serial.println(" Enter 's' to start, 'q' to stop acquisition and 'r' to restart MTP");
  Serial.flush();
}
    1cba:	add	sp, #8
    1cbc:	pop	{r4, r5, r6, pc}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1cbe:	ldr	r3, [r2, #0]
    1cc0:	str	r3, [sp, #4]
	return ret;
    1cc2:	ldr	r3, [sp, #4]

#include "TimeLib.h"
void printTimestamp(uint32_t tt);

void setup()
{ while(!Serial && millis()<3000); 
    1cc4:	cmp	r3, r0
    1cc6:	bls.n	1c4c <setup+0x10>
    1cc8:	b.n	1c62 <setup+0x26>
    1cca:	nop
    1ccc:	.word	0x1fff67b4
    1cd0:	.word	0x1fff66b0
    1cd4:	.word	0x1fff66ac
    1cd8:	.word	0x1fff6830
    1cdc:	.word	0x000142fc
    1ce0:	.word	0x1fff0ad0
    1ce4:	.word	0x0000de41
    1ce8:	.word	0x1fff6188
    1cec:	.word	0x000006f1
    1cf0:	.word	0x00016e36
    1cf4:	.word	0x1fff1bc6
    1cf8:	.word	0x00014308
    1cfc:	.word	0x00014314

00001d00 <_GLOBAL__sub_I__Z17usb_mtp_configurev>:
    if(state>3)
    { // stop acquisition
      acq_stop();
    }
    return state;
  }
    1d00:	push	{r3, r4, r5, r6, r7, lr}


class SDClass : public FS
{
public:
	SDClass() { }
    1d02:	ldr	r3, [pc, #272]	; (1e14 <_GLOBAL__sub_I__Z17usb_mtp_configurev+0x114>)
    1d04:	ldr	r1, [pc, #272]	; (1e18 <_GLOBAL__sub_I__Z17usb_mtp_configurev+0x118>)
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    1d06:	ldr	r7, [pc, #276]	; (1e1c <_GLOBAL__sub_I__Z17usb_mtp_configurev+0x11c>)
  return state;
}

/************ Basic File System Interface *************************/
#include "SD.h"
extern SDClass sdx[];
    1d08:	ldr	r6, [pc, #276]	; (1e20 <_GLOBAL__sub_I__Z17usb_mtp_configurev+0x120>)
    1d0a:	str	r1, [r3, #0]
    1d0c:	str.w	r1, [r3, #1208]	; 0x4b8
    1d10:	str.w	r7, [r3, #1172]	; 0x494
#else  // HAS_SDIO_CLASS
class SdSpiCard {
#endif  // HAS_SDIO_CLASS
 public:
  /** Construct an instance of SdSpiCard. */
  SdSpiCard() {}
    1d14:	ldr	r1, [pc, #268]	; (1e24 <_GLOBAL__sub_I__Z17usb_mtp_configurev+0x124>)
    1d16:	str.w	r7, [r3, #2380]	; 0x94c
		}
		if (dataMode & 0x04) {
			c |= SPI_CTAR_CPHA;
			t = (t & 0xFFFF0FFF) | ((t & 0xF000) >> 4);
		}
		ctar = c | t;
    1d1a:	ldr	r7, [pc, #268]	; (1e28 <_GLOBAL__sub_I__Z17usb_mtp_configurev+0x128>)
    1d1c:	str.w	r1, [r3, #1184]	; 0x4a0
 * \class FsVolume
 * \brief FsVolume class.
 */
class FsVolume {
 public:
  FsVolume() {}
    1d20:	movs	r4, #0
    1d22:	str.w	r1, [r3, #2392]	; 0x958
    1d26:	str.w	r7, [r3, #1192]	; 0x4a8
    1d2a:	movs	r1, #1
    1d2c:	str.w	r7, [r3, #2400]	; 0x960
    1d30:	movs	r7, #41	; 0x29

class mSD_Base
{
  public:
    mSD_Base() {
      fsCount = 0;
    1d32:	ldr	r5, [pc, #248]	; (1e2c <_GLOBAL__sub_I__Z17usb_mtp_configurev+0x12c>)
    1d34:	str.w	r4, [r3, #1156]	; 0x484
    1d38:	mov	r2, r6
    1d3a:	str.w	r4, [r3, #1160]	; 0x488
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    1d3e:	strb.w	r4, [r3, #1180]	; 0x49c
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    1d42:	strb.w	r4, [r3, #1181]	; 0x49d
    1d46:	strb.w	r4, [r3, #1206]	; 0x4b6
    1d4a:	str.w	r4, [r3, #2364]	; 0x93c
    1d4e:	str.w	r4, [r3, #2368]	; 0x940
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    1d52:	strb.w	r4, [r3, #2388]	; 0x954
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    1d56:	strb.w	r4, [r3, #2389]	; 0x955
    1d5a:	strb.w	r4, [r3, #2414]	; 0x96e
    1d5e:	strb.w	r1, [r3, #1201]	; 0x4b1
    1d62:	strb.w	r1, [r3, #2409]	; 0x969
    1d66:	strb.w	r7, [r3, #1203]	; 0x4b3
    1d6a:	strb.w	r7, [r3, #2411]	; 0x96b
    1d6e:	mov	r0, r4
    1d70:	ldr	r1, [pc, #188]	; (1e30 <_GLOBAL__sub_I__Z17usb_mtp_configurev+0x130>)
    1d72:	bl	f0e0 <__aeabi_atexit>

  void mtp_yield(void);


// Storage implementation for SD. SD needs to be already initialized.
class MTPStorage_SD : public MTPStorageInterface, mSD_Base
    1d76:	mvn.w	r7, #1
    1d7a:	ldr	r0, [pc, #184]	; (1e34 <_GLOBAL__sub_I__Z17usb_mtp_configurev+0x134>)
    1d7c:	ldr	r3, [pc, #184]	; (1e38 <_GLOBAL__sub_I__Z17usb_mtp_configurev+0x138>)
    1d7e:	str	r0, [r5, #0]
  const int nfs = sizeof(lfs_size)/sizeof(int);

  LittleFS_RAM ramfs[nfs]; // needs to be declared if LittleFS is used in storage.h
#endif

MTPStorage_SD storage;
    1d80:	mov	r2, r6
    1d82:	str.w	r7, [r5, #240]	; 0xf0
    1d86:	ldr	r1, [pc, #180]	; (1e3c <_GLOBAL__sub_I__Z17usb_mtp_configurev+0x13c>)
    1d88:	str.w	r3, [r5, #168]	; 0xa8
    1d8c:	mov.w	r7, #1000	; 0x3e8
    1d90:	mov	r0, r5
    1d92:	str.w	r7, [r5, #176]	; 0xb0
    1d96:	str.w	r7, [r5, #196]	; 0xc4
    1d9a:	str.w	r7, [r5, #216]	; 0xd8
    1d9e:	str.w	r3, [r5, #188]	; 0xbc
    1da2:	str.w	r3, [r5, #208]	; 0xd0
	/*************************************************/
	/**    Channel Allocation                       **/
	/*************************************************/

	DMAChannel() {
		begin();
    1da6:	ldr	r7, [pc, #152]	; (1e40 <_GLOBAL__sub_I__Z17usb_mtp_configurev+0x140>)

class mSD_Base
{
  public:
    mSD_Base() {
      fsCount = 0;
    1da8:	str	r4, [r5, #4]
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
    1daa:	strb.w	r4, [r5, #172]	; 0xac
    1dae:	strb.w	r4, [r5, #180]	; 0xb4
    1db2:	str.w	r4, [r5, #184]	; 0xb8
    1db6:	strb.w	r4, [r5, #192]	; 0xc0
    1dba:	strb.w	r4, [r5, #200]	; 0xc8
    1dbe:	str.w	r4, [r5, #204]	; 0xcc
    1dc2:	strb.w	r4, [r5, #212]	; 0xd4
    1dc6:	strb.w	r4, [r5, #220]	; 0xdc
    1dca:	str.w	r4, [r5, #224]	; 0xe0

  void mtp_yield(void);


// Storage implementation for SD. SD needs to be already initialized.
class MTPStorage_SD : public MTPStorageInterface, mSD_Base
    1dce:	str.w	r4, [r5, #228]	; 0xe4
    1dd2:	str.w	r4, [r5, #232]	; 0xe8
    1dd6:	str.w	r4, [r5, #236]	; 0xec
    1dda:	str.w	r4, [r5, #244]	; 0xf4
    1dde:	strb.w	r4, [r5, #248]	; 0xf8
    1de2:	strb.w	r4, [r5, #249]	; 0xf9
    1de6:	bl	f0e0 <__aeabi_atexit>

// MTP Responder.
class MTPD {
public:

  explicit MTPD(MTPStorageInterface* storage): storage_(storage) {}
    1dea:	ldr	r3, [pc, #88]	; (1e44 <_GLOBAL__sub_I__Z17usb_mtp_configurev+0x144>)
}

/************ Basic File System Interface *************************/
#include "SD.h"
extern SDClass sdx[];
static File mfile;
    1dec:	ldr	r1, [pc, #88]	; (1e48 <_GLOBAL__sub_I__Z17usb_mtp_configurev+0x148>)
    1dee:	ldr	r0, [pc, #92]	; (1e4c <_GLOBAL__sub_I__Z17usb_mtp_configurev+0x14c>)
    1df0:	str	r5, [r3, #0]
    1df2:	mov	r2, r6
    1df4:	str	r4, [r3, #4]
    1df6:	strb	r4, [r3, #8]
    1df8:	str	r4, [r3, #12]
    1dfa:	bl	f0e0 <__aeabi_atexit>
    1dfe:	mov	r1, r4
    1e00:	mov	r0, r7
    1e02:	bl	ecb0 <DMAChannel::begin(bool)>
  static uint32_t tdm_rx_buffer[2*NBUF_I2S];
  static uint32_t acq_rx_buffer[NBUF_ACQ];
  #define I2S_DMA_PRIO 6

  #include "DMAChannel.h"
  DMAChannel dma;
    1e06:	mov	r2, r6
    1e08:	mov	r0, r7
    1e0a:	ldr	r1, [pc, #68]	; (1e50 <_GLOBAL__sub_I__Z17usb_mtp_configurev+0x150>)
    if(state>3)
    { // stop acquisition
      acq_stop();
    }
    return state;
  }
    1e0c:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  static uint32_t tdm_rx_buffer[2*NBUF_I2S];
  static uint32_t acq_rx_buffer[NBUF_ACQ];
  #define I2S_DMA_PRIO 6

  #include "DMAChannel.h"
  DMAChannel dma;
    1e10:	b.w	f0e0 <__aeabi_atexit>
    1e14:	.word	0x1fff2bc8
    1e18:	.word	0x0001419c
    1e1c:	.word	0x000146dc
    1e20:	.word	0x1fff0938
    1e24:	.word	0x00014684
    1e28:	.word	0x38011001
    1e2c:	.word	0x1fff1ac0
    1e30:	.word	0x000005d5
    1e34:	.word	0x0001436c
    1e38:	.word	0x000140dc
    1e3c:	.word	0x00000f6d
    1e40:	.word	0x1fff14b0
    1e44:	.word	0x1fff6138
    1e48:	.word	0x00000eb1
    1e4c:	.word	0x1fff0948
    1e50:	.word	0x00000789

00001e54 <MTPStorage_SD::addFilesystem(FS&, char const*)>:
    mSD_Base() {
      fsCount = 0;
    }

    void sd_addFilesystem(FS &fs, const char *name) {
      if (fsCount < MTPD_MAX_FILESYSTEMS) {
    1e54:	ldr	r3, [r0, #4]
    1e56:	cmp	r3, #19
    1e58:	bgt.n	1e6c <MTPStorage_SD::addFilesystem(FS&, char const*)+0x18>

// Storage implementation for SD. SD needs to be already initialized.
class MTPStorage_SD : public MTPStorageInterface, mSD_Base
{ 
public:
  void addFilesystem(FS &fs, const char *name) { sd_addFilesystem(fs, name);}
    1e5a:	push	{r4}
    1e5c:	add.w	r4, r0, r3, lsl #2
    }

    void sd_addFilesystem(FS &fs, const char *name) {
      if (fsCount < MTPD_MAX_FILESYSTEMS) {
        sd_name[fsCount] = name;
        sdx[fsCount++] = &fs;
    1e60:	adds	r3, #1
      fsCount = 0;
    }

    void sd_addFilesystem(FS &fs, const char *name) {
      if (fsCount < MTPD_MAX_FILESYSTEMS) {
        sd_name[fsCount] = name;
    1e62:	str	r2, [r4, #8]
        sdx[fsCount++] = &fs;
    1e64:	str	r3, [r0, #4]
    1e66:	str	r1, [r4, #88]	; 0x58

// Storage implementation for SD. SD needs to be already initialized.
class MTPStorage_SD : public MTPStorageInterface, mSD_Base
{ 
public:
  void addFilesystem(FS &fs, const char *name) { sd_addFilesystem(fs, name);}
    1e68:	ldr.w	r4, [sp], #4
    1e6c:	bx	lr
    1e6e:	nop

00001e70 <MTPStorage_SD::get_FSCount()>:
  Record ReadIndexRecord(uint32_t i) ;
  uint16_t ConstructFilename(int i, char* out, int len) ;
  void OpenFileByIndex(uint32_t i, uint32_t mode = FILE_READ) ;
  void printRecord(int h, Record *p);

  uint32_t get_FSCount(void) {return sd_getFSCount();}
    1e70:	ldr	r0, [r0, #4]
    1e72:	bx	lr

00001e74 <MTPStorage_SD::get_FSName(unsigned long)>:
      for(int ii=0; ii<fsCount;ii++) if(!strcmp(name,sd_name[ii])) return ii;
      return 0xFFFFFFFFUL;
    }

    uint32_t sd_getFSCount(void) {return fsCount;}
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}
    1e74:	add.w	r1, r0, r1, lsl #2
  uint16_t ConstructFilename(int i, char* out, int len) ;
  void OpenFileByIndex(uint32_t i, uint32_t mode = FILE_READ) ;
  void printRecord(int h, Record *p);

  uint32_t get_FSCount(void) {return sd_getFSCount();}
  const char *get_FSName(uint32_t storage) { return sd_getFSName(storage);}
    1e78:	ldr	r0, [r1, #8]
    1e7a:	bx	lr

00001e7c <MTPStorage_SD::readonly(unsigned long)>:

// These should probably be weak.
void mtp_yield() {}
void mtp_lock_storage(bool lock) {}

  bool MTPStorage_SD::readonly(uint32_t store) { return false; }
    1e7c:	movs	r0, #0
    1e7e:	bx	lr

00001e80 <MTPStorage_SD::has_directories(unsigned long)>:
  bool MTPStorage_SD::has_directories(uint32_t store) { return true; }
    1e80:	movs	r0, #1
    1e82:	bx	lr

00001e84 <MTPStorage_SD::totalSize(unsigned long)>:
    bool sd_mkdir(uint32_t store, char *filename) {  return sdx[store]->mkdir(filename);  }
    bool sd_rename(uint32_t store, char *oldfilename, char *newfilename) { return sdx[store]->rename(oldfilename,newfilename);  }
    bool sd_remove(uint32_t store, const char *filename) {    Serial.println(filename); return sdx[store]->remove(filename);  }
    bool sd_rmdir(uint32_t store, char *filename) { return sdx[store]->rmdir(filename);  }

    uint64_t sd_totalSize(uint32_t store) { return sdx[store]->totalSize();  }
    1e84:	add.w	r1, r0, r1, lsl #2
    1e88:	ldr	r0, [r1, #88]	; 0x58
    1e8a:	ldr	r3, [r0, #0]
    1e8c:	ldr	r3, [r3, #28]
    1e8e:	bx	r3

00001e90 <MTPStorage_SD::usedSize(unsigned long)>:
    uint64_t sd_usedSize(uint32_t store)  { return sdx[store]->usedSize();  }
    1e90:	add.w	r1, r0, r1, lsl #2
    1e94:	ldr	r0, [r1, #88]	; 0x58
    1e96:	ldr	r3, [r0, #0]
    1e98:	ldr	r3, [r3, #24]
    1e9a:	bx	r3

00001e9c <MTPStorage_SD::write(char const*, unsigned long)>:
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
	}
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
    1e9c:	ldr.w	r0, [r0, #204]	; 0xcc
    1ea0:	cmp	r0, #0
    1ea2:	beq.n	1f0a <MTPStorage_SD::write(char const*, unsigned long)+0x6e>
    #endif
    return ret;
  }

  size_t MTPStorage_SD::write(const char* data, uint32_t bytes)
  {
    1ea4:	push	{r4, r5, r6}
    1ea6:	ldr	r4, [r0, #0]
    1ea8:	ldr	r3, [pc, #108]	; (1f18 <MTPStorage_SD::write(char const*, unsigned long)+0x7c>)
    1eaa:	ldr	r4, [r4, #44]	; 0x2c
    1eac:	cmp	r4, r3
    1eae:	bne.n	1f04 <MTPStorage_SD::write(char const*, unsigned long)+0x68>
    1eb0:	ldr	r0, [r0, #16]
    1eb2:	cbz	r0, 1efe <MTPStorage_SD::write(char const*, unsigned long)+0x62>
    1eb4:	ldr	r4, [r0, #0]
    1eb6:	ldr	r4, [r4, #44]	; 0x2c
    1eb8:	cmp	r4, r3
    1eba:	bne.n	1f04 <MTPStorage_SD::write(char const*, unsigned long)+0x68>
    1ebc:	ldr	r0, [r0, #16]
    1ebe:	cbz	r0, 1efe <MTPStorage_SD::write(char const*, unsigned long)+0x62>
    1ec0:	ldr	r4, [r0, #0]
    1ec2:	ldr	r4, [r4, #44]	; 0x2c
    1ec4:	cmp	r4, r3
    1ec6:	bne.n	1f04 <MTPStorage_SD::write(char const*, unsigned long)+0x68>
    1ec8:	ldr	r0, [r0, #16]
    1eca:	cbz	r0, 1efe <MTPStorage_SD::write(char const*, unsigned long)+0x62>
    1ecc:	ldr	r4, [r0, #0]
    1ece:	ldr	r4, [r4, #44]	; 0x2c
    1ed0:	cmp	r4, r3
    1ed2:	bne.n	1f04 <MTPStorage_SD::write(char const*, unsigned long)+0x68>
    1ed4:	ldr	r0, [r0, #16]
    1ed6:	cbz	r0, 1efe <MTPStorage_SD::write(char const*, unsigned long)+0x62>
    1ed8:	mov	r6, r2
    1eda:	ldr	r2, [r0, #0]
    1edc:	ldr	r4, [r2, #44]	; 0x2c
    1ede:	cmp	r4, r3
    1ee0:	mov	r5, r1
    1ee2:	bne.n	1f0e <MTPStorage_SD::write(char const*, unsigned long)+0x72>
    1ee4:	ldr	r0, [r0, #16]
    1ee6:	cbz	r0, 1efe <MTPStorage_SD::write(char const*, unsigned long)+0x62>
    1ee8:	ldr	r2, [r0, #0]
    1eea:	ldr	r4, [r2, #44]	; 0x2c
    1eec:	cmp	r4, r3
    1eee:	bne.n	1f0e <MTPStorage_SD::write(char const*, unsigned long)+0x72>
    1ef0:	ldr	r0, [r0, #16]
    1ef2:	cbz	r0, 1efe <MTPStorage_SD::write(char const*, unsigned long)+0x62>
    1ef4:	ldr	r3, [r0, #0]
    1ef6:	mov	r2, r6
    1ef8:	ldr	r3, [r3, #44]	; 0x2c
      mtp_lock_storage(true);
      size_t ret = file_.write(data,bytes);
      mtp_lock_storage(false);
      return ret;
  }
    1efa:	pop	{r4, r5, r6}
    1efc:	bx	r3
    1efe:	movs	r0, #0
    1f00:	pop	{r4, r5, r6}
    1f02:	bx	lr
    1f04:	mov	r3, r4
    1f06:	pop	{r4, r5, r6}
    1f08:	bx	r3
    1f0a:	movs	r0, #0
    1f0c:	bx	lr
    1f0e:	mov	r2, r6
    1f10:	mov	r1, r5
    1f12:	mov	r3, r4
    1f14:	pop	{r4, r5, r6}
    1f16:	bx	r3
    1f18:	.word	0x00000489

00001f1c <MTPStorage_SD::ResetIndex()>:
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    1f1c:	ldr.w	r3, [r0, #184]	; 0xb8
    1f20:	cmp	r3, #0
    1f22:	beq.n	1f8c <MTPStorage_SD::ResetIndex()+0x70>
    1f24:	ldr	r2, [r3, #0]
    1f26:	ldr	r1, [pc, #108]	; (1f94 <MTPStorage_SD::ResetIndex()+0x78>)
    1f28:	ldr	r2, [r2, #68]	; 0x44
    1f2a:	cmp	r2, r1
    index_=sd_open(0,indexFile, FILE_WRITE_BEGIN);
    if(!index_) Serial.println("cannot open Index file"); 
    mtp_lock_storage(false);
  }

  void MTPStorage_SD::ResetIndex() {
    1f2c:	push	{r4, lr}
    1f2e:	mov	r4, r0
    1f30:	bne.n	1f86 <MTPStorage_SD::ResetIndex()+0x6a>
    1f32:	ldr	r0, [r3, #16]
    1f34:	cbz	r0, 1f84 <MTPStorage_SD::ResetIndex()+0x68>
    1f36:	ldr	r3, [r0, #0]
    1f38:	ldr	r3, [r3, #68]	; 0x44
    1f3a:	cmp	r3, r2
    1f3c:	bne.n	1f8e <MTPStorage_SD::ResetIndex()+0x72>
    1f3e:	ldr	r0, [r0, #16]
    1f40:	cbz	r0, 1f84 <MTPStorage_SD::ResetIndex()+0x68>
    1f42:	ldr	r2, [r0, #0]
    1f44:	ldr	r2, [r2, #68]	; 0x44
    1f46:	cmp	r2, r3
    1f48:	bne.n	1f88 <MTPStorage_SD::ResetIndex()+0x6c>
    1f4a:	ldr	r0, [r0, #16]
    1f4c:	cbz	r0, 1f84 <MTPStorage_SD::ResetIndex()+0x68>
    1f4e:	ldr	r3, [r0, #0]
    1f50:	ldr	r3, [r3, #68]	; 0x44
    1f52:	cmp	r3, r2
    1f54:	bne.n	1f8e <MTPStorage_SD::ResetIndex()+0x72>
    1f56:	ldr	r0, [r0, #16]
    1f58:	cbz	r0, 1f84 <MTPStorage_SD::ResetIndex()+0x68>
    1f5a:	ldr	r2, [r0, #0]
    1f5c:	ldr	r2, [r2, #68]	; 0x44
    1f5e:	cmp	r2, r3
    1f60:	bne.n	1f88 <MTPStorage_SD::ResetIndex()+0x6c>
    1f62:	ldr	r0, [r0, #16]
    1f64:	cbz	r0, 1f84 <MTPStorage_SD::ResetIndex()+0x68>
    1f66:	ldr	r3, [r0, #0]
    1f68:	ldr	r3, [r3, #68]	; 0x44
    1f6a:	blx	r3
    if(!sd_isOpen(index_)) return;
    1f6c:	cbz	r0, 1f84 <MTPStorage_SD::ResetIndex()+0x68>
    CloseIndex();
    1f6e:	ldr	r3, [r4, #0]
    1f70:	mov	r0, r4
    1f72:	ldr	r3, [r3, #64]	; 0x40
    1f74:	blx	r3
//    OpenIndex();

    all_scanned_ = false;
    1f76:	movs	r2, #0
    open_file_ = 0xFFFFFFFEUL;
    1f78:	mvn.w	r3, #1
  void MTPStorage_SD::ResetIndex() {
    if(!sd_isOpen(index_)) return;
    CloseIndex();
//    OpenIndex();

    all_scanned_ = false;
    1f7c:	strb.w	r2, [r4, #249]	; 0xf9
    open_file_ = 0xFFFFFFFEUL;
    1f80:	str.w	r3, [r4, #240]	; 0xf0
    1f84:	pop	{r4, pc}
    1f86:	mov	r0, r3
    1f88:	blx	r2
    1f8a:	b.n	1f6c <MTPStorage_SD::ResetIndex()+0x50>
    1f8c:	bx	lr
    1f8e:	blx	r3
    1f90:	b.n	1f6c <MTPStorage_SD::ResetIndex()+0x50>
    1f92:	nop
    1f94:	.word	0x0000050d

00001f98 <MTPStorage_SD::CloseIndex()>:

  uint64_t MTPStorage_SD::totalSize(uint32_t store) { return sd_totalSize(store); }
  uint64_t MTPStorage_SD::usedSize(uint32_t store) { return sd_usedSize(store); }

  void MTPStorage_SD::CloseIndex()
  {
    1f98:	push	{r4, lr}
    1f9a:	mov	r4, r0
    1f9c:	ldr.w	r0, [r0, #184]	; 0xb8
    1fa0:	cmp	r0, #0
    1fa2:	beq.n	2084 <MTPStorage_SD::CloseIndex()+0xec>
    1fa4:	ldr	r3, [r0, #0]
    1fa6:	ldr	r2, [pc, #256]	; (20a8 <MTPStorage_SD::CloseIndex()+0x110>)
    1fa8:	ldr	r3, [r3, #68]	; 0x44
    1faa:	cmp	r3, r2
    1fac:	bne.n	2090 <MTPStorage_SD::CloseIndex()+0xf8>
    1fae:	ldr	r0, [r0, #16]
    1fb0:	cmp	r0, #0
    1fb2:	beq.n	2084 <MTPStorage_SD::CloseIndex()+0xec>
    1fb4:	ldr	r2, [r0, #0]
    1fb6:	ldr	r2, [r2, #68]	; 0x44
    1fb8:	cmp	r2, r3
    1fba:	bne.n	20a2 <MTPStorage_SD::CloseIndex()+0x10a>
    1fbc:	ldr	r0, [r0, #16]
    1fbe:	cmp	r0, #0
    1fc0:	beq.n	2084 <MTPStorage_SD::CloseIndex()+0xec>
    1fc2:	ldr	r3, [r0, #0]
    1fc4:	ldr	r3, [r3, #68]	; 0x44
    1fc6:	cmp	r3, r2
    1fc8:	bne.n	2090 <MTPStorage_SD::CloseIndex()+0xf8>
    1fca:	ldr	r0, [r0, #16]
    1fcc:	cmp	r0, #0
    1fce:	beq.n	2084 <MTPStorage_SD::CloseIndex()+0xec>
    1fd0:	ldr	r2, [r0, #0]
    1fd2:	ldr	r2, [r2, #68]	; 0x44
    1fd4:	cmp	r2, r3
    1fd6:	bne.n	20a2 <MTPStorage_SD::CloseIndex()+0x10a>
    1fd8:	ldr	r0, [r0, #16]
    1fda:	cmp	r0, #0
    1fdc:	beq.n	2084 <MTPStorage_SD::CloseIndex()+0xec>
    1fde:	ldr	r3, [r0, #0]
    1fe0:	ldr	r3, [r3, #68]	; 0x44
    1fe2:	cmp	r3, r2
    1fe4:	bne.n	2090 <MTPStorage_SD::CloseIndex()+0xf8>
    1fe6:	ldr	r0, [r0, #16]
    1fe8:	cmp	r0, #0
    1fea:	beq.n	2084 <MTPStorage_SD::CloseIndex()+0xec>
    1fec:	ldr	r3, [r0, #0]
    1fee:	ldr	r3, [r3, #68]	; 0x44
    1ff0:	blx	r3
    mtp_lock_storage(true);
    if(sd_isOpen(index_)) index_.close();
    1ff2:	cmp	r0, #0
    1ff4:	beq.n	2084 <MTPStorage_SD::CloseIndex()+0xec>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    1ff6:	ldr.w	r0, [r4, #184]	; 0xb8
    1ffa:	cmp	r0, #0
    1ffc:	beq.n	2084 <MTPStorage_SD::CloseIndex()+0xec>
    1ffe:	ldr	r2, [r0, #0]
    2000:	ldr	r3, [pc, #168]	; (20ac <MTPStorage_SD::CloseIndex()+0x114>)
    2002:	ldr	r2, [r2, #64]	; 0x40
    2004:	cmp	r2, r3
    2006:	bne.n	2094 <MTPStorage_SD::CloseIndex()+0xfc>
    2008:	ldr	r0, [r0, #16]
    200a:	cmp	r0, #0
    200c:	beq.n	2084 <MTPStorage_SD::CloseIndex()+0xec>
    200e:	ldr	r2, [r0, #0]
    2010:	ldr	r2, [r2, #64]	; 0x40
    2012:	cmp	r2, r3
    2014:	bne.n	2094 <MTPStorage_SD::CloseIndex()+0xfc>
    2016:	ldr	r0, [r0, #16]
    2018:	cmp	r0, #0
    201a:	beq.n	2084 <MTPStorage_SD::CloseIndex()+0xec>
    201c:	ldr	r2, [r0, #0]
    201e:	ldr	r2, [r2, #64]	; 0x40
    2020:	cmp	r2, r3
    2022:	bne.n	2094 <MTPStorage_SD::CloseIndex()+0xfc>
    2024:	ldr	r0, [r0, #16]
    2026:	cmp	r0, #0
    2028:	beq.n	2084 <MTPStorage_SD::CloseIndex()+0xec>
    202a:	ldr	r2, [r0, #0]
    202c:	ldr	r2, [r2, #64]	; 0x40
    202e:	cmp	r2, r3
    2030:	bne.n	2094 <MTPStorage_SD::CloseIndex()+0xfc>
    2032:	ldr	r0, [r0, #16]
    2034:	cbz	r0, 2084 <MTPStorage_SD::CloseIndex()+0xec>
    2036:	ldr	r2, [r0, #0]
    2038:	ldr	r2, [r2, #64]	; 0x40
    203a:	cmp	r2, r3
    203c:	bne.n	2094 <MTPStorage_SD::CloseIndex()+0xfc>
    203e:	ldr	r0, [r0, #16]
    2040:	cbz	r0, 2084 <MTPStorage_SD::CloseIndex()+0xec>
    2042:	ldr	r2, [r0, #0]
    2044:	ldr	r2, [r2, #64]	; 0x40
    2046:	cmp	r2, r3
    2048:	bne.n	2094 <MTPStorage_SD::CloseIndex()+0xfc>
    204a:	ldr	r0, [r0, #16]
    204c:	cbz	r0, 2084 <MTPStorage_SD::CloseIndex()+0xec>
    204e:	ldr	r2, [r0, #0]
    2050:	ldr	r2, [r2, #64]	; 0x40
    2052:	cmp	r2, r3
    2054:	bne.n	2094 <MTPStorage_SD::CloseIndex()+0xfc>
    2056:	ldr	r0, [r0, #16]
    2058:	cbz	r0, 2084 <MTPStorage_SD::CloseIndex()+0xec>
    205a:	ldr	r2, [r0, #0]
    205c:	ldr	r2, [r2, #64]	; 0x40
    205e:	cmp	r2, r3
    2060:	bne.n	2094 <MTPStorage_SD::CloseIndex()+0xfc>
    2062:	ldr	r0, [r0, #16]
    2064:	cbz	r0, 2084 <MTPStorage_SD::CloseIndex()+0xec>
    2066:	ldr	r2, [r0, #0]
    2068:	ldr	r2, [r2, #64]	; 0x40
    206a:	cmp	r2, r3
    206c:	bne.n	2094 <MTPStorage_SD::CloseIndex()+0xfc>
    206e:	ldr	r0, [r0, #16]
    2070:	cbz	r0, 2084 <MTPStorage_SD::CloseIndex()+0xec>
    2072:	ldr	r2, [r0, #0]
    2074:	ldr	r2, [r2, #64]	; 0x40
    2076:	cmp	r2, r3
    2078:	bne.n	2094 <MTPStorage_SD::CloseIndex()+0xfc>
    207a:	ldr	r0, [r0, #16]
    207c:	cbz	r0, 2084 <MTPStorage_SD::CloseIndex()+0xec>
    207e:	ldr	r3, [r0, #0]
    2080:	ldr	r3, [r3, #64]	; 0x40
    2082:	blx	r3
    mtp_lock_storage(false);
    index_generated = false;
    2084:	movs	r3, #0
    2086:	strb.w	r3, [r4, #248]	; 0xf8
    index_entries_ = 0;
    208a:	str.w	r3, [r4, #244]	; 0xf4
    208e:	pop	{r4, pc}
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    2090:	blx	r3
    2092:	b.n	1ff2 <MTPStorage_SD::CloseIndex()+0x5a>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    2094:	blx	r2
  void MTPStorage_SD::CloseIndex()
  {
    mtp_lock_storage(true);
    if(sd_isOpen(index_)) index_.close();
    mtp_lock_storage(false);
    index_generated = false;
    2096:	movs	r3, #0
    2098:	strb.w	r3, [r4, #248]	; 0xf8
    index_entries_ = 0;
    209c:	str.w	r3, [r4, #244]	; 0xf4
    20a0:	pop	{r4, pc}
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    20a2:	blx	r2
    20a4:	b.n	1ff2 <MTPStorage_SD::CloseIndex()+0x5a>
    20a6:	nop
    20a8:	.word	0x0000050d
    20ac:	.word	0x00000501

000020b0 <File::invalidate() [clone .isra.1]>:
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    20b0:	ldr	r2, [r0, #0]
    20b2:	cmp	r2, #0
    20b4:	beq.n	2130 <File::invalidate() [clone .isra.1]+0x80>
    20b6:	ldr	r3, [r2, #16]
    20b8:	subs	r3, #1
    20ba:	str	r3, [r2, #16]
    20bc:	cmp	r3, #0
    20be:	bne.n	2130 <File::invalidate() [clone .isra.1]+0x80>
	}
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
    20c0:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		if (f && --(f->refcount) == 0) delete f;
    20c4:	ldr	r4, [r0, #0]
    20c6:	cmp	r4, #0
    20c8:	beq.n	2132 <File::invalidate() [clone .isra.1]+0x82>
    20ca:	ldr	r3, [r4, #0]
    20cc:	ldr	r1, [pc, #120]	; (2148 <File::invalidate() [clone .isra.1]+0x98>)
    20ce:	ldr	r3, [r3, #32]
    20d0:	cmp	r3, r1
    20d2:	bne.n	2136 <File::invalidate() [clone .isra.1]+0x86>
    20d4:	ldr	r2, [r4, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    20d6:	ldr	r6, [pc, #116]	; (214c <File::invalidate() [clone .isra.1]+0x9c>)
    20d8:	str	r6, [r4, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    20da:	cbz	r2, 2124 <File::invalidate() [clone .isra.1]+0x74>
    20dc:	ldr	r3, [r2, #16]
    20de:	subs	r3, #1
    20e0:	str	r3, [r2, #16]
    20e2:	cbnz	r3, 2124 <File::invalidate() [clone .isra.1]+0x74>
    20e4:	ldr	r5, [r4, #16]
    20e6:	cbz	r5, 2124 <File::invalidate() [clone .isra.1]+0x74>
    20e8:	ldr	r3, [r5, #0]
    20ea:	ldr	r3, [r3, #32]
    20ec:	cmp	r3, r1
    20ee:	bne.n	213e <File::invalidate() [clone .isra.1]+0x8e>
    20f0:	ldr	r2, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    20f2:	str	r6, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    20f4:	cbz	r2, 211c <File::invalidate() [clone .isra.1]+0x6c>
    20f6:	ldr	r3, [r2, #16]
    20f8:	subs	r3, #1
    20fa:	str	r3, [r2, #16]
    20fc:	cbnz	r3, 211c <File::invalidate() [clone .isra.1]+0x6c>
    20fe:	ldr	r7, [r5, #16]
    2100:	cbz	r7, 211c <File::invalidate() [clone .isra.1]+0x6c>
    2102:	ldr	r3, [r7, #0]
    2104:	ldr	r3, [r3, #32]
    2106:	cmp	r3, r1
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2108:	mov	r0, r7
    210a:	bne.n	2144 <File::invalidate() [clone .isra.1]+0x94>
    210c:	str.w	r6, [r0], #16
		invalidate();
    2110:	bl	20b0 <File::invalidate() [clone .isra.1]>
	}
    2114:	mov	r0, r7
    2116:	movs	r1, #20
    2118:	bl	effc <operator delete(void*, unsigned int)>
    211c:	mov	r0, r5
    211e:	movs	r1, #20
    2120:	bl	effc <operator delete(void*, unsigned int)>
    2124:	mov	r0, r4
    2126:	movs	r1, #20
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
	}
    2128:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    212c:	b.w	effc <operator delete(void*, unsigned int)>
    2130:	bx	lr
    2132:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2136:	mov	r0, r4
	}
    2138:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    213c:	bx	r3
    213e:	mov	r0, r5
    2140:	blx	r3
    2142:	b.n	2124 <File::invalidate() [clone .isra.1]+0x74>
    2144:	blx	r3
    2146:	b.n	211c <File::invalidate() [clone .isra.1]+0x6c>
    2148:	.word	0x00000f3d
    214c:	.word	0x000140dc

00002150 <mtp_yield()>:
//   support serialflash
//   partial object fetch/receive
//   events (notify usb host when local storage changes) (But, this seems too difficult)

// These should probably be weak.
void mtp_yield() {}
    2150:	bx	lr
    2152:	nop

00002154 <MTPStorage_SD::OpenIndex()>:
    index_generated = false;
    index_entries_ = 0;
  }

  void MTPStorage_SD::OpenIndex() 
  { if(sd_isOpen(index_)) return; // only once
    2154:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    2158:	mov	r4, r0
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    215a:	ldr.w	r0, [r0, #184]	; 0xb8
    215e:	sub	sp, #28
    2160:	cbz	r0, 21b4 <MTPStorage_SD::OpenIndex()+0x60>
    2162:	ldr	r3, [r0, #0]
    2164:	ldr	r2, [pc, #536]	; (2380 <MTPStorage_SD::OpenIndex()+0x22c>)
    2166:	ldr	r3, [r3, #68]	; 0x44
    2168:	cmp	r3, r2
    216a:	bne.w	2484 <MTPStorage_SD::OpenIndex()+0x330>
    216e:	ldr	r0, [r0, #16]
    2170:	cbz	r0, 21b4 <MTPStorage_SD::OpenIndex()+0x60>
    2172:	ldr	r2, [r0, #0]
    2174:	ldr	r2, [r2, #68]	; 0x44
    2176:	cmp	r2, r3
    2178:	bne.w	2498 <MTPStorage_SD::OpenIndex()+0x344>
    217c:	ldr	r0, [r0, #16]
    217e:	cbz	r0, 21b4 <MTPStorage_SD::OpenIndex()+0x60>
    2180:	ldr	r3, [r0, #0]
    2182:	ldr	r3, [r3, #68]	; 0x44
    2184:	cmp	r3, r2
    2186:	bne.w	2484 <MTPStorage_SD::OpenIndex()+0x330>
    218a:	ldr	r0, [r0, #16]
    218c:	cbz	r0, 21b4 <MTPStorage_SD::OpenIndex()+0x60>
    218e:	ldr	r2, [r0, #0]
    2190:	ldr	r2, [r2, #68]	; 0x44
    2192:	cmp	r2, r3
    2194:	bne.w	2498 <MTPStorage_SD::OpenIndex()+0x344>
    2198:	ldr	r0, [r0, #16]
    219a:	cbz	r0, 21b4 <MTPStorage_SD::OpenIndex()+0x60>
    219c:	ldr	r3, [r0, #0]
    219e:	ldr	r3, [r3, #68]	; 0x44
    21a0:	cmp	r3, r2
    21a2:	bne.w	2484 <MTPStorage_SD::OpenIndex()+0x330>
    21a6:	ldr	r0, [r0, #16]
    21a8:	cbz	r0, 21b4 <MTPStorage_SD::OpenIndex()+0x60>
    21aa:	ldr	r3, [r0, #0]
    21ac:	ldr	r3, [r3, #68]	; 0x44
    21ae:	blx	r3
    21b0:	cmp	r0, #0
    21b2:	bne.n	2288 <MTPStorage_SD::OpenIndex()+0x134>
    }

    uint32_t sd_getFSCount(void) {return fsCount;}
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}

    File sd_open(uint32_t store, const char *filename, uint32_t mode) { return sdx[store]->open(filename,mode);  }
    21b4:	ldr	r1, [r4, #88]	; 0x58
    21b6:	ldr	r2, [pc, #460]	; (2384 <MTPStorage_SD::OpenIndex()+0x230>)
    21b8:	ldr	r3, [r1, #0]
    21ba:	add	r0, sp, #4
    21bc:	ldr	r5, [r3, #0]
    21be:	movs	r3, #2
    21c0:	blx	r5
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    21c2:	ldr.w	r3, [r4, #184]	; 0xb8
    21c6:	cbz	r3, 21d4 <MTPStorage_SD::OpenIndex()+0x80>
    21c8:	ldr	r2, [r3, #16]
    21ca:	subs	r2, #1
    21cc:	str	r2, [r3, #16]
    21ce:	cmp	r2, #0
    21d0:	beq.w	2398 <MTPStorage_SD::OpenIndex()+0x244>
	File& operator = (const File &file) {
		//Serial.println("File assignment");
		//static int assigncount=0;
		//if (++assigncount > 20) while (1) ;
		invalidate();
		f = file.f;
    21d4:	ldr	r3, [sp, #20]
    21d6:	str.w	r3, [r4, #184]	; 0xb8
		if (f) f->refcount++;
    21da:	cbz	r3, 21f4 <MTPStorage_SD::OpenIndex()+0xa0>
    21dc:	ldr	r2, [r3, #16]
		return *this;
	}
	virtual ~File() {
    21de:	ldr	r1, [pc, #424]	; (2388 <MTPStorage_SD::OpenIndex()+0x234>)
    21e0:	str	r1, [sp, #4]
		//Serial.println("File assignment");
		//static int assigncount=0;
		//if (++assigncount > 20) while (1) ;
		invalidate();
		f = file.f;
		if (f) f->refcount++;
    21e2:	adds	r2, #1
    21e4:	str	r2, [r3, #16]
    21e6:	ldr	r2, [sp, #20]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    21e8:	cbz	r2, 21f4 <MTPStorage_SD::OpenIndex()+0xa0>
    21ea:	ldr	r3, [r2, #16]
    21ec:	subs	r3, #1
    21ee:	str	r3, [r2, #16]
    21f0:	cmp	r3, #0
    21f2:	beq.n	228e <MTPStorage_SD::OpenIndex()+0x13a>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    21f4:	ldr.w	r0, [r4, #184]	; 0xb8
    21f8:	cmp	r0, #0
    21fa:	beq.n	227a <MTPStorage_SD::OpenIndex()+0x126>
    21fc:	ldr	r2, [r0, #0]
    21fe:	ldr	r3, [pc, #384]	; (2380 <MTPStorage_SD::OpenIndex()+0x22c>)
    2200:	ldr	r2, [r2, #68]	; 0x44
    2202:	cmp	r2, r3
    2204:	bne.w	248e <MTPStorage_SD::OpenIndex()+0x33a>
    2208:	ldr	r0, [r0, #16]
    220a:	cmp	r0, #0
    220c:	beq.n	227a <MTPStorage_SD::OpenIndex()+0x126>
    220e:	ldr	r2, [r0, #0]
    2210:	ldr	r2, [r2, #68]	; 0x44
    2212:	cmp	r2, r3
    2214:	bne.w	248e <MTPStorage_SD::OpenIndex()+0x33a>
    2218:	ldr	r0, [r0, #16]
    221a:	cmp	r0, #0
    221c:	beq.n	227a <MTPStorage_SD::OpenIndex()+0x126>
    221e:	ldr	r2, [r0, #0]
    2220:	ldr	r2, [r2, #68]	; 0x44
    2222:	cmp	r2, r3
    2224:	bne.w	248e <MTPStorage_SD::OpenIndex()+0x33a>
    2228:	ldr	r0, [r0, #16]
    222a:	cbz	r0, 227a <MTPStorage_SD::OpenIndex()+0x126>
    222c:	ldr	r2, [r0, #0]
    222e:	ldr	r2, [r2, #68]	; 0x44
    2230:	cmp	r2, r3
    2232:	bne.w	248e <MTPStorage_SD::OpenIndex()+0x33a>
    2236:	ldr	r0, [r0, #16]
    2238:	cbz	r0, 227a <MTPStorage_SD::OpenIndex()+0x126>
    223a:	ldr	r2, [r0, #0]
    223c:	ldr	r2, [r2, #68]	; 0x44
    223e:	cmp	r2, r3
    2240:	bne.w	248e <MTPStorage_SD::OpenIndex()+0x33a>
    2244:	ldr	r0, [r0, #16]
    2246:	cbz	r0, 227a <MTPStorage_SD::OpenIndex()+0x126>
    2248:	ldr	r2, [r0, #0]
    224a:	ldr	r2, [r2, #68]	; 0x44
    224c:	cmp	r2, r3
    224e:	bne.w	248e <MTPStorage_SD::OpenIndex()+0x33a>
    2252:	ldr	r0, [r0, #16]
    2254:	cbz	r0, 227a <MTPStorage_SD::OpenIndex()+0x126>
    2256:	ldr	r2, [r0, #0]
    2258:	ldr	r2, [r2, #68]	; 0x44
    225a:	cmp	r2, r3
    225c:	bne.w	248e <MTPStorage_SD::OpenIndex()+0x33a>
    2260:	ldr	r0, [r0, #16]
    2262:	cbz	r0, 227a <MTPStorage_SD::OpenIndex()+0x126>
    2264:	ldr	r2, [r0, #0]
    2266:	ldr	r2, [r2, #68]	; 0x44
    2268:	cmp	r2, r3
    226a:	bne.w	248e <MTPStorage_SD::OpenIndex()+0x33a>
    226e:	ldr	r0, [r0, #16]
    2270:	cbz	r0, 227a <MTPStorage_SD::OpenIndex()+0x126>
    2272:	ldr	r3, [r0, #0]
    2274:	ldr	r3, [r3, #68]	; 0x44
    2276:	blx	r3
    mtp_lock_storage(true);
    index_=sd_open(0,indexFile, FILE_WRITE_BEGIN);
    if(!index_) Serial.println("cannot open Index file"); 
    2278:	cbnz	r0, 2288 <MTPStorage_SD::OpenIndex()+0x134>
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    227a:	movs	r1, #22
    227c:	ldr	r0, [pc, #268]	; (238c <MTPStorage_SD::OpenIndex()+0x238>)
    227e:	bl	d6b8 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    2282:	ldr	r0, [pc, #268]	; (2390 <MTPStorage_SD::OpenIndex()+0x23c>)
    2284:	bl	eedc <Print::println()>
    mtp_lock_storage(false);
  }
    2288:	add	sp, #28
    228a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    228e:	ldr	r5, [sp, #20]
    2290:	cmp	r5, #0
    2292:	beq.n	21f4 <MTPStorage_SD::OpenIndex()+0xa0>
    2294:	ldr	r2, [r5, #0]
    2296:	ldr	r3, [pc, #252]	; (2394 <MTPStorage_SD::OpenIndex()+0x240>)
    2298:	ldr	r2, [r2, #32]
    229a:	cmp	r2, r3
    229c:	bne.w	24a8 <MTPStorage_SD::OpenIndex()+0x354>
    22a0:	ldr	r0, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    22a2:	str	r1, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    22a4:	cmp	r0, #0
    22a6:	beq.n	2376 <MTPStorage_SD::OpenIndex()+0x222>
    22a8:	ldr	r2, [r0, #16]
    22aa:	subs	r2, #1
    22ac:	str	r2, [r0, #16]
    22ae:	cmp	r2, #0
    22b0:	bne.n	2376 <MTPStorage_SD::OpenIndex()+0x222>
    22b2:	ldr	r6, [r5, #16]
    22b4:	cmp	r6, #0
    22b6:	beq.n	2376 <MTPStorage_SD::OpenIndex()+0x222>
    22b8:	ldr	r2, [r6, #0]
    22ba:	ldr	r2, [r2, #32]
    22bc:	cmp	r2, r3
    22be:	bne.w	24ae <MTPStorage_SD::OpenIndex()+0x35a>
    22c2:	ldr	r0, [r6, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    22c4:	str	r1, [r6, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    22c6:	cmp	r0, #0
    22c8:	beq.n	236e <MTPStorage_SD::OpenIndex()+0x21a>
    22ca:	ldr	r2, [r0, #16]
    22cc:	subs	r2, #1
    22ce:	str	r2, [r0, #16]
    22d0:	cmp	r2, #0
    22d2:	bne.n	236e <MTPStorage_SD::OpenIndex()+0x21a>
    22d4:	ldr	r7, [r6, #16]
    22d6:	cmp	r7, #0
    22d8:	beq.n	236e <MTPStorage_SD::OpenIndex()+0x21a>
    22da:	ldr	r2, [r7, #0]
    22dc:	ldr	r2, [r2, #32]
    22de:	cmp	r2, r3
    22e0:	bne.w	24c0 <MTPStorage_SD::OpenIndex()+0x36c>
    22e4:	ldr	r0, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    22e6:	str	r1, [r7, #0]
    22e8:	ldr.w	lr, [pc, #156]	; 2388 <MTPStorage_SD::OpenIndex()+0x234>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    22ec:	cmp	r0, #0
    22ee:	beq.n	2366 <MTPStorage_SD::OpenIndex()+0x212>
    22f0:	ldr	r2, [r0, #16]
    22f2:	subs	r2, #1
    22f4:	str	r2, [r0, #16]
    22f6:	cmp	r2, #0
    22f8:	bne.n	2366 <MTPStorage_SD::OpenIndex()+0x212>
    22fa:	ldr.w	r8, [r7, #16]
    22fe:	cmp.w	r8, #0
    2302:	beq.n	2366 <MTPStorage_SD::OpenIndex()+0x212>
    2304:	ldr.w	r2, [r8]
    2308:	ldr	r2, [r2, #32]
    230a:	cmp	r2, r3
    230c:	bne.w	24cc <MTPStorage_SD::OpenIndex()+0x378>
    2310:	ldr.w	r0, [r8, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2314:	str.w	lr, [r8]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2318:	cbz	r0, 235e <MTPStorage_SD::OpenIndex()+0x20a>
    231a:	ldr	r2, [r0, #16]
    231c:	subs	r2, #1
    231e:	str	r2, [r0, #16]
    2320:	cbnz	r2, 235e <MTPStorage_SD::OpenIndex()+0x20a>
    2322:	ldr.w	r9, [r8, #16]
    2326:	cmp.w	r9, #0
    232a:	beq.n	235e <MTPStorage_SD::OpenIndex()+0x20a>
    232c:	ldr.w	r2, [r9]
    2330:	ldr	r2, [r2, #32]
    2332:	cmp	r2, r3
    2334:	bne.w	24d8 <MTPStorage_SD::OpenIndex()+0x384>
    2338:	ldr.w	r2, [r9, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    233c:	str.w	r1, [r9]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2340:	cbz	r2, 2356 <MTPStorage_SD::OpenIndex()+0x202>
    2342:	ldr	r3, [r2, #16]
    2344:	subs	r3, #1
    2346:	str	r3, [r2, #16]
    2348:	cbnz	r3, 2356 <MTPStorage_SD::OpenIndex()+0x202>
    234a:	ldr.w	r0, [r9, #16]
    234e:	cbz	r0, 2356 <MTPStorage_SD::OpenIndex()+0x202>
    2350:	ldr	r3, [r0, #0]
    2352:	ldr	r3, [r3, #32]
    2354:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    2356:	mov	r0, r9
    2358:	movs	r1, #20
    235a:	bl	effc <operator delete(void*, unsigned int)>
    235e:	mov	r0, r8
    2360:	movs	r1, #20
    2362:	bl	effc <operator delete(void*, unsigned int)>
    2366:	mov	r0, r7
    2368:	movs	r1, #20
    236a:	bl	effc <operator delete(void*, unsigned int)>
    236e:	mov	r0, r6
    2370:	movs	r1, #20
    2372:	bl	effc <operator delete(void*, unsigned int)>
    2376:	mov	r0, r5
    2378:	movs	r1, #20
    237a:	bl	effc <operator delete(void*, unsigned int)>
    237e:	b.n	21f4 <MTPStorage_SD::OpenIndex()+0xa0>
    2380:	.word	0x0000050d
    2384:	.word	0x000143c4
    2388:	.word	0x000140dc
    238c:	.word	0x000143d4
    2390:	.word	0x1fff0ad0
    2394:	.word	0x00000f3d
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2398:	ldr.w	r5, [r4, #184]	; 0xb8
    239c:	cmp	r5, #0
    239e:	beq.w	21d4 <MTPStorage_SD::OpenIndex()+0x80>
    23a2:	ldr	r2, [r5, #0]
    23a4:	ldr	r3, [pc, #312]	; (24e0 <MTPStorage_SD::OpenIndex()+0x38c>)
    23a6:	ldr	r2, [r2, #32]
    23a8:	cmp	r2, r3
    23aa:	bne.n	24a2 <MTPStorage_SD::OpenIndex()+0x34e>
    23ac:	ldr	r0, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    23ae:	ldr	r1, [pc, #308]	; (24e4 <MTPStorage_SD::OpenIndex()+0x390>)
    23b0:	str	r1, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    23b2:	cmp	r0, #0
    23b4:	beq.n	247a <MTPStorage_SD::OpenIndex()+0x326>
    23b6:	ldr	r2, [r0, #16]
    23b8:	subs	r2, #1
    23ba:	str	r2, [r0, #16]
    23bc:	cmp	r2, #0
    23be:	bne.n	247a <MTPStorage_SD::OpenIndex()+0x326>
    23c0:	ldr	r6, [r5, #16]
    23c2:	cmp	r6, #0
    23c4:	beq.n	247a <MTPStorage_SD::OpenIndex()+0x326>
    23c6:	ldr	r2, [r6, #0]
    23c8:	ldr	r2, [r2, #32]
    23ca:	cmp	r2, r3
    23cc:	bne.n	24b4 <MTPStorage_SD::OpenIndex()+0x360>
    23ce:	ldr	r0, [r6, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    23d0:	str	r1, [r6, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    23d2:	cmp	r0, #0
    23d4:	beq.n	2472 <MTPStorage_SD::OpenIndex()+0x31e>
    23d6:	ldr	r2, [r0, #16]
    23d8:	subs	r2, #1
    23da:	str	r2, [r0, #16]
    23dc:	cmp	r2, #0
    23de:	bne.n	2472 <MTPStorage_SD::OpenIndex()+0x31e>
    23e0:	ldr	r7, [r6, #16]
    23e2:	cmp	r7, #0
    23e4:	beq.n	2472 <MTPStorage_SD::OpenIndex()+0x31e>
    23e6:	ldr	r2, [r7, #0]
    23e8:	ldr	r2, [r2, #32]
    23ea:	cmp	r2, r3
    23ec:	bne.n	24ba <MTPStorage_SD::OpenIndex()+0x366>
    23ee:	ldr	r0, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    23f0:	str	r1, [r7, #0]
    23f2:	ldr.w	lr, [pc, #240]	; 24e4 <MTPStorage_SD::OpenIndex()+0x390>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    23f6:	cmp	r0, #0
    23f8:	beq.n	246a <MTPStorage_SD::OpenIndex()+0x316>
    23fa:	ldr	r2, [r0, #16]
    23fc:	subs	r2, #1
    23fe:	str	r2, [r0, #16]
    2400:	cbnz	r2, 246a <MTPStorage_SD::OpenIndex()+0x316>
    2402:	ldr.w	r8, [r7, #16]
    2406:	cmp.w	r8, #0
    240a:	beq.n	246a <MTPStorage_SD::OpenIndex()+0x316>
    240c:	ldr.w	r2, [r8]
    2410:	ldr	r2, [r2, #32]
    2412:	cmp	r2, r3
    2414:	bne.n	24c6 <MTPStorage_SD::OpenIndex()+0x372>
    2416:	ldr.w	r0, [r8, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    241a:	str.w	lr, [r8]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    241e:	cbz	r0, 2462 <MTPStorage_SD::OpenIndex()+0x30e>
    2420:	ldr	r2, [r0, #16]
    2422:	subs	r2, #1
    2424:	str	r2, [r0, #16]
    2426:	cbnz	r2, 2462 <MTPStorage_SD::OpenIndex()+0x30e>
    2428:	ldr.w	r9, [r8, #16]
    242c:	cmp.w	r9, #0
    2430:	beq.n	2462 <MTPStorage_SD::OpenIndex()+0x30e>
    2432:	ldr.w	r2, [r9]
    2436:	ldr	r2, [r2, #32]
    2438:	cmp	r2, r3
    243a:	bne.n	24d2 <MTPStorage_SD::OpenIndex()+0x37e>
    243c:	ldr.w	r2, [r9, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2440:	str.w	r1, [r9]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2444:	cbz	r2, 245a <MTPStorage_SD::OpenIndex()+0x306>
    2446:	ldr	r3, [r2, #16]
    2448:	subs	r3, #1
    244a:	str	r3, [r2, #16]
    244c:	cbnz	r3, 245a <MTPStorage_SD::OpenIndex()+0x306>
    244e:	ldr.w	r0, [r9, #16]
    2452:	cbz	r0, 245a <MTPStorage_SD::OpenIndex()+0x306>
    2454:	ldr	r3, [r0, #0]
    2456:	ldr	r3, [r3, #32]
    2458:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    245a:	mov	r0, r9
    245c:	movs	r1, #20
    245e:	bl	effc <operator delete(void*, unsigned int)>
    2462:	mov	r0, r8
    2464:	movs	r1, #20
    2466:	bl	effc <operator delete(void*, unsigned int)>
    246a:	mov	r0, r7
    246c:	movs	r1, #20
    246e:	bl	effc <operator delete(void*, unsigned int)>
    2472:	mov	r0, r6
    2474:	movs	r1, #20
    2476:	bl	effc <operator delete(void*, unsigned int)>
    247a:	mov	r0, r5
    247c:	movs	r1, #20
    247e:	bl	effc <operator delete(void*, unsigned int)>
    2482:	b.n	21d4 <MTPStorage_SD::OpenIndex()+0x80>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    2484:	blx	r3
    index_generated = false;
    index_entries_ = 0;
  }

  void MTPStorage_SD::OpenIndex() 
  { if(sd_isOpen(index_)) return; // only once
    2486:	cmp	r0, #0
    2488:	bne.w	2288 <MTPStorage_SD::OpenIndex()+0x134>
    248c:	b.n	21b4 <MTPStorage_SD::OpenIndex()+0x60>
    248e:	blx	r2
    mtp_lock_storage(true);
    index_=sd_open(0,indexFile, FILE_WRITE_BEGIN);
    if(!index_) Serial.println("cannot open Index file"); 
    2490:	cmp	r0, #0
    2492:	bne.w	2288 <MTPStorage_SD::OpenIndex()+0x134>
    2496:	b.n	227a <MTPStorage_SD::OpenIndex()+0x126>
    2498:	blx	r2
    index_generated = false;
    index_entries_ = 0;
  }

  void MTPStorage_SD::OpenIndex() 
  { if(sd_isOpen(index_)) return; // only once
    249a:	cmp	r0, #0
    249c:	bne.w	2288 <MTPStorage_SD::OpenIndex()+0x134>
    24a0:	b.n	21b4 <MTPStorage_SD::OpenIndex()+0x60>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    24a2:	mov	r0, r5
    24a4:	blx	r2
    24a6:	b.n	21d4 <MTPStorage_SD::OpenIndex()+0x80>
    24a8:	mov	r0, r5
    24aa:	blx	r2
    24ac:	b.n	21f4 <MTPStorage_SD::OpenIndex()+0xa0>
    24ae:	mov	r0, r6
    24b0:	blx	r2
    24b2:	b.n	2376 <MTPStorage_SD::OpenIndex()+0x222>
    24b4:	mov	r0, r6
    24b6:	blx	r2
    24b8:	b.n	247a <MTPStorage_SD::OpenIndex()+0x326>
    24ba:	mov	r0, r7
    24bc:	blx	r2
    24be:	b.n	2472 <MTPStorage_SD::OpenIndex()+0x31e>
    24c0:	mov	r0, r7
    24c2:	blx	r2
    24c4:	b.n	236e <MTPStorage_SD::OpenIndex()+0x21a>
    24c6:	mov	r0, r8
    24c8:	blx	r2
    24ca:	b.n	246a <MTPStorage_SD::OpenIndex()+0x316>
    24cc:	mov	r0, r8
    24ce:	blx	r2
    24d0:	b.n	2366 <MTPStorage_SD::OpenIndex()+0x212>
    24d2:	mov	r0, r9
    24d4:	blx	r2
    24d6:	b.n	2462 <MTPStorage_SD::OpenIndex()+0x30e>
    24d8:	mov	r0, r9
    24da:	blx	r2
    24dc:	b.n	235e <MTPStorage_SD::OpenIndex()+0x20a>
    24de:	nop
    24e0:	.word	0x00000f3d
    24e4:	.word	0x000140dc

000024e8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>:
    all_scanned_ = false;
    open_file_ = 0xFFFFFFFEUL;
  }

  void MTPStorage_SD::WriteIndexRecord(uint32_t i, const Record& r) 
  { OpenIndex();
    24e8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    24ec:	mov	r6, r0
    24ee:	sub	sp, #12
    24f0:	mov	r4, r1
    24f2:	mov	r7, r2
    24f4:	bl	2154 <MTPStorage_SD::OpenIndex()>
	}
	virtual bool truncate(uint64_t size=0) {
		return (f) ? f->truncate(size) : false;
	}
	virtual bool seek(uint64_t pos, int mode) {
		return (f) ? f->seek(pos, mode) : false;
    24f8:	ldr.w	r5, [r6, #184]	; 0xb8
    mtp_lock_storage(true);
    index_.seek((sizeof(r) * i));
    24fc:	add.w	r4, r4, r4, lsl #4
    2500:	cmp	r5, #0
    2502:	beq.n	25da <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf2>
    2504:	ldr	r0, [r5, #0]
    2506:	ldr	r1, [pc, #308]	; (263c <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x154>)
    2508:	lsls	r2, r4, #4
    250a:	ldr	r4, [r0, #52]	; 0x34
    250c:	cmp	r4, r1
    250e:	mov.w	ip, #0
    2512:	bne.n	2602 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x11a>
    2514:	ldr	r1, [r5, #16]
    2516:	cmp	r1, #0
    2518:	beq.n	25d2 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xea>
    251a:	ldr	r3, [r1, #0]
    251c:	ldr.w	r8, [r3, #52]	; 0x34
    2520:	cmp	r8, r4
    2522:	bne.n	260e <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x126>
    2524:	ldr.w	lr, [r1, #16]
    2528:	cmp.w	lr, #0
    252c:	beq.n	25e0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf8>
    252e:	ldr.w	r4, [lr]
    2532:	ldr	r4, [r4, #52]	; 0x34
    2534:	cmp	r4, r8
    2536:	bne.n	261a <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x132>
    2538:	ldr.w	lr, [lr, #16]
    253c:	cmp.w	lr, #0
    2540:	beq.n	25e0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf8>
    2542:	ldr.w	r3, [lr]
    2546:	ldr.w	r8, [r3, #52]	; 0x34
    254a:	cmp	r8, r4
    254c:	bne.n	2626 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x13e>
    254e:	ldr.w	r4, [lr, #16]
    2552:	cmp	r4, #0
    2554:	beq.n	25e0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf8>
    2556:	ldr	r3, [r4, #0]
    2558:	ldr.w	r9, [r3, #52]	; 0x34
    255c:	cmp	r9, r8
    255e:	bne.n	2632 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x14a>
    2560:	ldr	r4, [r4, #16]
    2562:	cmp	r4, #0
    2564:	beq.n	25e0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf8>
    2566:	ldr	r1, [r4, #0]
    2568:	str.w	ip, [sp]
    256c:	mov	r3, ip
    256e:	mov	r0, r4
    2570:	ldr	r1, [r1, #52]	; 0x34
    2572:	blx	r1
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
	}
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
    2574:	ldr.w	r5, [r6, #184]	; 0xb8
    2578:	cmp	r5, #0
    257a:	beq.n	25da <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf2>
    257c:	ldr	r2, [r5, #0]
    257e:	ldr	r3, [pc, #192]	; (2640 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x158>)
    2580:	ldr	r4, [r2, #44]	; 0x2c
    2582:	cmp	r4, r3
    2584:	bne.n	25ec <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x104>
    2586:	ldr	r0, [r5, #16]
    2588:	cbz	r0, 25da <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf2>
    258a:	ldr	r2, [r0, #0]
    258c:	ldr	r4, [r2, #44]	; 0x2c
    258e:	cmp	r4, r3
    2590:	bne.n	25fe <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x116>
    2592:	ldr	r0, [r0, #16]
    2594:	cbz	r0, 25da <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf2>
    2596:	ldr	r2, [r0, #0]
    2598:	ldr	r4, [r2, #44]	; 0x2c
    259a:	cmp	r4, r3
    259c:	bne.n	25fe <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x116>
    259e:	ldr	r0, [r0, #16]
    25a0:	cbz	r0, 25da <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf2>
    25a2:	ldr	r2, [r0, #0]
    25a4:	ldr	r4, [r2, #44]	; 0x2c
    25a6:	cmp	r4, r3
    25a8:	bne.n	25fe <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x116>
    25aa:	ldr	r0, [r0, #16]
    25ac:	cbz	r0, 25da <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf2>
    25ae:	ldr	r2, [r0, #0]
    25b0:	ldr	r4, [r2, #44]	; 0x2c
    25b2:	cmp	r4, r3
    25b4:	bne.n	25fe <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x116>
    25b6:	ldr	r0, [r0, #16]
    25b8:	cbz	r0, 25da <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf2>
    25ba:	ldr	r2, [r0, #0]
    25bc:	ldr	r4, [r2, #44]	; 0x2c
    25be:	cmp	r4, r3
    25c0:	bne.n	25fe <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x116>
    25c2:	ldr	r0, [r0, #16]
    25c4:	cbz	r0, 25da <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xf2>
    25c6:	ldr	r3, [r0, #0]
    25c8:	mov	r1, r7
    25ca:	ldr	r3, [r3, #44]	; 0x2c
    25cc:	mov.w	r2, #272	; 0x110
    25d0:	b.n	25f6 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x10e>
    25d2:	ldr	r4, [r0, #44]	; 0x2c
    25d4:	ldr	r3, [pc, #104]	; (2640 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x158>)
    25d6:	cmp	r4, r3
    25d8:	bne.n	25ec <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x104>
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }
    25da:	add	sp, #12
    25dc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    25e0:	ldr	r4, [r0, #44]	; 0x2c
    25e2:	ldr	r3, [pc, #92]	; (2640 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x158>)
    25e4:	cmp	r4, r3
    25e6:	bne.n	25ec <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x104>
    25e8:	mov	r0, r1
    25ea:	b.n	258a <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0xa2>
    25ec:	mov	r1, r7
    25ee:	mov	r0, r5
    25f0:	mov.w	r2, #272	; 0x110
    25f4:	mov	r3, r4
    25f6:	add	sp, #12
    25f8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    25fc:	bx	r3
    25fe:	mov	r1, r7
    2600:	b.n	25f0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x108>
	}
	virtual bool truncate(uint64_t size=0) {
		return (f) ? f->truncate(size) : false;
	}
	virtual bool seek(uint64_t pos, int mode) {
		return (f) ? f->seek(pos, mode) : false;
    2602:	str.w	ip, [sp]
    2606:	mov	r3, ip
    2608:	mov	r0, r5
    260a:	blx	r4
    260c:	b.n	2574 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x8c>
    260e:	str.w	ip, [sp]
    2612:	mov	r3, ip
    2614:	mov	r0, r1
    2616:	blx	r8
    2618:	b.n	2574 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x8c>
    261a:	str.w	ip, [sp]
    261e:	mov	r3, ip
    2620:	mov	r0, lr
    2622:	blx	r4
    2624:	b.n	2574 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x8c>
    2626:	str.w	ip, [sp]
    262a:	mov	r3, ip
    262c:	mov	r0, lr
    262e:	blx	r8
    2630:	b.n	2574 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x8c>
    2632:	movs	r3, #0
    2634:	mov	r0, r4
    2636:	str	r3, [sp, #0]
    2638:	blx	r9
    263a:	b.n	2574 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x8c>
    263c:	.word	0x000004c9
    2640:	.word	0x00000489

00002644 <MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]>:
  }

  // MTP object handles should not change or be re-used during a session.
  // This would be easy if we could just have a list of all files in memory.
  // Since our RAM is limited, we'll keep the index in a file instead.
  void MTPStorage_SD::GenerateIndex(uint32_t store)
    2644:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  { if (index_generated) return; 
    index_generated = true;
    2648:	movs	r7, #1
  }

  // MTP object handles should not change or be re-used during a session.
  // This would be easy if we could just have a list of all files in memory.
  // Since our RAM is limited, we'll keep the index in a file instead.
  void MTPStorage_SD::GenerateIndex(uint32_t store)
    264a:	mov	r4, r0
    264c:	sub	sp, #272	; 0x110
    264e:	movs	r1, #13
  { if (index_generated) return; 
    index_generated = true;
    2650:	strb.w	r7, [r0, #248]	; 0xf8
    2654:	ldr	r0, [pc, #104]	; (26c0 <MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]+0x7c>)
    2656:	bl	d6b8 <usb_serial_write>
    265a:	ldr	r0, [pc, #104]	; (26c4 <MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]+0x80>)
    265c:	bl	eedc <Print::println()>
    bool sd_mkdir(uint32_t store, char *filename) {  return sdx[store]->mkdir(filename);  }
    bool sd_rename(uint32_t store, char *oldfilename, char *newfilename) { return sdx[store]->rename(oldfilename,newfilename);  }
    bool sd_remove(uint32_t store, const char *filename) {    Serial.println(filename); return sdx[store]->remove(filename);  }
    2660:	ldr	r0, [r4, #88]	; 0x58
    2662:	ldr	r1, [pc, #92]	; (26c0 <MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]+0x7c>)
    2664:	ldr	r3, [r0, #0]
    2666:	ldr	r3, [r3, #16]
    2668:	blx	r3
    266a:	ldr	r3, [r4, #4]
    // first remove old index file
    mtp_lock_storage(true);
    sd_remove(0,indexFile);
    mtp_lock_storage(false);

    num_storage = sd_getFSCount();
    266c:	str.w	r3, [r4, #228]	; 0xe4

    index_entries_ = 0;
    2670:	movs	r1, #0
    Record r;
    for(int ii=0; ii<num_storage; ii++)
    2672:	cmp	r3, r1
    sd_remove(0,indexFile);
    mtp_lock_storage(false);

    num_storage = sd_getFSCount();

    index_entries_ = 0;
    2674:	str.w	r1, [r4, #244]	; 0xf4
    Record r;
    for(int ii=0; ii<num_storage; ii++)
    2678:	ble.n	26ba <MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]+0x76>
    267a:	mov	r5, r1
    {
      r.store = ii; // 
      r.parent = 0xFFFFFFFFUL; // 
      r.sibling = 0;
    267c:	mov	r6, r1
    index_entries_ = 0;
    Record r;
    for(int ii=0; ii<num_storage; ii++)
    {
      r.store = ii; // 
      r.parent = 0xFFFFFFFFUL; // 
    267e:	mov.w	r8, #4294967295
    2682:	b.n	2688 <MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]+0x44>
    2684:	ldr.w	r1, [r4, #244]	; 0xf4

    index_entries_ = 0;
    Record r;
    for(int ii=0; ii<num_storage; ii++)
    {
      r.store = ii; // 
    2688:	strh.w	r5, [sp, #14]
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    268c:	adds	r3, r1, #1
    268e:	str.w	r3, [r4, #244]	; 0xf4
    WriteIndexRecord(new_record, r);
    2692:	mov	r2, sp
      r.parent = 0xFFFFFFFFUL; // 
      r.sibling = 0;
      r.child = 0;
      r.isdir = true;
      r.scanned = false;
      strcpy(r.name, "/");
    2694:	movs	r3, #47	; 0x2f
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    WriteIndexRecord(new_record, r);
    2696:	mov	r0, r4
      r.parent = 0xFFFFFFFFUL; // 
      r.sibling = 0;
      r.child = 0;
      r.isdir = true;
      r.scanned = false;
      strcpy(r.name, "/");
    2698:	strh.w	r3, [sp, #16]
    index_entries_ = 0;
    Record r;
    for(int ii=0; ii<num_storage; ii++)
    {
      r.store = ii; // 
      r.parent = 0xFFFFFFFFUL; // 
    269c:	str.w	r8, [sp]
      r.sibling = 0;
    26a0:	str	r6, [sp, #8]
      r.child = 0;
    26a2:	str	r6, [sp, #4]
      r.isdir = true;
    26a4:	strb.w	r7, [sp, #12]
      r.scanned = false;
    26a8:	strb.w	r6, [sp, #13]
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    WriteIndexRecord(new_record, r);
    26ac:	bl	24e8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>

    num_storage = sd_getFSCount();

    index_entries_ = 0;
    Record r;
    for(int ii=0; ii<num_storage; ii++)
    26b0:	ldr.w	r3, [r4, #228]	; 0xe4
    26b4:	adds	r5, #1
    26b6:	cmp	r3, r5
    26b8:	bgt.n	2684 <MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]+0x40>
      r.isdir = true;
      r.scanned = false;
      strcpy(r.name, "/");
      AppendIndexRecord(r);
    }
  }
    26ba:	add	sp, #272	; 0x110
    26bc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    26c0:	.word	0x000143c4
    26c4:	.word	0x1fff0ad0

000026c8 <MTPStorage_SD::ReadIndexRecord(unsigned long)>:
    return new_record;
  }

  // TODO(hubbe): Cache a few records for speed.
  Record MTPStorage_SD::ReadIndexRecord(uint32_t i) 
  {
    26c8:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    26cc:	mov	r5, r1
    26ce:	mov	r4, r2
    26d0:	sub	sp, #8
    Record ret;
    memset(&ret, 0, sizeof(ret));
    26d2:	movs	r1, #0
    26d4:	mov.w	r2, #272	; 0x110
    return new_record;
  }

  // TODO(hubbe): Cache a few records for speed.
  Record MTPStorage_SD::ReadIndexRecord(uint32_t i) 
  {
    26d8:	mov	r6, r0
    Record ret;
    memset(&ret, 0, sizeof(ret));
    26da:	bl	1059c <memset>
    if (i > index_entries_) 
    26de:	ldr.w	r3, [r5, #244]	; 0xf4
    26e2:	cmp	r3, r4
    26e4:	bcc.w	285e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x196>
    { memset(&ret, 0, sizeof(ret));
      return ret;
    }
    OpenIndex();
    26e8:	mov	r0, r5
    26ea:	bl	2154 <MTPStorage_SD::OpenIndex()>
    26ee:	ldr.w	r0, [r5, #184]	; 0xb8
    mtp_lock_storage(true);
    index_.seek(sizeof(ret) * i);
    26f2:	add.w	r4, r4, r4, lsl #4
    26f6:	lsls	r2, r4, #4
    26f8:	mov.w	ip, #0
    26fc:	cmp	r0, #0
    26fe:	beq.w	2856 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    2702:	ldr	r7, [r0, #0]
    2704:	ldr	r4, [pc, #456]	; (28d0 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x208>)
    2706:	ldr	r1, [r7, #52]	; 0x34
    2708:	cmp	r1, r4
    270a:	bne.w	288a <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1c2>
    270e:	ldr	r1, [r0, #16]
    2710:	cmp	r1, #0
    2712:	beq.w	2872 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1aa>
    2716:	ldr	r3, [r1, #0]
    2718:	ldr.w	r8, [r3, #52]	; 0x34
    271c:	cmp	r8, r4
    271e:	bne.w	28b8 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1f0>
    2722:	ldr.w	lr, [r1, #16]
    2726:	cmp.w	lr, #0
    272a:	beq.n	27de <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x116>
    272c:	ldr.w	r3, [lr]
    2730:	ldr.w	r8, [r3, #52]	; 0x34
    2734:	cmp	r8, r4
    2736:	bne.w	28ac <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1e4>
    273a:	ldr.w	lr, [lr, #16]
    273e:	cmp.w	lr, #0
    2742:	beq.n	27de <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x116>
    2744:	ldr.w	r3, [lr]
    2748:	ldr.w	r8, [r3, #52]	; 0x34
    274c:	cmp	r8, r4
    274e:	bne.w	28ac <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1e4>
    2752:	ldr.w	lr, [lr, #16]
    2756:	cmp.w	lr, #0
    275a:	beq.n	27de <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x116>
    275c:	ldr.w	r3, [lr]
    2760:	ldr.w	r8, [r3, #52]	; 0x34
    2764:	cmp	r8, r4
    2766:	bne.w	28c4 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1fc>
    276a:	ldr.w	lr, [lr, #16]
    276e:	cmp.w	lr, #0
    2772:	beq.n	27de <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x116>
    2774:	ldr.w	r3, [lr]
    2778:	ldr.w	r8, [r3, #52]	; 0x34
    277c:	cmp	r8, r4
    277e:	bne.w	28c4 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1fc>
    2782:	ldr.w	lr, [lr, #16]
    2786:	cmp.w	lr, #0
    278a:	beq.n	27de <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x116>
    278c:	ldr.w	r3, [lr]
    2790:	ldr.w	r8, [r3, #52]	; 0x34
    2794:	cmp	r8, r4
    2796:	bne.w	28c4 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1fc>
    279a:	ldr.w	lr, [lr, #16]
    279e:	cmp.w	lr, #0
    27a2:	beq.n	27de <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x116>
    27a4:	ldr.w	r3, [lr]
    27a8:	ldr.w	r8, [r3, #52]	; 0x34
    27ac:	cmp	r8, r4
    27ae:	bne.w	28c4 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1fc>
    27b2:	ldr.w	lr, [lr, #16]
    27b6:	cmp.w	lr, #0
    27ba:	beq.n	27de <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x116>
    27bc:	ldr.w	r3, [lr]
    27c0:	ldr.w	r8, [r3, #52]	; 0x34
    27c4:	cmp	r8, r4
    27c6:	bne.n	28c4 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1fc>
    27c8:	ldr.w	r4, [lr, #16]
    27cc:	cbz	r4, 27de <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x116>
    27ce:	ldr	r1, [r4, #0]
    27d0:	str.w	ip, [sp]
    27d4:	mov	r3, ip
    27d6:	mov	r0, r4
    27d8:	ldr	r1, [r1, #52]	; 0x34
    27da:	blx	r1
    27dc:	b.n	2892 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1ca>
	unsigned int getRefcount() { // testing only
		return refcount;
	}
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
    27de:	ldr	r4, [r7, #40]	; 0x28
    27e0:	ldr	r3, [pc, #240]	; (28d4 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x20c>)
    27e2:	cmp	r4, r3
    27e4:	bne.n	287a <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    27e6:	mov	r0, r1
    27e8:	ldr	r2, [r0, #0]
    27ea:	ldr	r4, [r2, #40]	; 0x28
    27ec:	cmp	r4, r3
    27ee:	bne.n	287a <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    27f0:	ldr	r0, [r0, #16]
    27f2:	cmp	r0, #0
    27f4:	beq.n	2856 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    27f6:	ldr	r2, [r0, #0]
    27f8:	ldr	r4, [r2, #40]	; 0x28
    27fa:	cmp	r4, r3
    27fc:	bne.n	287a <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    27fe:	ldr	r0, [r0, #16]
    2800:	cbz	r0, 2856 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    2802:	ldr	r2, [r0, #0]
    2804:	ldr	r4, [r2, #40]	; 0x28
    2806:	cmp	r4, r3
    2808:	bne.n	287a <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    280a:	ldr	r0, [r0, #16]
    280c:	cbz	r0, 2856 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    280e:	ldr	r2, [r0, #0]
    2810:	ldr	r4, [r2, #40]	; 0x28
    2812:	cmp	r4, r3
    2814:	bne.n	287a <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    2816:	ldr	r0, [r0, #16]
    2818:	cbz	r0, 2856 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    281a:	ldr	r2, [r0, #0]
    281c:	ldr	r4, [r2, #40]	; 0x28
    281e:	cmp	r4, r3
    2820:	bne.n	287a <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    2822:	ldr	r0, [r0, #16]
    2824:	cbz	r0, 2856 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    2826:	ldr	r2, [r0, #0]
    2828:	ldr	r4, [r2, #40]	; 0x28
    282a:	cmp	r4, r3
    282c:	bne.n	287a <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    282e:	ldr	r0, [r0, #16]
    2830:	cbz	r0, 2856 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    2832:	ldr	r2, [r0, #0]
    2834:	ldr	r4, [r2, #40]	; 0x28
    2836:	cmp	r4, r3
    2838:	bne.n	287a <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    283a:	ldr	r0, [r0, #16]
    283c:	cbz	r0, 2856 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    283e:	ldr	r2, [r0, #0]
    2840:	ldr	r4, [r2, #40]	; 0x28
    2842:	cmp	r4, r3
    2844:	bne.n	287a <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    2846:	ldr	r0, [r0, #16]
    2848:	cbz	r0, 2856 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    284a:	ldr	r3, [r0, #0]
    284c:	mov.w	r2, #272	; 0x110
    2850:	ldr	r3, [r3, #40]	; 0x28
    2852:	mov	r1, r6
    2854:	blx	r3
    index_.read((char *)&ret, sizeof(ret));
    mtp_lock_storage(false);

    return ret;
  }
    2856:	mov	r0, r6
    2858:	add	sp, #8
    285a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  Record MTPStorage_SD::ReadIndexRecord(uint32_t i) 
  {
    Record ret;
    memset(&ret, 0, sizeof(ret));
    if (i > index_entries_) 
    { memset(&ret, 0, sizeof(ret));
    285e:	mov.w	r2, #272	; 0x110
    2862:	movs	r1, #0
    2864:	mov	r0, r6
    2866:	bl	1059c <memset>
    index_.seek(sizeof(ret) * i);
    index_.read((char *)&ret, sizeof(ret));
    mtp_lock_storage(false);

    return ret;
  }
    286a:	mov	r0, r6
    286c:	add	sp, #8
    286e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2872:	ldr	r4, [r7, #40]	; 0x28
    2874:	ldr	r3, [pc, #92]	; (28d4 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x20c>)
    2876:	cmp	r4, r3
    2878:	beq.n	2856 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    287a:	mov.w	r2, #272	; 0x110
    287e:	mov	r1, r6
    2880:	blx	r4
    2882:	mov	r0, r6
    2884:	add	sp, #8
    2886:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	}
	virtual bool truncate(uint64_t size=0) {
		return (f) ? f->truncate(size) : false;
	}
	virtual bool seek(uint64_t pos, int mode) {
		return (f) ? f->seek(pos, mode) : false;
    288a:	str.w	ip, [sp]
    288e:	mov	r3, ip
    2890:	blx	r1
	unsigned int getRefcount() { // testing only
		return refcount;
	}
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
    2892:	ldr.w	r0, [r5, #184]	; 0xb8
    2896:	cmp	r0, #0
    2898:	beq.n	2856 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
    289a:	ldr	r2, [r0, #0]
    289c:	ldr	r3, [pc, #52]	; (28d4 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x20c>)
    289e:	ldr	r4, [r2, #40]	; 0x28
    28a0:	cmp	r4, r3
    28a2:	bne.n	287a <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1b2>
    28a4:	ldr	r0, [r0, #16]
    28a6:	cmp	r0, #0
    28a8:	bne.n	27e8 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x120>
    28aa:	b.n	2856 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x18e>
	}
	virtual bool truncate(uint64_t size=0) {
		return (f) ? f->truncate(size) : false;
	}
	virtual bool seek(uint64_t pos, int mode) {
		return (f) ? f->seek(pos, mode) : false;
    28ac:	str.w	ip, [sp]
    28b0:	mov	r3, ip
    28b2:	mov	r0, lr
    28b4:	blx	r8
    28b6:	b.n	2892 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1ca>
    28b8:	str.w	ip, [sp]
    28bc:	mov	r3, ip
    28be:	mov	r0, r1
    28c0:	blx	r8
    28c2:	b.n	2892 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1ca>
    28c4:	movs	r3, #0
    28c6:	mov	r0, lr
    28c8:	str	r3, [sp, #0]
    28ca:	blx	r8
    28cc:	b.n	2892 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1ca>
    28ce:	nop
    28d0:	.word	0x000004c9
    28d4:	.word	0x0000047d

000028d8 <MTPStorage_SD::GetNextObjectHandle(unsigned long)>:
      next_ = 1;
    }
  }

  uint32_t MTPStorage_SD::GetNextObjectHandle(uint32_t  store)
  {
    28d8:	push	{r4, r5, lr}
    while (true) 
    { if (next_ == 0) return 0;
    28da:	ldr.w	r5, [r0, #252]	; 0xfc
      next_ = 1;
    }
  }

  uint32_t MTPStorage_SD::GetNextObjectHandle(uint32_t  store)
  {
    28de:	sub	sp, #276	; 0x114
    28e0:	mov	r4, r0
    while (true) 
    { if (next_ == 0) return 0;
    28e2:	cbnz	r5, 28f8 <MTPStorage_SD::GetNextObjectHandle(unsigned long)+0x20>
    28e4:	b.n	292e <MTPStorage_SD::GetNextObjectHandle(unsigned long)+0x56>

      int ret = next_;
      Record r = ReadIndexRecord(ret);
      if (follow_sibling_) 
      { next_ = r.sibling;
    28e6:	ldr	r3, [sp, #8]
    28e8:	str.w	r3, [r4, #252]	; 0xfc
      } 
      else 
      { next_++;
        if (next_ >= index_entries_) next_ = 0;
      }
      if (r.name[0]) return ret;
    28ec:	ldrb.w	r3, [sp, #16]
    28f0:	cbnz	r3, 2928 <MTPStorage_SD::GetNextObjectHandle(unsigned long)+0x50>
  }

  uint32_t MTPStorage_SD::GetNextObjectHandle(uint32_t  store)
  {
    while (true) 
    { if (next_ == 0) return 0;
    28f2:	ldr.w	r5, [r4, #252]	; 0xfc
    28f6:	cbz	r5, 292e <MTPStorage_SD::GetNextObjectHandle(unsigned long)+0x56>

      int ret = next_;
      Record r = ReadIndexRecord(ret);
    28f8:	mov	r2, r5
    28fa:	mov	r1, r4
    28fc:	mov	r0, sp
    28fe:	bl	26c8 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
      if (follow_sibling_) 
    2902:	ldrb.w	r2, [r4, #256]	; 0x100
    2906:	cmp	r2, #0
    2908:	bne.n	28e6 <MTPStorage_SD::GetNextObjectHandle(unsigned long)+0xe>
      { next_ = r.sibling;
      } 
      else 
      { next_++;
    290a:	ldr.w	r3, [r4, #252]	; 0xfc
        if (next_ >= index_entries_) next_ = 0;
    290e:	ldr.w	r1, [r4, #244]	; 0xf4
      Record r = ReadIndexRecord(ret);
      if (follow_sibling_) 
      { next_ = r.sibling;
      } 
      else 
      { next_++;
    2912:	adds	r3, #1
    2914:	str.w	r3, [r4, #252]	; 0xfc
        if (next_ >= index_entries_) next_ = 0;
    2918:	cmp	r3, r1
      }
      if (r.name[0]) return ret;
    291a:	ldrb.w	r3, [sp, #16]
      if (follow_sibling_) 
      { next_ = r.sibling;
      } 
      else 
      { next_++;
        if (next_ >= index_entries_) next_ = 0;
    291e:	it	cs
    2920:	strcs.w	r2, [r4, #252]	; 0xfc
      }
      if (r.name[0]) return ret;
    2924:	cmp	r3, #0
    2926:	beq.n	28f2 <MTPStorage_SD::GetNextObjectHandle(unsigned long)+0x1a>
    }
  }
    2928:	mov	r0, r5
    292a:	add	sp, #276	; 0x114
    292c:	pop	{r4, r5, pc}
  }

  uint32_t MTPStorage_SD::GetNextObjectHandle(uint32_t  store)
  {
    while (true) 
    { if (next_ == 0) return 0;
    292e:	movs	r5, #0
      { next_++;
        if (next_ >= index_entries_) next_ = 0;
      }
      if (r.name[0]) return ret;
    }
  }
    2930:	mov	r0, r5
    2932:	add	sp, #276	; 0x114
    2934:	pop	{r4, r5, pc}
    2936:	nop

00002938 <MTPStorage_SD::GetObjectInfo(unsigned long, char*, unsigned long*, unsigned long*, unsigned short*)>:

  void MTPStorage_SD::GetObjectInfo(uint32_t handle, char* name, uint32_t* size, uint32_t* parent, uint16_t *store)
  {
    2938:	push	{r4, r5, r6, r7, lr}
    293a:	sub	sp, #276	; 0x114
    293c:	mov	r7, r2
    Record r = ReadIndexRecord(handle);
    293e:	mov	r2, r1
    2940:	mov	r1, r0
    2942:	mov	r0, sp
      if (r.name[0]) return ret;
    }
  }

  void MTPStorage_SD::GetObjectInfo(uint32_t handle, char* name, uint32_t* size, uint32_t* parent, uint16_t *store)
  {
    2944:	mov	r5, r3
    2946:	ldr	r6, [sp, #296]	; 0x128
    2948:	ldr	r4, [sp, #300]	; 0x12c
    Record r = ReadIndexRecord(handle);
    294a:	bl	26c8 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    strcpy(name, r.name);
    294e:	mov	r0, r7
    2950:	add	r1, sp, #16
    2952:	bl	10a90 <strcpy>
    *parent = r.parent;
    *size = r.isdir ? 0xFFFFFFFFUL : r.child;
    2956:	ldrb.w	r3, [sp, #12]

  void MTPStorage_SD::GetObjectInfo(uint32_t handle, char* name, uint32_t* size, uint32_t* parent, uint16_t *store)
  {
    Record r = ReadIndexRecord(handle);
    strcpy(name, r.name);
    *parent = r.parent;
    295a:	ldr	r2, [sp, #0]
    295c:	str	r2, [r6, #0]
    *size = r.isdir ? 0xFFFFFFFFUL : r.child;
    295e:	cbnz	r3, 296e <MTPStorage_SD::GetObjectInfo(unsigned long, char*, unsigned long*, unsigned long*, unsigned short*)+0x36>
    2960:	ldr	r3, [sp, #4]
    *store = r.store;
    2962:	ldrh.w	r2, [sp, #14]
  void MTPStorage_SD::GetObjectInfo(uint32_t handle, char* name, uint32_t* size, uint32_t* parent, uint16_t *store)
  {
    Record r = ReadIndexRecord(handle);
    strcpy(name, r.name);
    *parent = r.parent;
    *size = r.isdir ? 0xFFFFFFFFUL : r.child;
    2966:	str	r3, [r5, #0]
    *store = r.store;
    2968:	strh	r2, [r4, #0]
  }
    296a:	add	sp, #276	; 0x114
    296c:	pop	{r4, r5, r6, r7, pc}
  void MTPStorage_SD::GetObjectInfo(uint32_t handle, char* name, uint32_t* size, uint32_t* parent, uint16_t *store)
  {
    Record r = ReadIndexRecord(handle);
    strcpy(name, r.name);
    *parent = r.parent;
    *size = r.isdir ? 0xFFFFFFFFUL : r.child;
    296e:	mov.w	r3, #4294967295
    2972:	b.n	2962 <MTPStorage_SD::GetObjectInfo(unsigned long, char*, unsigned long*, unsigned long*, unsigned short*)+0x2a>

00002974 <MTPStorage_SD::GetSize(unsigned long)>:
    *store = r.store;
  }

  uint32_t MTPStorage_SD::GetSize(uint32_t handle) 
  {
    2974:	push	{lr}
    2976:	sub	sp, #276	; 0x114
    return ReadIndexRecord(handle).child;
    2978:	mov	r2, r1
    297a:	mov	r1, r0
    297c:	mov	r0, sp
    297e:	bl	26c8 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
  }
    2982:	ldr	r0, [sp, #4]
    2984:	add	sp, #276	; 0x114
    2986:	ldr.w	pc, [sp], #4
    298a:	nop

0000298c <MTPStorage_SD::close()>:
      mtp_lock_storage(false);
      return ret;
  }

  void MTPStorage_SD::close() 
  {
    298c:	push	{r4, r5, r6, lr}
	}
	virtual uint64_t position() {
		return (f) ? f->position() : 0;
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
    298e:	ldr.w	r3, [r0, #204]	; 0xcc
    2992:	sub	sp, #272	; 0x110
    2994:	mov	r4, r0
    2996:	cmp	r3, #0
    2998:	beq.n	2a34 <MTPStorage_SD::close()+0xa8>
    299a:	ldr	r5, [r3, #0]
    299c:	ldr	r1, [pc, #384]	; (2b20 <MTPStorage_SD::close()+0x194>)
    299e:	ldr	r2, [r5, #60]	; 0x3c
    29a0:	cmp	r2, r1
    29a2:	bne.w	2b14 <MTPStorage_SD::close()+0x188>
    29a6:	ldr	r2, [r3, #16]
    29a8:	cmp	r2, #0
    29aa:	beq.w	2b04 <MTPStorage_SD::close()+0x178>
    29ae:	ldr	r0, [r2, #0]
    29b0:	ldr	r6, [r0, #60]	; 0x3c
    29b2:	cmp	r6, r1
    29b4:	bne.n	2a5c <MTPStorage_SD::close()+0xd0>
    29b6:	ldr	r0, [r2, #16]
    29b8:	cmp	r0, #0
    29ba:	beq.n	2a26 <MTPStorage_SD::close()+0x9a>
    29bc:	ldr	r6, [r0, #0]
    29be:	ldr	r6, [r6, #60]	; 0x3c
    29c0:	cmp	r6, r1
    29c2:	bne.n	2a5e <MTPStorage_SD::close()+0xd2>
    29c4:	ldr	r0, [r0, #16]
    29c6:	cmp	r0, #0
    29c8:	beq.n	2a26 <MTPStorage_SD::close()+0x9a>
    29ca:	ldr	r6, [r0, #0]
    29cc:	ldr	r6, [r6, #60]	; 0x3c
    29ce:	cmp	r6, r1
    29d0:	bne.n	2a5e <MTPStorage_SD::close()+0xd2>
    29d2:	ldr	r0, [r0, #16]
    29d4:	cbz	r0, 2a26 <MTPStorage_SD::close()+0x9a>
    29d6:	ldr	r6, [r0, #0]
    29d8:	ldr	r6, [r6, #60]	; 0x3c
    29da:	cmp	r6, r1
    29dc:	bne.n	2a5e <MTPStorage_SD::close()+0xd2>
    29de:	ldr	r0, [r0, #16]
    29e0:	cbz	r0, 2a26 <MTPStorage_SD::close()+0x9a>
    29e2:	ldr	r6, [r0, #0]
    29e4:	ldr	r6, [r6, #60]	; 0x3c
    29e6:	cmp	r6, r1
    29e8:	bne.n	2a5e <MTPStorage_SD::close()+0xd2>
    29ea:	ldr	r0, [r0, #16]
    29ec:	cbz	r0, 2a26 <MTPStorage_SD::close()+0x9a>
    29ee:	ldr	r6, [r0, #0]
    29f0:	ldr	r6, [r6, #60]	; 0x3c
    29f2:	cmp	r6, r1
    29f4:	bne.n	2a5e <MTPStorage_SD::close()+0xd2>
    29f6:	ldr	r0, [r0, #16]
    29f8:	cbz	r0, 2a26 <MTPStorage_SD::close()+0x9a>
    29fa:	ldr	r6, [r0, #0]
    29fc:	ldr	r6, [r6, #60]	; 0x3c
    29fe:	cmp	r6, r1
    2a00:	bne.n	2a5e <MTPStorage_SD::close()+0xd2>
    2a02:	ldr	r0, [r0, #16]
    2a04:	cbz	r0, 2a26 <MTPStorage_SD::close()+0x9a>
    2a06:	ldr	r6, [r0, #0]
    2a08:	ldr	r6, [r6, #60]	; 0x3c
    2a0a:	cmp	r6, r1
    2a0c:	bne.n	2a5e <MTPStorage_SD::close()+0xd2>
    2a0e:	ldr	r0, [r0, #16]
    2a10:	cbz	r0, 2a26 <MTPStorage_SD::close()+0x9a>
    2a12:	ldr	r6, [r0, #0]
    2a14:	ldr	r6, [r6, #60]	; 0x3c
    2a16:	cmp	r6, r1
    2a18:	bne.n	2a5e <MTPStorage_SD::close()+0xd2>
    2a1a:	ldr	r0, [r0, #16]
    2a1c:	cbz	r0, 2a26 <MTPStorage_SD::close()+0x9a>
    2a1e:	ldr	r3, [r0, #0]
    2a20:	ldr	r3, [r3, #60]	; 0x3c
    2a22:	blx	r3
    2a24:	b.n	2a60 <MTPStorage_SD::close()+0xd4>
	}
	virtual void close() {
		if (f) f->close();
    2a26:	ldr	r6, [r5, #64]	; 0x40
    2a28:	ldr	r1, [pc, #248]	; (2b24 <MTPStorage_SD::close()+0x198>)
    2a2a:	cmp	r6, r1
    2a2c:	bne.n	2b1a <MTPStorage_SD::close()+0x18e>
    2a2e:	mov	r0, r2
    2a30:	movs	r5, #0
    2a32:	b.n	2a7a <MTPStorage_SD::close()+0xee>
    mtp_lock_storage(true);
    uint32_t size = (uint32_t) file_.size();
    2a34:	mov	r5, r3
    file_.close();
    mtp_lock_storage(false);
    //
    // update record with file size
    Record r = ReadIndexRecord(open_file_);
    2a36:	mov	r0, sp
    2a38:	ldr.w	r2, [r4, #240]	; 0xf0
    2a3c:	mov	r1, r4
    2a3e:	bl	26c8 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    r.child = size;
    WriteIndexRecord(open_file_, r);
    2a42:	mov	r2, sp
    2a44:	ldr.w	r1, [r4, #240]	; 0xf0
    file_.close();
    mtp_lock_storage(false);
    //
    // update record with file size
    Record r = ReadIndexRecord(open_file_);
    r.child = size;
    2a48:	str	r5, [sp, #4]
    WriteIndexRecord(open_file_, r);
    2a4a:	mov	r0, r4
    2a4c:	bl	24e8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    open_file_ = 0xFFFFFFFEUL;
    2a50:	mvn.w	r3, #1
    2a54:	str.w	r3, [r4, #240]	; 0xf0
  }
    2a58:	add	sp, #272	; 0x110
    2a5a:	pop	{r4, r5, r6, pc}
	}
	virtual uint64_t position() {
		return (f) ? f->position() : 0;
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
    2a5c:	mov	r0, r2
    2a5e:	blx	r6
	}
	virtual void close() {
		if (f) f->close();
    2a60:	ldr.w	r3, [r4, #204]	; 0xcc
  }

  void MTPStorage_SD::close() 
  {
    mtp_lock_storage(true);
    uint32_t size = (uint32_t) file_.size();
    2a64:	mov	r5, r0
    2a66:	cmp	r3, #0
    2a68:	beq.n	2a36 <MTPStorage_SD::close()+0xaa>
    2a6a:	ldr	r2, [r3, #0]
    2a6c:	ldr	r1, [pc, #180]	; (2b24 <MTPStorage_SD::close()+0x198>)
    2a6e:	ldr	r6, [r2, #64]	; 0x40
    2a70:	cmp	r6, r1
    2a72:	bne.n	2b0e <MTPStorage_SD::close()+0x182>
    2a74:	ldr	r0, [r3, #16]
    2a76:	cmp	r0, #0
    2a78:	beq.n	2a36 <MTPStorage_SD::close()+0xaa>
    2a7a:	ldr	r3, [r0, #0]
    2a7c:	ldr	r3, [r3, #64]	; 0x40
    2a7e:	cmp	r3, r1
    2a80:	bne.n	2b00 <MTPStorage_SD::close()+0x174>
    2a82:	ldr	r0, [r0, #16]
    2a84:	cmp	r0, #0
    2a86:	beq.n	2a36 <MTPStorage_SD::close()+0xaa>
    2a88:	ldr	r3, [r0, #0]
    2a8a:	ldr	r3, [r3, #64]	; 0x40
    2a8c:	cmp	r3, r1
    2a8e:	bne.n	2b00 <MTPStorage_SD::close()+0x174>
    2a90:	ldr	r0, [r0, #16]
    2a92:	cmp	r0, #0
    2a94:	beq.n	2a36 <MTPStorage_SD::close()+0xaa>
    2a96:	ldr	r3, [r0, #0]
    2a98:	ldr	r3, [r3, #64]	; 0x40
    2a9a:	cmp	r3, r1
    2a9c:	bne.n	2b00 <MTPStorage_SD::close()+0x174>
    2a9e:	ldr	r0, [r0, #16]
    2aa0:	cmp	r0, #0
    2aa2:	beq.n	2a36 <MTPStorage_SD::close()+0xaa>
    2aa4:	ldr	r3, [r0, #0]
    2aa6:	ldr	r3, [r3, #64]	; 0x40
    2aa8:	cmp	r3, r1
    2aaa:	bne.n	2b00 <MTPStorage_SD::close()+0x174>
    2aac:	ldr	r0, [r0, #16]
    2aae:	cmp	r0, #0
    2ab0:	beq.n	2a36 <MTPStorage_SD::close()+0xaa>
    2ab2:	ldr	r3, [r0, #0]
    2ab4:	ldr	r3, [r3, #64]	; 0x40
    2ab6:	cmp	r3, r1
    2ab8:	bne.n	2b00 <MTPStorage_SD::close()+0x174>
    2aba:	ldr	r0, [r0, #16]
    2abc:	cmp	r0, #0
    2abe:	beq.n	2a36 <MTPStorage_SD::close()+0xaa>
    2ac0:	ldr	r3, [r0, #0]
    2ac2:	ldr	r3, [r3, #64]	; 0x40
    2ac4:	cmp	r3, r1
    2ac6:	bne.n	2b00 <MTPStorage_SD::close()+0x174>
    2ac8:	ldr	r0, [r0, #16]
    2aca:	cmp	r0, #0
    2acc:	beq.n	2a36 <MTPStorage_SD::close()+0xaa>
    2ace:	ldr	r3, [r0, #0]
    2ad0:	ldr	r3, [r3, #64]	; 0x40
    2ad2:	cmp	r3, r1
    2ad4:	bne.n	2b00 <MTPStorage_SD::close()+0x174>
    2ad6:	ldr	r0, [r0, #16]
    2ad8:	cmp	r0, #0
    2ada:	beq.n	2a36 <MTPStorage_SD::close()+0xaa>
    2adc:	ldr	r3, [r0, #0]
    2ade:	ldr	r3, [r3, #64]	; 0x40
    2ae0:	cmp	r3, r1
    2ae2:	bne.n	2b00 <MTPStorage_SD::close()+0x174>
    2ae4:	ldr	r0, [r0, #16]
    2ae6:	cmp	r0, #0
    2ae8:	beq.n	2a36 <MTPStorage_SD::close()+0xaa>
    2aea:	ldr	r3, [r0, #0]
    2aec:	ldr	r3, [r3, #64]	; 0x40
    2aee:	cmp	r3, r1
    2af0:	bne.n	2b00 <MTPStorage_SD::close()+0x174>
    2af2:	ldr	r0, [r0, #16]
    2af4:	cmp	r0, #0
    2af6:	beq.n	2a36 <MTPStorage_SD::close()+0xaa>
    2af8:	ldr	r3, [r0, #0]
    2afa:	ldr	r3, [r3, #64]	; 0x40
    2afc:	blx	r3
    2afe:	b.n	2a36 <MTPStorage_SD::close()+0xaa>
    2b00:	blx	r3
    2b02:	b.n	2a36 <MTPStorage_SD::close()+0xaa>
    2b04:	ldr	r6, [r5, #64]	; 0x40
    2b06:	ldr	r1, [pc, #28]	; (2b24 <MTPStorage_SD::close()+0x198>)
    2b08:	cmp	r6, r1
    2b0a:	mov	r5, r2
    2b0c:	beq.n	2a36 <MTPStorage_SD::close()+0xaa>
    2b0e:	mov	r0, r3
    2b10:	blx	r6
    2b12:	b.n	2a36 <MTPStorage_SD::close()+0xaa>
	}
	virtual uint64_t position() {
		return (f) ? f->position() : 0;
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
    2b14:	mov	r0, r3
    2b16:	blx	r2
    2b18:	b.n	2a60 <MTPStorage_SD::close()+0xd4>
	}
	virtual void close() {
		if (f) f->close();
    2b1a:	movs	r5, #0
    2b1c:	b.n	2b0e <MTPStorage_SD::close()+0x182>
    2b1e:	nop
    2b20:	.word	0x000004f1
    2b24:	.word	0x00000501

00002b28 <MTPStorage_SD::ConstructFilename(int, char*, int)>:

    return ret;
  }

  uint16_t MTPStorage_SD::ConstructFilename(int i, char* out, int len) // construct filename rexursively
  {
    2b28:	push	{r4, r5, r6, lr}
    2b2a:	mov	r6, r0
    2b2c:	sub	sp, #272	; 0x110
    2b2e:	mov	r4, r2
    Record tmp = ReadIndexRecord(i);
    2b30:	mov	r0, sp
    2b32:	mov	r2, r1
    2b34:	mov	r1, r6

    return ret;
  }

  uint16_t MTPStorage_SD::ConstructFilename(int i, char* out, int len) // construct filename rexursively
  {
    2b36:	mov	r5, r3
    Record tmp = ReadIndexRecord(i);
    2b38:	bl	26c8 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
      
    if (tmp.parent==0xFFFFFFFFUL) //flags the root object
    2b3c:	ldr	r1, [sp, #0]
    2b3e:	adds	r3, r1, #1
    2b40:	beq.n	2b78 <MTPStorage_SD::ConstructFilename(int, char*, int)+0x50>
    { strcpy(out, "/");
      return tmp.store;
    }
    else 
    { ConstructFilename(tmp.parent, out, len);
    2b42:	mov	r3, r5
    2b44:	mov	r2, r4
    2b46:	mov	r0, r6
    2b48:	bl	2b28 <MTPStorage_SD::ConstructFilename(int, char*, int)>
      if (out[strlen(out)-1] != '/') strlcat(out, "/",len);
    2b4c:	mov	r0, r4
    2b4e:	bl	10c00 <strlen>
    2b52:	add	r0, r4
    2b54:	ldrb.w	r3, [r0, #-1]
    2b58:	cmp	r3, #47	; 0x2f
    2b5a:	beq.n	2b66 <MTPStorage_SD::ConstructFilename(int, char*, int)+0x3e>
    2b5c:	mov	r2, r5
    2b5e:	ldr	r1, [pc, #40]	; (2b88 <MTPStorage_SD::ConstructFilename(int, char*, int)+0x60>)
    2b60:	mov	r0, r4
    2b62:	bl	10b4c <strlcat>
      strlcat(out, tmp.name,len);
    2b66:	mov	r2, r5
    2b68:	mov	r0, r4
    2b6a:	add	r1, sp, #16
    2b6c:	bl	10b4c <strlcat>
      return tmp.store;
    2b70:	ldrh.w	r0, [sp, #14]
    }
  }
    2b74:	add	sp, #272	; 0x110
    2b76:	pop	{r4, r5, r6, pc}
  uint16_t MTPStorage_SD::ConstructFilename(int i, char* out, int len) // construct filename rexursively
  {
    Record tmp = ReadIndexRecord(i);
      
    if (tmp.parent==0xFFFFFFFFUL) //flags the root object
    { strcpy(out, "/");
    2b78:	ldr	r3, [pc, #12]	; (2b88 <MTPStorage_SD::ConstructFilename(int, char*, int)+0x60>)
      return tmp.store;
    2b7a:	ldrh.w	r0, [sp, #14]
  uint16_t MTPStorage_SD::ConstructFilename(int i, char* out, int len) // construct filename rexursively
  {
    Record tmp = ReadIndexRecord(i);
      
    if (tmp.parent==0xFFFFFFFFUL) //flags the root object
    { strcpy(out, "/");
    2b7e:	ldrh	r3, [r3, #0]
    2b80:	strh	r3, [r4, #0]
    { ConstructFilename(tmp.parent, out, len);
      if (out[strlen(out)-1] != '/') strlcat(out, "/",len);
      strlcat(out, tmp.name,len);
      return tmp.store;
    }
  }
    2b82:	add	sp, #272	; 0x110
    2b84:	pop	{r4, r5, r6, pc}
    2b86:	nop
    2b88:	.word	0x000143ec

00002b8c <MTPStorage_SD::rename(unsigned long, char const*)>:
    WriteIndexRecord(open_file_, r);
    open_file_ = 0xFFFFFFFEUL;
  }

  bool MTPStorage_SD::rename(uint32_t handle, const char* name) 
  { char oldName[MAX_FILENAME_LEN];
    2b8c:	push	{r4, r5, r6, r7, lr}
    2b8e:	subw	sp, sp, #1044	; 0x414
    char newName[MAX_FILENAME_LEN];
    char temp[MAX_FILENAME_LEN];

    uint16_t store = ConstructFilename(handle, oldName, MAX_FILENAME_LEN);
    2b92:	mov.w	r3, #256	; 0x100
    WriteIndexRecord(open_file_, r);
    open_file_ = 0xFFFFFFFEUL;
  }

  bool MTPStorage_SD::rename(uint32_t handle, const char* name) 
  { char oldName[MAX_FILENAME_LEN];
    2b96:	mov	r7, r2
    char newName[MAX_FILENAME_LEN];
    char temp[MAX_FILENAME_LEN];

    uint16_t store = ConstructFilename(handle, oldName, MAX_FILENAME_LEN);
    2b98:	mov	r2, sp
    WriteIndexRecord(open_file_, r);
    open_file_ = 0xFFFFFFFEUL;
  }

  bool MTPStorage_SD::rename(uint32_t handle, const char* name) 
  { char oldName[MAX_FILENAME_LEN];
    2b9a:	mov	r5, r1
    2b9c:	mov	r4, r0
    char newName[MAX_FILENAME_LEN];
    char temp[MAX_FILENAME_LEN];

    uint16_t store = ConstructFilename(handle, oldName, MAX_FILENAME_LEN);
    2b9e:	bl	2b28 <MTPStorage_SD::ConstructFilename(int, char*, int)>
    2ba2:	mov	r6, r0
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    2ba4:	mov	r0, sp
    2ba6:	bl	10c00 <strlen>
    2baa:	mov	r1, r0
    2bac:	mov	r0, sp
    2bae:	bl	d6b8 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    2bb2:	ldr	r0, [pc, #132]	; (2c38 <MTPStorage_SD::rename(unsigned long, char const*)+0xac>)
    2bb4:	bl	eedc <Print::println()>
    Serial.println(oldName);

    Record p1 = ReadIndexRecord(handle);
    2bb8:	mov	r2, r5
    2bba:	mov	r1, r4
    2bbc:	add	r0, sp, #768	; 0x300
    2bbe:	bl	26c8 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    strlcpy(temp,p1.name,MAX_FILENAME_LEN);
    2bc2:	add	r1, sp, #784	; 0x310
    2bc4:	mov.w	r2, #256	; 0x100
    2bc8:	add	r0, sp, #512	; 0x200
    2bca:	bl	10ba0 <strlcpy>
    strlcpy(p1.name,name,MAX_FILENAME_LEN);
    2bce:	mov	r1, r7
    2bd0:	mov.w	r2, #256	; 0x100
    2bd4:	add	r0, sp, #784	; 0x310
    2bd6:	bl	10ba0 <strlcpy>

    WriteIndexRecord(handle, p1);
    2bda:	add	r2, sp, #768	; 0x300
    2bdc:	mov	r1, r5
    2bde:	mov	r0, r4
    2be0:	bl	24e8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    ConstructFilename(handle, newName, MAX_FILENAME_LEN);
    2be4:	add	r2, sp, #256	; 0x100
    2be6:	mov.w	r3, #256	; 0x100
    2bea:	mov	r1, r5
    2bec:	mov	r0, r4
    2bee:	bl	2b28 <MTPStorage_SD::ConstructFilename(int, char*, int)>
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    2bf2:	add	r0, sp, #256	; 0x100
    2bf4:	bl	10c00 <strlen>
    uint32_t sd_getFSCount(void) {return fsCount;}
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}

    File sd_open(uint32_t store, const char *filename, uint32_t mode) { return sdx[store]->open(filename,mode);  }
    bool sd_mkdir(uint32_t store, char *filename) {  return sdx[store]->mkdir(filename);  }
    bool sd_rename(uint32_t store, char *oldfilename, char *newfilename) { return sdx[store]->rename(oldfilename,newfilename);  }
    2bf8:	add.w	r6, r4, r6, lsl #2
    2bfc:	mov	r1, r0
    2bfe:	add	r0, sp, #256	; 0x100
    2c00:	bl	d6b8 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    2c04:	ldr	r0, [pc, #48]	; (2c38 <MTPStorage_SD::rename(unsigned long, char const*)+0xac>)
    2c06:	bl	eedc <Print::println()>
    2c0a:	ldr	r0, [r6, #88]	; 0x58
    2c0c:	ldr	r3, [r0, #0]
    2c0e:	add	r2, sp, #256	; 0x100
    2c10:	mov	r1, sp
    2c12:	ldr	r3, [r3, #12]
    2c14:	blx	r3
    Serial.println(newName);

    if (sd_rename(store,oldName,newName)) return true;
    2c16:	mov	r6, r0
    2c18:	cbnz	r0, 2c30 <MTPStorage_SD::rename(unsigned long, char const*)+0xa4>

    // rename failed; undo index update
    strlcpy(p1.name,temp,MAX_FILENAME_LEN);
    2c1a:	add	r1, sp, #512	; 0x200
    2c1c:	mov.w	r2, #256	; 0x100
    2c20:	add	r0, sp, #784	; 0x310
    2c22:	bl	10ba0 <strlcpy>
    WriteIndexRecord(handle, p1);
    2c26:	add	r2, sp, #768	; 0x300
    2c28:	mov	r1, r5
    2c2a:	mov	r0, r4
    2c2c:	bl	24e8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    return false;
  }
    2c30:	mov	r0, r6
    2c32:	addw	sp, sp, #1044	; 0x414
    2c36:	pop	{r4, r5, r6, r7, pc}
    2c38:	.word	0x1fff0ad0

00002c3c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)>:
      return tmp.store;
    }
  }

  void MTPStorage_SD::OpenFileByIndex(uint32_t i, uint32_t mode) 
  {
    2c3c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if (open_file_ == i && mode_ == mode) return;
    2c40:	ldr.w	r3, [r0, #240]	; 0xf0
    2c44:	cmp	r3, r1
      return tmp.store;
    }
  }

  void MTPStorage_SD::OpenFileByIndex(uint32_t i, uint32_t mode) 
  {
    2c46:	sub	sp, #292	; 0x124
    if (open_file_ == i && mode_ == mode) return;
    2c48:	beq.w	3040 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x404>
    2c4c:	mov	r6, r2
    char filename[MAX_FILENAME_LEN];
    uint16_t store = ConstructFilename(i, filename, MAX_FILENAME_LEN);
    2c4e:	mov.w	r3, #256	; 0x100
    2c52:	add	r2, sp, #32
    2c54:	mov	r4, r0
    2c56:	mov	r5, r1
    2c58:	bl	2b28 <MTPStorage_SD::ConstructFilename(int, char*, int)>
    2c5c:	mov	r7, r0
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    2c5e:	ldr.w	r0, [r4, #204]	; 0xcc
    2c62:	cmp	r0, #0
    2c64:	beq.w	2d78 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2c68:	ldr	r2, [r0, #0]
    2c6a:	ldr	r3, [pc, #348]	; (2dc8 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x18c>)
    2c6c:	ldr	r2, [r2, #68]	; 0x44
    2c6e:	cmp	r2, r3
    2c70:	bne.w	3050 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x414>
    2c74:	ldr	r0, [r0, #16]
    2c76:	cmp	r0, #0
    2c78:	beq.n	2d78 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2c7a:	ldr	r2, [r0, #0]
    2c7c:	ldr	r2, [r2, #68]	; 0x44
    2c7e:	cmp	r2, r3
    2c80:	bne.w	3050 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x414>
    2c84:	ldr	r0, [r0, #16]
    2c86:	cmp	r0, #0
    2c88:	beq.n	2d78 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2c8a:	ldr	r2, [r0, #0]
    2c8c:	ldr	r2, [r2, #68]	; 0x44
    2c8e:	cmp	r2, r3
    2c90:	bne.w	3050 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x414>
    2c94:	ldr	r0, [r0, #16]
    2c96:	cmp	r0, #0
    2c98:	beq.n	2d78 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2c9a:	ldr	r2, [r0, #0]
    2c9c:	ldr	r2, [r2, #68]	; 0x44
    2c9e:	cmp	r2, r3
    2ca0:	bne.w	3050 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x414>
    2ca4:	ldr	r0, [r0, #16]
    2ca6:	cmp	r0, #0
    2ca8:	beq.n	2d78 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2caa:	ldr	r2, [r0, #0]
    2cac:	ldr	r2, [r2, #68]	; 0x44
    2cae:	cmp	r2, r3
    2cb0:	bne.w	3050 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x414>
    2cb4:	ldr	r0, [r0, #16]
    2cb6:	cmp	r0, #0
    2cb8:	beq.n	2d78 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2cba:	ldr	r2, [r0, #0]
    2cbc:	ldr	r2, [r2, #68]	; 0x44
    2cbe:	cmp	r2, r3
    2cc0:	bne.w	3050 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x414>
    2cc4:	ldr	r0, [r0, #16]
    2cc6:	cmp	r0, #0
    2cc8:	beq.n	2d78 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2cca:	ldr	r2, [r0, #0]
    2ccc:	ldr	r2, [r2, #68]	; 0x44
    2cce:	cmp	r2, r3
    2cd0:	bne.w	3050 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x414>
    2cd4:	ldr	r0, [r0, #16]
    2cd6:	cmp	r0, #0
    2cd8:	beq.n	2d78 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2cda:	ldr	r2, [r0, #0]
    2cdc:	ldr	r2, [r2, #68]	; 0x44
    2cde:	cmp	r2, r3
    2ce0:	bne.w	3050 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x414>
    2ce4:	ldr	r0, [r0, #16]
    2ce6:	cmp	r0, #0
    2ce8:	beq.n	2d78 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2cea:	ldr	r2, [r0, #0]
    2cec:	ldr	r2, [r2, #68]	; 0x44
    2cee:	cmp	r2, r3
    2cf0:	bne.w	3050 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x414>
    2cf4:	ldr	r0, [r0, #16]
    2cf6:	cmp	r0, #0
    2cf8:	beq.n	2d78 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2cfa:	ldr	r3, [r0, #0]
    2cfc:	ldr	r3, [r3, #68]	; 0x44
    2cfe:	blx	r3

    mtp_lock_storage(true);
    if(sd_isOpen(file_)) file_.close();
    2d00:	cmp	r0, #0
    2d02:	beq.n	2d78 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    2d04:	ldr.w	r0, [r4, #204]	; 0xcc
    2d08:	cmp	r0, #0
    2d0a:	beq.n	2d78 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2d0c:	ldr	r2, [r0, #0]
    2d0e:	ldr	r3, [pc, #188]	; (2dcc <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x190>)
    2d10:	ldr	r2, [r2, #64]	; 0x40
    2d12:	cmp	r2, r3
    2d14:	bne.w	3054 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x418>
    2d18:	ldr	r0, [r0, #16]
    2d1a:	cmp	r0, #0
    2d1c:	beq.n	2d78 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2d1e:	ldr	r2, [r0, #0]
    2d20:	ldr	r2, [r2, #64]	; 0x40
    2d22:	cmp	r2, r3
    2d24:	bne.w	3054 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x418>
    2d28:	ldr	r0, [r0, #16]
    2d2a:	cbz	r0, 2d78 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2d2c:	ldr	r2, [r0, #0]
    2d2e:	ldr	r2, [r2, #64]	; 0x40
    2d30:	cmp	r2, r3
    2d32:	bne.w	3054 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x418>
    2d36:	ldr	r0, [r0, #16]
    2d38:	cbz	r0, 2d78 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2d3a:	ldr	r2, [r0, #0]
    2d3c:	ldr	r2, [r2, #64]	; 0x40
    2d3e:	cmp	r2, r3
    2d40:	bne.w	3054 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x418>
    2d44:	ldr	r0, [r0, #16]
    2d46:	cbz	r0, 2d78 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2d48:	ldr	r2, [r0, #0]
    2d4a:	ldr	r2, [r2, #64]	; 0x40
    2d4c:	cmp	r2, r3
    2d4e:	bne.w	3054 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x418>
    2d52:	ldr	r0, [r0, #16]
    2d54:	cbz	r0, 2d78 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2d56:	ldr	r2, [r0, #0]
    2d58:	ldr	r2, [r2, #64]	; 0x40
    2d5a:	cmp	r2, r3
    2d5c:	bne.w	3054 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x418>
    2d60:	ldr	r0, [r0, #16]
    2d62:	cbz	r0, 2d78 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2d64:	ldr	r2, [r0, #0]
    2d66:	ldr	r2, [r2, #64]	; 0x40
    2d68:	cmp	r2, r3
    2d6a:	bne.w	3054 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x418>
    2d6e:	ldr	r0, [r0, #16]
    2d70:	cbz	r0, 2d78 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
    2d72:	ldr	r3, [r0, #0]
    2d74:	ldr	r3, [r3, #64]	; 0x40
    2d76:	blx	r3
    }

    uint32_t sd_getFSCount(void) {return fsCount;}
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}

    File sd_open(uint32_t store, const char *filename, uint32_t mode) { return sdx[store]->open(filename,mode);  }
    2d78:	add.w	r7, r4, r7, lsl #2
    2d7c:	add	r2, sp, #32
    2d7e:	ldr	r1, [r7, #88]	; 0x58
    2d80:	ldr	r3, [r1, #0]
    2d82:	add	r0, sp, #12
    2d84:	ldr	r7, [r3, #0]
    2d86:	uxtb	r3, r6
    2d88:	blx	r7
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2d8a:	ldr.w	r2, [r4, #204]	; 0xcc
    2d8e:	cbz	r2, 2d98 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x15c>
    2d90:	ldr	r3, [r2, #16]
    2d92:	subs	r3, #1
    2d94:	str	r3, [r2, #16]
    2d96:	cbz	r3, 2dd4 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x198>
	File& operator = (const File &file) {
		//Serial.println("File assignment");
		//static int assigncount=0;
		//if (++assigncount > 20) while (1) ;
		invalidate();
		f = file.f;
    2d98:	ldr	r2, [sp, #28]
    2d9a:	str.w	r2, [r4, #204]	; 0xcc
		if (f) f->refcount++;
    2d9e:	cbz	r2, 2dba <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x17e>
    2da0:	ldr	r1, [r2, #16]
		return *this;
	}
	virtual ~File() {
    2da2:	ldr	r3, [pc, #44]	; (2dd0 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x194>)
    2da4:	str	r3, [sp, #12]
		//Serial.println("File assignment");
		//static int assigncount=0;
		//if (++assigncount > 20) while (1) ;
		invalidate();
		f = file.f;
		if (f) f->refcount++;
    2da6:	adds	r1, #1
    2da8:	str	r1, [r2, #16]
    2daa:	ldr	r1, [sp, #28]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2dac:	cbz	r1, 2dba <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x17e>
    2dae:	ldr	r2, [r1, #16]
    2db0:	subs	r2, #1
    2db2:	str	r2, [r1, #16]
    2db4:	cmp	r2, #0
    2db6:	beq.w	2f10 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2d4>
    file_=sd_open(store,filename,mode);
    open_file_ = i;
    2dba:	str.w	r5, [r4, #240]	; 0xf0
    mode_ = mode;
    2dbe:	str.w	r6, [r4, #236]	; 0xec
    mtp_lock_storage(false);
  }
    2dc2:	add	sp, #292	; 0x124
    2dc4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2dc8:	.word	0x0000050d
    2dcc:	.word	0x00000501
    2dd0:	.word	0x000140dc
    2dd4:	ldr.w	r7, [r4, #204]	; 0xcc
    2dd8:	cmp	r7, #0
    2dda:	beq.n	2d98 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x15c>
    2ddc:	ldr	r3, [r7, #0]
    2dde:	ldr	r1, [pc, #680]	; (3088 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x44c>)
    2de0:	ldr	r3, [r3, #32]
    2de2:	cmp	r3, r1
    2de4:	bne.w	3058 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x41c>
    2de8:	ldr	r0, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2dea:	ldr	r3, [pc, #672]	; (308c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x450>)
    2dec:	str	r3, [r7, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2dee:	cmp	r0, #0
    2df0:	beq.w	2f06 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2ca>
    2df4:	ldr	r2, [r0, #16]
    2df6:	subs	r2, #1
    2df8:	str	r2, [r0, #16]
    2dfa:	cmp	r2, #0
    2dfc:	bne.w	2f06 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2ca>
    2e00:	ldr.w	r8, [r7, #16]
    2e04:	cmp.w	r8, #0
    2e08:	beq.n	2f06 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2ca>
    2e0a:	ldr.w	r2, [r8]
    2e0e:	ldr	r2, [r2, #32]
    2e10:	cmp	r2, r1
    2e12:	bne.w	3076 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x43a>
    2e16:	ldr.w	r0, [r8, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2e1a:	str.w	r3, [r8]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2e1e:	cmp	r0, #0
    2e20:	beq.n	2efe <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2c2>
    2e22:	ldr	r2, [r0, #16]
    2e24:	subs	r2, #1
    2e26:	str	r2, [r0, #16]
    2e28:	cmp	r2, #0
    2e2a:	bne.n	2efe <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2c2>
    2e2c:	ldr.w	r9, [r8, #16]
    2e30:	cmp.w	r9, #0
    2e34:	beq.n	2efe <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2c2>
    2e36:	ldr.w	r2, [r9]
    2e3a:	ldr	r2, [r2, #32]
    2e3c:	cmp	r2, r1
    2e3e:	bne.w	306a <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x42e>
    2e42:	ldr.w	r0, [r9, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2e46:	str.w	r3, [r9]
    2e4a:	ldr.w	lr, [pc, #576]	; 308c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x450>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2e4e:	cmp	r0, #0
    2e50:	beq.n	2ef6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2ba>
    2e52:	ldr	r2, [r0, #16]
    2e54:	subs	r2, #1
    2e56:	str	r2, [r0, #16]
    2e58:	cmp	r2, #0
    2e5a:	bne.n	2ef6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2ba>
    2e5c:	ldr.w	sl, [r9, #16]
    2e60:	cmp.w	sl, #0
    2e64:	beq.n	2ef6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2ba>
    2e66:	ldr.w	r2, [sl]
    2e6a:	ldr	r2, [r2, #32]
    2e6c:	cmp	r2, r1
    2e6e:	bne.w	3082 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x446>
    2e72:	ldr.w	r0, [sl, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2e76:	str.w	lr, [sl]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2e7a:	cmp	r0, #0
    2e7c:	beq.n	2eee <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2b2>
    2e7e:	ldr	r2, [r0, #16]
    2e80:	subs	r2, #1
    2e82:	str	r2, [r0, #16]
    2e84:	cmp	r2, #0
    2e86:	bne.n	2eee <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2b2>
    2e88:	ldr.w	fp, [sl, #16]
    2e8c:	cmp.w	fp, #0
    2e90:	beq.n	2eee <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2b2>
    2e92:	ldr.w	r2, [fp]
    2e96:	ldr	r2, [r2, #32]
    2e98:	cmp	r2, r1
    2e9a:	bne.w	3096 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x45a>
    2e9e:	ldr.w	r2, [fp, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2ea2:	str.w	r3, [fp]
    2ea6:	ldr	r0, [pc, #484]	; (308c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x450>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2ea8:	cbz	r2, 2ee6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2aa>
    2eaa:	ldr	r3, [r2, #16]
    2eac:	subs	r3, #1
    2eae:	str	r3, [r2, #16]
    2eb0:	cbnz	r3, 2ee6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2aa>
    2eb2:	ldr.w	r2, [fp, #16]
    2eb6:	cbz	r2, 2ee6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2aa>
    2eb8:	ldr	r3, [r2, #0]
    2eba:	ldr	r3, [r3, #32]
    2ebc:	cmp	r3, r1
    2ebe:	bne.w	30a2 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x466>
    2ec2:	ldr	r1, [r2, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2ec4:	str	r0, [r2, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2ec6:	cbz	r1, 2ede <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2a2>
    2ec8:	ldr	r3, [r1, #16]
    2eca:	subs	r3, #1
    2ecc:	str	r3, [r1, #16]
    2ece:	cbnz	r3, 2ede <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2a2>
    2ed0:	ldr	r0, [r2, #16]
    2ed2:	cbz	r0, 2ede <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2a2>
    2ed4:	ldr	r3, [r0, #0]
    2ed6:	str	r2, [sp, #4]
    2ed8:	ldr	r3, [r3, #32]
    2eda:	blx	r3
    2edc:	ldr	r2, [sp, #4]
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    2ede:	mov	r0, r2
    2ee0:	movs	r1, #20
    2ee2:	bl	effc <operator delete(void*, unsigned int)>
    2ee6:	mov	r0, fp
    2ee8:	movs	r1, #20
    2eea:	bl	effc <operator delete(void*, unsigned int)>
    2eee:	mov	r0, sl
    2ef0:	movs	r1, #20
    2ef2:	bl	effc <operator delete(void*, unsigned int)>
    2ef6:	mov	r0, r9
    2ef8:	movs	r1, #20
    2efa:	bl	effc <operator delete(void*, unsigned int)>
    2efe:	mov	r0, r8
    2f00:	movs	r1, #20
    2f02:	bl	effc <operator delete(void*, unsigned int)>
    2f06:	mov	r0, r7
    2f08:	movs	r1, #20
    2f0a:	bl	effc <operator delete(void*, unsigned int)>
    2f0e:	b.n	2d98 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x15c>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2f10:	ldr	r7, [sp, #28]
    2f12:	cmp	r7, #0
    2f14:	beq.w	2dba <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x17e>
    2f18:	ldr	r2, [r7, #0]
    2f1a:	ldr	r1, [pc, #364]	; (3088 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x44c>)
    2f1c:	ldr	r2, [r2, #32]
    2f1e:	cmp	r2, r1
    2f20:	bne.w	305e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x422>
    2f24:	ldr	r0, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2f26:	str	r3, [r7, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2f28:	cmp	r0, #0
    2f2a:	beq.w	3036 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3fa>
    2f2e:	ldr	r2, [r0, #16]
    2f30:	subs	r2, #1
    2f32:	str	r2, [r0, #16]
    2f34:	cmp	r2, #0
    2f36:	bne.n	3036 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3fa>
    2f38:	ldr.w	r8, [r7, #16]
    2f3c:	cmp.w	r8, #0
    2f40:	beq.n	3036 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3fa>
    2f42:	ldr.w	r2, [r8]
    2f46:	ldr	r2, [r2, #32]
    2f48:	cmp	r2, r1
    2f4a:	bne.w	3070 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x434>
    2f4e:	ldr.w	r0, [r8, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2f52:	str.w	r3, [r8]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2f56:	cmp	r0, #0
    2f58:	beq.n	302e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3f2>
    2f5a:	ldr	r2, [r0, #16]
    2f5c:	subs	r2, #1
    2f5e:	str	r2, [r0, #16]
    2f60:	cmp	r2, #0
    2f62:	bne.n	302e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3f2>
    2f64:	ldr.w	r9, [r8, #16]
    2f68:	cmp.w	r9, #0
    2f6c:	beq.n	302e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3f2>
    2f6e:	ldr.w	r2, [r9]
    2f72:	ldr	r2, [r2, #32]
    2f74:	cmp	r2, r1
    2f76:	bne.n	3064 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x428>
    2f78:	ldr.w	r0, [r9, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2f7c:	str.w	r3, [r9]
    2f80:	ldr.w	lr, [pc, #264]	; 308c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x450>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2f84:	cmp	r0, #0
    2f86:	beq.n	3026 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3ea>
    2f88:	ldr	r2, [r0, #16]
    2f8a:	subs	r2, #1
    2f8c:	str	r2, [r0, #16]
    2f8e:	cmp	r2, #0
    2f90:	bne.n	3026 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3ea>
    2f92:	ldr.w	sl, [r9, #16]
    2f96:	cmp.w	sl, #0
    2f9a:	beq.n	3026 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3ea>
    2f9c:	ldr.w	r2, [sl]
    2fa0:	ldr	r2, [r2, #32]
    2fa2:	cmp	r2, r1
    2fa4:	bne.n	307c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x440>
    2fa6:	ldr.w	r0, [sl, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2faa:	str.w	lr, [sl]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2fae:	cmp	r0, #0
    2fb0:	beq.n	301e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3e2>
    2fb2:	ldr	r2, [r0, #16]
    2fb4:	subs	r2, #1
    2fb6:	str	r2, [r0, #16]
    2fb8:	cmp	r2, #0
    2fba:	bne.n	301e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3e2>
    2fbc:	ldr.w	fp, [sl, #16]
    2fc0:	cmp.w	fp, #0
    2fc4:	beq.n	301e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3e2>
    2fc6:	ldr.w	r2, [fp]
    2fca:	ldr	r2, [r2, #32]
    2fcc:	cmp	r2, r1
    2fce:	bne.n	3090 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x454>
    2fd0:	ldr.w	r2, [fp, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2fd4:	str.w	r3, [fp]
    2fd8:	ldr	r0, [pc, #176]	; (308c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x450>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2fda:	cbz	r2, 3016 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3da>
    2fdc:	ldr	r3, [r2, #16]
    2fde:	subs	r3, #1
    2fe0:	str	r3, [r2, #16]
    2fe2:	cbnz	r3, 3016 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3da>
    2fe4:	ldr.w	r2, [fp, #16]
    2fe8:	cbz	r2, 3016 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3da>
    2fea:	ldr	r3, [r2, #0]
    2fec:	ldr	r3, [r3, #32]
    2fee:	cmp	r3, r1
    2ff0:	bne.n	309c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x460>
    2ff2:	ldr	r1, [r2, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    2ff4:	str	r0, [r2, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    2ff6:	cbz	r1, 300e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3d2>
    2ff8:	ldr	r3, [r1, #16]
    2ffa:	subs	r3, #1
    2ffc:	str	r3, [r1, #16]
    2ffe:	cbnz	r3, 300e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3d2>
    3000:	ldr	r0, [r2, #16]
    3002:	cbz	r0, 300e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3d2>
    3004:	ldr	r3, [r0, #0]
    3006:	str	r2, [sp, #4]
    3008:	ldr	r3, [r3, #32]
    300a:	blx	r3
    300c:	ldr	r2, [sp, #4]
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    300e:	mov	r0, r2
    3010:	movs	r1, #20
    3012:	bl	effc <operator delete(void*, unsigned int)>
    3016:	mov	r0, fp
    3018:	movs	r1, #20
    301a:	bl	effc <operator delete(void*, unsigned int)>
    301e:	mov	r0, sl
    3020:	movs	r1, #20
    3022:	bl	effc <operator delete(void*, unsigned int)>
    3026:	mov	r0, r9
    3028:	movs	r1, #20
    302a:	bl	effc <operator delete(void*, unsigned int)>
    302e:	mov	r0, r8
    3030:	movs	r1, #20
    3032:	bl	effc <operator delete(void*, unsigned int)>
    3036:	mov	r0, r7
    3038:	movs	r1, #20
    303a:	bl	effc <operator delete(void*, unsigned int)>
    303e:	b.n	2dba <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x17e>
    }
  }

  void MTPStorage_SD::OpenFileByIndex(uint32_t i, uint32_t mode) 
  {
    if (open_file_ == i && mode_ == mode) return;
    3040:	ldr.w	r3, [r0, #236]	; 0xec
    3044:	cmp	r3, r2
    3046:	bne.w	2c4c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x10>
    if(sd_isOpen(file_)) file_.close();
    file_=sd_open(store,filename,mode);
    open_file_ = i;
    mode_ = mode;
    mtp_lock_storage(false);
  }
    304a:	add	sp, #292	; 0x124
    304c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    3050:	blx	r2
    3052:	b.n	2d00 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0xc4>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    3054:	blx	r2
    3056:	b.n	2d78 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x13c>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3058:	mov	r0, r7
    305a:	blx	r3
    305c:	b.n	2d98 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x15c>
    305e:	mov	r0, r7
    3060:	blx	r2
    3062:	b.n	2dba <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x17e>
    3064:	mov	r0, r9
    3066:	blx	r2
    3068:	b.n	302e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3f2>
    306a:	mov	r0, r9
    306c:	blx	r2
    306e:	b.n	2efe <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2c2>
    3070:	mov	r0, r8
    3072:	blx	r2
    3074:	b.n	3036 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3fa>
    3076:	mov	r0, r8
    3078:	blx	r2
    307a:	b.n	2f06 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2ca>
    307c:	mov	r0, sl
    307e:	blx	r2
    3080:	b.n	3026 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3ea>
    3082:	mov	r0, sl
    3084:	blx	r2
    3086:	b.n	2ef6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2ba>
    3088:	.word	0x00000f3d
    308c:	.word	0x000140dc
    3090:	mov	r0, fp
    3092:	blx	r2
    3094:	b.n	301e <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3e2>
    3096:	mov	r0, fp
    3098:	blx	r2
    309a:	b.n	2eee <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2b2>
    309c:	mov	r0, r2
    309e:	blx	r3
    30a0:	b.n	3016 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x3da>
    30a2:	mov	r0, r2
    30a4:	blx	r3
    30a6:	b.n	2ee6 <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)+0x2aa>

000030a8 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)>:
  {
    return ReadIndexRecord(handle).child;
  }

  void MTPStorage_SD::read(uint32_t handle, uint32_t pos, char* out, uint32_t bytes)
  {
    30a8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    30ac:	mov	r5, r0
    30ae:	sub	sp, #8
    30b0:	mov	r7, r2
    OpenFileByIndex(handle);
    30b2:	movs	r2, #0
  {
    return ReadIndexRecord(handle).child;
  }

  void MTPStorage_SD::read(uint32_t handle, uint32_t pos, char* out, uint32_t bytes)
  {
    30b4:	mov	r8, r3
    30b6:	ldr.w	r9, [sp, #40]	; 0x28
    OpenFileByIndex(handle);
    30ba:	bl	2c3c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)>
	}
	virtual bool truncate(uint64_t size=0) {
		return (f) ? f->truncate(size) : false;
	}
	virtual bool seek(uint64_t pos, int mode) {
		return (f) ? f->seek(pos, mode) : false;
    30be:	ldr.w	r4, [r5, #204]	; 0xcc
    30c2:	cmp	r4, #0
    30c4:	beq.n	319c <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xf4>
    30c6:	ldr	r0, [r4, #0]
    30c8:	ldr	r2, [pc, #308]	; (3200 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x158>)
    30ca:	ldr	r6, [r0, #52]	; 0x34
    30cc:	cmp	r6, r2
    30ce:	mov.w	r3, #0
    30d2:	bne.n	31cc <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x124>
    30d4:	ldr	r1, [r4, #16]
    30d6:	cmp	r1, #0
    30d8:	beq.n	3194 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xec>
    30da:	ldr	r2, [r1, #0]
    30dc:	ldr.w	sl, [r2, #52]	; 0x34
    30e0:	cmp	sl, r6
    30e2:	bne.n	31d6 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x12e>
    30e4:	ldr.w	lr, [r1, #16]
    30e8:	cmp.w	lr, #0
    30ec:	beq.n	31a2 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xfa>
    30ee:	ldr.w	r2, [lr]
    30f2:	ldr	r6, [r2, #52]	; 0x34
    30f4:	cmp	r6, sl
    30f6:	bne.n	31e0 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x138>
    30f8:	ldr.w	lr, [lr, #16]
    30fc:	cmp.w	lr, #0
    3100:	beq.n	31a2 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xfa>
    3102:	ldr.w	r2, [lr]
    3106:	ldr.w	sl, [r2, #52]	; 0x34
    310a:	cmp	sl, r6
    310c:	bne.n	31ea <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x142>
    310e:	ldr.w	lr, [lr, #16]
    3112:	cmp.w	lr, #0
    3116:	beq.n	31a2 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xfa>
    3118:	ldr.w	r3, [lr]
    311c:	ldr	r6, [r3, #52]	; 0x34
    311e:	cmp	r6, sl
    3120:	bne.n	31f4 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x14c>
    3122:	ldr.w	r6, [lr, #16]
    3126:	cmp	r6, #0
    3128:	beq.n	31a2 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xfa>
    312a:	ldr	r1, [r6, #0]
    312c:	movs	r3, #0
    312e:	str	r3, [sp, #0]
    3130:	mov	r2, r7
    3132:	mov	r0, r6
    3134:	ldr	r1, [r1, #52]	; 0x34
    3136:	blx	r1
	unsigned int getRefcount() { // testing only
		return refcount;
	}
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
    3138:	ldr.w	r4, [r5, #204]	; 0xcc
    313c:	cmp	r4, #0
    313e:	beq.n	319c <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xf4>
    3140:	ldr	r2, [r4, #0]
    3142:	ldr	r3, [pc, #192]	; (3204 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x15c>)
    3144:	ldr	r5, [r2, #40]	; 0x28
    3146:	cmp	r5, r3
    3148:	bne.n	31ae <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x106>
    314a:	ldr	r0, [r4, #16]
    314c:	cbz	r0, 319c <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xf4>
    314e:	ldr	r2, [r0, #0]
    3150:	ldr	r4, [r2, #40]	; 0x28
    3152:	cmp	r4, r3
    3154:	bne.n	31be <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x116>
    3156:	ldr	r0, [r0, #16]
    3158:	cbz	r0, 319c <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xf4>
    315a:	ldr	r2, [r0, #0]
    315c:	ldr	r4, [r2, #40]	; 0x28
    315e:	cmp	r4, r3
    3160:	bne.n	31be <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x116>
    3162:	ldr	r0, [r0, #16]
    3164:	cbz	r0, 319c <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xf4>
    3166:	ldr	r2, [r0, #0]
    3168:	ldr	r4, [r2, #40]	; 0x28
    316a:	cmp	r4, r3
    316c:	bne.n	31be <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x116>
    316e:	ldr	r0, [r0, #16]
    3170:	cbz	r0, 319c <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xf4>
    3172:	ldr	r2, [r0, #0]
    3174:	ldr	r4, [r2, #40]	; 0x28
    3176:	cmp	r4, r3
    3178:	bne.n	31be <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x116>
    317a:	ldr	r0, [r0, #16]
    317c:	cbz	r0, 319c <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xf4>
    317e:	ldr	r2, [r0, #0]
    3180:	ldr	r4, [r2, #40]	; 0x28
    3182:	cmp	r4, r3
    3184:	bne.n	31be <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x116>
    3186:	ldr	r0, [r0, #16]
    3188:	cbz	r0, 319c <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xf4>
    318a:	ldr	r3, [r0, #0]
    318c:	mov	r2, r9
    318e:	mov	r1, r8
    3190:	ldr	r3, [r3, #40]	; 0x28
    3192:	b.n	31b6 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x10e>
    3194:	ldr	r5, [r0, #40]	; 0x28
    3196:	ldr	r3, [pc, #108]	; (3204 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x15c>)
    3198:	cmp	r5, r3
    319a:	bne.n	31ae <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x106>
    mtp_lock_storage(true);
    file_.seek(pos);
    file_.read(out,bytes);
    mtp_lock_storage(false);
  }
    319c:	add	sp, #8
    319e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    31a2:	ldr	r5, [r0, #40]	; 0x28
    31a4:	ldr	r3, [pc, #92]	; (3204 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x15c>)
    31a6:	cmp	r5, r3
    31a8:	bne.n	31ae <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x106>
    31aa:	mov	r0, r1
    31ac:	b.n	314e <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0xa6>
    31ae:	mov	r2, r9
    31b0:	mov	r1, r8
    31b2:	mov	r0, r4
    31b4:	mov	r3, r5
    31b6:	add	sp, #8
    31b8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    31bc:	bx	r3
    31be:	mov	r2, r9
    31c0:	mov	r1, r8
    31c2:	mov	r3, r4
    31c4:	add	sp, #8
    31c6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    31ca:	bx	r3
	}
	virtual bool truncate(uint64_t size=0) {
		return (f) ? f->truncate(size) : false;
	}
	virtual bool seek(uint64_t pos, int mode) {
		return (f) ? f->seek(pos, mode) : false;
    31cc:	str	r3, [sp, #0]
    31ce:	mov	r2, r7
    31d0:	mov	r0, r4
    31d2:	blx	r6
    31d4:	b.n	3138 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x90>
    31d6:	str	r3, [sp, #0]
    31d8:	mov	r2, r7
    31da:	mov	r0, r1
    31dc:	blx	sl
    31de:	b.n	3138 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x90>
    31e0:	str	r3, [sp, #0]
    31e2:	mov	r2, r7
    31e4:	mov	r0, lr
    31e6:	blx	r6
    31e8:	b.n	3138 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x90>
    31ea:	str	r3, [sp, #0]
    31ec:	mov	r2, r7
    31ee:	mov	r0, lr
    31f0:	blx	sl
    31f2:	b.n	3138 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x90>
    31f4:	movs	r3, #0
    31f6:	mov	r2, r7
    31f8:	mov	r0, lr
    31fa:	str	r3, [sp, #0]
    31fc:	blx	r6
    31fe:	b.n	3138 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x90>
    3200:	.word	0x000004c9
    3204:	.word	0x0000047d

00003208 <MTPStorage_SD::Create(unsigned long, unsigned long, bool, char const*)>:
    }
    return 1;
  }

  uint32_t MTPStorage_SD::Create(uint32_t store, uint32_t parent,  bool folder, const char* filename)
  {
    3208:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint32_t ret;
    if (parent == 0xFFFFFFFFUL) parent = store;
    320c:	cmp.w	r2, #4294967295
    3210:	ite	ne
    3212:	movne	r6, r2
    3214:	moveq	r6, r1
    }
    return 1;
  }

  uint32_t MTPStorage_SD::Create(uint32_t store, uint32_t parent,  bool folder, const char* filename)
  {
    3216:	sub.w	sp, sp, #800	; 0x320
    321a:	mov	r4, r0
    uint32_t ret;
    if (parent == 0xFFFFFFFFUL) parent = store;
    Record p = ReadIndexRecord(parent);
    321c:	mov	r2, r6
    }
    return 1;
  }

  uint32_t MTPStorage_SD::Create(uint32_t store, uint32_t parent,  bool folder, const char* filename)
  {
    321e:	mov	r7, r1
    uint32_t ret;
    if (parent == 0xFFFFFFFFUL) parent = store;
    Record p = ReadIndexRecord(parent);
    3220:	mov	r1, r0
    3222:	add	r0, sp, #256	; 0x100
    }
    return 1;
  }

  uint32_t MTPStorage_SD::Create(uint32_t store, uint32_t parent,  bool folder, const char* filename)
  {
    3224:	mov	r8, r3
    uint32_t ret;
    if (parent == 0xFFFFFFFFUL) parent = store;
    Record p = ReadIndexRecord(parent);
    3226:	bl	26c8 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    Record r;
    strlcpy(r.name, filename,MAX_FILENAME_LEN);
    322a:	ldr	r1, [sp, #824]	; 0x338
    322c:	mov.w	r2, #256	; 0x100
    3230:	add	r0, sp, #544	; 0x220
    3232:	bl	10ba0 <strlcpy>
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    3236:	ldr.w	r5, [r4, #244]	; 0xf4
    uint32_t ret;
    if (parent == 0xFFFFFFFFUL) parent = store;
    Record p = ReadIndexRecord(parent);
    Record r;
    strlcpy(r.name, filename,MAX_FILENAME_LEN);
    r.store = p.store;
    323a:	ldrh.w	r3, [sp, #270]	; 0x10e
    r.parent = parent;
    r.child = 0;
    r.sibling = p.child;
    323e:	ldr	r2, [sp, #260]	; 0x104
    uint32_t ret;
    if (parent == 0xFFFFFFFFUL) parent = store;
    Record p = ReadIndexRecord(parent);
    Record r;
    strlcpy(r.name, filename,MAX_FILENAME_LEN);
    r.store = p.store;
    3240:	strh.w	r3, [sp, #542]	; 0x21e
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    3244:	adds	r1, r5, #1
    Record p = ReadIndexRecord(parent);
    Record r;
    strlcpy(r.name, filename,MAX_FILENAME_LEN);
    r.store = p.store;
    r.parent = parent;
    r.child = 0;
    3246:	movs	r3, #0
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    3248:	str.w	r1, [r4, #244]	; 0xf4
    Record p = ReadIndexRecord(parent);
    Record r;
    strlcpy(r.name, filename,MAX_FILENAME_LEN);
    r.store = p.store;
    r.parent = parent;
    r.child = 0;
    324c:	str	r3, [sp, #532]	; 0x214
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    WriteIndexRecord(new_record, r);
    324e:	mov	r1, r5
    r.parent = parent;
    r.child = 0;
    r.sibling = p.child;
    r.isdir = folder;
    // New folder is empty, scanned = true.
    r.scanned = 1;
    3250:	movs	r3, #1
    Record r;
    strlcpy(r.name, filename,MAX_FILENAME_LEN);
    r.store = p.store;
    r.parent = parent;
    r.child = 0;
    r.sibling = p.child;
    3252:	str	r2, [sp, #536]	; 0x218
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    WriteIndexRecord(new_record, r);
    3254:	mov	r0, r4
    3256:	add	r2, sp, #528	; 0x210
    if (parent == 0xFFFFFFFFUL) parent = store;
    Record p = ReadIndexRecord(parent);
    Record r;
    strlcpy(r.name, filename,MAX_FILENAME_LEN);
    r.store = p.store;
    r.parent = parent;
    3258:	str	r6, [sp, #528]	; 0x210
    r.child = 0;
    r.sibling = p.child;
    r.isdir = folder;
    325a:	strb.w	r8, [sp, #540]	; 0x21c
    // New folder is empty, scanned = true.
    r.scanned = 1;
    325e:	strb.w	r3, [sp, #541]	; 0x21d
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    WriteIndexRecord(new_record, r);
    3262:	bl	24e8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    r.sibling = p.child;
    r.isdir = folder;
    // New folder is empty, scanned = true.
    r.scanned = 1;
    ret = p.child = AppendIndexRecord(r);
    WriteIndexRecord(parent, p);
    3266:	mov	r1, r6
    3268:	add	r2, sp, #256	; 0x100
    326a:	mov	r0, r4
    r.child = 0;
    r.sibling = p.child;
    r.isdir = folder;
    // New folder is empty, scanned = true.
    r.scanned = 1;
    ret = p.child = AppendIndexRecord(r);
    326c:	str	r5, [sp, #260]	; 0x104
    WriteIndexRecord(parent, p);
    326e:	bl	24e8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    if (folder) 
    3272:	cmp.w	r8, #0
    3276:	bne.n	328c <MTPStorage_SD::Create(unsigned long, unsigned long, bool, char const*)+0x84>
      sd_mkdir(store,filename);
      mtp_lock_storage(false);
    } 
    else 
    {
      OpenFileByIndex(ret, FILE_WRITE_BEGIN);
    3278:	mov	r0, r4
    327a:	movs	r2, #2
    327c:	mov	r1, r5
    327e:	bl	2c3c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)>
      Serial.print(store); Serial.print(" "); 
      Serial.print(parent); Serial.print(" "); 
      Serial.println(filename);
    #endif
    return ret;
  }
    3282:	mov	r0, r5
    3284:	add.w	sp, sp, #800	; 0x320
    3288:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ret = p.child = AppendIndexRecord(r);
    WriteIndexRecord(parent, p);
    if (folder) 
    {
      char filename[MAX_FILENAME_LEN];
      ConstructFilename(ret, filename, MAX_FILENAME_LEN);
    328c:	mov	r0, r4
    bool sd_mkdir(uint32_t store, char *filename) {  return sdx[store]->mkdir(filename);  }
    328e:	add.w	r4, r4, r7, lsl #2
    3292:	mov	r2, sp
    3294:	mov	r1, r5
    3296:	mov.w	r3, #256	; 0x100
    329a:	bl	2b28 <MTPStorage_SD::ConstructFilename(int, char*, int)>
    329e:	ldr	r0, [r4, #88]	; 0x58
    32a0:	ldr	r3, [r0, #0]
    32a2:	mov	r1, sp
    32a4:	ldr	r3, [r3, #8]
    32a6:	blx	r3
      Serial.print(store); Serial.print(" "); 
      Serial.print(parent); Serial.print(" "); 
      Serial.println(filename);
    #endif
    return ret;
  }
    32a8:	mov	r0, r5
    32aa:	add.w	sp, sp, #800	; 0x320
    32ae:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    32b2:	nop

000032b4 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)>:
      AppendIndexRecord(r);
    }
  }

  void MTPStorage_SD::ScanDir(uint32_t store, uint32_t i) 
  { if (i == 0xFFFFFFFFUL) i = store;
    32b4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    32b8:	cmp.w	r2, #4294967295
    32bc:	ite	ne
    32be:	movne	r6, r2
    32c0:	moveq	r6, r1
    32c2:	sub.w	sp, sp, #564	; 0x234
    
    Record record = ReadIndexRecord(i);
    32c6:	mov	r1, r0
      AppendIndexRecord(r);
    }
  }

  void MTPStorage_SD::ScanDir(uint32_t store, uint32_t i) 
  { if (i == 0xFFFFFFFFUL) i = store;
    32c8:	mov	r4, r0
    
    Record record = ReadIndexRecord(i);
    32ca:	mov	r2, r6
    32cc:	add	r0, sp, #16
    32ce:	bl	26c8 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    if (record.isdir && !record.scanned) {
    32d2:	ldrb.w	r3, [sp, #28]
    32d6:	cbz	r3, 32de <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x2a>
    32d8:	ldrb.w	r2, [sp, #29]
    32dc:	cbz	r2, 32e6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x32>
      }
      record.scanned = true;
      record.child = sibling;
      WriteIndexRecord(i, record);
    }
  }
    32de:	add.w	sp, sp, #564	; 0x234
    32e2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  void MTPStorage_SD::ScanDir(uint32_t store, uint32_t i) 
  { if (i == 0xFFFFFFFFUL) i = store;
    
    Record record = ReadIndexRecord(i);
    if (record.isdir && !record.scanned) {
      OpenFileByIndex(i);
    32e6:	mov	r0, r4
    32e8:	mov	r1, r6
    32ea:	bl	2c3c <MTPStorage_SD::OpenFileByIndex(unsigned long, unsigned long)>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    32ee:	ldr.w	r0, [r4, #204]	; 0xcc
    32f2:	cmp	r0, #0
    32f4:	beq.n	32de <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x2a>
    32f6:	ldr	r3, [r0, #0]
    32f8:	ldr.w	r8, [pc, #892]	; 3678 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3c4>
    32fc:	ldr	r3, [r3, #68]	; 0x44
    32fe:	cmp	r3, r8
    3300:	bne.n	33bc <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x108>
    3302:	ldr	r0, [r0, #16]
    3304:	cmp	r0, #0
    3306:	beq.n	32de <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x2a>
    3308:	ldr	r3, [r0, #0]
    330a:	ldr	r3, [r3, #68]	; 0x44
    330c:	cmp	r3, r8
    330e:	bne.n	33bc <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x108>
    3310:	ldr	r0, [r0, #16]
    3312:	cmp	r0, #0
    3314:	beq.n	32de <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x2a>
    3316:	ldr	r3, [r0, #0]
    3318:	ldr	r3, [r3, #68]	; 0x44
    331a:	cmp	r3, r8
    331c:	bne.n	33bc <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x108>
    331e:	ldr	r0, [r0, #16]
    3320:	cmp	r0, #0
    3322:	beq.n	32de <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x2a>
    3324:	ldr	r3, [r0, #0]
    3326:	ldr	r3, [r3, #68]	; 0x44
    3328:	cmp	r3, r8
    332a:	bne.n	33bc <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x108>
    332c:	ldr	r0, [r0, #16]
    332e:	cmp	r0, #0
    3330:	beq.n	32de <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x2a>
    3332:	ldr	r3, [r0, #0]
    3334:	ldr	r3, [r3, #68]	; 0x44
    3336:	cmp	r3, r8
    3338:	bne.n	33bc <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x108>
    333a:	ldr	r0, [r0, #16]
    333c:	cmp	r0, #0
    333e:	beq.n	32de <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x2a>
    3340:	ldr	r3, [r0, #0]
    3342:	ldr	r3, [r3, #68]	; 0x44
    3344:	blx	r3
      if (!sd_isOpen(file_)) return;
    3346:	cmp	r0, #0
    3348:	beq.n	32de <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x2a>
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
	}
	File(const File &file) {
    334a:	ldr.w	r9, [pc, #804]	; 3670 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3bc>
    334e:	ldr.w	fp, [pc, #812]	; 367c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3c8>
    3352:	movs	r5, #0
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
	}
	virtual File openNextFile(uint8_t mode=0) {
		return (f) ? f->openNextFile(mode) : *this;
    3354:	ldr.w	r1, [r4, #204]	; 0xcc
    3358:	cmp	r1, #0
    335a:	beq.n	33c0 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x10c>
    335c:	ldr	r3, [r1, #0]
    335e:	ldr	r3, [r3, #80]	; 0x50
    3360:	cmp	r3, fp
    3362:	bne.w	3876 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5c2>
    3366:	ldr	r1, [r1, #16]
    3368:	cbz	r1, 33c0 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x10c>
    336a:	ldr	r3, [r1, #0]
    336c:	ldr	r3, [r3, #80]	; 0x50
    336e:	cmp	r3, fp
    3370:	bne.w	3876 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5c2>
    3374:	ldr	r1, [r1, #16]
    3376:	cbz	r1, 33c0 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x10c>
    3378:	ldr	r3, [r1, #0]
    337a:	ldr	r3, [r3, #80]	; 0x50
    337c:	cmp	r3, fp
    337e:	bne.w	3876 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5c2>
    3382:	ldr	r1, [r1, #16]
    3384:	cbz	r1, 33c0 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x10c>
    3386:	ldr	r3, [r1, #0]
    3388:	ldr	r3, [r3, #80]	; 0x50
    338a:	cmp	r3, fp
    338c:	bne.w	3876 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5c2>
    3390:	ldr	r1, [r1, #16]
    3392:	cbz	r1, 33c0 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x10c>
    3394:	ldr	r3, [r1, #0]
    3396:	ldr	r3, [r3, #80]	; 0x50
    3398:	cmp	r3, fp
    339a:	bne.w	3876 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5c2>
    339e:	ldr	r1, [r1, #16]
    33a0:	cbz	r1, 33c0 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x10c>
    33a2:	ldr	r3, [r1, #0]
    33a4:	ldr	r3, [r3, #80]	; 0x50
    33a6:	cmp	r3, fp
    33a8:	bne.w	3876 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5c2>
    33ac:	ldr	r1, [r1, #16]
    33ae:	cbz	r1, 33c0 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x10c>
    33b0:	ldr	r3, [r1, #0]
    33b2:	movs	r2, #0
    33b4:	ldr	r3, [r3, #80]	; 0x50
    33b6:	add	r0, sp, #288	; 0x120
    33b8:	blx	r3
    33ba:	b.n	33d6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x122>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    33bc:	blx	r3
    33be:	b.n	3346 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x92>
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
    33c0:	movs	r3, #0
    33c2:	mov.w	r2, #1000	; 0x3e8
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
	}
	File(const File &file) {
    33c6:	str.w	r9, [sp, #288]	; 0x120
    33ca:	strb.w	r3, [sp, #292]	; 0x124
    33ce:	strb.w	r3, [sp, #300]	; 0x12c
		//Serial.println("File copy constructor");
		//static int copycount=0;
		//if (++copycount > 20) while (1) ;
		f = file.f;
    33d2:	str	r3, [sp, #304]	; 0x130
    33d4:	str	r2, [sp, #296]	; 0x128
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    33d6:	ldr.w	r2, [r4, #224]	; 0xe0
    33da:	cmp	r2, #0
    33dc:	beq.n	3472 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1be>
    33de:	ldr	r3, [r2, #16]
    33e0:	subs	r3, #1
    33e2:	str	r3, [r2, #16]
    33e4:	cmp	r3, #0
    33e6:	bne.n	3472 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1be>
    33e8:	ldr.w	r7, [r4, #224]	; 0xe0
    33ec:	cmp	r7, #0
    33ee:	beq.n	3472 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1be>
    33f0:	ldr	r3, [r7, #0]
    33f2:	ldr	r0, [pc, #632]	; (366c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b8>)
    33f4:	ldr	r3, [r3, #32]
    33f6:	cmp	r3, r0
    33f8:	bne.w	3898 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5e4>
    33fc:	ldr	r2, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    33fe:	str.w	r9, [r7]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3402:	cbz	r2, 346a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1b6>
    3404:	ldr	r3, [r2, #16]
    3406:	subs	r3, #1
    3408:	str	r3, [r2, #16]
    340a:	cbnz	r3, 346a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1b6>
    340c:	ldr.w	sl, [r7, #16]
    3410:	cmp.w	sl, #0
    3414:	beq.n	346a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1b6>
    3416:	ldr.w	r3, [sl]
    341a:	ldr	r3, [r3, #32]
    341c:	cmp	r3, r0
    341e:	bne.w	3a66 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7b2>
    3422:	ldr.w	r2, [sl, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3426:	ldr	r3, [pc, #584]	; (3670 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3bc>)
    3428:	str.w	r3, [sl]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    342c:	cbz	r2, 3462 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1ae>
    342e:	ldr	r3, [r2, #16]
    3430:	subs	r3, #1
    3432:	str	r3, [r2, #16]
    3434:	cbnz	r3, 3462 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1ae>
    3436:	ldr.w	r3, [sl, #16]
    343a:	cbz	r3, 3462 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1ae>
    343c:	ldr	r2, [r3, #0]
    343e:	ldr	r2, [r2, #32]
    3440:	cmp	r2, r0
    3442:	bne.w	3a78 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7c4>
    3446:	ldr	r1, [r3, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3448:	str.w	r9, [r3]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    344c:	cbz	r1, 345a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1a6>
    344e:	ldr	r2, [r1, #16]
    3450:	subs	r2, #1
    3452:	str	r2, [r1, #16]
    3454:	cmp	r2, #0
    3456:	beq.w	38b0 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5fc>
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    345a:	mov	r0, r3
    345c:	movs	r1, #20
    345e:	bl	effc <operator delete(void*, unsigned int)>
    3462:	mov	r0, sl
    3464:	movs	r1, #20
    3466:	bl	effc <operator delete(void*, unsigned int)>
    346a:	mov	r0, r7
    346c:	movs	r1, #20
    346e:	bl	effc <operator delete(void*, unsigned int)>
	File& operator = (const File &file) {
		//Serial.println("File assignment");
		//static int assigncount=0;
		//if (++assigncount > 20) while (1) ;
		invalidate();
		f = file.f;
    3472:	ldr	r3, [sp, #304]	; 0x130
    3474:	str.w	r3, [r4, #224]	; 0xe0
		if (f) f->refcount++;
    3478:	cmp	r3, #0
    347a:	beq.n	351e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x26a>
    347c:	ldr	r2, [r3, #16]
    347e:	adds	r2, #1
    3480:	str	r2, [r3, #16]
    3482:	ldr	r2, [sp, #304]	; 0x130
		return *this;
	}
	virtual ~File() {
    3484:	str.w	r9, [sp, #288]	; 0x120
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3488:	cmp	r2, #0
    348a:	beq.n	351e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x26a>
    348c:	ldr	r3, [r2, #16]
    348e:	subs	r3, #1
    3490:	str	r3, [r2, #16]
    3492:	cmp	r3, #0
    3494:	bne.n	351e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x26a>
    3496:	ldr	r7, [sp, #304]	; 0x130
    3498:	cmp	r7, #0
    349a:	beq.n	351e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x26a>
    349c:	ldr	r3, [r7, #0]
    349e:	ldr	r0, [pc, #460]	; (366c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b8>)
    34a0:	ldr	r3, [r3, #32]
    34a2:	cmp	r3, r0
    34a4:	bne.w	3892 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5de>
    34a8:	ldr	r2, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    34aa:	ldr	r3, [pc, #452]	; (3670 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3bc>)
    34ac:	str	r3, [r7, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    34ae:	cbz	r2, 3516 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x262>
    34b0:	ldr	r3, [r2, #16]
    34b2:	subs	r3, #1
    34b4:	str	r3, [r2, #16]
    34b6:	cbnz	r3, 3516 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x262>
    34b8:	ldr.w	sl, [r7, #16]
    34bc:	cmp.w	sl, #0
    34c0:	beq.n	3516 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x262>
    34c2:	ldr.w	r3, [sl]
    34c6:	ldr	r3, [r3, #32]
    34c8:	cmp	r3, r0
    34ca:	bne.w	3a6c <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7b8>
    34ce:	ldr.w	r2, [sl, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    34d2:	ldr	r3, [pc, #412]	; (3670 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3bc>)
    34d4:	str.w	r3, [sl]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    34d8:	cbz	r2, 350e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x25a>
    34da:	ldr	r3, [r2, #16]
    34dc:	subs	r3, #1
    34de:	str	r3, [r2, #16]
    34e0:	cbnz	r3, 350e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x25a>
    34e2:	ldr.w	r3, [sl, #16]
    34e6:	cbz	r3, 350e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x25a>
    34e8:	ldr	r2, [r3, #0]
    34ea:	ldr	r2, [r2, #32]
    34ec:	cmp	r2, r0
    34ee:	bne.w	3a72 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7be>
    34f2:	ldr	r1, [r3, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    34f4:	str.w	r9, [r3]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    34f8:	cbz	r1, 3506 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x252>
    34fa:	ldr	r2, [r1, #16]
    34fc:	subs	r2, #1
    34fe:	str	r2, [r1, #16]
    3500:	cmp	r2, #0
    3502:	beq.w	398e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6da>
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    3506:	mov	r0, r3
    3508:	movs	r1, #20
    350a:	bl	effc <operator delete(void*, unsigned int)>
    350e:	mov	r0, sl
    3510:	movs	r1, #20
    3512:	bl	effc <operator delete(void*, unsigned int)>
    3516:	mov	r0, r7
    3518:	movs	r1, #20
    351a:	bl	effc <operator delete(void*, unsigned int)>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    351e:	ldr.w	r0, [r4, #224]	; 0xe0
    3522:	cmp	r0, #0
    3524:	beq.w	364e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
    3528:	ldr	r3, [r0, #0]
    352a:	ldr	r3, [r3, #68]	; 0x44
    352c:	cmp	r3, r8
    352e:	bne.w	3668 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b4>
    3532:	ldr	r0, [r0, #16]
    3534:	cmp	r0, #0
    3536:	beq.w	364e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
    353a:	ldr	r3, [r0, #0]
    353c:	ldr	r3, [r3, #68]	; 0x44
    353e:	cmp	r3, r8
    3540:	bne.w	3668 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b4>
    3544:	ldr	r0, [r0, #16]
    3546:	cmp	r0, #0
    3548:	beq.w	364e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
    354c:	ldr	r3, [r0, #0]
    354e:	ldr	r3, [r3, #68]	; 0x44
    3550:	cmp	r3, r8
    3552:	bne.w	3668 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b4>
    3556:	ldr	r0, [r0, #16]
    3558:	cmp	r0, #0
    355a:	beq.n	364e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
    355c:	ldr	r3, [r0, #0]
    355e:	ldr	r3, [r3, #68]	; 0x44
    3560:	cmp	r3, r8
    3562:	bne.w	3668 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b4>
    3566:	ldr	r0, [r0, #16]
    3568:	cmp	r0, #0
    356a:	beq.n	364e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
    356c:	ldr	r3, [r0, #0]
    356e:	ldr	r3, [r3, #68]	; 0x44
    3570:	cmp	r3, r8
    3572:	bne.n	3668 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b4>
    3574:	ldr	r0, [r0, #16]
    3576:	cmp	r0, #0
    3578:	beq.n	364e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
    357a:	ldr	r3, [r0, #0]
    357c:	ldr	r3, [r3, #68]	; 0x44
    357e:	cmp	r3, r8
    3580:	bne.n	3668 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b4>
    3582:	ldr	r0, [r0, #16]
    3584:	cmp	r0, #0
    3586:	beq.n	364e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
    3588:	ldr	r3, [r0, #0]
    358a:	ldr	r3, [r3, #68]	; 0x44
    358c:	cmp	r3, r8
    358e:	bne.n	3668 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b4>
    3590:	ldr	r0, [r0, #16]
    3592:	cmp	r0, #0
    3594:	beq.n	364e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
    3596:	ldr	r3, [r0, #0]
    3598:	ldr	r3, [r3, #68]	; 0x44
    359a:	cmp	r3, r8
    359c:	bne.n	3668 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3b4>
    359e:	ldr	r0, [r0, #16]
    35a0:	cmp	r0, #0
    35a2:	beq.n	364e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
    35a4:	ldr	r3, [r0, #0]
    35a6:	ldr	r3, [r3, #68]	; 0x44
    35a8:	blx	r3
      int sibling = 0;
      while (true) 
      { mtp_lock_storage(true);
        child_=file_.openNextFile();
        mtp_lock_storage(false);
        if(!sd_isOpen(child_)) break;
    35aa:	cmp	r0, #0
    35ac:	beq.n	364e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x39a>
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
    35ae:	ldr.w	r3, [r4, #224]	; 0xe0

        Record r;
        r.store = record.store;
    35b2:	ldrh.w	r2, [sp, #30]
        r.parent = i;
    35b6:	str	r6, [sp, #288]	; 0x120
        r.sibling = sibling;
    35b8:	str	r5, [sp, #296]	; 0x128
        child_=file_.openNextFile();
        mtp_lock_storage(false);
        if(!sd_isOpen(child_)) break;

        Record r;
        r.store = record.store;
    35ba:	strh.w	r2, [sp, #302]	; 0x12e
    35be:	cmp	r3, #0
    35c0:	beq.w	37ea <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x536>
    35c4:	ldr	r1, [r3, #0]
    35c6:	ldr	r2, [pc, #172]	; (3674 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3c0>)
    35c8:	ldr	r1, [r1, #76]	; 0x4c
    35ca:	cmp	r1, r2
    35cc:	bne.n	3680 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3cc>
    35ce:	ldr	r0, [r3, #16]
    35d0:	cmp	r0, #0
    35d2:	beq.w	37ea <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x536>
    35d6:	ldr	r1, [r0, #0]
    35d8:	ldr	r1, [r1, #76]	; 0x4c
    35da:	cmp	r1, r2
    35dc:	bne.n	3682 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3ce>
    35de:	ldr	r0, [r0, #16]
    35e0:	cmp	r0, #0
    35e2:	beq.w	37ea <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x536>
    35e6:	ldr	r1, [r0, #0]
    35e8:	ldr	r1, [r1, #76]	; 0x4c
    35ea:	cmp	r1, r2
    35ec:	bne.n	3682 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3ce>
    35ee:	ldr	r0, [r0, #16]
    35f0:	cmp	r0, #0
    35f2:	beq.w	37ea <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x536>
    35f6:	ldr	r1, [r0, #0]
    35f8:	ldr	r1, [r1, #76]	; 0x4c
    35fa:	cmp	r1, r2
    35fc:	bne.n	3682 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3ce>
    35fe:	ldr	r0, [r0, #16]
    3600:	cmp	r0, #0
    3602:	beq.w	37ea <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x536>
    3606:	ldr	r1, [r0, #0]
    3608:	ldr	r1, [r1, #76]	; 0x4c
    360a:	cmp	r1, r2
    360c:	bne.n	3682 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3ce>
    360e:	ldr	r0, [r0, #16]
    3610:	cmp	r0, #0
    3612:	beq.w	37ea <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x536>
    3616:	ldr	r1, [r0, #0]
    3618:	ldr	r1, [r1, #76]	; 0x4c
    361a:	cmp	r1, r2
    361c:	bne.n	3682 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3ce>
    361e:	ldr	r0, [r0, #16]
    3620:	cmp	r0, #0
    3622:	beq.w	37ea <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x536>
    3626:	ldr	r1, [r0, #0]
    3628:	ldr	r1, [r1, #76]	; 0x4c
    362a:	cmp	r1, r2
    362c:	bne.n	3682 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3ce>
    362e:	ldr	r0, [r0, #16]
    3630:	cmp	r0, #0
    3632:	beq.w	37ea <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x536>
    3636:	ldr	r1, [r0, #0]
    3638:	ldr	r1, [r1, #76]	; 0x4c
    363a:	cmp	r1, r2
    363c:	bne.n	3682 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3ce>
    363e:	ldr	r0, [r0, #16]
    3640:	cmp	r0, #0
    3642:	beq.w	37ea <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x536>
    3646:	ldr	r3, [r0, #0]
    3648:	ldr	r3, [r3, #76]	; 0x4c
    364a:	blx	r3
    364c:	b.n	3684 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3d0>
        r.scanned = false;
        sd_getName(child_,r.name, MAX_FILENAME_LEN);
        sibling = AppendIndexRecord(r);
        child_.close();
      }
      record.scanned = true;
    364e:	movs	r3, #1
      record.child = sibling;
      WriteIndexRecord(i, record);
    3650:	mov	r1, r6
    3652:	mov	r0, r4
    3654:	add	r2, sp, #16
        sd_getName(child_,r.name, MAX_FILENAME_LEN);
        sibling = AppendIndexRecord(r);
        child_.close();
      }
      record.scanned = true;
      record.child = sibling;
    3656:	str	r5, [sp, #20]
        r.scanned = false;
        sd_getName(child_,r.name, MAX_FILENAME_LEN);
        sibling = AppendIndexRecord(r);
        child_.close();
      }
      record.scanned = true;
    3658:	strb.w	r3, [sp, #29]
      record.child = sibling;
      WriteIndexRecord(i, record);
    365c:	bl	24e8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    }
  }
    3660:	add.w	sp, sp, #564	; 0x234
    3664:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    3668:	blx	r3
    366a:	b.n	35aa <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x2f6>
    366c:	.word	0x00000f3d
    3670:	.word	0x000140dc
    3674:	.word	0x0000052d
    3678:	.word	0x0000050d
    367c:	.word	0x00000539
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
    3680:	mov	r0, r3
    3682:	blx	r1

        Record r;
        r.store = record.store;
        r.parent = i;
        r.sibling = sibling;
        r.isdir = child_.isDirectory();
    3684:	strb.w	r0, [sp, #300]	; 0x12c
    3688:	ldr.w	r3, [r4, #224]	; 0xe0
        r.child = r.isdir ? 0 : (uint32_t) child_.size();
    368c:	cmp	r0, #0
    368e:	beq.w	37f0 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x53c>
    3692:	movs	r0, #0
        r.scanned = false;
    3694:	movs	r2, #0
        Record r;
        r.store = record.store;
        r.parent = i;
        r.sibling = sibling;
        r.isdir = child_.isDirectory();
        r.child = r.isdir ? 0 : (uint32_t) child_.size();
    3696:	str	r0, [sp, #292]	; 0x124
        r.scanned = false;
    3698:	strb.w	r2, [sp, #301]	; 0x12d
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
    369c:	cmp	r3, #0
    369e:	beq.w	3872 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5be>
    36a2:	ldr	r1, [r3, #0]
    36a4:	ldr	r2, [pc, #504]	; (38a0 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5ec>)
    36a6:	ldr	r1, [r1, #72]	; 0x48
    36a8:	cmp	r1, r2
    36aa:	bne.w	386a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5b6>
    36ae:	ldr	r0, [r3, #16]
    36b0:	cmp	r0, #0
    36b2:	beq.w	3872 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5be>
    36b6:	ldr	r3, [r0, #0]
    36b8:	ldr	r3, [r3, #72]	; 0x48
    36ba:	cmp	r3, r2
    36bc:	bne.n	3730 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x47c>
    36be:	ldr	r0, [r0, #16]
    36c0:	cmp	r0, #0
    36c2:	beq.w	3872 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5be>
    36c6:	ldr	r3, [r0, #0]
    36c8:	ldr	r3, [r3, #72]	; 0x48
    36ca:	cmp	r3, r2
    36cc:	bne.n	3730 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x47c>
    36ce:	ldr	r0, [r0, #16]
    36d0:	cmp	r0, #0
    36d2:	beq.w	3872 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5be>
    36d6:	ldr	r3, [r0, #0]
    36d8:	ldr	r3, [r3, #72]	; 0x48
    36da:	cmp	r3, r2
    36dc:	bne.n	3730 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x47c>
    36de:	ldr	r0, [r0, #16]
    36e0:	cmp	r0, #0
    36e2:	beq.w	3872 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5be>
    36e6:	ldr	r3, [r0, #0]
    36e8:	ldr	r3, [r3, #72]	; 0x48
    36ea:	cmp	r3, r2
    36ec:	bne.n	3730 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x47c>
    36ee:	ldr	r0, [r0, #16]
    36f0:	cmp	r0, #0
    36f2:	beq.w	3872 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5be>
    36f6:	ldr	r3, [r0, #0]
    36f8:	ldr	r3, [r3, #72]	; 0x48
    36fa:	cmp	r3, r2
    36fc:	bne.n	3730 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x47c>
    36fe:	ldr	r0, [r0, #16]
    3700:	cmp	r0, #0
    3702:	beq.w	3872 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5be>
    3706:	ldr	r3, [r0, #0]
    3708:	ldr	r3, [r3, #72]	; 0x48
    370a:	cmp	r3, r2
    370c:	bne.n	3730 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x47c>
    370e:	ldr	r0, [r0, #16]
    3710:	cmp	r0, #0
    3712:	beq.w	3872 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5be>
    3716:	ldr	r3, [r0, #0]
    3718:	ldr	r3, [r3, #72]	; 0x48
    371a:	cmp	r3, r2
    371c:	bne.n	3730 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x47c>
    371e:	ldr	r0, [r0, #16]
    3720:	cmp	r0, #0
    3722:	beq.w	3872 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5be>
    3726:	ldr	r3, [r0, #0]
    3728:	ldr	r3, [r3, #72]	; 0x48
    372a:	blx	r3
    372c:	mov	r1, r0
    372e:	b.n	3734 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x480>
    3730:	blx	r3
    3732:	mov	r1, r0
        sd_getName(child_,r.name, MAX_FILENAME_LEN);
    3734:	mov.w	r2, #256	; 0x100
    3738:	add	r0, sp, #304	; 0x130
    373a:	bl	10ba0 <strlcpy>
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    373e:	ldr.w	r5, [r4, #244]	; 0xf4
    3742:	adds	r3, r5, #1
    WriteIndexRecord(new_record, r);
    3744:	mov	r0, r4
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    3746:	str.w	r3, [r4, #244]	; 0xf4
    WriteIndexRecord(new_record, r);
    374a:	mov	r1, r5
    374c:	add	r2, sp, #288	; 0x120
    374e:	bl	24e8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    3752:	ldr.w	r0, [r4, #224]	; 0xe0
    3756:	cmp	r0, #0
    3758:	beq.w	3354 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    375c:	ldr	r2, [r0, #0]
    375e:	ldr	r3, [pc, #324]	; (38a4 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5f0>)
    3760:	ldr	r2, [r2, #64]	; 0x40
    3762:	cmp	r2, r3
    3764:	bne.n	37e6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x532>
    3766:	ldr	r0, [r0, #16]
    3768:	cmp	r0, #0
    376a:	beq.w	3354 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    376e:	ldr	r2, [r0, #0]
    3770:	ldr	r2, [r2, #64]	; 0x40
    3772:	cmp	r2, r3
    3774:	bne.n	37e6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x532>
    3776:	ldr	r0, [r0, #16]
    3778:	cmp	r0, #0
    377a:	beq.w	3354 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    377e:	ldr	r2, [r0, #0]
    3780:	ldr	r2, [r2, #64]	; 0x40
    3782:	cmp	r2, r3
    3784:	bne.n	37e6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x532>
    3786:	ldr	r0, [r0, #16]
    3788:	cmp	r0, #0
    378a:	beq.w	3354 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    378e:	ldr	r2, [r0, #0]
    3790:	ldr	r2, [r2, #64]	; 0x40
    3792:	cmp	r2, r3
    3794:	bne.n	37e6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x532>
    3796:	ldr	r0, [r0, #16]
    3798:	cmp	r0, #0
    379a:	beq.w	3354 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    379e:	ldr	r2, [r0, #0]
    37a0:	ldr	r2, [r2, #64]	; 0x40
    37a2:	cmp	r2, r3
    37a4:	bne.n	37e6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x532>
    37a6:	ldr	r0, [r0, #16]
    37a8:	cmp	r0, #0
    37aa:	beq.w	3354 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    37ae:	ldr	r2, [r0, #0]
    37b0:	ldr	r2, [r2, #64]	; 0x40
    37b2:	cmp	r2, r3
    37b4:	bne.n	37e6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x532>
    37b6:	ldr	r0, [r0, #16]
    37b8:	cmp	r0, #0
    37ba:	beq.w	3354 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    37be:	ldr	r2, [r0, #0]
    37c0:	ldr	r2, [r2, #64]	; 0x40
    37c2:	cmp	r2, r3
    37c4:	bne.n	37e6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x532>
    37c6:	ldr	r0, [r0, #16]
    37c8:	cmp	r0, #0
    37ca:	beq.w	3354 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    37ce:	ldr	r2, [r0, #0]
    37d0:	ldr	r2, [r2, #64]	; 0x40
    37d2:	cmp	r2, r3
    37d4:	bne.n	37e6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x532>
    37d6:	ldr	r0, [r0, #16]
    37d8:	cmp	r0, #0
    37da:	beq.w	3354 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    37de:	ldr	r3, [r0, #0]
    37e0:	ldr	r3, [r3, #64]	; 0x40
    37e2:	blx	r3
    37e4:	b.n	3354 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>
    37e6:	blx	r2
    if (record.isdir && !record.scanned) {
      OpenFileByIndex(i);
      if (!sd_isOpen(file_)) return;
    
      int sibling = 0;
      while (true) 
    37e8:	b.n	3354 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0xa0>

        Record r;
        r.store = record.store;
        r.parent = i;
        r.sibling = sibling;
        r.isdir = child_.isDirectory();
    37ea:	movs	r2, #0
    37ec:	strb.w	r2, [sp, #300]	; 0x12c
	}
	virtual uint64_t position() {
		return (f) ? f->position() : 0;
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
    37f0:	cmp	r3, #0
    37f2:	beq.n	3888 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5d4>
    37f4:	ldr	r1, [r3, #0]
    37f6:	ldr	r2, [pc, #176]	; (38a8 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5f4>)
    37f8:	ldr	r1, [r1, #60]	; 0x3c
    37fa:	cmp	r1, r2
    37fc:	bne.n	387e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5ca>
    37fe:	ldr	r0, [r3, #16]
    3800:	cbz	r0, 3856 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5a2>
    3802:	ldr	r1, [r0, #0]
    3804:	ldr	r1, [r1, #60]	; 0x3c
    3806:	cmp	r1, r2
    3808:	bne.n	3880 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5cc>
    380a:	ldr	r0, [r0, #16]
    380c:	cbz	r0, 3856 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5a2>
    380e:	ldr	r1, [r0, #0]
    3810:	ldr	r1, [r1, #60]	; 0x3c
    3812:	cmp	r1, r2
    3814:	bne.n	3880 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5cc>
    3816:	ldr	r0, [r0, #16]
    3818:	cbz	r0, 3856 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5a2>
    381a:	ldr	r1, [r0, #0]
    381c:	ldr	r1, [r1, #60]	; 0x3c
    381e:	cmp	r1, r2
    3820:	bne.n	3880 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5cc>
    3822:	ldr	r0, [r0, #16]
    3824:	cbz	r0, 3856 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5a2>
    3826:	ldr	r1, [r0, #0]
    3828:	ldr	r1, [r1, #60]	; 0x3c
    382a:	cmp	r1, r2
    382c:	bne.n	3880 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5cc>
    382e:	ldr	r0, [r0, #16]
    3830:	cbz	r0, 3856 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5a2>
    3832:	ldr	r1, [r0, #0]
    3834:	ldr	r1, [r1, #60]	; 0x3c
    3836:	cmp	r1, r2
    3838:	bne.n	3880 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5cc>
    383a:	ldr	r0, [r0, #16]
    383c:	cbz	r0, 3856 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5a2>
    383e:	ldr	r1, [r0, #0]
    3840:	ldr	r1, [r1, #60]	; 0x3c
    3842:	cmp	r1, r2
    3844:	bne.n	3880 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5cc>
    3846:	ldr	r0, [r0, #16]
    3848:	cbz	r0, 3856 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5a2>
    384a:	ldr	r3, [r0, #0]
    384c:	ldr	r3, [r3, #60]	; 0x3c
    384e:	blx	r3
    3850:	ldr.w	r3, [r4, #224]	; 0xe0
    3854:	b.n	3694 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3e0>
        r.child = r.isdir ? 0 : (uint32_t) child_.size();
    3856:	movs	r2, #0
        r.scanned = false;
    3858:	strb.w	r2, [sp, #301]	; 0x12d
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
    385c:	ldr	r1, [r3, #0]
        Record r;
        r.store = record.store;
        r.parent = i;
        r.sibling = sibling;
        r.isdir = child_.isDirectory();
        r.child = r.isdir ? 0 : (uint32_t) child_.size();
    385e:	str	r2, [sp, #292]	; 0x124
    3860:	ldr	r1, [r1, #72]	; 0x48
    3862:	ldr	r2, [pc, #60]	; (38a0 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5ec>)
    3864:	cmp	r1, r2
    3866:	beq.w	36ae <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3fa>
    386a:	mov	r0, r3
    386c:	blx	r1
    386e:	mov	r1, r0
    3870:	b.n	3734 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x480>
    3872:	ldr	r1, [pc, #56]	; (38ac <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5f8>)
    3874:	b.n	3734 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x480>
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
	}
	virtual File openNextFile(uint8_t mode=0) {
		return (f) ? f->openNextFile(mode) : *this;
    3876:	movs	r2, #0
    3878:	add	r0, sp, #288	; 0x120
    387a:	blx	r3
    387c:	b.n	33d6 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x122>
	}
	virtual uint64_t position() {
		return (f) ? f->position() : 0;
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
    387e:	mov	r0, r3
    3880:	blx	r1
    3882:	ldr.w	r3, [r4, #224]	; 0xe0
    3886:	b.n	3694 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x3e0>
    3888:	str	r3, [sp, #292]	; 0x124
        r.scanned = false;
    388a:	strb.w	r3, [sp, #301]	; 0x12d
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
    388e:	ldr	r1, [pc, #28]	; (38ac <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x5f8>)
    3890:	b.n	3734 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x480>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3892:	mov	r0, r7
    3894:	blx	r3
    3896:	b.n	351e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x26a>
    3898:	mov	r0, r7
    389a:	blx	r3
    389c:	b.n	3472 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1be>
    389e:	nop
    38a0:	.word	0x00000519
    38a4:	.word	0x00000501
    38a8:	.word	0x000004f1
    38ac:	.word	0x000142d0
    38b0:	ldr	r2, [r3, #16]
    38b2:	cmp	r2, #0
    38b4:	beq.w	345a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1a6>
    38b8:	ldr	r1, [r2, #0]
    38ba:	ldr	r1, [r1, #32]
    38bc:	cmp	r1, r0
    38be:	bne.w	3a88 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7d4>
    38c2:	ldr.w	lr, [r2, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    38c6:	str.w	r9, [r2]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    38ca:	cmp.w	lr, #0
    38ce:	beq.n	3980 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6cc>
    38d0:	ldr.w	r1, [lr, #16]
    38d4:	subs	r1, #1
    38d6:	str.w	r1, [lr, #16]
    38da:	cmp	r1, #0
    38dc:	bne.n	3980 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6cc>
    38de:	ldr	r1, [r2, #16]
    38e0:	str	r1, [sp, #0]
    38e2:	cmp	r1, #0
    38e4:	beq.n	3980 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6cc>
    38e6:	ldr	r1, [sp, #0]
    38e8:	ldr	r1, [r1, #0]
    38ea:	ldr	r1, [r1, #32]
    38ec:	cmp	r1, r0
    38ee:	bne.w	3aa0 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7ec>
    38f2:	ldr	r1, [sp, #0]
    38f4:	ldr.w	lr, [r1, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    38f8:	str.w	r9, [r1]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    38fc:	cmp.w	lr, #0
    3900:	beq.n	3970 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6bc>
    3902:	ldr.w	r1, [lr, #16]
    3906:	subs	r1, #1
    3908:	str.w	r1, [lr, #16]
    390c:	cbnz	r1, 3970 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6bc>
    390e:	ldr	r1, [sp, #0]
    3910:	ldr.w	ip, [r1, #16]
    3914:	cmp.w	ip, #0
    3918:	beq.n	3970 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6bc>
    391a:	ldr.w	r1, [ip]
    391e:	ldr	r1, [r1, #32]
    3920:	cmp	r1, r0
    3922:	bne.w	3abc <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x808>
    3926:	ldr.w	r0, [ip, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    392a:	str.w	r9, [ip]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    392e:	cbz	r0, 3960 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6ac>
    3930:	ldr	r1, [r0, #16]
    3932:	add.w	lr, r1, #4294967295
    3936:	str.w	lr, [r0, #16]
    393a:	cmp.w	lr, #0
    393e:	bne.n	3960 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6ac>
    3940:	ldr.w	r0, [ip, #16]
    3944:	cbz	r0, 3960 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6ac>
    3946:	ldr.w	lr, [r0]
    394a:	str.w	ip, [sp, #12]
    394e:	str	r2, [sp, #8]
    3950:	str	r3, [sp, #4]
    3952:	ldr.w	r3, [lr, #32]
    3956:	blx	r3
    3958:	ldr.w	ip, [sp, #12]
    395c:	ldr	r2, [sp, #8]
    395e:	ldr	r3, [sp, #4]
    3960:	str	r2, [sp, #8]
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    3962:	mov	r0, ip
    3964:	movs	r1, #20
    3966:	str	r3, [sp, #4]
    3968:	bl	effc <operator delete(void*, unsigned int)>
    396c:	ldr	r3, [sp, #4]
    396e:	ldr	r2, [sp, #8]
    3970:	ldr	r0, [sp, #0]
    3972:	str	r2, [sp, #8]
    3974:	movs	r1, #20
    3976:	str	r3, [sp, #4]
    3978:	bl	effc <operator delete(void*, unsigned int)>
    397c:	ldr	r3, [sp, #4]
    397e:	ldr	r2, [sp, #8]
    3980:	str	r3, [sp, #0]
    3982:	mov	r0, r2
    3984:	movs	r1, #20
    3986:	bl	effc <operator delete(void*, unsigned int)>
    398a:	ldr	r3, [sp, #0]
    398c:	b.n	345a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1a6>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    398e:	ldr	r2, [r3, #16]
    3990:	cmp	r2, #0
    3992:	beq.w	3506 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x252>
    3996:	ldr	r1, [r2, #0]
    3998:	ldr	r1, [r1, #32]
    399a:	cmp	r1, r0
    399c:	bne.n	3a7e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7ca>
    399e:	ldr.w	lr, [r2, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    39a2:	str.w	r9, [r2]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    39a6:	cmp.w	lr, #0
    39aa:	beq.n	3a58 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7a4>
    39ac:	ldr.w	r1, [lr, #16]
    39b0:	subs	r1, #1
    39b2:	str.w	r1, [lr, #16]
    39b6:	cmp	r1, #0
    39b8:	bne.n	3a58 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7a4>
    39ba:	ldr	r1, [r2, #16]
    39bc:	str	r1, [sp, #0]
    39be:	cmp	r1, #0
    39c0:	beq.n	3a58 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7a4>
    39c2:	ldr	r1, [sp, #0]
    39c4:	ldr	r1, [r1, #0]
    39c6:	ldr	r1, [r1, #32]
    39c8:	cmp	r1, r0
    39ca:	bne.n	3a92 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7de>
    39cc:	ldr	r1, [sp, #0]
    39ce:	ldr.w	lr, [r1, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    39d2:	str.w	r9, [r1]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    39d6:	cmp.w	lr, #0
    39da:	beq.n	3a48 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x794>
    39dc:	ldr.w	r1, [lr, #16]
    39e0:	subs	r1, #1
    39e2:	str.w	r1, [lr, #16]
    39e6:	cbnz	r1, 3a48 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x794>
    39e8:	ldr	r1, [sp, #0]
    39ea:	ldr.w	ip, [r1, #16]
    39ee:	cmp.w	ip, #0
    39f2:	beq.n	3a48 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x794>
    39f4:	ldr.w	r1, [ip]
    39f8:	ldr	r1, [r1, #32]
    39fa:	cmp	r1, r0
    39fc:	bne.n	3aae <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7fa>
    39fe:	ldr.w	r0, [ip, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3a02:	str.w	r9, [ip]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3a06:	cbz	r0, 3a38 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x784>
    3a08:	ldr	r1, [r0, #16]
    3a0a:	add.w	lr, r1, #4294967295
    3a0e:	str.w	lr, [r0, #16]
    3a12:	cmp.w	lr, #0
    3a16:	bne.n	3a38 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x784>
    3a18:	ldr.w	r0, [ip, #16]
    3a1c:	cbz	r0, 3a38 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x784>
    3a1e:	ldr.w	lr, [r0]
    3a22:	str.w	ip, [sp, #12]
    3a26:	str	r2, [sp, #8]
    3a28:	str	r3, [sp, #4]
    3a2a:	ldr.w	r3, [lr, #32]
    3a2e:	blx	r3
    3a30:	ldr.w	ip, [sp, #12]
    3a34:	ldr	r2, [sp, #8]
    3a36:	ldr	r3, [sp, #4]
    3a38:	str	r2, [sp, #8]
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    3a3a:	mov	r0, ip
    3a3c:	movs	r1, #20
    3a3e:	str	r3, [sp, #4]
    3a40:	bl	effc <operator delete(void*, unsigned int)>
    3a44:	ldr	r3, [sp, #4]
    3a46:	ldr	r2, [sp, #8]
    3a48:	ldr	r0, [sp, #0]
    3a4a:	str	r2, [sp, #8]
    3a4c:	movs	r1, #20
    3a4e:	str	r3, [sp, #4]
    3a50:	bl	effc <operator delete(void*, unsigned int)>
    3a54:	ldr	r3, [sp, #4]
    3a56:	ldr	r2, [sp, #8]
    3a58:	str	r3, [sp, #0]
    3a5a:	mov	r0, r2
    3a5c:	movs	r1, #20
    3a5e:	bl	effc <operator delete(void*, unsigned int)>
    3a62:	ldr	r3, [sp, #0]
    3a64:	b.n	3506 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x252>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3a66:	mov	r0, sl
    3a68:	blx	r3
    3a6a:	b.n	346a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1b6>
    3a6c:	mov	r0, sl
    3a6e:	blx	r3
    3a70:	b.n	3516 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x262>
    3a72:	mov	r0, r3
    3a74:	blx	r2
    3a76:	b.n	350e <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x25a>
    3a78:	mov	r0, r3
    3a7a:	blx	r2
    3a7c:	b.n	3462 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1ae>
    3a7e:	str	r3, [sp, #0]
    3a80:	mov	r0, r2
    3a82:	blx	r1
    3a84:	ldr	r3, [sp, #0]
    3a86:	b.n	3506 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x252>
    3a88:	str	r3, [sp, #0]
    3a8a:	mov	r0, r2
    3a8c:	blx	r1
    3a8e:	ldr	r3, [sp, #0]
    3a90:	b.n	345a <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x1a6>
    3a92:	str	r2, [sp, #8]
    3a94:	str	r3, [sp, #4]
    3a96:	ldr	r0, [sp, #0]
    3a98:	blx	r1
    3a9a:	ldr	r2, [sp, #8]
    3a9c:	ldr	r3, [sp, #4]
    3a9e:	b.n	3a58 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x7a4>
    3aa0:	str	r2, [sp, #8]
    3aa2:	str	r3, [sp, #4]
    3aa4:	ldr	r0, [sp, #0]
    3aa6:	blx	r1
    3aa8:	ldr	r2, [sp, #8]
    3aaa:	ldr	r3, [sp, #4]
    3aac:	b.n	3980 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6cc>
    3aae:	str	r2, [sp, #8]
    3ab0:	str	r3, [sp, #4]
    3ab2:	mov	r0, ip
    3ab4:	blx	r1
    3ab6:	ldr	r2, [sp, #8]
    3ab8:	ldr	r3, [sp, #4]
    3aba:	b.n	3a48 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x794>
    3abc:	str	r2, [sp, #8]
    3abe:	str	r3, [sp, #4]
    3ac0:	mov	r0, ip
    3ac2:	blx	r1
    3ac4:	ldr	r2, [sp, #8]
    3ac6:	ldr	r3, [sp, #4]
    3ac8:	b.n	3970 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)+0x6bc>
    3aca:	nop

00003acc <MTPStorage_SD::ScanAll(unsigned long) [clone .part.7] [clone .constprop.12]>:

  // MTP object handles should not change or be re-used during a session.
  // This would be easy if we could just have a list of all files in memory.
  // Since our RAM is limited, we'll keep the index in a file instead.
  void MTPStorage_SD::GenerateIndex(uint32_t store)
  { if (index_generated) return; 
    3acc:	ldrb.w	r3, [r0, #248]	; 0xf8
    }
  }

  void MTPStorage_SD::ScanAll(uint32_t store) 
  { if (all_scanned_) return;
    all_scanned_ = true;
    3ad0:	movs	r2, #1
      record.child = sibling;
      WriteIndexRecord(i, record);
    }
  }

  void MTPStorage_SD::ScanAll(uint32_t store) 
    3ad2:	push	{r4, r5, r6, lr}
    3ad4:	mov	r5, r0
  { if (all_scanned_) return;
    all_scanned_ = true;
    3ad6:	strb.w	r2, [r0, #249]	; 0xf9
      record.child = sibling;
      WriteIndexRecord(i, record);
    }
  }

  void MTPStorage_SD::ScanAll(uint32_t store) 
    3ada:	mov	r6, r1

  // MTP object handles should not change or be re-used during a session.
  // This would be easy if we could just have a list of all files in memory.
  // Since our RAM is limited, we'll keep the index in a file instead.
  void MTPStorage_SD::GenerateIndex(uint32_t store)
  { if (index_generated) return; 
    3adc:	cbz	r3, 3afc <MTPStorage_SD::ScanAll(unsigned long) [clone .part.7] [clone .constprop.12]+0x30>
  void MTPStorage_SD::ScanAll(uint32_t store) 
  { if (all_scanned_) return;
    all_scanned_ = true;

    GenerateIndex(store);
    for (uint32_t i = 0; i < index_entries_; i++)  ScanDir(store,i);
    3ade:	ldr.w	r3, [r5, #244]	; 0xf4
    3ae2:	cbz	r3, 3afa <MTPStorage_SD::ScanAll(unsigned long) [clone .part.7] [clone .constprop.12]+0x2e>
    3ae4:	movs	r4, #0
    3ae6:	mov	r2, r4
    3ae8:	mov	r1, r6
    3aea:	mov	r0, r5
    3aec:	bl	32b4 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)>
    3af0:	ldr.w	r3, [r5, #244]	; 0xf4
    3af4:	adds	r4, #1
    3af6:	cmp	r3, r4
    3af8:	bhi.n	3ae6 <MTPStorage_SD::ScanAll(unsigned long) [clone .part.7] [clone .constprop.12]+0x1a>
    3afa:	pop	{r4, r5, r6, pc}
    3afc:	bl	2644 <MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]>
    3b00:	b.n	3ade <MTPStorage_SD::ScanAll(unsigned long) [clone .part.7] [clone .constprop.12]+0x12>
    3b02:	nop

00003b04 <MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long) [clone .part.8] [clone .constprop.13]>:
  }

  void MTPStorage_SD::StartGetObjectHandles(uint32_t store, uint32_t parent) 
    3b04:	push	{r4, r5, lr}
  { 
    GenerateIndex(store);
    if (parent) 
    { if (parent == 0xFFFFFFFFUL) parent = store; // As per initizalization
    3b06:	cmp.w	r2, #4294967295
    3b0a:	ite	ne
    3b0c:	movne	r5, r2
    3b0e:	moveq	r5, r1

    GenerateIndex(store);
    for (uint32_t i = 0; i < index_entries_; i++)  ScanDir(store,i);
  }

  void MTPStorage_SD::StartGetObjectHandles(uint32_t store, uint32_t parent) 
    3b10:	mov	r4, r0
    3b12:	sub	sp, #276	; 0x114
  { 
    GenerateIndex(store);
    if (parent) 
    { if (parent == 0xFFFFFFFFUL) parent = store; // As per initizalization

      ScanDir(store, parent);
    3b14:	mov	r2, r5
    3b16:	bl	32b4 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)>
      follow_sibling_ = true;
    3b1a:	movs	r3, #1
    3b1c:	strb.w	r3, [r4, #256]	; 0x100
      // Root folder?
      next_ = ReadIndexRecord(parent).child;
    3b20:	mov	r2, r5
    3b22:	mov	r1, r4
    3b24:	mov	r0, sp
    3b26:	bl	26c8 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    3b2a:	ldr	r3, [sp, #4]
    3b2c:	str.w	r3, [r4, #252]	; 0xfc
    { 
      ScanAll(store);
      follow_sibling_ = false;
      next_ = 1;
    }
  }
    3b30:	add	sp, #276	; 0x114
    3b32:	pop	{r4, r5, pc}

00003b34 <MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long)>:
    GenerateIndex(store);
    for (uint32_t i = 0; i < index_entries_; i++)  ScanDir(store,i);
  }

  void MTPStorage_SD::StartGetObjectHandles(uint32_t store, uint32_t parent) 
  { 
    3b34:	push	{r4, lr}

  // MTP object handles should not change or be re-used during a session.
  // This would be easy if we could just have a list of all files in memory.
  // Since our RAM is limited, we'll keep the index in a file instead.
  void MTPStorage_SD::GenerateIndex(uint32_t store)
  { if (index_generated) return; 
    3b36:	ldrb.w	r3, [r0, #248]	; 0xf8
    GenerateIndex(store);
    for (uint32_t i = 0; i < index_entries_; i++)  ScanDir(store,i);
  }

  void MTPStorage_SD::StartGetObjectHandles(uint32_t store, uint32_t parent) 
  { 
    3b3a:	sub	sp, #8
    3b3c:	mov	r4, r0

  // MTP object handles should not change or be re-used during a session.
  // This would be easy if we could just have a list of all files in memory.
  // Since our RAM is limited, we'll keep the index in a file instead.
  void MTPStorage_SD::GenerateIndex(uint32_t store)
  { if (index_generated) return; 
    3b3e:	cbz	r3, 3b64 <MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long)+0x30>
  }

  void MTPStorage_SD::StartGetObjectHandles(uint32_t store, uint32_t parent) 
  { 
    GenerateIndex(store);
    if (parent) 
    3b40:	cbz	r2, 3b4e <MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long)+0x1a>
    3b42:	mov	r0, r4
    { 
      ScanAll(store);
      follow_sibling_ = false;
      next_ = 1;
    }
  }
    3b44:	add	sp, #8
    3b46:	ldmia.w	sp!, {r4, lr}
    3b4a:	b.w	3b04 <MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long) [clone .part.8] [clone .constprop.13]>
      WriteIndexRecord(i, record);
    }
  }

  void MTPStorage_SD::ScanAll(uint32_t store) 
  { if (all_scanned_) return;
    3b4e:	ldrb.w	r3, [r4, #249]	; 0xf9
    3b52:	cbz	r3, 3b72 <MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long)+0x3e>
      next_ = ReadIndexRecord(parent).child;
    } 
    else 
    { 
      ScanAll(store);
      follow_sibling_ = false;
    3b54:	movs	r2, #0
      next_ = 1;
    3b56:	movs	r3, #1
      next_ = ReadIndexRecord(parent).child;
    } 
    else 
    { 
      ScanAll(store);
      follow_sibling_ = false;
    3b58:	strb.w	r2, [r4, #256]	; 0x100
      next_ = 1;
    3b5c:	str.w	r3, [r4, #252]	; 0xfc
    }
  }
    3b60:	add	sp, #8
    3b62:	pop	{r4, pc}
    3b64:	stmia.w	sp, {r1, r2}
    3b68:	bl	2644 <MTPStorage_SD::GenerateIndex(unsigned long) [clone .part.6] [clone .constprop.14]>
    3b6c:	ldmia.w	sp, {r1, r2}
    3b70:	b.n	3b40 <MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long)+0xc>
    3b72:	mov	r0, r4
    3b74:	bl	3acc <MTPStorage_SD::ScanAll(unsigned long) [clone .part.7] [clone .constprop.12]>
    3b78:	b.n	3b54 <MTPStorage_SD::StartGetObjectHandles(unsigned long, unsigned long)+0x20>
    3b7a:	nop

00003b7c <MTPStorage_SD::removeFile(unsigned long, char*)>:
    file_.read(out,bytes);
    mtp_lock_storage(false);
  }

void MTPStorage_SD::removeFile(uint32_t store, char *file)
{ 
    3b7c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3b80:	add.w	r9, r0, r1, lsl #2
    3b84:	sub	sp, #340	; 0x154
    3b86:	str	r1, [sp, #12]
    }

    uint32_t sd_getFSCount(void) {return fsCount;}
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}

    File sd_open(uint32_t store, const char *filename, uint32_t mode) { return sdx[store]->open(filename,mode);  }
    3b88:	ldr.w	r1, [r9, #88]	; 0x58
    3b8c:	str	r0, [sp, #8]
    3b8e:	ldr	r3, [r1, #0]
    3b90:	str	r2, [sp, #4]
    3b92:	ldr	r4, [r3, #0]
    3b94:	add	r0, sp, #40	; 0x28
    3b96:	movs	r3, #0
    3b98:	blx	r4
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
    3b9a:	ldr	r0, [sp, #56]	; 0x38
    3b9c:	cmp	r0, #0
    3b9e:	beq.w	3f48 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    3ba2:	ldr	r3, [r0, #0]
    3ba4:	ldr.w	sl, [pc, #868]	; 3f0c <MTPStorage_SD::removeFile(unsigned long, char*)+0x390>
    3ba8:	ldr	r3, [r3, #76]	; 0x4c
    3baa:	cmp	r3, sl
    3bac:	bne.w	40ac <MTPStorage_SD::removeFile(unsigned long, char*)+0x530>
    3bb0:	ldr	r0, [r0, #16]
    3bb2:	cmp	r0, #0
    3bb4:	beq.w	3f48 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    3bb8:	ldr	r3, [r0, #0]
    3bba:	ldr	r3, [r3, #76]	; 0x4c
    3bbc:	cmp	r3, sl
    3bbe:	bne.w	40ac <MTPStorage_SD::removeFile(unsigned long, char*)+0x530>
    3bc2:	ldr	r0, [r0, #16]
    3bc4:	cmp	r0, #0
    3bc6:	beq.w	3f48 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    3bca:	ldr	r3, [r0, #0]
    3bcc:	ldr	r3, [r3, #76]	; 0x4c
    3bce:	cmp	r3, sl
    3bd0:	bne.w	40ac <MTPStorage_SD::removeFile(unsigned long, char*)+0x530>
    3bd4:	ldr	r0, [r0, #16]
    3bd6:	cmp	r0, #0
    3bd8:	beq.w	3f48 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    3bdc:	ldr	r3, [r0, #0]
    3bde:	ldr	r3, [r3, #76]	; 0x4c
    3be0:	cmp	r3, sl
    3be2:	bne.w	40ac <MTPStorage_SD::removeFile(unsigned long, char*)+0x530>
    3be6:	ldr	r0, [r0, #16]
    3be8:	cmp	r0, #0
    3bea:	beq.w	3f48 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    3bee:	ldr	r3, [r0, #0]
    3bf0:	ldr	r3, [r3, #76]	; 0x4c
    3bf2:	cmp	r3, sl
    3bf4:	bne.w	40ac <MTPStorage_SD::removeFile(unsigned long, char*)+0x530>
    3bf8:	ldr	r0, [r0, #16]
    3bfa:	cmp	r0, #0
    3bfc:	beq.w	3f48 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    3c00:	ldr	r3, [r0, #0]
    3c02:	ldr	r3, [r3, #76]	; 0x4c
    3c04:	cmp	r3, sl
    3c06:	bne.w	40ac <MTPStorage_SD::removeFile(unsigned long, char*)+0x530>
    3c0a:	ldr	r0, [r0, #16]
    3c0c:	cmp	r0, #0
    3c0e:	beq.w	3f48 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    3c12:	ldr	r3, [r0, #0]
    3c14:	ldr	r3, [r3, #76]	; 0x4c
    3c16:	cmp	r3, sl
    3c18:	bne.w	40ac <MTPStorage_SD::removeFile(unsigned long, char*)+0x530>
    3c1c:	ldr	r0, [r0, #16]
    3c1e:	cmp	r0, #0
    3c20:	beq.w	3f48 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    3c24:	ldr	r3, [r0, #0]
    3c26:	ldr	r3, [r3, #76]	; 0x4c
    3c28:	cmp	r3, sl
    3c2a:	bne.w	40ac <MTPStorage_SD::removeFile(unsigned long, char*)+0x530>
    3c2e:	ldr	r0, [r0, #16]
    3c30:	cmp	r0, #0
    3c32:	beq.w	3f48 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    3c36:	ldr	r3, [r0, #0]
    3c38:	ldr	r3, [r3, #76]	; 0x4c
    3c3a:	blx	r3
  char tname[MAX_FILENAME_LEN];
  File f1=sd_open(store,file,0);
  if(f1.isDirectory())
    3c3c:	cmp	r0, #0
    3c3e:	beq.w	3f48 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3cc>
    3c42:	ldr.w	fp, [pc, #700]	; 3f00 <MTPStorage_SD::removeFile(unsigned long, char*)+0x384>
    3c46:	ldr.w	r8, [pc, #712]	; 3f10 <MTPStorage_SD::removeFile(unsigned long, char*)+0x394>
    3c4a:	movs	r4, #0
    3c4c:	mov	r7, fp
	}
	virtual File openNextFile(uint8_t mode=0) {
		return (f) ? f->openNextFile(mode) : *this;
    3c4e:	ldr	r1, [sp, #56]	; 0x38
    3c50:	cmp	r1, #0
    3c52:	beq.w	3f32 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3b6>
    3c56:	ldr	r3, [r1, #0]
    3c58:	ldr	r2, [pc, #668]	; (3ef8 <MTPStorage_SD::removeFile(unsigned long, char*)+0x37c>)
    3c5a:	ldr	r3, [r3, #80]	; 0x50
    3c5c:	cmp	r3, r2
    3c5e:	bne.w	40b0 <MTPStorage_SD::removeFile(unsigned long, char*)+0x534>
    3c62:	ldr	r1, [r1, #16]
    3c64:	cmp	r1, #0
    3c66:	beq.w	3f32 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3b6>
    3c6a:	ldr	r3, [r1, #0]
    3c6c:	ldr	r3, [r3, #80]	; 0x50
    3c6e:	cmp	r3, r2
    3c70:	bne.w	40b0 <MTPStorage_SD::removeFile(unsigned long, char*)+0x534>
    3c74:	ldr	r1, [r1, #16]
    3c76:	cmp	r1, #0
    3c78:	beq.w	3f32 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3b6>
    3c7c:	ldr	r3, [r1, #0]
    3c7e:	ldr	r3, [r3, #80]	; 0x50
    3c80:	cmp	r3, r2
    3c82:	bne.w	40b0 <MTPStorage_SD::removeFile(unsigned long, char*)+0x534>
    3c86:	ldr	r1, [r1, #16]
    3c88:	cmp	r1, #0
    3c8a:	beq.w	3f32 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3b6>
    3c8e:	ldr	r3, [r1, #0]
    3c90:	ldr	r3, [r3, #80]	; 0x50
    3c92:	cmp	r3, r2
    3c94:	bne.w	40b0 <MTPStorage_SD::removeFile(unsigned long, char*)+0x534>
    3c98:	ldr	r1, [r1, #16]
    3c9a:	cmp	r1, #0
    3c9c:	beq.w	3f32 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3b6>
    3ca0:	ldr	r3, [r1, #0]
    3ca2:	ldr	r3, [r3, #80]	; 0x50
    3ca4:	cmp	r3, r2
    3ca6:	bne.w	40b0 <MTPStorage_SD::removeFile(unsigned long, char*)+0x534>
    3caa:	ldr	r1, [r1, #16]
    3cac:	cmp	r1, #0
    3cae:	beq.w	3f32 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3b6>
    3cb2:	ldr	r3, [r1, #0]
    3cb4:	ldr	r3, [r3, #80]	; 0x50
    3cb6:	cmp	r3, r2
    3cb8:	bne.w	40b0 <MTPStorage_SD::removeFile(unsigned long, char*)+0x534>
    3cbc:	ldr	r1, [r1, #16]
    3cbe:	cmp	r1, #0
    3cc0:	beq.w	3f32 <MTPStorage_SD::removeFile(unsigned long, char*)+0x3b6>
    3cc4:	ldr	r3, [r1, #0]
    3cc6:	movs	r2, #0
    3cc8:	ldr	r3, [r3, #80]	; 0x50
    3cca:	add	r0, sp, #60	; 0x3c
    3ccc:	blx	r3
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3cce:	cbz	r4, 3cec <MTPStorage_SD::removeFile(unsigned long, char*)+0x170>
    3cd0:	ldr	r3, [r4, #16]
    3cd2:	subs	r3, #1
    3cd4:	str	r3, [r4, #16]
    3cd6:	cbnz	r3, 3cec <MTPStorage_SD::removeFile(unsigned long, char*)+0x170>
    3cd8:	ldr	r3, [r4, #0]
    3cda:	ldr	r2, [pc, #544]	; (3efc <MTPStorage_SD::removeFile(unsigned long, char*)+0x380>)
    3cdc:	ldr	r3, [r3, #32]
    3cde:	cmp	r3, r2
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    3ce0:	mov	r0, r4
    3ce2:	bne.w	42a0 <MTPStorage_SD::removeFile(unsigned long, char*)+0x724>
    3ce6:	movs	r1, #20
    3ce8:	bl	effc <operator delete(void*, unsigned int)>
	File& operator = (const File &file) {
		//Serial.println("File assignment");
		//static int assigncount=0;
		//if (++assigncount > 20) while (1) ;
		invalidate();
		f = file.f;
    3cec:	ldr	r4, [sp, #76]	; 0x4c
		if (f) f->refcount++;
    3cee:	cmp	r4, #0
    3cf0:	beq.w	426c <MTPStorage_SD::removeFile(unsigned long, char*)+0x6f0>
    3cf4:	ldr	r3, [r4, #16]
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    3cf6:	ldr	r2, [r4, #0]
		//Serial.println("File assignment");
		//static int assigncount=0;
		//if (++assigncount > 20) while (1) ;
		invalidate();
		f = file.f;
		if (f) f->refcount++;
    3cf8:	adds	r0, r3, #1
    3cfa:	str	r0, [r4, #16]
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    3cfc:	ldr	r2, [r2, #68]	; 0x44
    3cfe:	cmp	r2, r8
    3d00:	bne.w	4258 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6dc>
    3d04:	cmp	r0, #0
    3d06:	beq.w	4238 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6bc>
    3d0a:	ldr.w	r3, [r3, #1]
    3d0e:	ldr	r3, [r3, #68]	; 0x44
    3d10:	cmp	r3, r8
    3d12:	bne.w	4250 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d4>
    3d16:	ldr	r0, [r0, #16]
    3d18:	cmp	r0, #0
    3d1a:	beq.w	4238 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6bc>
    3d1e:	ldr	r3, [r0, #0]
    3d20:	ldr	r3, [r3, #68]	; 0x44
    3d22:	cmp	r3, r8
    3d24:	bne.w	4250 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d4>
    3d28:	ldr	r0, [r0, #16]
    3d2a:	cmp	r0, #0
    3d2c:	beq.w	4238 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6bc>
    3d30:	ldr	r3, [r0, #0]
    3d32:	ldr	r3, [r3, #68]	; 0x44
    3d34:	cmp	r3, r8
    3d36:	bne.w	4250 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d4>
    3d3a:	ldr	r0, [r0, #16]
    3d3c:	cmp	r0, #0
    3d3e:	beq.w	4238 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6bc>
    3d42:	ldr	r3, [r0, #0]
    3d44:	ldr	r3, [r3, #68]	; 0x44
    3d46:	cmp	r3, r8
    3d48:	bne.w	4250 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d4>
    3d4c:	ldr	r0, [r0, #16]
    3d4e:	cmp	r0, #0
    3d50:	beq.w	4238 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6bc>
    3d54:	ldr	r3, [r0, #0]
    3d56:	ldr	r3, [r3, #68]	; 0x44
    3d58:	blx	r3
    3d5a:	ldr	r2, [sp, #76]	; 0x4c
    3d5c:	mov	r6, r0
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3d5e:	str	r7, [sp, #60]	; 0x3c
    3d60:	ldr	r1, [pc, #412]	; (3f00 <MTPStorage_SD::removeFile(unsigned long, char*)+0x384>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3d62:	cmp	r2, #0
    3d64:	beq.n	3dfc <MTPStorage_SD::removeFile(unsigned long, char*)+0x280>
    3d66:	ldr	r3, [r2, #16]
    3d68:	subs	r3, #1
    3d6a:	str	r3, [r2, #16]
    3d6c:	cmp	r3, #0
    3d6e:	bne.n	3dfc <MTPStorage_SD::removeFile(unsigned long, char*)+0x280>
    3d70:	ldr	r5, [sp, #76]	; 0x4c
    3d72:	cmp	r5, #0
    3d74:	beq.n	3dfc <MTPStorage_SD::removeFile(unsigned long, char*)+0x280>
    3d76:	ldr	r3, [r5, #0]
    3d78:	ldr	r2, [pc, #384]	; (3efc <MTPStorage_SD::removeFile(unsigned long, char*)+0x380>)
    3d7a:	ldr	r3, [r3, #32]
    3d7c:	cmp	r3, r2
    3d7e:	bne.w	4262 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6e6>
    3d82:	ldr	r2, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3d84:	str	r1, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3d86:	cmp	r2, #0
    3d88:	beq.n	3df4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x278>
    3d8a:	ldr	r3, [r2, #16]
    3d8c:	subs	r3, #1
    3d8e:	str	r3, [r2, #16]
    3d90:	cbnz	r3, 3df4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x278>
    3d92:	ldr.w	fp, [r5, #16]
    3d96:	cmp.w	fp, #0
    3d9a:	beq.n	3df4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x278>
    3d9c:	ldr.w	r3, [fp]
    3da0:	ldr	r2, [pc, #344]	; (3efc <MTPStorage_SD::removeFile(unsigned long, char*)+0x380>)
    3da2:	ldr	r3, [r3, #32]
    3da4:	cmp	r3, r2
    3da6:	bne.w	42a4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x728>
    3daa:	ldr.w	r2, [fp, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3dae:	str.w	r1, [fp]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3db2:	cbz	r2, 3dec <MTPStorage_SD::removeFile(unsigned long, char*)+0x270>
    3db4:	ldr	r3, [r2, #16]
    3db6:	subs	r3, #1
    3db8:	str	r3, [r2, #16]
    3dba:	cbnz	r3, 3dec <MTPStorage_SD::removeFile(unsigned long, char*)+0x270>
    3dbc:	ldr.w	r3, [fp, #16]
    3dc0:	cbz	r3, 3dec <MTPStorage_SD::removeFile(unsigned long, char*)+0x270>
    3dc2:	ldr	r2, [r3, #0]
    3dc4:	ldr	r1, [pc, #308]	; (3efc <MTPStorage_SD::removeFile(unsigned long, char*)+0x380>)
    3dc6:	ldr	r2, [r2, #32]
    3dc8:	cmp	r2, r1
    3dca:	bne.w	42aa <MTPStorage_SD::removeFile(unsigned long, char*)+0x72e>
    3dce:	ldr	r1, [r3, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3dd0:	str	r7, [r3, #0]
    3dd2:	ldr.w	ip, [pc, #300]	; 3f00 <MTPStorage_SD::removeFile(unsigned long, char*)+0x384>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3dd6:	cbz	r1, 3de4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x268>
    3dd8:	ldr	r2, [r1, #16]
    3dda:	subs	r2, #1
    3ddc:	str	r2, [r1, #16]
    3dde:	cmp	r2, #0
    3de0:	beq.w	40c4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x548>
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    3de4:	mov	r0, r3
    3de6:	movs	r1, #20
    3de8:	bl	effc <operator delete(void*, unsigned int)>
    3dec:	mov	r0, fp
    3dee:	movs	r1, #20
    3df0:	bl	effc <operator delete(void*, unsigned int)>
    3df4:	mov	r0, r5
    3df6:	movs	r1, #20
    3df8:	bl	effc <operator delete(void*, unsigned int)>
  {
    File f2;
    while(f2=f1.openNextFile())
    3dfc:	cmp	r6, #0
    3dfe:	beq.w	426c <MTPStorage_SD::removeFile(unsigned long, char*)+0x6f0>
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
    3e02:	cmp	r4, #0
    3e04:	beq.w	4208 <MTPStorage_SD::removeFile(unsigned long, char*)+0x68c>
    3e08:	ldr	r2, [r4, #0]
    3e0a:	ldr	r3, [pc, #248]	; (3f04 <MTPStorage_SD::removeFile(unsigned long, char*)+0x388>)
    3e0c:	ldr	r2, [r2, #72]	; 0x48
    3e0e:	cmp	r2, r3
    3e10:	bne.w	4244 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6c8>
    3e14:	ldr	r0, [r4, #16]
    3e16:	cmp	r0, #0
    3e18:	beq.w	424c <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d0>
    3e1c:	ldr	r2, [r0, #0]
    3e1e:	ldr	r2, [r2, #72]	; 0x48
    3e20:	cmp	r2, r3
    3e22:	bne.w	4246 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6ca>
    3e26:	ldr	r0, [r0, #16]
    3e28:	cmp	r0, #0
    3e2a:	beq.w	424c <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d0>
    3e2e:	ldr	r2, [r0, #0]
    3e30:	ldr	r2, [r2, #72]	; 0x48
    3e32:	cmp	r2, r3
    3e34:	bne.w	4246 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6ca>
    3e38:	ldr	r0, [r0, #16]
    3e3a:	cmp	r0, #0
    3e3c:	beq.w	424c <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d0>
    3e40:	ldr	r2, [r0, #0]
    3e42:	ldr	r2, [r2, #72]	; 0x48
    3e44:	cmp	r2, r3
    3e46:	bne.w	4246 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6ca>
    3e4a:	ldr	r0, [r0, #16]
    3e4c:	cmp	r0, #0
    3e4e:	beq.w	424c <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d0>
    3e52:	ldr	r2, [r0, #0]
    3e54:	ldr	r2, [r2, #72]	; 0x48
    3e56:	cmp	r2, r3
    3e58:	bne.w	4246 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6ca>
    3e5c:	ldr	r0, [r0, #16]
    3e5e:	cmp	r0, #0
    3e60:	beq.w	424c <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d0>
    3e64:	ldr	r2, [r0, #0]
    3e66:	ldr	r2, [r2, #72]	; 0x48
    3e68:	cmp	r2, r3
    3e6a:	bne.w	4246 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6ca>
    3e6e:	ldr	r0, [r0, #16]
    3e70:	cmp	r0, #0
    3e72:	beq.w	424c <MTPStorage_SD::removeFile(unsigned long, char*)+0x6d0>
    3e76:	ldr	r3, [r0, #0]
    3e78:	ldr	r3, [r3, #72]	; 0x48
    3e7a:	blx	r3
    3e7c:	mov	r3, r0
    { sprintf(tname,"%s/%s",file,f2.name());
    3e7e:	add	r5, sp, #80	; 0x50
    3e80:	ldr	r1, [pc, #132]	; (3f08 <MTPStorage_SD::removeFile(unsigned long, char*)+0x38c>)
    3e82:	ldr	r2, [sp, #4]
    3e84:	mov	r0, r5
    3e86:	bl	10a44 <sprintf>
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
    3e8a:	ldr	r3, [r4, #0]
    3e8c:	ldr	r3, [r3, #76]	; 0x4c
    3e8e:	cmp	r3, sl
    3e90:	bne.w	423e <MTPStorage_SD::removeFile(unsigned long, char*)+0x6c2>
    3e94:	ldr	r0, [r4, #16]
    3e96:	cmp	r0, #0
    3e98:	beq.w	4216 <MTPStorage_SD::removeFile(unsigned long, char*)+0x69a>
    3e9c:	ldr	r3, [r0, #0]
    3e9e:	ldr	r3, [r3, #76]	; 0x4c
    3ea0:	cmp	r3, sl
    3ea2:	bne.w	4240 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6c4>
    3ea6:	ldr	r0, [r0, #16]
    3ea8:	cmp	r0, #0
    3eaa:	beq.w	4216 <MTPStorage_SD::removeFile(unsigned long, char*)+0x69a>
    3eae:	ldr	r3, [r0, #0]
    3eb0:	ldr	r3, [r3, #76]	; 0x4c
    3eb2:	cmp	r3, sl
    3eb4:	bne.w	4240 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6c4>
    3eb8:	ldr	r0, [r0, #16]
    3eba:	cmp	r0, #0
    3ebc:	beq.w	4216 <MTPStorage_SD::removeFile(unsigned long, char*)+0x69a>
    3ec0:	ldr	r3, [r0, #0]
    3ec2:	ldr	r3, [r3, #76]	; 0x4c
    3ec4:	cmp	r3, sl
    3ec6:	bne.w	4240 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6c4>
    3eca:	ldr	r0, [r0, #16]
    3ecc:	cmp	r0, #0
    3ece:	beq.w	4216 <MTPStorage_SD::removeFile(unsigned long, char*)+0x69a>
    3ed2:	ldr	r3, [r0, #0]
    3ed4:	ldr	r3, [r3, #76]	; 0x4c
    3ed6:	cmp	r3, sl
    3ed8:	bne.w	4240 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6c4>
    3edc:	ldr	r0, [r0, #16]
    3ede:	cmp	r0, #0
    3ee0:	beq.w	4216 <MTPStorage_SD::removeFile(unsigned long, char*)+0x69a>
    3ee4:	ldr	r3, [r0, #0]
    3ee6:	ldr	r3, [r3, #76]	; 0x4c
    3ee8:	cmp	r3, sl
    3eea:	bne.w	4240 <MTPStorage_SD::removeFile(unsigned long, char*)+0x6c4>
    3eee:	ldr	r0, [r0, #16]
    3ef0:	cmp	r0, #0
    3ef2:	beq.w	4216 <MTPStorage_SD::removeFile(unsigned long, char*)+0x69a>
    3ef6:	b.n	3f14 <MTPStorage_SD::removeFile(unsigned long, char*)+0x398>
    3ef8:	.word	0x00000539
    3efc:	.word	0x00000f3d
    3f00:	.word	0x000140dc
    3f04:	.word	0x00000519
    3f08:	.word	0x000143f0
    3f0c:	.word	0x0000052d
    3f10:	.word	0x0000050d
    3f14:	ldr	r3, [r0, #0]
    3f16:	ldr	r3, [r3, #76]	; 0x4c
    3f18:	blx	r3
      if(f2.isDirectory()) removeFile(store,tname); else sd_remove(store,tname);
    3f1a:	cmp	r0, #0
    3f1c:	beq.w	4216 <MTPStorage_SD::removeFile(unsigned long, char*)+0x69a>
    3f20:	ldr	r1, [sp, #12]
    3f22:	ldr	r0, [sp, #8]
    3f24:	mov	r2, r5
    3f26:	bl	3b7c <MTPStorage_SD::removeFile(unsigned long, char*)>
	}
	virtual File openNextFile(uint8_t mode=0) {
		return (f) ? f->openNextFile(mode) : *this;
    3f2a:	ldr	r1, [sp, #56]	; 0x38
    3f2c:	cmp	r1, #0
    3f2e:	bne.w	3c56 <MTPStorage_SD::removeFile(unsigned long, char*)+0xda>
    3f32:	movs	r3, #0
    3f34:	mov.w	r2, #1000	; 0x3e8
			//"File(File *file) constructor only accepts pointers "
			//"to derived classes, not File itself");
		f = file;
		if (f) f->refcount++;
	}
	File(const File &file) {
    3f38:	str	r7, [sp, #60]	; 0x3c
    3f3a:	strb.w	r3, [sp, #64]	; 0x40
    3f3e:	strb.w	r3, [sp, #72]	; 0x48
		//Serial.println("File copy constructor");
		//static int copycount=0;
		//if (++copycount > 20) while (1) ;
		f = file.f;
    3f42:	str	r3, [sp, #76]	; 0x4c
    3f44:	str	r2, [sp, #68]	; 0x44
    3f46:	b.n	3cce <MTPStorage_SD::removeFile(unsigned long, char*)+0x152>
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    3f48:	ldr	r4, [sp, #4]
    3f4a:	ldr.w	fp, [pc, #368]	; 40bc <MTPStorage_SD::removeFile(unsigned long, char*)+0x540>
    3f4e:	mov	r0, r4
    3f50:	bl	10c00 <strlen>
    3f54:	mov	r1, r0
    3f56:	mov	r0, r4
    3f58:	bl	d6b8 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    3f5c:	ldr	r0, [pc, #344]	; (40b8 <MTPStorage_SD::removeFile(unsigned long, char*)+0x53c>)
    3f5e:	bl	eedc <Print::println()>
    bool sd_mkdir(uint32_t store, char *filename) {  return sdx[store]->mkdir(filename);  }
    bool sd_rename(uint32_t store, char *oldfilename, char *newfilename) { return sdx[store]->rename(oldfilename,newfilename);  }
    bool sd_remove(uint32_t store, const char *filename) {    Serial.println(filename); return sdx[store]->remove(filename);  }
    3f62:	ldr.w	r0, [r9, #88]	; 0x58
    3f66:	ldr	r3, [r0, #0]
    3f68:	mov	r1, r4
    3f6a:	ldr	r3, [r3, #16]
    3f6c:	blx	r3
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3f6e:	ldr	r2, [sp, #56]	; 0x38
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3f70:	str.w	fp, [sp, #40]	; 0x28
    3f74:	ldr	r1, [pc, #324]	; (40bc <MTPStorage_SD::removeFile(unsigned long, char*)+0x540>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3f76:	cmp	r2, #0
    3f78:	beq.w	40a6 <MTPStorage_SD::removeFile(unsigned long, char*)+0x52a>
    3f7c:	ldr	r3, [r2, #16]
    3f7e:	subs	r3, #1
    3f80:	str	r3, [r2, #16]
    3f82:	cmp	r3, #0
    3f84:	bne.w	40a6 <MTPStorage_SD::removeFile(unsigned long, char*)+0x52a>
    3f88:	ldr	r4, [sp, #56]	; 0x38
    3f8a:	cmp	r4, #0
    3f8c:	beq.w	40a6 <MTPStorage_SD::removeFile(unsigned long, char*)+0x52a>
    3f90:	ldr	r3, [r4, #0]
    3f92:	ldr	r0, [pc, #300]	; (40c0 <MTPStorage_SD::removeFile(unsigned long, char*)+0x544>)
    3f94:	ldr	r3, [r3, #32]
    3f96:	cmp	r3, r0
    3f98:	bne.w	42b0 <MTPStorage_SD::removeFile(unsigned long, char*)+0x734>
    3f9c:	ldr	r2, [r4, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3f9e:	str	r1, [r4, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3fa0:	cmp	r2, #0
    3fa2:	beq.n	409e <MTPStorage_SD::removeFile(unsigned long, char*)+0x522>
    3fa4:	ldr	r3, [r2, #16]
    3fa6:	subs	r3, #1
    3fa8:	str	r3, [r2, #16]
    3faa:	cmp	r3, #0
    3fac:	bne.n	409e <MTPStorage_SD::removeFile(unsigned long, char*)+0x522>
    3fae:	ldr	r5, [r4, #16]
    3fb0:	cmp	r5, #0
    3fb2:	beq.n	409e <MTPStorage_SD::removeFile(unsigned long, char*)+0x522>
    3fb4:	ldr	r3, [r5, #0]
    3fb6:	ldr	r3, [r3, #32]
    3fb8:	cmp	r3, r0
    3fba:	bne.w	42c4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x748>
    3fbe:	ldr	r2, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3fc0:	str	r1, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3fc2:	cmp	r2, #0
    3fc4:	beq.n	4096 <MTPStorage_SD::removeFile(unsigned long, char*)+0x51a>
    3fc6:	ldr	r3, [r2, #16]
    3fc8:	subs	r3, #1
    3fca:	str	r3, [r2, #16]
    3fcc:	cmp	r3, #0
    3fce:	bne.n	4096 <MTPStorage_SD::removeFile(unsigned long, char*)+0x51a>
    3fd0:	ldr	r6, [r5, #16]
    3fd2:	cmp	r6, #0
    3fd4:	beq.n	4096 <MTPStorage_SD::removeFile(unsigned long, char*)+0x51a>
    3fd6:	ldr	r3, [r6, #0]
    3fd8:	ldr	r3, [r3, #32]
    3fda:	cmp	r3, r0
    3fdc:	bne.w	42d8 <MTPStorage_SD::removeFile(unsigned long, char*)+0x75c>
    3fe0:	ldr	r2, [r6, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    3fe2:	str.w	fp, [r6]
    3fe6:	ldr	r1, [pc, #212]	; (40bc <MTPStorage_SD::removeFile(unsigned long, char*)+0x540>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    3fe8:	cmp	r2, #0
    3fea:	beq.n	408e <MTPStorage_SD::removeFile(unsigned long, char*)+0x512>
    3fec:	ldr	r3, [r2, #16]
    3fee:	subs	r3, #1
    3ff0:	str	r3, [r2, #16]
    3ff2:	cmp	r3, #0
    3ff4:	bne.n	408e <MTPStorage_SD::removeFile(unsigned long, char*)+0x512>
    3ff6:	ldr	r7, [r6, #16]
    3ff8:	cmp	r7, #0
    3ffa:	beq.n	408e <MTPStorage_SD::removeFile(unsigned long, char*)+0x512>
    3ffc:	ldr	r3, [r7, #0]
    3ffe:	ldr	r3, [r3, #32]
    4000:	cmp	r3, r0
    4002:	bne.w	42de <MTPStorage_SD::removeFile(unsigned long, char*)+0x762>
    4006:	ldr	r2, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4008:	str	r1, [r7, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    400a:	cmp	r2, #0
    400c:	beq.n	4086 <MTPStorage_SD::removeFile(unsigned long, char*)+0x50a>
    400e:	ldr	r3, [r2, #16]
    4010:	subs	r3, #1
    4012:	str	r3, [r2, #16]
    4014:	cmp	r3, #0
    4016:	bne.n	4086 <MTPStorage_SD::removeFile(unsigned long, char*)+0x50a>
    4018:	ldr.w	r8, [r7, #16]
    401c:	cmp.w	r8, #0
    4020:	beq.n	4086 <MTPStorage_SD::removeFile(unsigned long, char*)+0x50a>
    4022:	ldr.w	r3, [r8]
    4026:	ldr	r3, [r3, #32]
    4028:	cmp	r3, r0
    402a:	bne.w	4300 <MTPStorage_SD::removeFile(unsigned long, char*)+0x784>
    402e:	ldr.w	r2, [r8, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4032:	str.w	fp, [r8]
    4036:	ldr	r1, [pc, #132]	; (40bc <MTPStorage_SD::removeFile(unsigned long, char*)+0x540>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4038:	cbz	r2, 407e <MTPStorage_SD::removeFile(unsigned long, char*)+0x502>
    403a:	ldr	r3, [r2, #16]
    403c:	subs	r3, #1
    403e:	str	r3, [r2, #16]
    4040:	cbnz	r3, 407e <MTPStorage_SD::removeFile(unsigned long, char*)+0x502>
    4042:	ldr.w	r9, [r8, #16]
    4046:	cmp.w	r9, #0
    404a:	beq.n	407e <MTPStorage_SD::removeFile(unsigned long, char*)+0x502>
    404c:	ldr.w	r3, [r9]
    4050:	ldr	r3, [r3, #32]
    4052:	cmp	r3, r0
    4054:	bne.w	4316 <MTPStorage_SD::removeFile(unsigned long, char*)+0x79a>
    4058:	ldr.w	r2, [r9, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    405c:	str.w	r1, [r9]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4060:	cbz	r2, 4076 <MTPStorage_SD::removeFile(unsigned long, char*)+0x4fa>
    4062:	ldr	r3, [r2, #16]
    4064:	subs	r3, #1
    4066:	str	r3, [r2, #16]
    4068:	cbnz	r3, 4076 <MTPStorage_SD::removeFile(unsigned long, char*)+0x4fa>
    406a:	ldr.w	r0, [r9, #16]
    406e:	cbz	r0, 4076 <MTPStorage_SD::removeFile(unsigned long, char*)+0x4fa>
    4070:	ldr	r3, [r0, #0]
    4072:	ldr	r3, [r3, #32]
    4074:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    4076:	mov	r0, r9
    4078:	movs	r1, #20
    407a:	bl	effc <operator delete(void*, unsigned int)>
    407e:	mov	r0, r8
    4080:	movs	r1, #20
    4082:	bl	effc <operator delete(void*, unsigned int)>
    4086:	mov	r0, r7
    4088:	movs	r1, #20
    408a:	bl	effc <operator delete(void*, unsigned int)>
    408e:	mov	r0, r6
    4090:	movs	r1, #20
    4092:	bl	effc <operator delete(void*, unsigned int)>
    4096:	mov	r0, r5
    4098:	movs	r1, #20
    409a:	bl	effc <operator delete(void*, unsigned int)>
    409e:	mov	r0, r4
    40a0:	movs	r1, #20
    40a2:	bl	effc <operator delete(void*, unsigned int)>
  }
  else
  {
    sd_remove(store,file);
  }
}
    40a6:	add	sp, #340	; 0x154
    40a8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
    40ac:	blx	r3
    40ae:	b.n	3c3c <MTPStorage_SD::removeFile(unsigned long, char*)+0xc0>
	}
	virtual File openNextFile(uint8_t mode=0) {
		return (f) ? f->openNextFile(mode) : *this;
    40b0:	movs	r2, #0
    40b2:	add	r0, sp, #60	; 0x3c
    40b4:	blx	r3
    40b6:	b.n	3cce <MTPStorage_SD::removeFile(unsigned long, char*)+0x152>
    40b8:	.word	0x1fff0ad0
    40bc:	.word	0x000140dc
    40c0:	.word	0x00000f3d
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    40c4:	ldr	r2, [r3, #16]
    40c6:	cmp	r2, #0
    40c8:	beq.w	3de4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x268>
    40cc:	ldr	r1, [r2, #0]
    40ce:	ldr	r0, [pc, #588]	; (431c <MTPStorage_SD::removeFile(unsigned long, char*)+0x7a0>)
    40d0:	ldr	r1, [r1, #32]
    40d2:	cmp	r1, r0
    40d4:	bne.w	42ba <MTPStorage_SD::removeFile(unsigned long, char*)+0x73e>
    40d8:	ldr.w	lr, [r2, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    40dc:	str.w	ip, [r2]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    40e0:	cmp.w	lr, #0
    40e4:	beq.w	41fa <MTPStorage_SD::removeFile(unsigned long, char*)+0x67e>
    40e8:	ldr.w	r1, [lr, #16]
    40ec:	subs	r1, #1
    40ee:	str.w	r1, [lr, #16]
    40f2:	cmp	r1, #0
    40f4:	bne.w	41fa <MTPStorage_SD::removeFile(unsigned long, char*)+0x67e>
    40f8:	ldr	r1, [r2, #16]
    40fa:	str	r1, [sp, #16]
    40fc:	cmp	r1, #0
    40fe:	beq.n	41fa <MTPStorage_SD::removeFile(unsigned long, char*)+0x67e>
    4100:	ldr	r1, [sp, #16]
    4102:	ldr	r0, [pc, #536]	; (431c <MTPStorage_SD::removeFile(unsigned long, char*)+0x7a0>)
    4104:	ldr	r1, [r1, #0]
    4106:	ldr	r1, [r1, #32]
    4108:	cmp	r1, r0
    410a:	bne.w	42ca <MTPStorage_SD::removeFile(unsigned long, char*)+0x74e>
    410e:	ldr	r1, [sp, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4110:	ldr.w	ip, [pc, #536]	; 432c <MTPStorage_SD::removeFile(unsigned long, char*)+0x7b0>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4114:	ldr.w	lr, [r1, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4118:	str	r7, [r1, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    411a:	cmp.w	lr, #0
    411e:	beq.n	41ea <MTPStorage_SD::removeFile(unsigned long, char*)+0x66e>
    4120:	ldr.w	r1, [lr, #16]
    4124:	subs	r1, #1
    4126:	str.w	r1, [lr, #16]
    412a:	cmp	r1, #0
    412c:	bne.n	41ea <MTPStorage_SD::removeFile(unsigned long, char*)+0x66e>
    412e:	ldr	r1, [sp, #16]
    4130:	ldr	r1, [r1, #16]
    4132:	str	r1, [sp, #20]
    4134:	cmp	r1, #0
    4136:	beq.n	41ea <MTPStorage_SD::removeFile(unsigned long, char*)+0x66e>
    4138:	ldr	r1, [sp, #20]
    413a:	ldr	r0, [pc, #480]	; (431c <MTPStorage_SD::removeFile(unsigned long, char*)+0x7a0>)
    413c:	ldr	r1, [r1, #0]
    413e:	ldr	r1, [r1, #32]
    4140:	cmp	r1, r0
    4142:	bne.w	42e4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x768>
    4146:	ldr	r0, [sp, #20]
    4148:	ldr.w	lr, [r0, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    414c:	str.w	ip, [r0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4150:	cmp.w	lr, #0
    4154:	beq.n	41da <MTPStorage_SD::removeFile(unsigned long, char*)+0x65e>
    4156:	ldr.w	r1, [lr, #16]
    415a:	subs	r1, #1
    415c:	str.w	r1, [lr, #16]
    4160:	cmp	r1, #0
    4162:	bne.n	41da <MTPStorage_SD::removeFile(unsigned long, char*)+0x65e>
    4164:	ldr	r1, [sp, #20]
    4166:	ldr	r1, [r1, #16]
    4168:	str	r1, [sp, #24]
    416a:	cmp	r1, #0
    416c:	beq.n	41da <MTPStorage_SD::removeFile(unsigned long, char*)+0x65e>
    416e:	ldr	r1, [sp, #24]
    4170:	ldr	r0, [pc, #424]	; (431c <MTPStorage_SD::removeFile(unsigned long, char*)+0x7a0>)
    4172:	ldr	r1, [r1, #0]
    4174:	ldr	r1, [r1, #32]
    4176:	cmp	r1, r0
    4178:	bne.w	42f2 <MTPStorage_SD::removeFile(unsigned long, char*)+0x776>
    417c:	ldr	r0, [sp, #24]
    417e:	ldr.w	lr, [r0, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4182:	str.w	ip, [r0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4186:	cmp.w	lr, #0
    418a:	beq.n	41ca <MTPStorage_SD::removeFile(unsigned long, char*)+0x64e>
    418c:	ldr.w	r1, [lr, #16]
    4190:	subs	r1, #1
    4192:	str.w	r1, [lr, #16]
    4196:	cbnz	r1, 41ca <MTPStorage_SD::removeFile(unsigned long, char*)+0x64e>
    4198:	ldr	r1, [sp, #24]
    419a:	ldr	r1, [r1, #16]
    419c:	cbz	r1, 41ca <MTPStorage_SD::removeFile(unsigned long, char*)+0x64e>
    419e:	ldr	r0, [r1, #0]
    41a0:	ldr	r0, [r0, #32]
    41a2:	mov	lr, r0
    41a4:	ldr	r0, [pc, #372]	; (431c <MTPStorage_SD::removeFile(unsigned long, char*)+0x7a0>)
    41a6:	cmp	lr, r0
    41a8:	bne.w	4306 <MTPStorage_SD::removeFile(unsigned long, char*)+0x78a>
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    41ac:	mov	r0, r1
    41ae:	str	r2, [sp, #36]	; 0x24
    41b0:	str.w	r7, [r0], #16
    41b4:	str	r3, [sp, #32]
    41b6:	str	r1, [sp, #28]
		invalidate();
    41b8:	bl	20b0 <File::invalidate() [clone .isra.1]>
	}
    41bc:	ldr	r1, [sp, #28]
    41be:	mov	r0, r1
    41c0:	movs	r1, #20
    41c2:	bl	effc <operator delete(void*, unsigned int)>
    41c6:	ldr	r3, [sp, #32]
    41c8:	ldr	r2, [sp, #36]	; 0x24
    41ca:	ldr	r0, [sp, #24]
    41cc:	str	r2, [sp, #32]
    41ce:	movs	r1, #20
    41d0:	str	r3, [sp, #28]
    41d2:	bl	effc <operator delete(void*, unsigned int)>
    41d6:	ldr	r3, [sp, #28]
    41d8:	ldr	r2, [sp, #32]
    41da:	ldr	r0, [sp, #20]
    41dc:	str	r2, [sp, #28]
    41de:	movs	r1, #20
    41e0:	str	r3, [sp, #24]
    41e2:	bl	effc <operator delete(void*, unsigned int)>
    41e6:	ldr	r3, [sp, #24]
    41e8:	ldr	r2, [sp, #28]
    41ea:	ldr	r0, [sp, #16]
    41ec:	str	r2, [sp, #24]
    41ee:	movs	r1, #20
    41f0:	str	r3, [sp, #20]
    41f2:	bl	effc <operator delete(void*, unsigned int)>
    41f6:	ldr	r3, [sp, #20]
    41f8:	ldr	r2, [sp, #24]
    41fa:	str	r3, [sp, #16]
    41fc:	mov	r0, r2
    41fe:	movs	r1, #20
    4200:	bl	effc <operator delete(void*, unsigned int)>
    4204:	ldr	r3, [sp, #16]
    4206:	b.n	3de4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x268>
  File f1=sd_open(store,file,0);
  if(f1.isDirectory())
  {
    File f2;
    while(f2=f1.openNextFile())
    { sprintf(tname,"%s/%s",file,f2.name());
    4208:	add	r5, sp, #80	; 0x50
    420a:	mov	r0, r5
    420c:	ldr	r3, [pc, #272]	; (4320 <MTPStorage_SD::removeFile(unsigned long, char*)+0x7a4>)
    420e:	ldr	r1, [pc, #276]	; (4324 <MTPStorage_SD::removeFile(unsigned long, char*)+0x7a8>)
    4210:	ldr	r2, [sp, #4]
    4212:	bl	10a44 <sprintf>
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    4216:	mov	r0, r5
    4218:	bl	10c00 <strlen>
    421c:	mov	r1, r0
    421e:	mov	r0, r5
    4220:	bl	d6b8 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    4224:	ldr	r0, [pc, #256]	; (4328 <MTPStorage_SD::removeFile(unsigned long, char*)+0x7ac>)
    4226:	bl	eedc <Print::println()>
    422a:	ldr.w	r0, [r9, #88]	; 0x58
    422e:	ldr	r3, [r0, #0]
    4230:	mov	r1, r5
    4232:	ldr	r3, [r3, #16]
    4234:	blx	r3
    4236:	b.n	3c4e <MTPStorage_SD::removeFile(unsigned long, char*)+0xd2>
    4238:	ldr	r2, [sp, #76]	; 0x4c
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    423a:	movs	r6, #0
    423c:	b.n	3d5e <MTPStorage_SD::removeFile(unsigned long, char*)+0x1e2>
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
    423e:	mov	r0, r4
    4240:	blx	r3
    4242:	b.n	3f1a <MTPStorage_SD::removeFile(unsigned long, char*)+0x39e>
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
    4244:	mov	r0, r4
    4246:	blx	r2
    4248:	mov	r3, r0
    424a:	b.n	3e7e <MTPStorage_SD::removeFile(unsigned long, char*)+0x302>
    424c:	ldr	r3, [pc, #208]	; (4320 <MTPStorage_SD::removeFile(unsigned long, char*)+0x7a4>)
    424e:	b.n	3e7e <MTPStorage_SD::removeFile(unsigned long, char*)+0x302>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    4250:	blx	r3
    4252:	ldr	r2, [sp, #76]	; 0x4c
    4254:	mov	r6, r0
    4256:	b.n	3d5e <MTPStorage_SD::removeFile(unsigned long, char*)+0x1e2>
    4258:	mov	r0, r4
    425a:	blx	r2
    425c:	ldr	r2, [sp, #76]	; 0x4c
    425e:	mov	r6, r0
    4260:	b.n	3d5e <MTPStorage_SD::removeFile(unsigned long, char*)+0x1e2>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4262:	mov	r0, r5
    4264:	blx	r3
  char tname[MAX_FILENAME_LEN];
  File f1=sd_open(store,file,0);
  if(f1.isDirectory())
  {
    File f2;
    while(f2=f1.openNextFile())
    4266:	cmp	r6, #0
    4268:	bne.w	3e02 <MTPStorage_SD::removeFile(unsigned long, char*)+0x286>
    bool sd_rmdir(uint32_t store, char *filename) { return sdx[store]->rmdir(filename);  }
    426c:	ldr.w	r0, [r9, #88]	; 0x58
    4270:	ldr	r1, [sp, #4]
    4272:	ldr	r3, [r0, #0]
    4274:	ldr	r3, [r3, #20]
    4276:	mov	fp, r7
    4278:	blx	r3
    427a:	cmp	r4, #0
    427c:	beq.w	3f6e <MTPStorage_SD::removeFile(unsigned long, char*)+0x3f2>
    4280:	ldr	r3, [r4, #16]
    4282:	subs	r3, #1
    4284:	str	r3, [r4, #16]
    4286:	cmp	r3, #0
    4288:	bne.w	3f6e <MTPStorage_SD::removeFile(unsigned long, char*)+0x3f2>
    428c:	ldr	r3, [r4, #0]
    428e:	ldr	r2, [pc, #140]	; (431c <MTPStorage_SD::removeFile(unsigned long, char*)+0x7a0>)
    4290:	ldr	r3, [r3, #32]
    4292:	cmp	r3, r2
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    4294:	mov	r0, r4
    4296:	bne.n	42b6 <MTPStorage_SD::removeFile(unsigned long, char*)+0x73a>
    4298:	movs	r1, #20
    429a:	bl	effc <operator delete(void*, unsigned int)>
    429e:	b.n	3f6e <MTPStorage_SD::removeFile(unsigned long, char*)+0x3f2>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    42a0:	blx	r3
    42a2:	b.n	3cec <MTPStorage_SD::removeFile(unsigned long, char*)+0x170>
    42a4:	mov	r0, fp
    42a6:	blx	r3
    42a8:	b.n	3df4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x278>
    42aa:	mov	r0, r3
    42ac:	blx	r2
    42ae:	b.n	3dec <MTPStorage_SD::removeFile(unsigned long, char*)+0x270>
    42b0:	mov	r0, r4
    42b2:	blx	r3
  }
  else
  {
    sd_remove(store,file);
  }
}
    42b4:	b.n	40a6 <MTPStorage_SD::removeFile(unsigned long, char*)+0x52a>
    42b6:	blx	r3
    42b8:	b.n	3f6e <MTPStorage_SD::removeFile(unsigned long, char*)+0x3f2>
    42ba:	str	r3, [sp, #16]
    42bc:	mov	r0, r2
    42be:	blx	r1
    42c0:	ldr	r3, [sp, #16]
    42c2:	b.n	3de4 <MTPStorage_SD::removeFile(unsigned long, char*)+0x268>
    42c4:	mov	r0, r5
    42c6:	blx	r3
    42c8:	b.n	409e <MTPStorage_SD::removeFile(unsigned long, char*)+0x522>
    42ca:	str	r2, [sp, #24]
    42cc:	str	r3, [sp, #20]
    42ce:	ldr	r0, [sp, #16]
    42d0:	blx	r1
    42d2:	ldr	r2, [sp, #24]
    42d4:	ldr	r3, [sp, #20]
    42d6:	b.n	41fa <MTPStorage_SD::removeFile(unsigned long, char*)+0x67e>
    42d8:	mov	r0, r6
    42da:	blx	r3
    42dc:	b.n	4096 <MTPStorage_SD::removeFile(unsigned long, char*)+0x51a>
    42de:	mov	r0, r7
    42e0:	blx	r3
    42e2:	b.n	408e <MTPStorage_SD::removeFile(unsigned long, char*)+0x512>
    42e4:	str	r2, [sp, #28]
    42e6:	str	r3, [sp, #24]
    42e8:	ldr	r0, [sp, #20]
    42ea:	blx	r1
    42ec:	ldr	r2, [sp, #28]
    42ee:	ldr	r3, [sp, #24]
    42f0:	b.n	41ea <MTPStorage_SD::removeFile(unsigned long, char*)+0x66e>
    42f2:	str	r2, [sp, #32]
    42f4:	str	r3, [sp, #28]
    42f6:	ldr	r0, [sp, #24]
    42f8:	blx	r1
    42fa:	ldr	r2, [sp, #32]
    42fc:	ldr	r3, [sp, #28]
    42fe:	b.n	41da <MTPStorage_SD::removeFile(unsigned long, char*)+0x65e>
    4300:	mov	r0, r8
    4302:	blx	r3
    4304:	b.n	4086 <MTPStorage_SD::removeFile(unsigned long, char*)+0x50a>
    4306:	str	r2, [sp, #32]
    4308:	str	r3, [sp, #28]
    430a:	mov	r0, r1
    430c:	mov	r3, lr
    430e:	blx	r3
    4310:	ldr	r2, [sp, #32]
    4312:	ldr	r3, [sp, #28]
    4314:	b.n	41ca <MTPStorage_SD::removeFile(unsigned long, char*)+0x64e>
    4316:	mov	r0, r9
    4318:	blx	r3
    431a:	b.n	407e <MTPStorage_SD::removeFile(unsigned long, char*)+0x502>
    431c:	.word	0x00000f3d
    4320:	.word	0x000142d0
    4324:	.word	0x000143f0
    4328:	.word	0x1fff0ad0
    432c:	.word	0x000140dc

00004330 <MTPStorage_SD::DeleteObject(unsigned long) [clone .part.9] [clone .constprop.11]>:

  bool MTPStorage_SD::DeleteObject(uint32_t object)
    4330:	push	{r4, r5, r6, r7, lr}
    4332:	subw	sp, sp, #1348	; 0x544
    4336:	mov	r5, r0
    4338:	mov	r6, r1
  {
    if(object==0xFFFFFFFFUL) return true; // don't do anything if trying to delete a root directory see below

    // first create full filename
    char filename[MAX_FILENAME_LEN];
    ConstructFilename(object, filename, MAX_FILENAME_LEN);
    433a:	mov.w	r3, #256	; 0x100
    433e:	add	r2, sp, #272	; 0x110
    4340:	bl	2b28 <MTPStorage_SD::ConstructFilename(int, char*, int)>

    Record r = ReadIndexRecord(object);
    4344:	mov	r2, r6
    4346:	mov	r1, r5
    4348:	add	r0, sp, #528	; 0x210
    434a:	bl	26c8 <MTPStorage_SD::ReadIndexRecord(unsigned long)>

    // remove file from storage (assume it is always working)
    mtp_lock_storage(true);
    removeFile(r.store,filename);
    434e:	add	r2, sp, #272	; 0x110
    4350:	ldrh.w	r1, [sp, #542]	; 0x21e
    4354:	mov	r0, r5
    4356:	bl	3b7c <MTPStorage_SD::removeFile(unsigned long, char*)>
    mtp_lock_storage(false);

    // mark object as deleted
    r.name[0]=0;
    435a:	movs	r3, #0
    WriteIndexRecord(object, r);
    435c:	add	r2, sp, #528	; 0x210
    435e:	mov	r1, r6
    4360:	mov	r0, r5
    mtp_lock_storage(true);
    removeFile(r.store,filename);
    mtp_lock_storage(false);

    // mark object as deleted
    r.name[0]=0;
    4362:	strb.w	r3, [sp, #544]	; 0x220
    WriteIndexRecord(object, r);
    4366:	bl	24e8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    
    // update index file
    Record t = ReadIndexRecord(r.parent);
    436a:	ldr	r2, [sp, #528]	; 0x210
    436c:	mov	r1, r5
    436e:	add	r0, sp, #800	; 0x320
    4370:	bl	26c8 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    if(t.child==object)
    4374:	ldr	r7, [sp, #804]	; 0x324
    4376:	cmp	r6, r7
    4378:	beq.n	43ca <MTPStorage_SD::DeleteObject(unsigned long) [clone .part.9] [clone .constprop.11]+0x9a>
    }
    else
    { // link junger to older sibling
      // find junger sibling
      uint32_t is = t.child;
      Record x = ReadIndexRecord(is);
    437a:	add.w	r0, sp, #1072	; 0x430
    437e:	mov	r2, r7
    4380:	mov	r1, r5
    4382:	bl	26c8 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
      while((x.sibling != object)) { is=x.sibling; x=ReadIndexRecord(is);}
    4386:	ldr.w	r4, [sp, #1080]	; 0x438
    438a:	cmp	r6, r4
    438c:	bne.n	4392 <MTPStorage_SD::DeleteObject(unsigned long) [clone .part.9] [clone .constprop.11]+0x62>
    438e:	b.n	43de <MTPStorage_SD::DeleteObject(unsigned long) [clone .part.9] [clone .constprop.11]+0xae>
    4390:	mov	r4, r3
    4392:	mov	r2, r4
    4394:	mov	r1, r5
    4396:	mov	r0, sp
    4398:	bl	26c8 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    439c:	mov.w	r2, #272	; 0x110
    43a0:	mov	r1, sp
    43a2:	add.w	r0, sp, #1072	; 0x430
    43a6:	bl	d444 <memcpy>
    43aa:	ldr.w	r3, [sp, #1080]	; 0x438
    43ae:	cmp	r6, r3
    43b0:	bne.n	4390 <MTPStorage_SD::DeleteObject(unsigned long) [clone .part.9] [clone .constprop.11]+0x60>
      // is points now to junder sibling
      x.sibling = r.sibling;
      WriteIndexRecord(is, x);
    43b2:	mov	r0, r5
      // find junger sibling
      uint32_t is = t.child;
      Record x = ReadIndexRecord(is);
      while((x.sibling != object)) { is=x.sibling; x=ReadIndexRecord(is);}
      // is points now to junder sibling
      x.sibling = r.sibling;
    43b4:	ldr	r3, [sp, #536]	; 0x218
    43b6:	str.w	r3, [sp, #1080]	; 0x438
      WriteIndexRecord(is, x);
    43ba:	add.w	r2, sp, #1072	; 0x430
    43be:	mov	r1, r4
    43c0:	bl	24e8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    }
    return 1;
  }
    43c4:	addw	sp, sp, #1348	; 0x544
    43c8:	pop	{r4, r5, r6, r7, pc}
    // update index file
    Record t = ReadIndexRecord(r.parent);
    if(t.child==object)
    { // we are the jungest, simply relink parent to older sibling
      t.child = r.sibling;
      WriteIndexRecord(r.parent, t);
    43ca:	mov	r0, r5
    
    // update index file
    Record t = ReadIndexRecord(r.parent);
    if(t.child==object)
    { // we are the jungest, simply relink parent to older sibling
      t.child = r.sibling;
    43cc:	ldr	r3, [sp, #536]	; 0x218
      WriteIndexRecord(r.parent, t);
    43ce:	ldr	r1, [sp, #528]	; 0x210
    
    // update index file
    Record t = ReadIndexRecord(r.parent);
    if(t.child==object)
    { // we are the jungest, simply relink parent to older sibling
      t.child = r.sibling;
    43d0:	str	r3, [sp, #804]	; 0x324
      WriteIndexRecord(r.parent, t);
    43d2:	add	r2, sp, #800	; 0x320
    43d4:	bl	24e8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
      // is points now to junder sibling
      x.sibling = r.sibling;
      WriteIndexRecord(is, x);
    }
    return 1;
  }
    43d8:	addw	sp, sp, #1348	; 0x544
    43dc:	pop	{r4, r5, r6, r7, pc}
    else
    { // link junger to older sibling
      // find junger sibling
      uint32_t is = t.child;
      Record x = ReadIndexRecord(is);
      while((x.sibling != object)) { is=x.sibling; x=ReadIndexRecord(is);}
    43de:	mov	r4, r7
    43e0:	b.n	43b2 <MTPStorage_SD::DeleteObject(unsigned long) [clone .part.9] [clone .constprop.11]+0x82>
    43e2:	nop

000043e4 <MTPStorage_SD::DeleteObject(unsigned long)>:
  }
}

  bool MTPStorage_SD::DeleteObject(uint32_t object)
  {
    if(object==0xFFFFFFFFUL) return true; // don't do anything if trying to delete a root directory see below
    43e4:	adds	r2, r1, #1
    43e6:	beq.n	43f2 <MTPStorage_SD::DeleteObject(unsigned long)+0xe>
    sd_remove(store,file);
  }
}

  bool MTPStorage_SD::DeleteObject(uint32_t object)
  {
    43e8:	push	{r3, lr}
    43ea:	bl	4330 <MTPStorage_SD::DeleteObject(unsigned long) [clone .part.9] [clone .constprop.11]>
      // is points now to junder sibling
      x.sibling = r.sibling;
      WriteIndexRecord(is, x);
    }
    return 1;
  }
    43ee:	movs	r0, #1
    43f0:	pop	{r3, pc}
    43f2:	movs	r0, #1
    43f4:	bx	lr
    43f6:	nop

000043f8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)>:
  WriteIndexRecord(newHandle,p2);
  return true;
}
/************************************** mSD_Base *******************************/
bool mSD_Base::sd_copy(uint32_t store0, char *oldfilename, uint32_t store1, char *newfilename)
{
    43f8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    }

    uint32_t sd_getFSCount(void) {return fsCount;}
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}

    File sd_open(uint32_t store, const char *filename, uint32_t mode) { return sdx[store]->open(filename,mode);  }
    43fc:	add.w	r1, r0, r1, lsl #2
    4400:	mov	r6, r0
    4402:	ldr	r1, [r1, #84]	; 0x54
    4404:	ldr	r0, [r1, #0]
    4406:	subw	sp, sp, #2092	; 0x82c
    440a:	ldr	r4, [r0, #0]
    440c:	mov	r7, r3
    440e:	mov	r0, sp
    4410:	movs	r3, #0
    4412:	blx	r4
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    4414:	ldr	r3, [sp, #16]
    4416:	cmp	r3, #0
    4418:	beq.w	4842 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x44a>
    441c:	ldr	r2, [r3, #0]
    441e:	ldr	r5, [pc, #624]	; (4690 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x298>)
    4420:	ldr	r2, [r2, #68]	; 0x44
    4422:	cmp	r2, r5
    4424:	bne.w	47a0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3a8>
    4428:	ldr	r0, [r3, #16]
    442a:	cmp	r0, #0
    442c:	beq.w	4650 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x258>
    4430:	ldr	r2, [r0, #0]
    4432:	ldr	r2, [r2, #68]	; 0x44
    4434:	cmp	r2, r5
    4436:	bne.w	47a2 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3aa>
    443a:	ldr	r0, [r0, #16]
    443c:	cmp	r0, #0
    443e:	beq.w	4650 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x258>
    4442:	ldr	r2, [r0, #0]
    4444:	ldr	r2, [r2, #68]	; 0x44
    4446:	cmp	r2, r5
    4448:	bne.w	47a2 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3aa>
    444c:	ldr	r0, [r0, #16]
    444e:	cmp	r0, #0
    4450:	beq.w	4650 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x258>
    4454:	ldr	r2, [r0, #0]
    4456:	ldr	r2, [r2, #68]	; 0x44
    4458:	cmp	r2, r5
    445a:	bne.w	47a2 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3aa>
    445e:	ldr	r0, [r0, #16]
    4460:	cmp	r0, #0
    4462:	beq.w	4650 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x258>
    4466:	ldr	r2, [r0, #0]
    4468:	ldr	r2, [r2, #68]	; 0x44
    446a:	cmp	r2, r5
    446c:	bne.w	47a2 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3aa>
    4470:	ldr	r0, [r0, #16]
    4472:	cmp	r0, #0
    4474:	beq.w	4650 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x258>
    4478:	ldr	r2, [r0, #0]
    447a:	ldr	r2, [r2, #68]	; 0x44
    447c:	cmp	r2, r5
    447e:	bne.w	47a2 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3aa>
    4482:	ldr	r0, [r0, #16]
    4484:	cmp	r0, #0
    4486:	beq.w	4650 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x258>
    448a:	ldr	r2, [r0, #0]
    448c:	ldr	r2, [r2, #68]	; 0x44
    448e:	cmp	r2, r5
    4490:	bne.w	47a2 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3aa>
    4494:	ldr	r0, [r0, #16]
    4496:	cmp	r0, #0
    4498:	beq.w	4650 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x258>
    449c:	ldr	r3, [r0, #0]
    449e:	ldr	r3, [r3, #68]	; 0x44
    44a0:	blx	r3
    44a2:	mov	r4, r0
  #if DEBUG>1
    Serial.print("From "); Serial.print(store0); Serial.print(": ");Serial.println(oldfilename);
    Serial.print("To   "); Serial.print(store1); Serial.print(": ");Serial.println(newfilename);
  #endif

  File f1 = sd_open(store0,oldfilename,FILE_READ); if(!f1) {DBG_FAIL_MACRO; return false;}
    44a4:	cmp	r4, #0
    44a6:	beq.w	4c8a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x892>
    44aa:	add.w	r6, r6, r7, lsl #2
    44ae:	add	r0, sp, #20
    44b0:	ldr	r1, [r6, #84]	; 0x54
    44b2:	ldr.w	r2, [sp, #2128]	; 0x850
    44b6:	ldr	r3, [r1, #0]
    44b8:	ldr	r4, [r3, #0]
    44ba:	movs	r3, #2
    44bc:	blx	r4
    44be:	ldr	r0, [sp, #36]	; 0x24
    44c0:	cmp	r0, #0
    44c2:	beq.w	47a8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    44c6:	ldr	r3, [r0, #0]
    44c8:	ldr	r3, [r3, #68]	; 0x44
    44ca:	cmp	r3, r5
    44cc:	bne.w	4972 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    44d0:	ldr	r0, [r0, #16]
    44d2:	cmp	r0, #0
    44d4:	beq.w	47a8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    44d8:	ldr	r3, [r0, #0]
    44da:	ldr	r3, [r3, #68]	; 0x44
    44dc:	cmp	r3, r5
    44de:	bne.w	4972 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    44e2:	ldr	r0, [r0, #16]
    44e4:	cmp	r0, #0
    44e6:	beq.w	47a8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    44ea:	ldr	r3, [r0, #0]
    44ec:	ldr	r3, [r3, #68]	; 0x44
    44ee:	cmp	r3, r5
    44f0:	bne.w	4972 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    44f4:	ldr	r0, [r0, #16]
    44f6:	cmp	r0, #0
    44f8:	beq.w	47a8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    44fc:	ldr	r3, [r0, #0]
    44fe:	ldr	r3, [r3, #68]	; 0x44
    4500:	cmp	r3, r5
    4502:	bne.w	4972 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    4506:	ldr	r0, [r0, #16]
    4508:	cmp	r0, #0
    450a:	beq.w	47a8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    450e:	ldr	r3, [r0, #0]
    4510:	ldr	r3, [r3, #68]	; 0x44
    4512:	cmp	r3, r5
    4514:	bne.w	4972 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    4518:	ldr	r0, [r0, #16]
    451a:	cmp	r0, #0
    451c:	beq.w	47a8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    4520:	ldr	r3, [r0, #0]
    4522:	ldr	r3, [r3, #68]	; 0x44
    4524:	cmp	r3, r5
    4526:	bne.w	4972 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    452a:	ldr	r0, [r0, #16]
    452c:	cmp	r0, #0
    452e:	beq.w	47a8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    4532:	ldr	r3, [r0, #0]
    4534:	ldr	r3, [r3, #68]	; 0x44
    4536:	cmp	r3, r5
    4538:	bne.w	4972 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    453c:	ldr	r0, [r0, #16]
    453e:	cmp	r0, #0
    4540:	beq.w	47a8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    4544:	ldr	r3, [r0, #0]
    4546:	ldr	r3, [r3, #68]	; 0x44
    4548:	cmp	r3, r5
    454a:	bne.w	4972 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    454e:	ldr	r0, [r0, #16]
    4550:	cmp	r0, #0
    4552:	beq.w	47a8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    4556:	ldr	r3, [r0, #0]
    4558:	ldr	r3, [r3, #68]	; 0x44
    455a:	cmp	r3, r5
    455c:	bne.w	4972 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    4560:	ldr	r0, [r0, #16]
    4562:	cmp	r0, #0
    4564:	beq.w	47a8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    4568:	ldr	r3, [r0, #0]
    456a:	ldr	r3, [r3, #68]	; 0x44
    456c:	cmp	r3, r5
    456e:	bne.w	4972 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57a>
    4572:	ldr	r0, [r0, #16]
    4574:	cmp	r0, #0
    4576:	beq.w	47a8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    457a:	ldr	r3, [r0, #0]
    457c:	ldr	r3, [r3, #68]	; 0x44
    457e:	blx	r3
  File f2 = sd_open(store1,newfilename,FILE_WRITE_BEGIN);
  if(!f2) { f1.close(); {DBG_FAIL_MACRO; return false;}}
    4580:	cmp	r0, #0
    4582:	beq.w	47a8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x3b0>
    4586:	ldr	r5, [pc, #268]	; (4694 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x29c>)
    4588:	mov.w	r4, #4294967295
	}
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
	}
	virtual int available() {
		return (f) ? f->available() : 0;
    458c:	ldr	r3, [sp, #16]
    458e:	cmp	r3, #0
    4590:	beq.w	4b8e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    4594:	ldr	r1, [r3, #0]
    4596:	ldr	r2, [r1, #16]
    4598:	cmp	r2, r5
    459a:	bne.w	4b80 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x788>
    459e:	ldr	r2, [r3, #16]
    45a0:	cmp	r2, #0
    45a2:	beq.w	4b86 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x78e>
    45a6:	ldr	r0, [r2, #0]
    45a8:	ldr	r6, [r0, #16]
    45aa:	cmp	r6, r5
    45ac:	bne.w	4a28 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x630>
    45b0:	ldr	r0, [r2, #16]
    45b2:	cmp	r0, #0
    45b4:	beq.w	4976 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57e>
    45b8:	ldr	r6, [r0, #0]
    45ba:	ldr	r6, [r6, #16]
    45bc:	cmp	r6, r5
    45be:	bne.w	4a2a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x632>
    45c2:	ldr	r0, [r0, #16]
    45c4:	cmp	r0, #0
    45c6:	beq.w	4976 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57e>
    45ca:	ldr	r6, [r0, #0]
    45cc:	ldr	r6, [r6, #16]
    45ce:	cmp	r6, r5
    45d0:	bne.w	4a2a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x632>
    45d4:	ldr	r0, [r0, #16]
    45d6:	cmp	r0, #0
    45d8:	beq.w	4976 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57e>
    45dc:	ldr	r6, [r0, #0]
    45de:	ldr	r6, [r6, #16]
    45e0:	cmp	r6, r5
    45e2:	bne.w	4a2a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x632>
    45e6:	ldr	r0, [r0, #16]
    45e8:	cmp	r0, #0
    45ea:	beq.w	4976 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57e>
    45ee:	ldr	r6, [r0, #0]
    45f0:	ldr	r6, [r6, #16]
    45f2:	cmp	r6, r5
    45f4:	bne.w	4a2a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x632>
    45f8:	ldr	r0, [r0, #16]
    45fa:	cmp	r0, #0
    45fc:	beq.w	4976 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57e>
    4600:	ldr	r6, [r0, #0]
    4602:	ldr	r6, [r6, #16]
    4604:	cmp	r6, r5
    4606:	bne.w	4a2a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x632>
    460a:	ldr	r0, [r0, #16]
    460c:	cmp	r0, #0
    460e:	beq.w	4976 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57e>
    4612:	ldr	r6, [r0, #0]
    4614:	ldr	r6, [r6, #16]
    4616:	cmp	r6, r5
    4618:	bne.w	4a2a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x632>
    461c:	ldr	r0, [r0, #16]
    461e:	cmp	r0, #0
    4620:	beq.w	4976 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57e>
    4624:	ldr	r6, [r0, #0]
    4626:	ldr	r6, [r6, #16]
    4628:	cmp	r6, r5
    462a:	bne.w	4a2a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x632>
    462e:	ldr	r0, [r0, #16]
    4630:	cmp	r0, #0
    4632:	beq.w	4976 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57e>
    4636:	ldr	r6, [r0, #0]
    4638:	ldr	r6, [r6, #16]
    463a:	cmp	r6, r5
    463c:	bne.w	4a2a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x632>
    4640:	ldr	r0, [r0, #16]
    4642:	cmp	r0, #0
    4644:	beq.w	4976 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x57e>
    4648:	ldr	r3, [r0, #0]
    464a:	ldr	r3, [r3, #16]
    464c:	blx	r3
    464e:	b.n	4a2c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x634>
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4650:	ldr	r6, [pc, #68]	; (4698 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x2a0>)
    4652:	str	r6, [sp, #0]
    4654:	movs	r4, #0
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4656:	ldr	r2, [r3, #16]
    4658:	subs	r2, #1
    465a:	str	r2, [r3, #16]
    465c:	cbnz	r2, 4684 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x28c>
    465e:	ldr	r5, [sp, #16]
    4660:	cbz	r5, 4684 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x28c>
    4662:	ldr	r3, [r5, #0]
    4664:	ldr	r2, [pc, #52]	; (469c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x2a4>)
    4666:	ldr	r3, [r3, #32]
    4668:	cmp	r3, r2
    466a:	bne.w	4c1e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x826>
    466e:	ldr	r1, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4670:	str	r6, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4672:	cbz	r1, 467c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x284>
    4674:	ldr	r3, [r1, #16]
    4676:	subs	r3, #1
    4678:	str	r3, [r1, #16]
    467a:	cbz	r3, 46a0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x2a8>
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    467c:	mov	r0, r5
    467e:	movs	r1, #20
    4680:	bl	effc <operator delete(void*, unsigned int)>
  // close all files
  f1.close();
  f2.close();
  if(nd<0) {DBG_FAIL_MACRO; return false;}
  return true;
}
    4684:	mov	r0, r4
    4686:	addw	sp, sp, #2092	; 0x82c
    468a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    468e:	nop
    4690:	.word	0x0000050d
    4694:	.word	0x00000495
    4698:	.word	0x000140dc
    469c:	.word	0x00000f3d
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    46a0:	ldr	r7, [r5, #16]
    46a2:	cmp	r7, #0
    46a4:	beq.n	467c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x284>
    46a6:	ldr	r3, [r7, #0]
    46a8:	ldr	r3, [r3, #32]
    46aa:	cmp	r3, r2
    46ac:	bne.w	4c40 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x848>
    46b0:	ldr	r1, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    46b2:	str	r6, [r7, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    46b4:	cmp	r1, #0
    46b6:	beq.n	4796 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x39e>
    46b8:	ldr	r3, [r1, #16]
    46ba:	subs	r3, #1
    46bc:	str	r3, [r1, #16]
    46be:	cmp	r3, #0
    46c0:	bne.n	4796 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x39e>
    46c2:	ldr.w	r8, [r7, #16]
    46c6:	cmp.w	r8, #0
    46ca:	beq.n	4796 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x39e>
    46cc:	ldr.w	r3, [r8]
    46d0:	ldr	r3, [r3, #32]
    46d2:	cmp	r3, r2
    46d4:	bne.w	4c66 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x86e>
    46d8:	ldr.w	r1, [r8, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    46dc:	str.w	r6, [r8]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    46e0:	cmp	r1, #0
    46e2:	beq.n	478e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x396>
    46e4:	ldr	r3, [r1, #16]
    46e6:	subs	r3, #1
    46e8:	str	r3, [r1, #16]
    46ea:	cmp	r3, #0
    46ec:	bne.n	478e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x396>
    46ee:	ldr.w	r9, [r8, #16]
    46f2:	cmp.w	r9, #0
    46f6:	beq.n	478e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x396>
    46f8:	ldr.w	r3, [r9]
    46fc:	ldr	r3, [r3, #32]
    46fe:	cmp	r3, r2
    4700:	bne.w	4c6c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x874>
    4704:	ldr.w	r1, [r9, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4708:	str.w	r6, [r9]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    470c:	cmp	r1, #0
    470e:	beq.n	4786 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x38e>
    4710:	ldr	r3, [r1, #16]
    4712:	subs	r3, #1
    4714:	str	r3, [r1, #16]
    4716:	cmp	r3, #0
    4718:	bne.n	4786 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x38e>
    471a:	ldr.w	sl, [r9, #16]
    471e:	cmp.w	sl, #0
    4722:	beq.n	4786 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x38e>
    4724:	ldr.w	r3, [sl]
    4728:	ldr	r3, [r3, #32]
    472a:	cmp	r3, r2
    472c:	bne.w	4c7e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x886>
    4730:	ldr.w	r1, [sl, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4734:	str.w	r6, [sl]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4738:	cbz	r1, 477e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x386>
    473a:	ldr	r3, [r1, #16]
    473c:	subs	r3, #1
    473e:	str	r3, [r1, #16]
    4740:	cbnz	r3, 477e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x386>
    4742:	ldr.w	fp, [sl, #16]
    4746:	cmp.w	fp, #0
    474a:	beq.n	477e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x386>
    474c:	ldr.w	r3, [fp]
    4750:	ldr	r3, [r3, #32]
    4752:	cmp	r3, r2
    4754:	bne.w	4c84 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x88c>
    4758:	ldr.w	r2, [fp, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    475c:	str.w	r6, [fp]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4760:	cbz	r2, 4776 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x37e>
    4762:	ldr	r3, [r2, #16]
    4764:	subs	r3, #1
    4766:	str	r3, [r2, #16]
    4768:	cbnz	r3, 4776 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x37e>
    476a:	ldr.w	r0, [fp, #16]
    476e:	cbz	r0, 4776 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x37e>
    4770:	ldr	r3, [r0, #0]
    4772:	ldr	r3, [r3, #32]
    4774:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    4776:	mov	r0, fp
    4778:	movs	r1, #20
    477a:	bl	effc <operator delete(void*, unsigned int)>
    477e:	mov	r0, sl
    4780:	movs	r1, #20
    4782:	bl	effc <operator delete(void*, unsigned int)>
    4786:	mov	r0, r9
    4788:	movs	r1, #20
    478a:	bl	effc <operator delete(void*, unsigned int)>
    478e:	mov	r0, r8
    4790:	movs	r1, #20
    4792:	bl	effc <operator delete(void*, unsigned int)>
    4796:	mov	r0, r7
    4798:	movs	r1, #20
    479a:	bl	effc <operator delete(void*, unsigned int)>
    479e:	b.n	467c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x284>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    47a0:	mov	r0, r3
    47a2:	blx	r2
    47a4:	mov	r4, r0
    47a6:	b.n	44a4 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0xac>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    47a8:	ldr	r0, [sp, #16]
    47aa:	cmp	r0, #0
    47ac:	beq.n	484e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    47ae:	ldr	r3, [r0, #0]
    47b0:	ldr	r1, [pc, #616]	; (4a1c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x624>)
    47b2:	ldr	r3, [r3, #64]	; 0x40
    47b4:	cmp	r3, r1
    47b6:	bne.w	496a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x572>
    47ba:	ldr	r0, [r0, #16]
    47bc:	cmp	r0, #0
    47be:	beq.n	484e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    47c0:	ldr	r3, [r0, #0]
    47c2:	ldr	r3, [r3, #64]	; 0x40
    47c4:	cmp	r3, r1
    47c6:	bne.w	496a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x572>
    47ca:	ldr	r0, [r0, #16]
    47cc:	cmp	r0, #0
    47ce:	beq.n	484e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    47d0:	ldr	r3, [r0, #0]
    47d2:	ldr	r3, [r3, #64]	; 0x40
    47d4:	cmp	r3, r1
    47d6:	bne.w	496a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x572>
    47da:	ldr	r0, [r0, #16]
    47dc:	cmp	r0, #0
    47de:	beq.n	484e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    47e0:	ldr	r3, [r0, #0]
    47e2:	ldr	r3, [r3, #64]	; 0x40
    47e4:	cmp	r3, r1
    47e6:	bne.w	496a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x572>
    47ea:	ldr	r0, [r0, #16]
    47ec:	cmp	r0, #0
    47ee:	beq.n	484e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    47f0:	ldr	r3, [r0, #0]
    47f2:	ldr	r3, [r3, #64]	; 0x40
    47f4:	cmp	r3, r1
    47f6:	bne.w	496a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x572>
    47fa:	ldr	r0, [r0, #16]
    47fc:	cbz	r0, 484e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    47fe:	ldr	r3, [r0, #0]
    4800:	ldr	r3, [r3, #64]	; 0x40
    4802:	cmp	r3, r1
    4804:	bne.w	496a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x572>
    4808:	ldr	r0, [r0, #16]
    480a:	cbz	r0, 484e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    480c:	ldr	r3, [r0, #0]
    480e:	ldr	r3, [r3, #64]	; 0x40
    4810:	cmp	r3, r1
    4812:	bne.w	496a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x572>
    4816:	ldr	r0, [r0, #16]
    4818:	cbz	r0, 484e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    481a:	ldr	r3, [r0, #0]
    481c:	ldr	r3, [r3, #64]	; 0x40
    481e:	cmp	r3, r1
    4820:	bne.w	496a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x572>
    4824:	ldr	r0, [r0, #16]
    4826:	cbz	r0, 484e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    4828:	ldr	r3, [r0, #0]
    482a:	ldr	r3, [r3, #64]	; 0x40
    482c:	cmp	r3, r1
    482e:	bne.w	496a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x572>
    4832:	ldr	r0, [r0, #16]
    4834:	cbz	r0, 484e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x456>
    4836:	ldr	r3, [r0, #0]
    4838:	ldr	r3, [r3, #64]	; 0x40
    483a:	blx	r3
    Serial.print("To   "); Serial.print(store1); Serial.print(": ");Serial.println(newfilename);
  #endif

  File f1 = sd_open(store0,oldfilename,FILE_READ); if(!f1) {DBG_FAIL_MACRO; return false;}
  File f2 = sd_open(store1,newfilename,FILE_WRITE_BEGIN);
  if(!f2) { f1.close(); {DBG_FAIL_MACRO; return false;}}
    483c:	movs	r4, #0
    483e:	ldr	r3, [sp, #36]	; 0x24
    4840:	b.n	4852 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x45a>
  #if DEBUG>1
    Serial.print("From "); Serial.print(store0); Serial.print(": ");Serial.println(oldfilename);
    Serial.print("To   "); Serial.print(store1); Serial.print(": ");Serial.println(newfilename);
  #endif

  File f1 = sd_open(store0,oldfilename,FILE_READ); if(!f1) {DBG_FAIL_MACRO; return false;}
    4842:	mov	r4, r3
  // close all files
  f1.close();
  f2.close();
  if(nd<0) {DBG_FAIL_MACRO; return false;}
  return true;
}
    4844:	mov	r0, r4
    4846:	addw	sp, sp, #2092	; 0x82c
    484a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    484e:	ldr	r3, [sp, #36]	; 0x24
    Serial.print("To   "); Serial.print(store1); Serial.print(": ");Serial.println(newfilename);
  #endif

  File f1 = sd_open(store0,oldfilename,FILE_READ); if(!f1) {DBG_FAIL_MACRO; return false;}
  File f2 = sd_open(store1,newfilename,FILE_WRITE_BEGIN);
  if(!f2) { f1.close(); {DBG_FAIL_MACRO; return false;}}
    4850:	movs	r4, #0
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4852:	ldr	r6, [pc, #460]	; (4a20 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x628>)
    4854:	str	r6, [sp, #20]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4856:	cmp	r3, #0
    4858:	beq.w	495e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x566>
    485c:	ldr	r2, [r3, #16]
    485e:	subs	r2, #1
    4860:	str	r2, [r3, #16]
    4862:	cmp	r2, #0
    4864:	bne.n	495e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x566>
    4866:	ldr	r5, [sp, #36]	; 0x24
    4868:	cmp	r5, #0
    486a:	beq.n	495e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x566>
    486c:	ldr	r3, [r5, #0]
    486e:	ldr	r2, [pc, #436]	; (4a24 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x62c>)
    4870:	ldr	r3, [r3, #32]
    4872:	cmp	r3, r2
    4874:	bne.w	4c46 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x84e>
    4878:	ldr	r1, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    487a:	str	r6, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    487c:	cmp	r1, #0
    487e:	beq.n	4956 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x55e>
    4880:	ldr	r3, [r1, #16]
    4882:	subs	r3, #1
    4884:	str	r3, [r1, #16]
    4886:	cmp	r3, #0
    4888:	bne.n	4956 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x55e>
    488a:	ldr	r7, [r5, #16]
    488c:	cmp	r7, #0
    488e:	beq.n	4956 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x55e>
    4890:	ldr	r3, [r7, #0]
    4892:	ldr	r3, [r3, #32]
    4894:	cmp	r3, r2
    4896:	bne.w	4c60 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x868>
    489a:	ldr	r1, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    489c:	str	r6, [r7, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    489e:	cmp	r1, #0
    48a0:	beq.n	494e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x556>
    48a2:	ldr	r3, [r1, #16]
    48a4:	subs	r3, #1
    48a6:	str	r3, [r1, #16]
    48a8:	cmp	r3, #0
    48aa:	bne.n	494e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x556>
    48ac:	ldr.w	r8, [r7, #16]
    48b0:	cmp.w	r8, #0
    48b4:	beq.n	494e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x556>
    48b6:	ldr.w	r3, [r8]
    48ba:	ldr	r3, [r3, #32]
    48bc:	cmp	r3, r2
    48be:	bne.w	4c72 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x87a>
    48c2:	ldr.w	r1, [r8, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    48c6:	str.w	r6, [r8]
    48ca:	ldr	r0, [pc, #340]	; (4a20 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x628>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    48cc:	cmp	r1, #0
    48ce:	beq.n	4946 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x54e>
    48d0:	ldr	r3, [r1, #16]
    48d2:	subs	r3, #1
    48d4:	str	r3, [r1, #16]
    48d6:	cmp	r3, #0
    48d8:	bne.n	4946 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x54e>
    48da:	ldr.w	r9, [r8, #16]
    48de:	cmp.w	r9, #0
    48e2:	beq.n	4946 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x54e>
    48e4:	ldr.w	r3, [r9]
    48e8:	ldr	r3, [r3, #32]
    48ea:	cmp	r3, r2
    48ec:	bne.w	4c78 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x880>
    48f0:	ldr.w	r1, [r9, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    48f4:	str.w	r0, [r9]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    48f8:	cbz	r1, 493e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x546>
    48fa:	ldr	r3, [r1, #16]
    48fc:	subs	r3, #1
    48fe:	str	r3, [r1, #16]
    4900:	cbnz	r3, 493e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x546>
    4902:	ldr.w	sl, [r9, #16]
    4906:	cmp.w	sl, #0
    490a:	beq.n	493e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x546>
    490c:	ldr.w	r3, [sl]
    4910:	ldr	r3, [r3, #32]
    4912:	cmp	r3, r2
    4914:	bne.w	4c94 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x89c>
    4918:	ldr.w	r2, [sl, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    491c:	str.w	r6, [sl]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4920:	cbz	r2, 4936 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x53e>
    4922:	ldr	r3, [r2, #16]
    4924:	subs	r3, #1
    4926:	str	r3, [r2, #16]
    4928:	cbnz	r3, 4936 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x53e>
    492a:	ldr.w	r0, [sl, #16]
    492e:	cbz	r0, 4936 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x53e>
    4930:	ldr	r3, [r0, #0]
    4932:	ldr	r3, [r3, #32]
    4934:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    4936:	mov	r0, sl
    4938:	movs	r1, #20
    493a:	bl	effc <operator delete(void*, unsigned int)>
    493e:	mov	r0, r9
    4940:	movs	r1, #20
    4942:	bl	effc <operator delete(void*, unsigned int)>
    4946:	mov	r0, r8
    4948:	movs	r1, #20
    494a:	bl	effc <operator delete(void*, unsigned int)>
    494e:	mov	r0, r7
    4950:	movs	r1, #20
    4952:	bl	effc <operator delete(void*, unsigned int)>
    4956:	mov	r0, r5
    4958:	movs	r1, #20
    495a:	bl	effc <operator delete(void*, unsigned int)>
    495e:	ldr	r3, [sp, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    4960:	str	r6, [sp, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4962:	cmp	r3, #0
    4964:	bne.w	4656 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x25e>
    4968:	b.n	4684 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x28c>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    496a:	blx	r3
    496c:	movs	r4, #0
    496e:	ldr	r3, [sp, #36]	; 0x24
    4970:	b.n	4852 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x45a>
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    4972:	blx	r3
    4974:	b.n	4580 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x188>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    4976:	ldr	r5, [r1, #64]	; 0x40
    4978:	ldr	r1, [pc, #160]	; (4a1c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x624>)
    497a:	cmp	r5, r1
    497c:	bne.w	4c4c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x854>
    4980:	mov	r0, r2
    4982:	ldr	r3, [r0, #0]
    4984:	ldr	r3, [r3, #64]	; 0x40
    4986:	cmp	r3, r1
    4988:	bne.w	4c3c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x844>
    498c:	ldr	r0, [r0, #16]
    498e:	cmp	r0, #0
    4990:	beq.w	4b8e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    4994:	ldr	r3, [r0, #0]
    4996:	ldr	r3, [r3, #64]	; 0x40
    4998:	cmp	r3, r1
    499a:	bne.w	4c3c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x844>
    499e:	ldr	r0, [r0, #16]
    49a0:	cmp	r0, #0
    49a2:	beq.w	4b8e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    49a6:	ldr	r3, [r0, #0]
    49a8:	ldr	r3, [r3, #64]	; 0x40
    49aa:	cmp	r3, r1
    49ac:	bne.w	4c3c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x844>
    49b0:	ldr	r0, [r0, #16]
    49b2:	cmp	r0, #0
    49b4:	beq.w	4b8e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    49b8:	ldr	r3, [r0, #0]
    49ba:	ldr	r3, [r3, #64]	; 0x40
    49bc:	cmp	r3, r1
    49be:	bne.w	4c3c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x844>
    49c2:	ldr	r0, [r0, #16]
    49c4:	cmp	r0, #0
    49c6:	beq.w	4b8e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    49ca:	ldr	r3, [r0, #0]
    49cc:	ldr	r3, [r3, #64]	; 0x40
    49ce:	cmp	r3, r1
    49d0:	bne.w	4c3c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x844>
    49d4:	ldr	r0, [r0, #16]
    49d6:	cmp	r0, #0
    49d8:	beq.w	4b8e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    49dc:	ldr	r3, [r0, #0]
    49de:	ldr	r3, [r3, #64]	; 0x40
    49e0:	cmp	r3, r1
    49e2:	bne.w	4c3c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x844>
    49e6:	ldr	r0, [r0, #16]
    49e8:	cmp	r0, #0
    49ea:	beq.w	4b8e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    49ee:	ldr	r3, [r0, #0]
    49f0:	ldr	r3, [r3, #64]	; 0x40
    49f2:	cmp	r3, r1
    49f4:	bne.w	4c3c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x844>
    49f8:	ldr	r0, [r0, #16]
    49fa:	cmp	r0, #0
    49fc:	beq.w	4b8e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    4a00:	ldr	r3, [r0, #0]
    4a02:	ldr	r3, [r3, #64]	; 0x40
    4a04:	cmp	r3, r1
    4a06:	bne.w	4c3c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x844>
    4a0a:	ldr	r0, [r0, #16]
    4a0c:	cmp	r0, #0
    4a0e:	beq.w	4b8e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    4a12:	ldr	r3, [r0, #0]
    4a14:	ldr	r3, [r3, #64]	; 0x40
    4a16:	blx	r3
    4a18:	b.n	4b8e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    4a1a:	nop
    4a1c:	.word	0x00000501
    4a20:	.word	0x000140dc
    4a24:	.word	0x00000f3d
	}
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
	}
	virtual int available() {
		return (f) ? f->available() : 0;
    4a28:	mov	r0, r2
    4a2a:	blx	r6

  while(f1.available()>0)
    4a2c:	cmp	r0, #0
	unsigned int getRefcount() { // testing only
		return refcount;
	}
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
    4a2e:	ldr	r3, [sp, #16]
    4a30:	ble.n	4adc <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6e4>
    4a32:	cmp	r3, #0
    4a34:	beq.n	4ae4 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    4a36:	ldr	r1, [r3, #0]
    4a38:	ldr	r2, [pc, #536]	; (4c54 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x85c>)
    4a3a:	ldr	r4, [r1, #40]	; 0x28
    4a3c:	cmp	r4, r2
    4a3e:	bne.n	4abe <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6c6>
    4a40:	ldr	r0, [r3, #16]
    4a42:	cmp	r0, #0
    4a44:	beq.n	4ae4 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    4a46:	ldr	r1, [r0, #0]
    4a48:	ldr	r4, [r1, #40]	; 0x28
    4a4a:	cmp	r4, r2
    4a4c:	bne.n	4ac0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6c8>
    4a4e:	ldr	r0, [r0, #16]
    4a50:	cmp	r0, #0
    4a52:	beq.n	4ae4 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    4a54:	ldr	r1, [r0, #0]
    4a56:	ldr	r4, [r1, #40]	; 0x28
    4a58:	cmp	r4, r2
    4a5a:	bne.n	4ac0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6c8>
    4a5c:	ldr	r0, [r0, #16]
    4a5e:	cmp	r0, #0
    4a60:	beq.n	4ae4 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    4a62:	ldr	r1, [r0, #0]
    4a64:	ldr	r4, [r1, #40]	; 0x28
    4a66:	cmp	r4, r2
    4a68:	bne.n	4ac0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6c8>
    4a6a:	ldr	r0, [r0, #16]
    4a6c:	cmp	r0, #0
    4a6e:	beq.n	4ae4 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    4a70:	ldr	r1, [r0, #0]
    4a72:	ldr	r4, [r1, #40]	; 0x28
    4a74:	cmp	r4, r2
    4a76:	bne.n	4ac0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6c8>
    4a78:	ldr	r0, [r0, #16]
    4a7a:	cmp	r0, #0
    4a7c:	beq.n	4ae4 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    4a7e:	ldr	r1, [r0, #0]
    4a80:	ldr	r4, [r1, #40]	; 0x28
    4a82:	cmp	r4, r2
    4a84:	bne.n	4ac0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6c8>
    4a86:	ldr	r0, [r0, #16]
    4a88:	cbz	r0, 4ae4 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    4a8a:	ldr	r1, [r0, #0]
    4a8c:	ldr	r4, [r1, #40]	; 0x28
    4a8e:	cmp	r4, r2
    4a90:	bne.n	4ac0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6c8>
    4a92:	ldr	r0, [r0, #16]
    4a94:	cbz	r0, 4ae4 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    4a96:	ldr	r1, [r0, #0]
    4a98:	ldr	r4, [r1, #40]	; 0x28
    4a9a:	cmp	r4, r2
    4a9c:	bne.n	4ac0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6c8>
    4a9e:	ldr	r0, [r0, #16]
    4aa0:	cbz	r0, 4ae4 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    4aa2:	ldr	r1, [r0, #0]
    4aa4:	ldr	r4, [r1, #40]	; 0x28
    4aa6:	cmp	r4, r2
    4aa8:	bne.n	4ac0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6c8>
    4aaa:	ldr	r0, [r0, #16]
    4aac:	cbz	r0, 4ae4 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6ec>
    4aae:	ldr	r3, [r0, #0]
    4ab0:	mov.w	r2, #2048	; 0x800
    4ab4:	ldr	r3, [r3, #40]	; 0x28
    4ab6:	add	r1, sp, #40	; 0x28
    4ab8:	blx	r3
    4aba:	mov	r2, r0
    4abc:	b.n	4aca <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6d2>
    4abe:	mov	r0, r3
    4ac0:	mov.w	r2, #2048	; 0x800
    4ac4:	add	r1, sp, #40	; 0x28
    4ac6:	blx	r4
    4ac8:	mov	r2, r0
  {
    nd=f1.read(buffer,nbuf);
    if(nd<0) break;     // read error
    4aca:	subs	r4, r2, #0
    4acc:	blt.n	4ada <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6e2>
	}
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
    4ace:	ldr	r0, [sp, #36]	; 0x24
    4ad0:	cbnz	r0, 4af0 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6f8>
    f2.write(buffer,nd);
    if(nd<nbuf) break;  // end of file
    4ad2:	cmp.w	r4, #2048	; 0x800
    4ad6:	bge.w	458c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x194>
    4ada:	ldr	r3, [sp, #16]
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    4adc:	cmp	r3, #0
    4ade:	bne.w	4c2a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x832>
    4ae2:	b.n	4b8e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
	}
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
    4ae4:	ldr	r0, [sp, #36]	; 0x24
    4ae6:	cmp	r0, #0
    4ae8:	beq.w	4c24 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x82c>
    4aec:	movs	r2, #0
  File f2 = sd_open(store1,newfilename,FILE_WRITE_BEGIN);
  if(!f2) { f1.close(); {DBG_FAIL_MACRO; return false;}}

  while(f1.available()>0)
  {
    nd=f1.read(buffer,nbuf);
    4aee:	mov	r4, r2
    4af0:	ldr	r1, [r0, #0]
    4af2:	ldr	r3, [pc, #356]	; (4c58 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x860>)
    4af4:	ldr	r6, [r1, #44]	; 0x2c
    4af6:	cmp	r6, r3
    4af8:	bne.n	4b7a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x782>
    4afa:	ldr	r0, [r0, #16]
    4afc:	cmp	r0, #0
    4afe:	beq.n	4ad2 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    4b00:	ldr	r1, [r0, #0]
    4b02:	ldr	r6, [r1, #44]	; 0x2c
    4b04:	cmp	r6, r3
    4b06:	bne.n	4b7a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x782>
    4b08:	ldr	r0, [r0, #16]
    4b0a:	cmp	r0, #0
    4b0c:	beq.n	4ad2 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    4b0e:	ldr	r1, [r0, #0]
    4b10:	ldr	r6, [r1, #44]	; 0x2c
    4b12:	cmp	r6, r3
    4b14:	bne.n	4b7a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x782>
    4b16:	ldr	r0, [r0, #16]
    4b18:	cmp	r0, #0
    4b1a:	beq.n	4ad2 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    4b1c:	ldr	r1, [r0, #0]
    4b1e:	ldr	r6, [r1, #44]	; 0x2c
    4b20:	cmp	r6, r3
    4b22:	bne.n	4b7a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x782>
    4b24:	ldr	r0, [r0, #16]
    4b26:	cmp	r0, #0
    4b28:	beq.n	4ad2 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    4b2a:	ldr	r1, [r0, #0]
    4b2c:	ldr	r6, [r1, #44]	; 0x2c
    4b2e:	cmp	r6, r3
    4b30:	bne.n	4b7a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x782>
    4b32:	ldr	r0, [r0, #16]
    4b34:	cmp	r0, #0
    4b36:	beq.n	4ad2 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    4b38:	ldr	r1, [r0, #0]
    4b3a:	ldr	r6, [r1, #44]	; 0x2c
    4b3c:	cmp	r6, r3
    4b3e:	bne.n	4b7a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x782>
    4b40:	ldr	r0, [r0, #16]
    4b42:	cmp	r0, #0
    4b44:	beq.n	4ad2 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    4b46:	ldr	r1, [r0, #0]
    4b48:	ldr	r6, [r1, #44]	; 0x2c
    4b4a:	cmp	r6, r3
    4b4c:	bne.n	4b7a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x782>
    4b4e:	ldr	r0, [r0, #16]
    4b50:	cmp	r0, #0
    4b52:	beq.n	4ad2 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    4b54:	ldr	r1, [r0, #0]
    4b56:	ldr	r6, [r1, #44]	; 0x2c
    4b58:	cmp	r6, r3
    4b5a:	bne.n	4b7a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x782>
    4b5c:	ldr	r0, [r0, #16]
    4b5e:	cmp	r0, #0
    4b60:	beq.n	4ad2 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    4b62:	ldr	r1, [r0, #0]
    4b64:	ldr	r6, [r1, #44]	; 0x2c
    4b66:	cmp	r6, r3
    4b68:	bne.n	4b7a <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x782>
    4b6a:	ldr	r0, [r0, #16]
    4b6c:	cmp	r0, #0
    4b6e:	beq.n	4ad2 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    4b70:	ldr	r3, [r0, #0]
    4b72:	add	r1, sp, #40	; 0x28
    4b74:	ldr	r3, [r3, #44]	; 0x2c
    4b76:	blx	r3
    4b78:	b.n	4ad2 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
    4b7a:	add	r1, sp, #40	; 0x28
    4b7c:	blx	r6
    4b7e:	b.n	4ad2 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x6da>
	}
	virtual int available() {
		return (f) ? f->available() : 0;
    4b80:	mov	r0, r3
    4b82:	blx	r2
    4b84:	b.n	4a2c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x634>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    4b86:	ldr	r5, [r1, #64]	; 0x40
    4b88:	ldr	r2, [pc, #208]	; (4c5c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x864>)
    4b8a:	cmp	r5, r2
    4b8c:	bne.n	4c4c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x854>
    4b8e:	ldr	r3, [sp, #36]	; 0x24
    4b90:	cmp	r3, #0
    4b92:	beq.n	4c18 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    4b94:	ldr	r2, [r3, #0]
    4b96:	ldr	r1, [pc, #196]	; (4c5c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x864>)
    4b98:	ldr	r2, [r2, #64]	; 0x40
    4b9a:	cmp	r2, r1
    4b9c:	bne.n	4c12 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x81a>
    4b9e:	ldr	r0, [r3, #16]
    4ba0:	cmp	r0, #0
    4ba2:	beq.n	4c18 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    4ba4:	ldr	r2, [r0, #0]
    4ba6:	ldr	r2, [r2, #64]	; 0x40
    4ba8:	cmp	r2, r1
    4baa:	bne.n	4c14 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x81c>
    4bac:	ldr	r0, [r0, #16]
    4bae:	cmp	r0, #0
    4bb0:	beq.n	4c18 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    4bb2:	ldr	r2, [r0, #0]
    4bb4:	ldr	r2, [r2, #64]	; 0x40
    4bb6:	cmp	r2, r1
    4bb8:	bne.n	4c14 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x81c>
    4bba:	ldr	r0, [r0, #16]
    4bbc:	cmp	r0, #0
    4bbe:	beq.n	4c18 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    4bc0:	ldr	r2, [r0, #0]
    4bc2:	ldr	r2, [r2, #64]	; 0x40
    4bc4:	cmp	r2, r1
    4bc6:	bne.n	4c14 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x81c>
    4bc8:	ldr	r0, [r0, #16]
    4bca:	cbz	r0, 4c18 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    4bcc:	ldr	r2, [r0, #0]
    4bce:	ldr	r2, [r2, #64]	; 0x40
    4bd0:	cmp	r2, r1
    4bd2:	bne.n	4c14 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x81c>
    4bd4:	ldr	r0, [r0, #16]
    4bd6:	cbz	r0, 4c18 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    4bd8:	ldr	r2, [r0, #0]
    4bda:	ldr	r2, [r2, #64]	; 0x40
    4bdc:	cmp	r2, r1
    4bde:	bne.n	4c14 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x81c>
    4be0:	ldr	r0, [r0, #16]
    4be2:	cbz	r0, 4c18 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    4be4:	ldr	r2, [r0, #0]
    4be6:	ldr	r2, [r2, #64]	; 0x40
    4be8:	cmp	r2, r1
    4bea:	bne.n	4c14 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x81c>
    4bec:	ldr	r0, [r0, #16]
    4bee:	cbz	r0, 4c18 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    4bf0:	ldr	r2, [r0, #0]
    4bf2:	ldr	r2, [r2, #64]	; 0x40
    4bf4:	cmp	r2, r1
    4bf6:	bne.n	4c14 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x81c>
    4bf8:	ldr	r0, [r0, #16]
    4bfa:	cbz	r0, 4c18 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    4bfc:	ldr	r2, [r0, #0]
    4bfe:	ldr	r2, [r2, #64]	; 0x40
    4c00:	cmp	r2, r1
    4c02:	bne.n	4c14 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x81c>
    4c04:	ldr	r0, [r0, #16]
    4c06:	cbz	r0, 4c18 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    4c08:	ldr	r3, [r0, #0]
    4c0a:	ldr	r3, [r3, #64]	; 0x40
    4c0c:	blx	r3
    4c0e:	ldr	r3, [sp, #36]	; 0x24
    4c10:	b.n	4c18 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    4c12:	mov	r0, r3
    4c14:	blx	r2
    4c16:	ldr	r3, [sp, #36]	; 0x24
    if(nd<nbuf) break;  // end of file
  }
  // close all files
  f1.close();
  f2.close();
  if(nd<0) {DBG_FAIL_MACRO; return false;}
    4c18:	mvns	r4, r4
    4c1a:	lsrs	r4, r4, #31
    4c1c:	b.n	4852 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x45a>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4c1e:	mov	r0, r5
    4c20:	blx	r3
    4c22:	b.n	4684 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x28c>
  File f2 = sd_open(store1,newfilename,FILE_WRITE_BEGIN);
  if(!f2) { f1.close(); {DBG_FAIL_MACRO; return false;}}

  while(f1.available()>0)
  {
    nd=f1.read(buffer,nbuf);
    4c24:	mov	r4, r0
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    4c26:	cmp	r3, #0
    4c28:	beq.n	4c90 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x898>
    4c2a:	ldr	r2, [r3, #0]
    4c2c:	ldr	r1, [pc, #44]	; (4c5c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x864>)
    4c2e:	ldr	r5, [r2, #64]	; 0x40
    4c30:	cmp	r5, r1
    4c32:	bne.n	4c4c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x854>
    4c34:	ldr	r0, [r3, #16]
    4c36:	cmp	r0, #0
    4c38:	beq.n	4b8e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    4c3a:	b.n	4982 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x58a>
    4c3c:	blx	r3
    4c3e:	b.n	4b8e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4c40:	mov	r0, r7
    4c42:	blx	r3
    4c44:	b.n	467c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x284>
    4c46:	mov	r0, r5
    4c48:	blx	r3
    4c4a:	b.n	495e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x566>
	}
	virtual uint64_t size() {
		return (f) ? f->size() : 0;
	}
	virtual void close() {
		if (f) f->close();
    4c4c:	mov	r0, r3
    4c4e:	blx	r5
    4c50:	b.n	4b8e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x796>
    4c52:	nop
    4c54:	.word	0x0000047d
    4c58:	.word	0x00000489
    4c5c:	.word	0x00000501
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    4c60:	mov	r0, r7
    4c62:	blx	r3
    4c64:	b.n	4956 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x55e>
    4c66:	mov	r0, r8
    4c68:	blx	r3
    4c6a:	b.n	4796 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x39e>
    4c6c:	mov	r0, r9
    4c6e:	blx	r3
    4c70:	b.n	478e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x396>
    4c72:	mov	r0, r8
    4c74:	blx	r3
    4c76:	b.n	494e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x556>
    4c78:	mov	r0, r9
    4c7a:	blx	r3
    4c7c:	b.n	4946 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x54e>
    4c7e:	mov	r0, sl
    4c80:	blx	r3
    4c82:	b.n	4786 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x38e>
    4c84:	mov	r0, fp
    4c86:	blx	r3
    4c88:	b.n	477e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x386>
    4c8a:	ldr	r3, [sp, #16]
    4c8c:	ldr	r6, [pc, #12]	; (4c9c <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x8a4>)
    4c8e:	b.n	4960 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x568>
    4c90:	mov	r4, r3
    4c92:	b.n	4c18 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x820>
    4c94:	mov	r0, sl
    4c96:	blx	r3
    4c98:	b.n	493e <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)+0x546>
    4c9a:	nop
    4c9c:	.word	0x000140dc

00004ca0 <MTPStorage_SD::copy(unsigned long, unsigned long, unsigned long)>:
    WriteIndexRecord(newParent,p2o);      
    return false;
  }

  uint32_t MTPStorage_SD::copy(uint32_t handle, uint32_t newStore, uint32_t newParent ) 
  { 
    4ca0:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4ca4:	mov	r8, r1
    4ca6:	sub.w	sp, sp, #1336	; 0x538
    if(newParent==0xFFFFFFFFUL) newParent=newStore;
    4caa:	cmp.w	r3, #4294967295
    4cae:	ite	ne
    4cb0:	movne	r7, r3
    4cb2:	moveq	r7, r2

    Record p1 = ReadIndexRecord(handle);
    4cb4:	mov	r1, r0
    WriteIndexRecord(newParent,p2o);      
    return false;
  }

  uint32_t MTPStorage_SD::copy(uint32_t handle, uint32_t newStore, uint32_t newParent ) 
  { 
    4cb6:	mov	r4, r0
    if(newParent==0xFFFFFFFFUL) newParent=newStore;

    Record p1 = ReadIndexRecord(handle);
    4cb8:	mov	r2, r8
    4cba:	add	r0, sp, #520	; 0x208
    4cbc:	bl	26c8 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    Record p2 = ReadIndexRecord(newParent);
    4cc0:	mov	r2, r7
    4cc2:	mov	r1, r4
    4cc4:	add	r0, sp, #792	; 0x318
    4cc6:	bl	26c8 <MTPStorage_SD::ReadIndexRecord(unsigned long)>

    uint32_t newHandle;
    if(p1.isdir)
    4cca:	ldrb.w	r6, [sp, #532]	; 0x214
    4cce:	cmp	r6, #0
    4cd0:	bne.n	4d58 <MTPStorage_SD::copy(unsigned long, unsigned long, unsigned long)+0xb8>
      CopyFiles(handle, p2.store, newHandle);
    }
    else
    {  
      Record r;
      strlcpy(r.name, p1.name,MAX_FILENAME_LEN);
    4cd2:	add	r1, sp, #536	; 0x218
    4cd4:	mov.w	r2, #256	; 0x100
    4cd8:	add.w	r0, sp, #1080	; 0x438
    4cdc:	bl	10ba0 <strlcpy>
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    4ce0:	ldr.w	r5, [r4, #244]	; 0xf4
    }
    else
    {  
      Record r;
      strlcpy(r.name, p1.name,MAX_FILENAME_LEN);
      r.store = p2.store;
    4ce4:	ldrh.w	r0, [sp, #806]	; 0x326
      r.parent = newParent;
      r.child = 0;
      r.sibling = p2.child;
    4ce8:	ldr	r3, [sp, #796]	; 0x31c
    }
    else
    {  
      Record r;
      strlcpy(r.name, p1.name,MAX_FILENAME_LEN);
      r.store = p2.store;
    4cea:	strh.w	r0, [sp, #1078]	; 0x436
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    4cee:	adds	r2, r5, #1
    4cf0:	str.w	r2, [r4, #244]	; 0xf4
    WriteIndexRecord(new_record, r);
    4cf4:	mov	r1, r5
    4cf6:	add.w	r2, sp, #1064	; 0x428
    4cfa:	mov	r0, r4
      Record r;
      strlcpy(r.name, p1.name,MAX_FILENAME_LEN);
      r.store = p2.store;
      r.parent = newParent;
      r.child = 0;
      r.sibling = p2.child;
    4cfc:	str.w	r3, [sp, #1072]	; 0x430
    else
    {  
      Record r;
      strlcpy(r.name, p1.name,MAX_FILENAME_LEN);
      r.store = p2.store;
      r.parent = newParent;
    4d00:	str.w	r7, [sp, #1064]	; 0x428
      r.child = 0;
    4d04:	str.w	r6, [sp, #1068]	; 0x42c
      r.sibling = p2.child;
      r.isdir = 0;
    4d08:	strb.w	r6, [sp, #1076]	; 0x434
      r.scanned = 0;
    4d0c:	strb.w	r6, [sp, #1077]	; 0x435
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    WriteIndexRecord(new_record, r);
    4d10:	bl	24e8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
      r.child = 0;
      r.sibling = p2.child;
      r.isdir = 0;
      r.scanned = 0;
      newHandle = p2.child = AppendIndexRecord(r);
      WriteIndexRecord(newParent, p2);
    4d14:	add	r2, sp, #792	; 0x318
    4d16:	mov	r1, r7
    4d18:	mov	r0, r4
      r.parent = newParent;
      r.child = 0;
      r.sibling = p2.child;
      r.isdir = 0;
      r.scanned = 0;
      newHandle = p2.child = AppendIndexRecord(r);
    4d1a:	str	r5, [sp, #796]	; 0x31c
      WriteIndexRecord(newParent, p2);
    4d1c:	bl	24e8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>

      char oldfilename[MAX_FILENAME_LEN];
      char newfilename[MAX_FILENAME_LEN];
      uint32_t store0 = ConstructFilename(handle,oldfilename,MAX_FILENAME_LEN);
    4d20:	mov	r1, r8
    4d22:	add	r2, sp, #8
    4d24:	mov.w	r3, #256	; 0x100
    4d28:	mov	r0, r4
    4d2a:	bl	2b28 <MTPStorage_SD::ConstructFilename(int, char*, int)>
      uint32_t store1 = ConstructFilename(newHandle,newfilename,MAX_FILENAME_LEN);
    4d2e:	add	r6, sp, #264	; 0x108
      newHandle = p2.child = AppendIndexRecord(r);
      WriteIndexRecord(newParent, p2);

      char oldfilename[MAX_FILENAME_LEN];
      char newfilename[MAX_FILENAME_LEN];
      uint32_t store0 = ConstructFilename(handle,oldfilename,MAX_FILENAME_LEN);
    4d30:	mov	r7, r0
      uint32_t store1 = ConstructFilename(newHandle,newfilename,MAX_FILENAME_LEN);
    4d32:	mov	r1, r5
    4d34:	mov	r2, r6
    4d36:	mov.w	r3, #256	; 0x100
    4d3a:	mov	r0, r4
    4d3c:	bl	2b28 <MTPStorage_SD::ConstructFilename(int, char*, int)>

      sd_copy(store0,oldfilename,store1,newfilename);
    4d40:	str	r6, [sp, #0]
    4d42:	mov	r3, r0
    4d44:	add	r2, sp, #8
    4d46:	mov	r1, r7
    4d48:	adds	r0, r4, #4
    4d4a:	bl	43f8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)>
    }

    return newHandle;
  }
    4d4e:	mov	r0, r5
    4d50:	add.w	sp, sp, #1336	; 0x538
    4d54:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    Record p2 = ReadIndexRecord(newParent);

    uint32_t newHandle;
    if(p1.isdir)
    {
      ScanDir(p1.store+1,handle);
    4d58:	ldrh.w	r1, [sp, #534]	; 0x216
    4d5c:	mov	r2, r8
    4d5e:	mov	r0, r4
    4d60:	adds	r1, #1
    4d62:	bl	32b4 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)>
      newHandle = Create(p2.store,newParent,p1.isdir,p1.name);
    4d66:	ldrb.w	r3, [sp, #532]	; 0x214
    4d6a:	ldr	r0, [r4, #0]
    4d6c:	ldrh.w	r1, [sp, #806]	; 0x326
    4d70:	add	r2, sp, #536	; 0x218
    4d72:	adds	r3, #0
    4d74:	str	r2, [sp, #0]
    4d76:	it	ne
    4d78:	movne	r3, #1
    4d7a:	mov	r2, r7
    4d7c:	ldr	r5, [r0, #44]	; 0x2c
    4d7e:	mov	r0, r4
    4d80:	blx	r5
      CopyFiles(handle, p2.store, newHandle);
    4d82:	ldr	r3, [r4, #0]
    4d84:	ldrh.w	r2, [sp, #806]	; 0x326
    4d88:	ldr	r6, [r3, #84]	; 0x54

    uint32_t newHandle;
    if(p1.isdir)
    {
      ScanDir(p1.store+1,handle);
      newHandle = Create(p2.store,newParent,p1.isdir,p1.name);
    4d8a:	mov	r5, r0
      CopyFiles(handle, p2.store, newHandle);
    4d8c:	mov	r3, r0
    4d8e:	mov	r1, r8
    4d90:	mov	r0, r4
    4d92:	blx	r6

      sd_copy(store0,oldfilename,store1,newfilename);
    }

    return newHandle;
  }
    4d94:	mov	r0, r5
    4d96:	add.w	sp, sp, #1336	; 0x538
    4d9a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4d9e:	nop

00004da0 <MTPStorage_SD::CopyFiles(unsigned long, unsigned long, unsigned long)>:

bool MTPStorage_SD::CopyFiles(uint32_t handle, uint32_t store, uint32_t newHandle)
{ // assume handle and newHandle point to existing directories
    4da0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4da4:	mov	r4, r0
    4da6:	subw	sp, sp, #1612	; 0x64c
  if(newHandle==0xFFFFFFFFUL) newHandle=store;
    4daa:	cmp.w	r3, #4294967295
    4dae:	ite	ne
    4db0:	movne	r8, r3
    4db2:	moveq	r8, r2
  #if DEBUG>1
    Serial.printf("%d -> %d\n",handle,newHandle);
  #endif

  Record p1=ReadIndexRecord(handle);
    4db4:	add	r0, sp, #520	; 0x208
    4db6:	mov	r2, r1
    4db8:	mov	r1, r4
    4dba:	bl	26c8 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
  Record p2=ReadIndexRecord(newHandle);
    4dbe:	mov	r2, r8
    4dc0:	mov	r1, r4
    4dc2:	add	r0, sp, #792	; 0x318
  if(newHandle==0xFFFFFFFFUL) newHandle=store;
  #if DEBUG>1
    Serial.printf("%d -> %d\n",handle,newHandle);
  #endif

  Record p1=ReadIndexRecord(handle);
    4dc4:	ldrh.w	r9, [sp, #534]	; 0x216
  Record p2=ReadIndexRecord(newHandle);
    4dc8:	bl	26c8 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
  uint32_t ix= p1.child;
    4dcc:	ldr	r6, [sp, #524]	; 0x20c
  uint32_t iy= 0;
  while(ix)
    4dce:	cmp	r6, #0
    4dd0:	beq.n	4ea6 <MTPStorage_SD::CopyFiles(unsigned long, unsigned long, unsigned long)+0x106>
    4dd2:	movs	r5, #0
    4dd4:	add	r7, sp, #264	; 0x108

      ScanDir(p1.store,ix); 
      CopyFiles(ix,p2.store,iy); 
    }
    else
    { sd_copy(p1.store,oldfilename,py.store,newfilename);
    4dd6:	add.w	sl, r4, #4
    4dda:	b.n	4e10 <MTPStorage_SD::CopyFiles(unsigned long, unsigned long, unsigned long)+0x70>
    bool sd_mkdir(uint32_t store, char *filename) {  return sdx[store]->mkdir(filename);  }
    4ddc:	ldrh.w	r3, [sp, #1350]	; 0x546
    4de0:	add.w	r3, r4, r3, lsl #2
    4de4:	ldr	r0, [r3, #88]	; 0x58
    4de6:	ldr	r3, [r0, #0]
    4de8:	ldr	r3, [r3, #8]
    4dea:	blx	r3

    if(py.isdir) 
    { 
      sd_mkdir(py.store,newfilename);

      ScanDir(p1.store,ix); 
    4dec:	mov	r2, r6
    4dee:	mov	r1, r9
    4df0:	mov	r0, r4
    4df2:	bl	32b4 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)>
      CopyFiles(ix,p2.store,iy); 
    4df6:	ldr	r3, [r4, #0]
    4df8:	ldrh.w	r2, [sp, #806]	; 0x326
    4dfc:	ldr.w	fp, [r3, #84]	; 0x54
    4e00:	mov	r1, r6
    4e02:	mov	r3, r5
    4e04:	mov	r0, r4
    4e06:	blx	fp
    }
    else
    { sd_copy(p1.store,oldfilename,py.store,newfilename);
    }
    ix = px.sibling;
    4e08:	ldr.w	r6, [sp, #1072]	; 0x430

  Record p1=ReadIndexRecord(handle);
  Record p2=ReadIndexRecord(newHandle);
  uint32_t ix= p1.child;
  uint32_t iy= 0;
  while(ix)
    4e0c:	cmp	r6, #0
    4e0e:	beq.n	4e90 <MTPStorage_SD::CopyFiles(unsigned long, unsigned long, unsigned long)+0xf0>
  { // get child
    Record px = ReadIndexRecord(ix) ;
    4e10:	mov	r2, r6
    4e12:	mov	r1, r4
    4e14:	add.w	r0, sp, #1064	; 0x428
    4e18:	bl	26c8 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    Record py = px;
    4e1c:	mov.w	r2, #272	; 0x110
    4e20:	add.w	r1, sp, #1064	; 0x428
    4e24:	add.w	r0, sp, #1336	; 0x538
    4e28:	bl	d444 <memcpy>
    py.store = p2.store;
    py.parent = newHandle;
    py.sibling = iy;
    4e2c:	str.w	r5, [sp, #1344]	; 0x540
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    4e30:	ldr.w	r5, [r4, #244]	; 0xf4
  uint32_t iy= 0;
  while(ix)
  { // get child
    Record px = ReadIndexRecord(ix) ;
    Record py = px;
    py.store = p2.store;
    4e34:	ldrh.w	r3, [sp, #806]	; 0x326
    4e38:	strh.w	r3, [sp, #1350]	; 0x546
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    4e3c:	adds	r2, r5, #1
    4e3e:	str.w	r2, [r4, #244]	; 0xf4
    WriteIndexRecord(new_record, r);
    4e42:	mov	r1, r5
    4e44:	add.w	r2, sp, #1336	; 0x538
    4e48:	mov	r0, r4
  while(ix)
  { // get child
    Record px = ReadIndexRecord(ix) ;
    Record py = px;
    py.store = p2.store;
    py.parent = newHandle;
    4e4a:	str.w	r8, [sp, #1336]	; 0x538
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) 
  { uint32_t new_record = index_entries_++;
    WriteIndexRecord(new_record, r);
    4e4e:	bl	24e8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    py.sibling = iy;
    iy = AppendIndexRecord(py);

    char oldfilename[MAX_FILENAME_LEN];
    char newfilename[MAX_FILENAME_LEN];
    ConstructFilename(ix,oldfilename,MAX_FILENAME_LEN);
    4e52:	mov.w	r3, #256	; 0x100
    4e56:	add	r2, sp, #8
    4e58:	mov	r1, r6
    4e5a:	mov	r0, r4
    4e5c:	bl	2b28 <MTPStorage_SD::ConstructFilename(int, char*, int)>
    ConstructFilename(iy,newfilename,MAX_FILENAME_LEN);
    4e60:	mov	r1, r5
    4e62:	mov.w	r3, #256	; 0x100
    4e66:	mov	r2, r7
    4e68:	mov	r0, r4
    4e6a:	bl	2b28 <MTPStorage_SD::ConstructFilename(int, char*, int)>

    if(py.isdir) 
    4e6e:	ldrb.w	r3, [sp, #1348]	; 0x544
    4e72:	mov	r1, r7

      ScanDir(p1.store,ix); 
      CopyFiles(ix,p2.store,iy); 
    }
    else
    { sd_copy(p1.store,oldfilename,py.store,newfilename);
    4e74:	add	r2, sp, #8
    4e76:	mov	r0, sl
    char oldfilename[MAX_FILENAME_LEN];
    char newfilename[MAX_FILENAME_LEN];
    ConstructFilename(ix,oldfilename,MAX_FILENAME_LEN);
    ConstructFilename(iy,newfilename,MAX_FILENAME_LEN);

    if(py.isdir) 
    4e78:	cmp	r3, #0
    4e7a:	bne.n	4ddc <MTPStorage_SD::CopyFiles(unsigned long, unsigned long, unsigned long)+0x3c>

      ScanDir(p1.store,ix); 
      CopyFiles(ix,p2.store,iy); 
    }
    else
    { sd_copy(p1.store,oldfilename,py.store,newfilename);
    4e7c:	ldrh.w	r3, [sp, #1350]	; 0x546
    4e80:	str	r7, [sp, #0]
    4e82:	mov	r1, r9
    4e84:	bl	43f8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)>
    }
    ix = px.sibling;
    4e88:	ldr.w	r6, [sp, #1072]	; 0x430

  Record p1=ReadIndexRecord(handle);
  Record p2=ReadIndexRecord(newHandle);
  uint32_t ix= p1.child;
  uint32_t iy= 0;
  while(ix)
    4e8c:	cmp	r6, #0
    4e8e:	bne.n	4e10 <MTPStorage_SD::CopyFiles(unsigned long, unsigned long, unsigned long)+0x70>
    { sd_copy(p1.store,oldfilename,py.store,newfilename);
    }
    ix = px.sibling;
  }
  p2.child=iy;
  WriteIndexRecord(newHandle,p2);
    4e90:	mov	r0, r4
    4e92:	mov	r1, r8
    4e94:	add	r2, sp, #792	; 0x318
    else
    { sd_copy(p1.store,oldfilename,py.store,newfilename);
    }
    ix = px.sibling;
  }
  p2.child=iy;
    4e96:	str	r5, [sp, #796]	; 0x31c
  WriteIndexRecord(newHandle,p2);
    4e98:	bl	24e8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
  return true;
}
    4e9c:	movs	r0, #1
    4e9e:	addw	sp, sp, #1612	; 0x64c
    4ea2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  #endif

  Record p1=ReadIndexRecord(handle);
  Record p2=ReadIndexRecord(newHandle);
  uint32_t ix= p1.child;
  uint32_t iy= 0;
    4ea6:	mov	r5, r6
    4ea8:	b.n	4e90 <MTPStorage_SD::CopyFiles(unsigned long, unsigned long, unsigned long)+0xf0>
    4eaa:	nop

00004eac <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*)>:
  if(nd<0) {DBG_FAIL_MACRO; return false;}
  return true;
}

bool mSD_Base::sd_moveDir(uint32_t store0, char *oldfilename, uint32_t store1, char *newfilename)
{ // old and new are directory paths
    4eac:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4eb0:	mov	r5, r3
    4eb2:	add.w	r3, r0, r3, lsl #2
    4eb6:	mov	r4, r0
    4eb8:	ldr	r0, [r3, #84]	; 0x54
    4eba:	ldr	r6, [sp, #24]
    4ebc:	ldr	r3, [r0, #0]
    4ebe:	mov	r7, r1
    4ec0:	ldr	r3, [r3, #8]
    4ec2:	mov	r1, r6
    4ec4:	mov	r8, r2
    4ec6:	blx	r3

  char tmp0Name[MAX_FILENAME_LEN];
  char tmp1Name[MAX_FILENAME_LEN];

  if(!sd_mkdir(store1,newfilename))  {DBG_FAIL_MACRO; return false;}
    4ec8:	cbnz	r0, 4ece <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*)+0x22>
        }
      }
    }
  }
  return sd_rmdir(store0,oldfilename);
}
    4eca:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4ece:	str	r6, [sp, #24]
    4ed0:	mov	r3, r5
    4ed2:	mov	r2, r8
    4ed4:	mov	r1, r7
    4ed6:	mov	r0, r4
    4ed8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    4edc:	b.w	4ee0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]>

00004ee0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]>:
  f2.close();
  if(nd<0) {DBG_FAIL_MACRO; return false;}
  return true;
}

bool mSD_Base::sd_moveDir(uint32_t store0, char *oldfilename, uint32_t store1, char *newfilename)
    4ee0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4ee4:	add.w	sl, r0, r1, lsl #2
    4ee8:	mov	r8, r1
    }

    uint32_t sd_getFSCount(void) {return fsCount;}
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}

    File sd_open(uint32_t store, const char *filename, uint32_t mode) { return sdx[store]->open(filename,mode);  }
    4eea:	ldr.w	r1, [sl, #84]	; 0x54
    4eee:	sub.w	sp, sp, #596	; 0x254
    4ef2:	mov	r9, r0
    4ef4:	ldr	r0, [r1, #0]
    4ef6:	str	r3, [sp, #8]
    4ef8:	ldr	r4, [r0, #0]
    4efa:	str	r2, [sp, #12]
    4efc:	movs	r3, #0
    4efe:	add	r0, sp, #40	; 0x28
    4f00:	blx	r4
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    4f02:	ldr	r3, [sp, #56]	; 0x38
    4f04:	cmp	r3, #0
    4f06:	beq.w	585e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x97e>
    4f0a:	ldr	r2, [r3, #0]
    4f0c:	ldr	r6, [pc, #460]	; (50dc <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1fc>)
    4f0e:	ldr	r2, [r2, #68]	; 0x44
    4f10:	cmp	r2, r6
    4f12:	bne.w	51ea <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x30a>
    4f16:	ldr	r0, [r3, #16]
    4f18:	cmp	r0, #0
    4f1a:	beq.w	5098 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1b8>
    4f1e:	ldr	r2, [r0, #0]
    4f20:	ldr	r2, [r2, #68]	; 0x44
    4f22:	cmp	r2, r6
    4f24:	bne.w	51ec <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x30c>
    4f28:	ldr	r0, [r0, #16]
    4f2a:	cmp	r0, #0
    4f2c:	beq.w	5098 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1b8>
    4f30:	ldr	r2, [r0, #0]
    4f32:	ldr	r2, [r2, #68]	; 0x44
    4f34:	cmp	r2, r6
    4f36:	bne.w	51ec <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x30c>
    4f3a:	ldr	r0, [r0, #16]
    4f3c:	cmp	r0, #0
    4f3e:	beq.w	5098 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1b8>
    4f42:	ldr	r2, [r0, #0]
    4f44:	ldr	r2, [r2, #68]	; 0x44
    4f46:	cmp	r2, r6
    4f48:	bne.w	51ec <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x30c>
    4f4c:	ldr	r0, [r0, #16]
    4f4e:	cmp	r0, #0
    4f50:	beq.w	5098 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1b8>
    4f54:	ldr	r2, [r0, #0]
    4f56:	ldr	r2, [r2, #68]	; 0x44
    4f58:	cmp	r2, r6
    4f5a:	bne.w	51ec <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x30c>
    4f5e:	ldr	r0, [r0, #16]
    4f60:	cmp	r0, #0
    4f62:	beq.w	5098 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1b8>
    4f66:	ldr	r2, [r0, #0]
    4f68:	ldr	r2, [r2, #68]	; 0x44
    4f6a:	cmp	r2, r6
    4f6c:	bne.w	51ec <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x30c>
    4f70:	ldr	r0, [r0, #16]
    4f72:	cmp	r0, #0
    4f74:	beq.w	5098 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1b8>
    4f78:	ldr	r2, [r0, #0]
    4f7a:	ldr	r2, [r2, #68]	; 0x44
    4f7c:	cmp	r2, r6
    4f7e:	bne.w	51ec <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x30c>
    4f82:	ldr	r0, [r0, #16]
    4f84:	cmp	r0, #0
    4f86:	beq.w	5098 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1b8>
    4f8a:	ldr	r3, [r0, #0]
    4f8c:	ldr	r3, [r3, #68]	; 0x44
    4f8e:	blx	r3
    4f90:	mov	r4, r0
  char tmp1Name[MAX_FILENAME_LEN];

  if(!sd_mkdir(store1,newfilename))  {DBG_FAIL_MACRO; return false;}

  File f1=sd_open(store0,oldfilename,FILE_READ);
  if(!f1) {DBG_FAIL_MACRO; return false;}
    4f92:	cmp	r4, #0
    4f94:	beq.w	5914 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa34>
    4f98:	ldr.w	fp, [pc, #336]	; 50ec <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x20c>
    4f9c:	add	r4, sp, #336	; 0x150
  { while(1)
    {
      strlcpy(tmp0Name,oldfilename,MAX_FILENAME_LEN);
    4f9e:	mov.w	r2, #256	; 0x100
    4fa2:	ldr	r1, [sp, #12]
    4fa4:	add	r0, sp, #80	; 0x50
    4fa6:	bl	10ba0 <strlcpy>
      if(tmp0Name[strlen(tmp0Name)-1]!='/') strlcat(tmp0Name,"/",MAX_FILENAME_LEN);
    4faa:	add	r0, sp, #80	; 0x50
    4fac:	bl	10c00 <strlen>
    4fb0:	add	r3, sp, #80	; 0x50
    4fb2:	add	r0, r3
    4fb4:	ldrb.w	r3, [r0, #-1]
    4fb8:	cmp	r3, #47	; 0x2f
    4fba:	beq.n	4fc8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xe8>
    4fbc:	mov.w	r2, #256	; 0x100
    4fc0:	ldr	r1, [pc, #284]	; (50e0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x200>)
    4fc2:	add	r0, sp, #80	; 0x50
    4fc4:	bl	10b4c <strlcat>

      strlcpy(tmp1Name,newfilename,MAX_FILENAME_LEN);
    4fc8:	mov.w	r2, #256	; 0x100
    4fcc:	ldr	r1, [sp, #632]	; 0x278
    4fce:	mov	r0, r4
    4fd0:	bl	10ba0 <strlcpy>
      if(tmp1Name[strlen(tmp1Name)-1]!='/') strlcat(tmp1Name,"/",MAX_FILENAME_LEN);
    4fd4:	mov	r0, r4
    4fd6:	bl	10c00 <strlen>
    4fda:	add	r0, r4
    4fdc:	ldrb.w	r3, [r0, #-1]
    4fe0:	cmp	r3, #47	; 0x2f
    4fe2:	beq.n	4ff0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x110>
    4fe4:	mov.w	r2, #256	; 0x100
    4fe8:	ldr	r1, [pc, #244]	; (50e0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x200>)
    4fea:	mov	r0, r4
    4fec:	bl	10b4c <strlcat>
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
	}
	virtual File openNextFile(uint8_t mode=0) {
		return (f) ? f->openNextFile(mode) : *this;
    4ff0:	ldr	r1, [sp, #56]	; 0x38
    4ff2:	cmp	r1, #0
    4ff4:	beq.w	52ae <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    4ff8:	ldr	r3, [r1, #0]
    4ffa:	ldr	r2, [pc, #232]	; (50e4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x204>)
    4ffc:	ldr	r3, [r3, #80]	; 0x50
    4ffe:	cmp	r3, r2
    5000:	bne.w	52d4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f4>
    5004:	ldr	r1, [r1, #16]
    5006:	cmp	r1, #0
    5008:	beq.w	52ae <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    500c:	ldr	r3, [r1, #0]
    500e:	ldr	r3, [r3, #80]	; 0x50
    5010:	cmp	r3, r2
    5012:	bne.w	52d4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f4>
    5016:	ldr	r1, [r1, #16]
    5018:	cmp	r1, #0
    501a:	beq.w	52ae <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    501e:	ldr	r3, [r1, #0]
    5020:	ldr	r3, [r3, #80]	; 0x50
    5022:	cmp	r3, r2
    5024:	bne.w	52d4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f4>
    5028:	ldr	r1, [r1, #16]
    502a:	cmp	r1, #0
    502c:	beq.w	52ae <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    5030:	ldr	r3, [r1, #0]
    5032:	ldr	r3, [r3, #80]	; 0x50
    5034:	cmp	r3, r2
    5036:	bne.w	52d4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f4>
    503a:	ldr	r1, [r1, #16]
    503c:	cmp	r1, #0
    503e:	beq.w	52ae <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    5042:	ldr	r3, [r1, #0]
    5044:	ldr	r3, [r3, #80]	; 0x50
    5046:	cmp	r3, r2
    5048:	bne.w	52d4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f4>
    504c:	ldr	r1, [r1, #16]
    504e:	cmp	r1, #0
    5050:	beq.w	52ae <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    5054:	ldr	r3, [r1, #0]
    5056:	ldr	r3, [r3, #80]	; 0x50
    5058:	cmp	r3, r2
    505a:	bne.w	52d4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f4>
    505e:	ldr	r1, [r1, #16]
    5060:	cmp	r1, #0
    5062:	beq.w	52ae <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    5066:	ldr	r3, [r1, #0]
    5068:	ldr	r3, [r3, #80]	; 0x50
    506a:	cmp	r3, r2
    506c:	bne.w	52d4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f4>
    5070:	ldr	r1, [r1, #16]
    5072:	cmp	r1, #0
    5074:	beq.w	52ae <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    5078:	ldr	r3, [r1, #0]
    507a:	ldr	r3, [r3, #80]	; 0x50
    507c:	cmp	r3, r2
    507e:	bne.w	52d4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f4>
    5082:	ldr	r1, [r1, #16]
    5084:	cmp	r1, #0
    5086:	beq.w	52ae <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    508a:	ldr	r3, [r1, #0]
    508c:	add	r5, sp, #60	; 0x3c
    508e:	ldr	r3, [r3, #80]	; 0x50
    5090:	mov	r0, r5
    5092:	movs	r2, #0
    5094:	blx	r3
    5096:	b.n	52dc <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3fc>
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5098:	ldr.w	fp, [pc, #80]	; 50ec <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x20c>
    509c:	str.w	fp, [sp, #40]	; 0x28
    50a0:	movs	r4, #0
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    50a2:	ldr	r2, [r3, #16]
    50a4:	subs	r2, #1
    50a6:	str	r2, [r3, #16]
    50a8:	cbnz	r2, 50d2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1f2>
    50aa:	ldr	r5, [sp, #56]	; 0x38
    50ac:	cbz	r5, 50d2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1f2>
    50ae:	ldr	r2, [r5, #0]
    50b0:	ldr	r3, [pc, #52]	; (50e8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x208>)
    50b2:	ldr	r2, [r2, #32]
    50b4:	cmp	r2, r3
    50b6:	bne.w	5878 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x998>
    50ba:	ldr	r1, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    50bc:	str.w	fp, [r5]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    50c0:	cbz	r1, 50ca <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1ea>
    50c2:	ldr	r2, [r1, #16]
    50c4:	subs	r2, #1
    50c6:	str	r2, [r1, #16]
    50c8:	cbz	r2, 50f0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x210>
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    50ca:	mov	r0, r5
    50cc:	movs	r1, #20
    50ce:	bl	effc <operator delete(void*, unsigned int)>
        }
      }
    }
  }
  return sd_rmdir(store0,oldfilename);
}
    50d2:	mov	r0, r4
    50d4:	add.w	sp, sp, #596	; 0x254
    50d8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    50dc:	.word	0x0000050d
    50e0:	.word	0x000143ec
    50e4:	.word	0x00000539
    50e8:	.word	0x00000f3d
    50ec:	.word	0x000140dc
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    50f0:	ldr	r6, [r5, #16]
    50f2:	cmp	r6, #0
    50f4:	beq.n	50ca <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1ea>
    50f6:	ldr	r2, [r6, #0]
    50f8:	ldr	r2, [r2, #32]
    50fa:	cmp	r2, r3
    50fc:	bne.w	588e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9ae>
    5100:	ldr	r1, [r6, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5102:	str.w	fp, [r6]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5106:	cmp	r1, #0
    5108:	beq.n	51e0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x300>
    510a:	ldr	r2, [r1, #16]
    510c:	subs	r2, #1
    510e:	str	r2, [r1, #16]
    5110:	cmp	r2, #0
    5112:	bne.n	51e0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x300>
    5114:	ldr	r7, [r6, #16]
    5116:	cmp	r7, #0
    5118:	beq.n	51e0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x300>
    511a:	ldr	r2, [r7, #0]
    511c:	ldr	r2, [r2, #32]
    511e:	cmp	r2, r3
    5120:	bne.w	58aa <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9ca>
    5124:	ldr	r1, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5126:	str.w	fp, [r7]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    512a:	cmp	r1, #0
    512c:	beq.n	51d8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2f8>
    512e:	ldr	r2, [r1, #16]
    5130:	subs	r2, #1
    5132:	str	r2, [r1, #16]
    5134:	cmp	r2, #0
    5136:	bne.n	51d8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2f8>
    5138:	ldr.w	r8, [r7, #16]
    513c:	cmp.w	r8, #0
    5140:	beq.n	51d8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2f8>
    5142:	ldr.w	r2, [r8]
    5146:	ldr	r2, [r2, #32]
    5148:	cmp	r2, r3
    514a:	bne.w	58c0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9e0>
    514e:	ldr.w	r1, [r8, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5152:	str.w	fp, [r8]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5156:	cmp	r1, #0
    5158:	beq.n	51d0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2f0>
    515a:	ldr	r2, [r1, #16]
    515c:	subs	r2, #1
    515e:	str	r2, [r1, #16]
    5160:	cmp	r2, #0
    5162:	bne.n	51d0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2f0>
    5164:	ldr.w	r9, [r8, #16]
    5168:	cmp.w	r9, #0
    516c:	beq.n	51d0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2f0>
    516e:	ldr.w	r2, [r9]
    5172:	ldr	r2, [r2, #32]
    5174:	cmp	r2, r3
    5176:	bne.w	58e8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa08>
    517a:	ldr.w	r1, [r9, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    517e:	str.w	fp, [r9]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5182:	cbz	r1, 51c8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2e8>
    5184:	ldr	r2, [r1, #16]
    5186:	subs	r2, #1
    5188:	str	r2, [r1, #16]
    518a:	cbnz	r2, 51c8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2e8>
    518c:	ldr.w	sl, [r9, #16]
    5190:	cmp.w	sl, #0
    5194:	beq.n	51c8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2e8>
    5196:	ldr.w	r2, [sl]
    519a:	ldr	r2, [r2, #32]
    519c:	cmp	r2, r3
    519e:	bne.w	58ee <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa0e>
    51a2:	ldr.w	r2, [sl, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    51a6:	str.w	fp, [sl]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    51aa:	cbz	r2, 51c0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2e0>
    51ac:	ldr	r3, [r2, #16]
    51ae:	subs	r3, #1
    51b0:	str	r3, [r2, #16]
    51b2:	cbnz	r3, 51c0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2e0>
    51b4:	ldr.w	r0, [sl, #16]
    51b8:	cbz	r0, 51c0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2e0>
    51ba:	ldr	r3, [r0, #0]
    51bc:	ldr	r3, [r3, #32]
    51be:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    51c0:	mov	r0, sl
    51c2:	movs	r1, #20
    51c4:	bl	effc <operator delete(void*, unsigned int)>
    51c8:	mov	r0, r9
    51ca:	movs	r1, #20
    51cc:	bl	effc <operator delete(void*, unsigned int)>
    51d0:	mov	r0, r8
    51d2:	movs	r1, #20
    51d4:	bl	effc <operator delete(void*, unsigned int)>
    51d8:	mov	r0, r7
    51da:	movs	r1, #20
    51dc:	bl	effc <operator delete(void*, unsigned int)>
    51e0:	mov	r0, r6
    51e2:	movs	r1, #20
    51e4:	bl	effc <operator delete(void*, unsigned int)>
    51e8:	b.n	50ca <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1ea>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    51ea:	mov	r0, r3
    51ec:	blx	r2
    51ee:	mov	r4, r0
    51f0:	b.n	4f92 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xb2>
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    51f2:	str.w	fp, [r5]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    51f6:	ldr	r3, [r2, #16]
    51f8:	subs	r3, #1
    51fa:	str	r3, [r2, #16]
    51fc:	cmp	r3, #0
    51fe:	bne.n	52ae <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    5200:	ldr	r4, [r5, #16]
    5202:	cmp	r4, #0
    5204:	beq.n	52ae <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    5206:	ldr	r2, [r4, #0]
    5208:	ldr	r3, [pc, #192]	; (52cc <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ec>)
    520a:	ldr	r2, [r2, #32]
    520c:	cmp	r2, r3
    520e:	bne.w	589a <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9ba>
    5212:	ldr	r1, [r4, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5214:	str.w	fp, [r4]
    5218:	ldr	r0, [pc, #180]	; (52d0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f0>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    521a:	cmp	r1, #0
    521c:	beq.n	52a6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3c6>
    521e:	ldr	r2, [r1, #16]
    5220:	subs	r2, #1
    5222:	str	r2, [r1, #16]
    5224:	cmp	r2, #0
    5226:	bne.n	52a6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3c6>
    5228:	ldr	r5, [r4, #16]
    522a:	cmp	r5, #0
    522c:	beq.n	52a6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3c6>
    522e:	ldr	r2, [r5, #0]
    5230:	ldr	r2, [r2, #32]
    5232:	cmp	r2, r3
    5234:	bne.w	58b0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9d0>
    5238:	ldr	r1, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    523a:	str	r0, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    523c:	cmp	r1, #0
    523e:	beq.n	529e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3be>
    5240:	ldr	r2, [r1, #16]
    5242:	subs	r2, #1
    5244:	str	r2, [r1, #16]
    5246:	cbnz	r2, 529e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3be>
    5248:	ldr	r6, [r5, #16]
    524a:	cbz	r6, 529e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3be>
    524c:	ldr	r2, [r6, #0]
    524e:	ldr	r2, [r2, #32]
    5250:	cmp	r2, r3
    5252:	bne.w	58d6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9f6>
    5256:	ldr	r1, [r6, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5258:	str.w	fp, [r6]
    525c:	ldr	r0, [pc, #112]	; (52d0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3f0>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    525e:	cbz	r1, 5296 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3b6>
    5260:	ldr	r2, [r1, #16]
    5262:	subs	r2, #1
    5264:	str	r2, [r1, #16]
    5266:	cbnz	r2, 5296 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3b6>
    5268:	ldr	r7, [r6, #16]
    526a:	cbz	r7, 5296 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3b6>
    526c:	ldr	r2, [r7, #0]
    526e:	ldr	r2, [r2, #32]
    5270:	cmp	r2, r3
    5272:	bne.w	58dc <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9fc>
    5276:	ldr	r2, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5278:	str	r0, [r7, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    527a:	cbz	r2, 528e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ae>
    527c:	ldr	r3, [r2, #16]
    527e:	subs	r3, #1
    5280:	str	r3, [r2, #16]
    5282:	cbnz	r3, 528e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ae>
    5284:	ldr	r0, [r7, #16]
    5286:	cbz	r0, 528e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ae>
    5288:	ldr	r3, [r0, #0]
    528a:	ldr	r3, [r3, #32]
    528c:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    528e:	mov	r0, r7
    5290:	movs	r1, #20
    5292:	bl	effc <operator delete(void*, unsigned int)>
    5296:	mov	r0, r6
    5298:	movs	r1, #20
    529a:	bl	effc <operator delete(void*, unsigned int)>
    529e:	mov	r0, r5
    52a0:	movs	r1, #20
    52a2:	bl	effc <operator delete(void*, unsigned int)>
    52a6:	mov	r0, r4
    52a8:	movs	r1, #20
    52aa:	bl	effc <operator delete(void*, unsigned int)>
    bool sd_mkdir(uint32_t store, char *filename) {  return sdx[store]->mkdir(filename);  }
    bool sd_rename(uint32_t store, char *oldfilename, char *newfilename) { return sdx[store]->rename(oldfilename,newfilename);  }
    bool sd_remove(uint32_t store, const char *filename) {    Serial.println(filename); return sdx[store]->remove(filename);  }
    bool sd_rmdir(uint32_t store, char *filename) { return sdx[store]->rmdir(filename);  }
    52ae:	ldr.w	r0, [sl, #84]	; 0x54
    52b2:	ldr	r1, [sp, #12]
    52b4:	ldr	r3, [r0, #0]
    52b6:	ldr	r3, [r3, #20]
    52b8:	blx	r3
    52ba:	ldr	r3, [sp, #56]	; 0x38
    52bc:	mov	r4, r0
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    52be:	str.w	fp, [sp, #40]	; 0x28
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    52c2:	cmp	r3, #0
    52c4:	bne.w	50a2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1c2>
    52c8:	b.n	50d2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1f2>
    52ca:	nop
    52cc:	.word	0x00000f3d
    52d0:	.word	0x000140dc
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
	}
	virtual File openNextFile(uint8_t mode=0) {
		return (f) ? f->openNextFile(mode) : *this;
    52d4:	add	r5, sp, #60	; 0x3c
    52d6:	mov	r0, r5
    52d8:	movs	r2, #0
    52da:	blx	r3
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    52dc:	ldr	r2, [r5, #16]
    52de:	cmp	r2, #0
    52e0:	beq.n	52ae <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    52e2:	ldr	r3, [r2, #0]
    52e4:	ldr	r3, [r3, #68]	; 0x44
    52e6:	cmp	r3, r6
    52e8:	bne.w	582c <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x94c>
    52ec:	ldr	r0, [r2, #16]
    52ee:	cmp	r0, #0
    52f0:	beq.w	51f2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x312>
    52f4:	ldr	r1, [r0, #0]
    52f6:	ldr	r1, [r1, #68]	; 0x44
    52f8:	cmp	r1, r6
    52fa:	bne.w	5842 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x962>
    52fe:	ldr	r0, [r0, #16]
    5300:	cmp	r0, #0
    5302:	beq.w	51f2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x312>
    5306:	ldr	r3, [r0, #0]
    5308:	ldr	r3, [r3, #68]	; 0x44
    530a:	cmp	r3, r6
    530c:	bne.w	582e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x94e>
    5310:	ldr	r0, [r0, #16]
    5312:	cmp	r0, #0
    5314:	beq.w	51f2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x312>
    5318:	ldr	r3, [r0, #0]
    531a:	ldr	r3, [r3, #68]	; 0x44
    531c:	cmp	r3, r6
    531e:	bne.w	582e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x94e>
    5322:	ldr	r0, [r0, #16]
    5324:	cmp	r0, #0
    5326:	beq.w	51f2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x312>
    532a:	ldr	r3, [r0, #0]
    532c:	ldr	r3, [r3, #68]	; 0x44
    532e:	cmp	r3, r6
    5330:	bne.w	582e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x94e>
    5334:	ldr	r0, [r0, #16]
    5336:	cmp	r0, #0
    5338:	beq.w	51f2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x312>
    533c:	ldr	r3, [r0, #0]
    533e:	ldr	r3, [r3, #68]	; 0x44
    5340:	cmp	r3, r6
    5342:	bne.w	582e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x94e>
    5346:	ldr	r0, [r0, #16]
    5348:	cmp	r0, #0
    534a:	beq.w	51f2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x312>
    534e:	ldr	r3, [r0, #0]
    5350:	ldr	r3, [r3, #68]	; 0x44
    5352:	blx	r3

      strlcpy(tmp1Name,newfilename,MAX_FILENAME_LEN);
      if(tmp1Name[strlen(tmp1Name)-1]!='/') strlcat(tmp1Name,"/",MAX_FILENAME_LEN);

      File f2=f1.openNextFile();
      if(!f2) break;
    5354:	cmp	r0, #0
    5356:	beq.w	5906 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa26>
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
    535a:	ldr	r0, [r5, #16]
    535c:	cmp	r0, #0
    535e:	beq.w	5828 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x948>
    5362:	ldr	r2, [r0, #0]
    5364:	ldr	r3, [pc, #696]	; (5620 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x740>)
    5366:	ldr	r2, [r2, #72]	; 0x48
    5368:	cmp	r2, r3
    536a:	bne.w	5832 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x952>
    536e:	ldr	r0, [r0, #16]
    5370:	cmp	r0, #0
    5372:	beq.w	5828 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x948>
    5376:	ldr	r2, [r0, #0]
    5378:	ldr	r2, [r2, #72]	; 0x48
    537a:	cmp	r2, r3
    537c:	bne.w	5832 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x952>
    5380:	ldr	r0, [r0, #16]
    5382:	cmp	r0, #0
    5384:	beq.w	5828 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x948>
    5388:	ldr	r2, [r0, #0]
    538a:	ldr	r2, [r2, #72]	; 0x48
    538c:	cmp	r2, r3
    538e:	bne.w	5832 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x952>
    5392:	ldr	r0, [r0, #16]
    5394:	cmp	r0, #0
    5396:	beq.w	5828 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x948>
    539a:	ldr	r2, [r0, #0]
    539c:	ldr	r2, [r2, #72]	; 0x48
    539e:	cmp	r2, r3
    53a0:	bne.w	5832 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x952>
    53a4:	ldr	r0, [r0, #16]
    53a6:	cmp	r0, #0
    53a8:	beq.w	5828 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x948>
    53ac:	ldr	r2, [r0, #0]
    53ae:	ldr	r2, [r2, #72]	; 0x48
    53b0:	cmp	r2, r3
    53b2:	bne.w	5832 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x952>
    53b6:	ldr	r0, [r0, #16]
    53b8:	cmp	r0, #0
    53ba:	beq.w	5828 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x948>
    53be:	ldr	r2, [r0, #0]
    53c0:	ldr	r2, [r2, #72]	; 0x48
    53c2:	cmp	r2, r3
    53c4:	bne.w	5832 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x952>
    53c8:	ldr	r0, [r0, #16]
    53ca:	cmp	r0, #0
    53cc:	beq.w	5828 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x948>
    53d0:	ldr	r3, [r0, #0]
    53d2:	ldr	r3, [r3, #72]	; 0x48
    53d4:	blx	r3
    53d6:	mov	r1, r0
      { // generate filenames
        strlcat(tmp0Name,f2.name(),MAX_FILENAME_LEN);
    53d8:	mov.w	r2, #256	; 0x100
    53dc:	add	r0, sp, #80	; 0x50
    53de:	bl	10b4c <strlcat>
    53e2:	ldr	r0, [r5, #16]
    53e4:	cmp	r0, #0
    53e6:	beq.w	5824 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x944>
    53ea:	ldr	r2, [r0, #0]
    53ec:	ldr	r3, [pc, #560]	; (5620 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x740>)
    53ee:	ldr	r2, [r2, #72]	; 0x48
    53f0:	cmp	r2, r3
    53f2:	bne.w	583c <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x95c>
    53f6:	ldr	r0, [r0, #16]
    53f8:	cmp	r0, #0
    53fa:	beq.w	5824 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x944>
    53fe:	ldr	r2, [r0, #0]
    5400:	ldr	r2, [r2, #72]	; 0x48
    5402:	cmp	r2, r3
    5404:	bne.w	583c <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x95c>
    5408:	ldr	r0, [r0, #16]
    540a:	cmp	r0, #0
    540c:	beq.w	5824 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x944>
    5410:	ldr	r2, [r0, #0]
    5412:	ldr	r2, [r2, #72]	; 0x48
    5414:	cmp	r2, r3
    5416:	bne.w	583c <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x95c>
    541a:	ldr	r0, [r0, #16]
    541c:	cmp	r0, #0
    541e:	beq.w	5824 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x944>
    5422:	ldr	r2, [r0, #0]
    5424:	ldr	r2, [r2, #72]	; 0x48
    5426:	cmp	r2, r3
    5428:	bne.w	583c <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x95c>
    542c:	ldr	r0, [r0, #16]
    542e:	cmp	r0, #0
    5430:	beq.w	5824 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x944>
    5434:	ldr	r2, [r0, #0]
    5436:	ldr	r2, [r2, #72]	; 0x48
    5438:	cmp	r2, r3
    543a:	bne.w	583c <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x95c>
    543e:	ldr	r0, [r0, #16]
    5440:	cmp	r0, #0
    5442:	beq.w	5824 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x944>
    5446:	ldr	r2, [r0, #0]
    5448:	ldr	r2, [r2, #72]	; 0x48
    544a:	cmp	r2, r3
    544c:	bne.w	583c <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x95c>
    5450:	ldr	r0, [r0, #16]
    5452:	cmp	r0, #0
    5454:	beq.w	5824 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x944>
    5458:	ldr	r3, [r0, #0]
    545a:	ldr	r3, [r3, #72]	; 0x48
    545c:	blx	r3
    545e:	mov	r1, r0
        strlcat(tmp1Name,f2.name(),MAX_FILENAME_LEN);
    5460:	mov.w	r2, #256	; 0x100
    5464:	mov	r0, r4
    5466:	bl	10b4c <strlcat>
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
    546a:	ldr	r0, [r5, #16]
    546c:	cmp	r0, #0
    546e:	beq.w	56f0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x810>
    5472:	ldr	r2, [r0, #0]
    5474:	ldr	r3, [pc, #428]	; (5624 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x744>)
    5476:	ldr	r2, [r2, #76]	; 0x4c
    5478:	cmp	r2, r3
    547a:	bne.w	5838 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x958>
    547e:	ldr	r0, [r0, #16]
    5480:	cmp	r0, #0
    5482:	beq.w	56f0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x810>
    5486:	ldr	r2, [r0, #0]
    5488:	ldr	r2, [r2, #76]	; 0x4c
    548a:	cmp	r2, r3
    548c:	bne.w	5838 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x958>
    5490:	ldr	r0, [r0, #16]
    5492:	cmp	r0, #0
    5494:	beq.w	56f0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x810>
    5498:	ldr	r2, [r0, #0]
    549a:	ldr	r2, [r2, #76]	; 0x4c
    549c:	cmp	r2, r3
    549e:	bne.w	5838 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x958>
    54a2:	ldr	r0, [r0, #16]
    54a4:	cmp	r0, #0
    54a6:	beq.w	56f0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x810>
    54aa:	ldr	r2, [r0, #0]
    54ac:	ldr	r2, [r2, #76]	; 0x4c
    54ae:	cmp	r2, r3
    54b0:	bne.w	5838 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x958>
    54b4:	ldr	r0, [r0, #16]
    54b6:	cmp	r0, #0
    54b8:	beq.w	56f0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x810>
    54bc:	ldr	r2, [r0, #0]
    54be:	ldr	r2, [r2, #76]	; 0x4c
    54c0:	cmp	r2, r3
    54c2:	bne.w	5838 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x958>
    54c6:	ldr	r0, [r0, #16]
    54c8:	cmp	r0, #0
    54ca:	beq.w	56f0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x810>
    54ce:	ldr	r2, [r0, #0]
    54d0:	ldr	r2, [r2, #76]	; 0x4c
    54d2:	cmp	r2, r3
    54d4:	bne.w	5838 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x958>
    54d8:	ldr	r0, [r0, #16]
    54da:	cmp	r0, #0
    54dc:	beq.w	56f0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x810>
    54e0:	ldr	r3, [r0, #0]
    54e2:	ldr	r3, [r3, #76]	; 0x4c
    54e4:	blx	r3

        if(f2.isDirectory())
    54e6:	cmp	r0, #0
    54e8:	beq.w	56f0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x810>
        { 
          if(!sd_moveDir(store0, tmp0Name, store1, tmp1Name)) {DBG_FAIL_MACRO; return false;}
    54ec:	str	r4, [sp, #0]
    54ee:	ldr	r3, [sp, #8]
    54f0:	add	r2, sp, #80	; 0x50
    54f2:	mov	r1, r8
    54f4:	mov	r0, r9
    54f6:	bl	4eac <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*)>
    54fa:	cmp	r0, #0
    54fc:	beq.w	5726 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x846>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5500:	ldr	r2, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5502:	str.w	fp, [r5]
    5506:	ldr	r1, [pc, #288]	; (5628 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x748>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5508:	cmp	r2, #0
    550a:	beq.w	4f9e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xbe>
    550e:	ldr	r3, [r2, #16]
    5510:	subs	r3, #1
    5512:	str	r3, [r2, #16]
    5514:	cmp	r3, #0
    5516:	bne.w	4f9e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xbe>
    551a:	ldr	r5, [r5, #16]
    551c:	cmp	r5, #0
    551e:	beq.w	4f9e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xbe>
    5522:	ldr	r2, [r5, #0]
    5524:	ldr	r3, [pc, #260]	; (562c <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x74c>)
    5526:	ldr	r2, [r2, #32]
    5528:	cmp	r2, r3
    552a:	bne.w	5846 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x966>
    552e:	ldr	r0, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5530:	str	r1, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5532:	cmp	r0, #0
    5534:	beq.w	56e6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x806>
    5538:	ldr	r2, [r0, #16]
    553a:	subs	r2, #1
    553c:	str	r2, [r0, #16]
    553e:	cmp	r2, #0
    5540:	bne.w	56e6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x806>
    5544:	ldr	r7, [r5, #16]
    5546:	cmp	r7, #0
    5548:	beq.w	56e6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x806>
    554c:	ldr	r2, [r7, #0]
    554e:	ldr	r2, [r2, #32]
    5550:	cmp	r2, r3
    5552:	bne.w	584e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x96e>
    5556:	ldr	r0, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5558:	str	r1, [r7, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    555a:	cmp	r0, #0
    555c:	beq.w	56de <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7fe>
    5560:	ldr	r2, [r0, #16]
    5562:	subs	r2, #1
    5564:	str	r2, [r0, #16]
    5566:	cmp	r2, #0
    5568:	bne.w	56de <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7fe>
    556c:	ldr	r2, [r7, #16]
    556e:	cmp	r2, #0
    5570:	beq.w	56de <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7fe>
    5574:	ldr	r1, [r2, #0]
    5576:	ldr	r1, [r1, #32]
    5578:	cmp	r1, r3
    557a:	bne.w	586a <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x98a>
    557e:	ldr.w	lr, [r2, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5582:	str.w	fp, [r2]
    5586:	ldr	r0, [pc, #160]	; (5628 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x748>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5588:	cmp.w	lr, #0
    558c:	beq.w	56d6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7f6>
    5590:	ldr.w	r1, [lr, #16]
    5594:	subs	r1, #1
    5596:	str.w	r1, [lr, #16]
    559a:	cmp	r1, #0
    559c:	bne.w	56d6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7f6>
    55a0:	ldr	r1, [r2, #16]
    55a2:	str	r1, [sp, #16]
    55a4:	cmp	r1, #0
    55a6:	beq.w	56d6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7f6>
    55aa:	ldr	r1, [sp, #16]
    55ac:	ldr	r1, [r1, #0]
    55ae:	ldr	r1, [r1, #32]
    55b0:	cmp	r1, r3
    55b2:	bne.w	587e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x99e>
    55b6:	ldr	r1, [sp, #16]
    55b8:	ldr.w	lr, [r1, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    55bc:	str	r0, [r1, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    55be:	cmp.w	lr, #0
    55c2:	beq.w	56ca <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7ea>
    55c6:	ldr.w	r1, [lr, #16]
    55ca:	subs	r1, #1
    55cc:	str.w	r1, [lr, #16]
    55d0:	cmp	r1, #0
    55d2:	bne.n	56ca <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7ea>
    55d4:	ldr	r1, [sp, #16]
    55d6:	ldr	r1, [r1, #16]
    55d8:	str	r1, [sp, #20]
    55da:	cmp	r1, #0
    55dc:	beq.n	56ca <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7ea>
    55de:	ldr	r0, [sp, #20]
    55e0:	ldr	r1, [r0, #0]
    55e2:	ldr	r1, [r1, #32]
    55e4:	cmp	r1, r3
    55e6:	bne.w	58a0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9c0>
    55ea:	ldr.w	lr, [r0, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    55ee:	str.w	fp, [r0]
    55f2:	ldr	r0, [pc, #52]	; (5628 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x748>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    55f4:	cmp.w	lr, #0
    55f8:	beq.n	56be <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7de>
    55fa:	ldr.w	r1, [lr, #16]
    55fe:	subs	r1, #1
    5600:	str.w	r1, [lr, #16]
    5604:	cmp	r1, #0
    5606:	bne.n	56be <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7de>
    5608:	ldr	r1, [sp, #20]
    560a:	ldr	r1, [r1, #16]
    560c:	str	r1, [sp, #24]
    560e:	cmp	r1, #0
    5610:	beq.n	56be <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7de>
    5612:	ldr	r1, [sp, #24]
    5614:	ldr	r1, [r1, #0]
    5616:	ldr	r1, [r1, #32]
    5618:	cmp	r1, r3
    561a:	bne.w	58b6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9d6>
    561e:	b.n	5630 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x750>
    5620:	.word	0x00000519
    5624:	.word	0x0000052d
    5628:	.word	0x000140dc
    562c:	.word	0x00000f3d
    5630:	ldr	r1, [sp, #24]
    5632:	ldr.w	lr, [r1, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5636:	str	r0, [r1, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5638:	cmp.w	lr, #0
    563c:	beq.n	56b2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7d2>
    563e:	ldr.w	r1, [lr, #16]
    5642:	subs	r1, #1
    5644:	str.w	r1, [lr, #16]
    5648:	cmp	r1, #0
    564a:	bne.n	56b2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7d2>
    564c:	ldr	r1, [sp, #24]
    564e:	ldr	r1, [r1, #16]
    5650:	str	r1, [sp, #28]
    5652:	cbz	r1, 56b2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7d2>
    5654:	ldr	r1, [sp, #28]
    5656:	ldr	r1, [r1, #0]
    5658:	ldr	r1, [r1, #32]
    565a:	cmp	r1, r3
    565c:	bne.w	58cc <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9ec>
    5660:	ldr	r1, [sp, #28]
    5662:	ldr.w	lr, [r1, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5666:	str	r0, [r1, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5668:	cmp.w	lr, #0
    566c:	beq.n	56a6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7c6>
    566e:	ldr.w	r1, [lr, #16]
    5672:	subs	r1, #1
    5674:	str.w	r1, [lr, #16]
    5678:	cbnz	r1, 56a6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7c6>
    567a:	ldr	r1, [sp, #28]
    567c:	ldr	r1, [r1, #16]
    567e:	cbz	r1, 56a6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7c6>
    5680:	ldr	r0, [r1, #0]
    5682:	ldr	r0, [r0, #32]
    5684:	cmp	r0, r3
    5686:	mov	lr, r0
    5688:	bne.w	58f4 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa14>
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    568c:	mov	r0, r1
    568e:	str	r2, [sp, #36]	; 0x24
    5690:	str.w	fp, [r0], #16
    5694:	str	r1, [sp, #32]
		invalidate();
    5696:	bl	20b0 <File::invalidate() [clone .isra.1]>
	}
    569a:	ldr	r1, [sp, #32]
    569c:	mov	r0, r1
    569e:	movs	r1, #20
    56a0:	bl	effc <operator delete(void*, unsigned int)>
    56a4:	ldr	r2, [sp, #36]	; 0x24
    56a6:	ldr	r0, [sp, #28]
    56a8:	str	r2, [sp, #32]
    56aa:	movs	r1, #20
    56ac:	bl	effc <operator delete(void*, unsigned int)>
    56b0:	ldr	r2, [sp, #32]
    56b2:	ldr	r0, [sp, #24]
    56b4:	str	r2, [sp, #28]
    56b6:	movs	r1, #20
    56b8:	bl	effc <operator delete(void*, unsigned int)>
    56bc:	ldr	r2, [sp, #28]
    56be:	ldr	r0, [sp, #20]
    56c0:	str	r2, [sp, #24]
    56c2:	movs	r1, #20
    56c4:	bl	effc <operator delete(void*, unsigned int)>
    56c8:	ldr	r2, [sp, #24]
    56ca:	ldr	r0, [sp, #16]
    56cc:	str	r2, [sp, #20]
    56ce:	movs	r1, #20
    56d0:	bl	effc <operator delete(void*, unsigned int)>
    56d4:	ldr	r2, [sp, #20]
    56d6:	mov	r0, r2
    56d8:	movs	r1, #20
    56da:	bl	effc <operator delete(void*, unsigned int)>
    56de:	mov	r0, r7
    56e0:	movs	r1, #20
    56e2:	bl	effc <operator delete(void*, unsigned int)>
    56e6:	mov	r0, r5
    56e8:	movs	r1, #20
    56ea:	bl	effc <operator delete(void*, unsigned int)>
    56ee:	b.n	4f9e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xbe>
        }
        else
        { 
          if(!sd_copy(store0, tmp0Name, store1, tmp1Name)) {DBG_FAIL_MACRO; return false;}
    56f0:	str	r4, [sp, #0]
    56f2:	ldr	r3, [sp, #8]
    56f4:	add	r2, sp, #80	; 0x50
    56f6:	mov	r1, r8
    56f8:	mov	r0, r9
    56fa:	bl	43f8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)>
    56fe:	cbz	r0, 5726 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x846>
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    5700:	add	r0, sp, #80	; 0x50
    5702:	bl	10c00 <strlen>
    5706:	mov	r1, r0
    5708:	add	r0, sp, #80	; 0x50
    570a:	bl	d6b8 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    570e:	ldr	r0, [pc, #524]	; (591c <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa3c>)
    5710:	bl	eedc <Print::println()>
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}

    File sd_open(uint32_t store, const char *filename, uint32_t mode) { return sdx[store]->open(filename,mode);  }
    bool sd_mkdir(uint32_t store, char *filename) {  return sdx[store]->mkdir(filename);  }
    bool sd_rename(uint32_t store, char *oldfilename, char *newfilename) { return sdx[store]->rename(oldfilename,newfilename);  }
    bool sd_remove(uint32_t store, const char *filename) {    Serial.println(filename); return sdx[store]->remove(filename);  }
    5714:	ldr.w	r0, [sl, #84]	; 0x54
    5718:	ldr	r3, [r0, #0]
    571a:	add	r1, sp, #80	; 0x50
    571c:	ldr	r3, [r3, #16]
    571e:	blx	r3
          if(!sd_remove(store0,tmp0Name)) {DBG_FAIL_MACRO; return false;}
    5720:	cmp	r0, #0
    5722:	bne.w	5500 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x620>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5726:	ldr	r2, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5728:	str.w	fp, [r5]
    572c:	ldr	r1, [pc, #496]	; (5920 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa40>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    572e:	cmp	r2, #0
    5730:	beq.n	581e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x93e>
    5732:	ldr	r3, [r2, #16]
    5734:	subs	r3, #1
    5736:	str	r3, [r2, #16]
    5738:	cmp	r3, #0
    573a:	bne.n	581e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x93e>
    573c:	ldr	r4, [r5, #16]
    573e:	cmp	r4, #0
    5740:	beq.n	581e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x93e>
    5742:	ldr	r2, [r4, #0]
    5744:	ldr	r3, [pc, #476]	; (5924 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa44>)
    5746:	ldr	r2, [r2, #32]
    5748:	cmp	r2, r3
    574a:	bne.w	5894 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9b4>
    574e:	ldr	r0, [r4, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5750:	str	r1, [r4, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5752:	cmp	r0, #0
    5754:	beq.n	5816 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x936>
    5756:	ldr	r2, [r0, #16]
    5758:	subs	r2, #1
    575a:	str	r2, [r0, #16]
    575c:	cmp	r2, #0
    575e:	bne.n	5816 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x936>
    5760:	ldr	r5, [r4, #16]
    5762:	cmp	r5, #0
    5764:	beq.n	5816 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x936>
    5766:	ldr	r2, [r5, #0]
    5768:	ldr	r2, [r2, #32]
    576a:	cmp	r2, r3
    576c:	bne.w	5888 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9a8>
    5770:	ldr	r0, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5772:	str	r1, [r5, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5774:	cmp	r0, #0
    5776:	beq.n	580e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x92e>
    5778:	ldr	r2, [r0, #16]
    577a:	subs	r2, #1
    577c:	str	r2, [r0, #16]
    577e:	cmp	r2, #0
    5780:	bne.n	580e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x92e>
    5782:	ldr	r6, [r5, #16]
    5784:	cmp	r6, #0
    5786:	beq.n	580e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x92e>
    5788:	ldr	r2, [r6, #0]
    578a:	ldr	r2, [r2, #32]
    578c:	cmp	r2, r3
    578e:	bne.w	58c6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x9e6>
    5792:	ldr	r1, [r6, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5794:	str.w	fp, [r6]
    5798:	ldr	r0, [pc, #388]	; (5920 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa40>)
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    579a:	cmp	r1, #0
    579c:	beq.n	5806 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x926>
    579e:	ldr	r2, [r1, #16]
    57a0:	subs	r2, #1
    57a2:	str	r2, [r1, #16]
    57a4:	cbnz	r2, 5806 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x926>
    57a6:	ldr	r7, [r6, #16]
    57a8:	cbz	r7, 5806 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x926>
    57aa:	ldr	r2, [r7, #0]
    57ac:	ldr	r2, [r2, #32]
    57ae:	cmp	r2, r3
    57b0:	bne.w	58e2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa02>
    57b4:	ldr	r1, [r7, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    57b6:	str	r0, [r7, #0]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    57b8:	cbz	r1, 57fe <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x91e>
    57ba:	ldr	r2, [r1, #16]
    57bc:	subs	r2, #1
    57be:	str	r2, [r1, #16]
    57c0:	cbnz	r2, 57fe <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x91e>
    57c2:	ldr.w	r8, [r7, #16]
    57c6:	cmp.w	r8, #0
    57ca:	beq.n	57fe <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x91e>
    57cc:	ldr.w	r2, [r8]
    57d0:	ldr	r2, [r2, #32]
    57d2:	cmp	r2, r3
    57d4:	bne.w	5900 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa20>
    57d8:	ldr.w	r2, [r8, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    57dc:	str.w	fp, [r8]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    57e0:	cbz	r2, 57f6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x916>
    57e2:	ldr	r3, [r2, #16]
    57e4:	subs	r3, #1
    57e6:	str	r3, [r2, #16]
    57e8:	cbnz	r3, 57f6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x916>
    57ea:	ldr.w	r0, [r8, #16]
    57ee:	cbz	r0, 57f6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x916>
    57f0:	ldr	r3, [r0, #0]
    57f2:	ldr	r3, [r3, #32]
    57f4:	blx	r3
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    57f6:	mov	r0, r8
    57f8:	movs	r1, #20
    57fa:	bl	effc <operator delete(void*, unsigned int)>
    57fe:	mov	r0, r7
    5800:	movs	r1, #20
    5802:	bl	effc <operator delete(void*, unsigned int)>
    5806:	mov	r0, r6
    5808:	movs	r1, #20
    580a:	bl	effc <operator delete(void*, unsigned int)>
    580e:	mov	r0, r5
    5810:	movs	r1, #20
    5812:	bl	effc <operator delete(void*, unsigned int)>
    5816:	mov	r0, r4
    5818:	movs	r1, #20
    581a:	bl	effc <operator delete(void*, unsigned int)>
    581e:	ldr	r3, [sp, #56]	; 0x38
    5820:	movs	r4, #0
    5822:	b.n	52be <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3de>
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
    5824:	ldr	r1, [pc, #256]	; (5928 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa48>)
    5826:	b.n	5460 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x580>
    5828:	ldr	r1, [pc, #252]	; (5928 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa48>)
    582a:	b.n	53d8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x4f8>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    582c:	mov	r0, r2
    582e:	blx	r3
    5830:	b.n	5354 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x474>
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
    5832:	blx	r2
    5834:	mov	r1, r0
    5836:	b.n	53d8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x4f8>
	}
	virtual bool isDirectory() {
		return (f) ? f->isDirectory() : false;
    5838:	blx	r2
    583a:	b.n	54e6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x606>
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
	}
	virtual const char* name() {
		return (f) ? f->name() : "";
    583c:	blx	r2
    583e:	mov	r1, r0
    5840:	b.n	5460 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x580>
	}
	virtual void close() {
		if (f) f->close();
	}
	virtual operator bool() {
		return (f) ? (bool)*f : false;
    5842:	blx	r1
    5844:	b.n	5354 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x474>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5846:	mov	r0, r5
    5848:	blx	r2
    584a:	b.w	4f9e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xbe>
    584e:	mov	r0, r7
    5850:	blx	r2
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    5852:	mov	r0, r5
    5854:	movs	r1, #20
    5856:	bl	effc <operator delete(void*, unsigned int)>
    585a:	b.w	4f9e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xbe>
  char tmp1Name[MAX_FILENAME_LEN];

  if(!sd_mkdir(store1,newfilename))  {DBG_FAIL_MACRO; return false;}

  File f1=sd_open(store0,oldfilename,FILE_READ);
  if(!f1) {DBG_FAIL_MACRO; return false;}
    585e:	mov	r4, r3
        }
      }
    }
  }
  return sd_rmdir(store0,oldfilename);
}
    5860:	mov	r0, r4
    5862:	add.w	sp, sp, #596	; 0x254
    5866:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    586a:	mov	r0, r2
    586c:	blx	r1
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
		invalidate();
	}
    586e:	mov	r0, r7
    5870:	movs	r1, #20
    5872:	bl	effc <operator delete(void*, unsigned int)>
    5876:	b.n	56e6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x806>
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    5878:	mov	r0, r5
    587a:	blx	r2
    587c:	b.n	50d2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1f2>
    587e:	str	r2, [sp, #20]
    5880:	ldr	r0, [sp, #16]
    5882:	blx	r1
    5884:	ldr	r2, [sp, #20]
    5886:	b.n	56d6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7f6>
    5888:	mov	r0, r5
    588a:	blx	r2
    588c:	b.n	5816 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x936>
    588e:	mov	r0, r6
    5890:	blx	r2
    5892:	b.n	50ca <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x1ea>
    5894:	mov	r0, r4
    5896:	blx	r2
    5898:	b.n	581e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x93e>
    589a:	mov	r0, r4
    589c:	blx	r2
    589e:	b.n	52ae <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    58a0:	str	r2, [sp, #24]
    58a2:	ldr	r0, [sp, #20]
    58a4:	blx	r1
    58a6:	ldr	r2, [sp, #24]
    58a8:	b.n	56ca <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7ea>
    58aa:	mov	r0, r7
    58ac:	blx	r2
    58ae:	b.n	51e0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x300>
    58b0:	mov	r0, r5
    58b2:	blx	r2
    58b4:	b.n	52a6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3c6>
    58b6:	str	r2, [sp, #28]
    58b8:	ldr	r0, [sp, #24]
    58ba:	blx	r1
    58bc:	ldr	r2, [sp, #28]
    58be:	b.n	56be <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7de>
    58c0:	mov	r0, r8
    58c2:	blx	r2
    58c4:	b.n	51d8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2f8>
    58c6:	mov	r0, r6
    58c8:	blx	r2
    58ca:	b.n	580e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x92e>
    58cc:	str	r2, [sp, #32]
    58ce:	ldr	r0, [sp, #28]
    58d0:	blx	r1
    58d2:	ldr	r2, [sp, #32]
    58d4:	b.n	56b2 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7d2>
    58d6:	mov	r0, r6
    58d8:	blx	r2
    58da:	b.n	529e <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3be>
    58dc:	mov	r0, r7
    58de:	blx	r2
    58e0:	b.n	5296 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3b6>
    58e2:	mov	r0, r7
    58e4:	blx	r2
    58e6:	b.n	5806 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x926>
    58e8:	mov	r0, r9
    58ea:	blx	r2
    58ec:	b.n	51d0 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2f0>
    58ee:	mov	r0, sl
    58f0:	blx	r2
    58f2:	b.n	51c8 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x2e8>
    58f4:	str	r2, [sp, #32]
    58f6:	mov	r0, r1
    58f8:	mov	r3, lr
    58fa:	blx	r3
    58fc:	ldr	r2, [sp, #32]
    58fe:	b.n	56a6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x7c6>
    5900:	mov	r0, r8
    5902:	blx	r2
    5904:	b.n	57fe <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x91e>
    5906:	ldr	r2, [r5, #16]
		invalidate();
		f = file.f;
		if (f) f->refcount++;
		return *this;
	}
	virtual ~File() {
    5908:	str.w	fp, [r5]
	size_t readBytes(char *buffer, size_t length) {
		return read(buffer, length);
	}
private:
	void invalidate() {
		if (f && --(f->refcount) == 0) delete f;
    590c:	cmp	r2, #0
    590e:	beq.w	52ae <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3ce>
    5912:	b.n	51f6 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x316>
    5914:	ldr	r3, [sp, #56]	; 0x38
    5916:	ldr.w	fp, [pc, #8]	; 5920 <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0xa40>
    591a:	b.n	52be <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*) [clone .part.10]+0x3de>
    591c:	.word	0x1fff0ad0
    5920:	.word	0x000140dc
    5924:	.word	0x00000f3d
    5928:	.word	0x000142d0

0000592c <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)>:
 * save p2
 * 
*/

  bool MTPStorage_SD::move(uint32_t handle, uint32_t newStore, uint32_t newParent ) 
  { 
    592c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5930:	mov	r6, r1
    5932:	subw	sp, sp, #2696	; 0xa88
    #if DEBUG>1
      Serial.printf("%d -> %d %d\n",handle,newStorage,newParent);
    #endif
    if(newParent==0xFFFFFFFFUL) newParent=newStore; //storage runs from 1, while record.store runs from 0
    5936:	cmp.w	r3, #4294967295
    593a:	ite	ne
    593c:	movne	r7, r3
    593e:	moveq	r7, r2
 * save p2
 * 
*/

  bool MTPStorage_SD::move(uint32_t handle, uint32_t newStore, uint32_t newParent ) 
  { 
    5940:	mov	r4, r0
    #if DEBUG>1
      Serial.printf("%d -> %d %d\n",handle,newStorage,newParent);
    #endif
    if(newParent==0xFFFFFFFFUL) newParent=newStore; //storage runs from 1, while record.store runs from 0

    Record p1 = ReadIndexRecord(handle);
    5942:	mov	r1, r0
    5944:	mov	r2, r6
    5946:	add	r0, sp, #792	; 0x318
    5948:	bl	26c8 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    Record p2 = ReadIndexRecord(newParent);
    594c:	mov	r2, r7
    594e:	mov	r1, r4
    5950:	add.w	r0, sp, #1064	; 0x428
    5954:	bl	26c8 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    Record p3 = ReadIndexRecord(p1.parent); 
    5958:	ldr	r2, [sp, #792]	; 0x318
    595a:	mov	r1, r4
    595c:	add.w	r0, sp, #1336	; 0x538
    5960:	bl	26c8 <MTPStorage_SD::ReadIndexRecord(unsigned long)>

    if(p1.isdir) 
    5964:	ldrb.w	r3, [sp, #804]	; 0x324
    5968:	cbz	r3, 5974 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x48>
    { if(!p1.scanned) 
    596a:	ldrb.w	r3, [sp, #805]	; 0x325
    596e:	cmp	r3, #0
    5970:	beq.w	5b20 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x1f4>
      { ScanDir(p1.store, handle) ; // in case scan directory
        WriteIndexRecord(handle, p1);
      }
    }

    Record p1o = p1;
    5974:	mov.w	r2, #272	; 0x110
    5978:	add	r1, sp, #792	; 0x318
    597a:	add.w	r0, sp, #1608	; 0x648
    597e:	bl	d444 <memcpy>
    Record p2o = p2;
    5982:	mov.w	r2, #272	; 0x110
    5986:	add.w	r1, sp, #1064	; 0x428
    598a:	add.w	r0, sp, #1880	; 0x758
    598e:	bl	d444 <memcpy>
    Record p3o = p3;

    char oldName[MAX_FILENAME_LEN];
    ConstructFilename(handle, oldName, MAX_FILENAME_LEN);
    5992:	add	r2, sp, #280	; 0x118
    5994:	mov.w	r3, #256	; 0x100
    5998:	mov	r1, r6
    599a:	mov	r0, r4
    599c:	bl	2b28 <MTPStorage_SD::ConstructFilename(int, char*, int)>
    uint32_t jx=-1;
    Record pxo;

      // remove index from old parent
      Record px;
      if(p3.child==handle)
    59a0:	ldr.w	r8, [sp, #1340]	; 0x53c
    59a4:	cmp	r6, r8
    59a6:	beq.w	5ae6 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x1ba>
        p3.child = p1.sibling;
        WriteIndexRecord(p1.parent, p3);    
      }
      else
      { jx = p3.child;
        px = ReadIndexRecord(jx); 
    59aa:	add	r0, sp, #8
    59ac:	mov	r2, r8
    59ae:	mov	r1, r4
    59b0:	bl	26c8 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    59b4:	add	r1, sp, #8
    59b6:	mov.w	r2, #272	; 0x110
    59ba:	addw	r0, sp, #2424	; 0x978
    59be:	bl	d444 <memcpy>
        pxo = px;
    59c2:	addw	r1, sp, #2424	; 0x978
    59c6:	addw	r0, sp, #2152	; 0x868
    59ca:	mov.w	r2, #272	; 0x110
    59ce:	bl	d444 <memcpy>
        while(handle != px.sibling)
    59d2:	ldr.w	r5, [sp, #2432]	; 0x980
    59d6:	cmp	r6, r5
    59d8:	bne.n	59de <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0xb2>
    59da:	b.n	5b38 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x20c>
    59dc:	mov	r5, r3
        {
          jx = px.sibling;
          px = ReadIndexRecord(jx); 
    59de:	mov	r2, r5
    59e0:	mov	r1, r4
    59e2:	add	r0, sp, #8
    59e4:	bl	26c8 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    59e8:	mov.w	r2, #272	; 0x110
    59ec:	add	r1, sp, #8
    59ee:	addw	r0, sp, #2424	; 0x978
    59f2:	bl	d444 <memcpy>
          pxo = px;
    59f6:	mov.w	r2, #272	; 0x110
    59fa:	addw	r1, sp, #2424	; 0x978
    59fe:	addw	r0, sp, #2152	; 0x868
    5a02:	bl	d444 <memcpy>
      }
      else
      { jx = p3.child;
        px = ReadIndexRecord(jx); 
        pxo = px;
        while(handle != px.sibling)
    5a06:	ldr.w	r3, [sp, #2432]	; 0x980
    5a0a:	cmp	r6, r3
    5a0c:	bne.n	59dc <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0xb0>
        {
          jx = px.sibling;
          px = ReadIndexRecord(jx); 
          pxo = px;
        }
        px.sibling = p1.sibling;
    5a0e:	ldr	r3, [sp, #800]	; 0x320
    5a10:	str.w	r3, [sp, #2432]	; 0x980
        WriteIndexRecord(jx, px);
    5a14:	addw	r2, sp, #2424	; 0x978
    5a18:	mov	r1, r5
    5a1a:	mov	r0, r4
    5a1c:	bl	24e8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
      }
    
      // add to new parent
      p1.parent = newParent;
      p1.store = p2.store;
    5a20:	ldrh.w	r0, [sp, #1078]	; 0x436
      p1.sibling = p2.child;
    5a24:	ldr.w	r3, [sp, #1068]	; 0x42c
        WriteIndexRecord(jx, px);
      }
    
      // add to new parent
      p1.parent = newParent;
      p1.store = p2.store;
    5a28:	strh.w	r0, [sp, #806]	; 0x326
      p1.sibling = p2.child;
      p2.child = handle;
      WriteIndexRecord(handle, p1);
    5a2c:	add	r2, sp, #792	; 0x318
    5a2e:	mov	r1, r6
    5a30:	mov	r0, r4
      }
    
      // add to new parent
      p1.parent = newParent;
      p1.store = p2.store;
      p1.sibling = p2.child;
    5a32:	str	r3, [sp, #800]	; 0x320
        px.sibling = p1.sibling;
        WriteIndexRecord(jx, px);
      }
    
      // add to new parent
      p1.parent = newParent;
    5a34:	str	r7, [sp, #792]	; 0x318
      p1.store = p2.store;
      p1.sibling = p2.child;
      p2.child = handle;
    5a36:	str.w	r6, [sp, #1068]	; 0x42c
      WriteIndexRecord(handle, p1);
    5a3a:	bl	24e8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
      WriteIndexRecord(newParent,p2);
    5a3e:	add.w	r2, sp, #1064	; 0x428
    5a42:	mov	r1, r7
    5a44:	mov	r0, r4
    5a46:	bl	24e8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>

      // now working on disk storage
      char newName[MAX_FILENAME_LEN];
      ConstructFilename(handle, newName, MAX_FILENAME_LEN);
    5a4a:	mov.w	r3, #256	; 0x100
    5a4e:	mov	r1, r6
    5a50:	add	r2, sp, #536	; 0x218
    5a52:	mov	r0, r4
    5a54:	bl	2b28 <MTPStorage_SD::ConstructFilename(int, char*, int)>
        Serial.print(p1.store); Serial.print(": ");Serial.println(newName);
        dumpIndexList();
      #endif


    if(p1o.store == p2o.store)
    5a58:	ldrh.w	r1, [sp, #1622]	; 0x656
    5a5c:	ldrh.w	r3, [sp, #1894]	; 0x766
    5a60:	cmp	r1, r3
    5a62:	beq.n	5afe <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x1d2>
    { // do a simple rename (works for files and directories)
      if(sd_rename(p1o.store,oldName,newName)) return true; else {DBG_FAIL_MACRO; goto fail;}
    }
    else if(!p1o.isdir)
    5a64:	ldrb.w	r2, [sp, #1620]	; 0x654
    5a68:	cbz	r2, 5aac <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x180>
    { if(sd_copy(p1o.store,oldName, p2o.store, newName)) 
      { sd_remove(p2o.store,oldName); return true; } else { DBG_FAIL_MACRO; goto fail;}
    }
    else
    { // move directory cross mtp-disks
      if(sd_moveDir(p1o.store,oldName,p2o.store,newName)) return true; else {DBG_FAIL_MACRO; goto fail;}
    5a6a:	add	r2, sp, #536	; 0x218
    5a6c:	str	r2, [sp, #0]
    5a6e:	adds	r0, r4, #4
    5a70:	add	r2, sp, #280	; 0x118
    5a72:	bl	4eac <mSD_Base::sd_moveDir(unsigned long, char*, unsigned long, char*)>
    5a76:	cmp	r0, #0
    5a78:	bne.n	5b12 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x1e6>
    }

  fail:
    // undo changes in index list
    if(jx<0) WriteIndexRecord(p1.parent, p3o); else WriteIndexRecord(jx, pxo);
    5a7a:	mov	r1, r5
    5a7c:	addw	r2, sp, #2152	; 0x868
    5a80:	mov	r0, r4
    5a82:	bl	24e8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    WriteIndexRecord(handle, p1o);
    5a86:	add.w	r2, sp, #1608	; 0x648
    5a8a:	mov	r1, r6
    5a8c:	mov	r0, r4
    5a8e:	bl	24e8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    WriteIndexRecord(newParent,p2o);      
    5a92:	add.w	r2, sp, #1880	; 0x758
    5a96:	mov	r1, r7
    5a98:	mov	r0, r4
    5a9a:	bl	24e8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    return false;
    5a9e:	mov.w	r8, #0
  }
    5aa2:	mov	r0, r8
    5aa4:	addw	sp, sp, #2696	; 0xa88
    5aa8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(p1o.store == p2o.store)
    { // do a simple rename (works for files and directories)
      if(sd_rename(p1o.store,oldName,newName)) return true; else {DBG_FAIL_MACRO; goto fail;}
    }
    else if(!p1o.isdir)
    { if(sd_copy(p1o.store,oldName, p2o.store, newName)) 
    5aac:	add	r2, sp, #536	; 0x218
    5aae:	str	r2, [sp, #0]
    5ab0:	adds	r0, r4, #4
    5ab2:	add	r2, sp, #280	; 0x118
    5ab4:	bl	43f8 <mSD_Base::sd_copy(unsigned long, char*, unsigned long, char*)>
    5ab8:	mov	r8, r0
    5aba:	cmp	r0, #0
    5abc:	beq.n	5a7a <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x14e>
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    5abe:	add	r0, sp, #280	; 0x118
    5ac0:	bl	10c00 <strlen>
      { sd_remove(p2o.store,oldName); return true; } else { DBG_FAIL_MACRO; goto fail;}
    5ac4:	ldrh.w	r5, [sp, #1894]	; 0x766
    5ac8:	mov	r1, r0
    5aca:	add.w	r4, r4, r5, lsl #2
    5ace:	add	r0, sp, #280	; 0x118
    5ad0:	bl	d6b8 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    5ad4:	ldr	r0, [pc, #100]	; (5b3c <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x210>)
    5ad6:	bl	eedc <Print::println()>
    5ada:	ldr	r0, [r4, #88]	; 0x58
    5adc:	ldr	r3, [r0, #0]
    5ade:	add	r1, sp, #280	; 0x118
    5ae0:	ldr	r3, [r3, #16]
    5ae2:	blx	r3
    5ae4:	b.n	5aa2 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x176>

      // remove index from old parent
      Record px;
      if(p3.child==handle)
      {
        p3.child = p1.sibling;
    5ae6:	ldr	r3, [sp, #800]	; 0x320
        WriteIndexRecord(p1.parent, p3);    
    5ae8:	ldr	r1, [sp, #792]	; 0x318

      // remove index from old parent
      Record px;
      if(p3.child==handle)
      {
        p3.child = p1.sibling;
    5aea:	str.w	r3, [sp, #1340]	; 0x53c
        WriteIndexRecord(p1.parent, p3);    
    5aee:	add.w	r2, sp, #1336	; 0x538
    5af2:	mov	r0, r4
    5af4:	bl	24e8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    #if DEBUG>1
      Serial.print(p1.store); Serial.print(": "); Serial.println(oldName);
      dumpIndexList();
    #endif

    uint32_t jx=-1;
    5af8:	mov.w	r5, #4294967295
    5afc:	b.n	5a20 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0xf4>
    uint32_t sd_getFSCount(void) {return fsCount;}
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}

    File sd_open(uint32_t store, const char *filename, uint32_t mode) { return sdx[store]->open(filename,mode);  }
    bool sd_mkdir(uint32_t store, char *filename) {  return sdx[store]->mkdir(filename);  }
    bool sd_rename(uint32_t store, char *oldfilename, char *newfilename) { return sdx[store]->rename(oldfilename,newfilename);  }
    5afe:	add.w	r1, r4, r1, lsl #2
    5b02:	add	r2, sp, #536	; 0x218
    5b04:	ldr	r0, [r1, #88]	; 0x58
    5b06:	ldr	r3, [r0, #0]
    5b08:	add	r1, sp, #280	; 0x118
    5b0a:	ldr	r3, [r3, #12]
    5b0c:	blx	r3
      #endif


    if(p1o.store == p2o.store)
    { // do a simple rename (works for files and directories)
      if(sd_rename(p1o.store,oldName,newName)) return true; else {DBG_FAIL_MACRO; goto fail;}
    5b0e:	cmp	r0, #0
    5b10:	beq.n	5a7a <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x14e>
    5b12:	mov.w	r8, #1
    // undo changes in index list
    if(jx<0) WriteIndexRecord(p1.parent, p3o); else WriteIndexRecord(jx, pxo);
    WriteIndexRecord(handle, p1o);
    WriteIndexRecord(newParent,p2o);      
    return false;
  }
    5b16:	mov	r0, r8
    5b18:	addw	sp, sp, #2696	; 0xa88
    5b1c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    Record p2 = ReadIndexRecord(newParent);
    Record p3 = ReadIndexRecord(p1.parent); 

    if(p1.isdir) 
    { if(!p1.scanned) 
      { ScanDir(p1.store, handle) ; // in case scan directory
    5b20:	mov	r2, r6
    5b22:	ldrh.w	r1, [sp, #806]	; 0x326
    5b26:	mov	r0, r4
    5b28:	bl	32b4 <MTPStorage_SD::ScanDir(unsigned long, unsigned long)>
        WriteIndexRecord(handle, p1);
    5b2c:	add	r2, sp, #792	; 0x318
    5b2e:	mov	r1, r6
    5b30:	mov	r0, r4
    5b32:	bl	24e8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    5b36:	b.n	5974 <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0x48>
      }
      else
      { jx = p3.child;
        px = ReadIndexRecord(jx); 
        pxo = px;
        while(handle != px.sibling)
    5b38:	mov	r5, r8
    5b3a:	b.n	5a0e <MTPStorage_SD::move(unsigned long, unsigned long, unsigned long)+0xe2>
    5b3c:	.word	0x1fff0ad0

00005b40 <MTPD::GetNumObjects(unsigned long, unsigned long)>:

    //printf("%d %d ",storage,store); Serial.println(name); Serial.flush();
  }

  uint32_t MTPD::GetNumObjects(uint32_t storage, uint32_t parent) 
  { uint32_t store = Storage2Store(storage);
    5b40:	push	{r4, r5, r6, lr}
    5b42:	mov	r6, r0
    storage_->StartGetObjectHandles(store, parent);
    5b44:	ldr	r0, [r0, #0]
    5b46:	ldr	r3, [r0, #0]

    //printf("%d %d ",storage,store); Serial.println(name); Serial.flush();
  }

  uint32_t MTPD::GetNumObjects(uint32_t storage, uint32_t parent) 
  { uint32_t store = Storage2Store(storage);
    5b48:	subs	r5, r1, #1
    storage_->StartGetObjectHandles(store, parent);
    5b4a:	ldr	r3, [r3, #28]
    5b4c:	mov	r1, r5
    5b4e:	blx	r3
    int num = 0;
    5b50:	movs	r4, #0
    5b52:	b.n	5b56 <MTPD::GetNumObjects(unsigned long, unsigned long)+0x16>
    while (storage_->GetNextObjectHandle(store)) num++;
    5b54:	adds	r4, #1
    5b56:	ldr	r0, [r6, #0]
    5b58:	ldr	r3, [r0, #0]
    5b5a:	mov	r1, r5
    5b5c:	ldr	r3, [r3, #32]
    5b5e:	blx	r3
    5b60:	cmp	r0, #0
    5b62:	bne.n	5b54 <MTPD::GetNumObjects(unsigned long, unsigned long)+0x14>
    return num;
  }
    5b64:	mov	r0, r4
    5b66:	pop	{r4, r5, r6, pc}

00005b68 <MTPD::get_buffer()>:


#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)

//  usb_packet_t *data_buffer_ = NULL;
  void MTPD::get_buffer() {
    5b68:	push	{r4, lr}
    5b6a:	mov	r4, r0
    5b6c:	ldr	r0, [r4, #4]
    while (!data_buffer_) {
    5b6e:	cbnz	r0, 5b78 <MTPD::get_buffer()+0x10>
      data_buffer_ = usb_malloc();
    5b70:	bl	e090 <usb_malloc>
    5b74:	str	r0, [r4, #4]
      if (!data_buffer_) mtp_yield();
    5b76:	cbz	r0, 5b7a <MTPD::get_buffer()+0x12>
    5b78:	pop	{r4, pc}
    5b7a:	bl	2150 <mtp_yield()>
    5b7e:	b.n	5b6c <MTPD::get_buffer()+0x4>

00005b80 <MTPD::write(char const*, int) [clone .part.2]>:
  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    } else {
      int pos = 0;
      while (pos < len) {
    5b80:	cmp	r2, #0
    5b82:	ble.n	5be2 <MTPD::write(char const*, int) [clone .part.2]+0x62>
      data_buffer_ = usb_rx(MTP_RX_ENDPOINT);
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    5b84:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    if (write_get_length_) {
      write_length_ += len;
    } else {
      int pos = 0;
      while (pos < len) {
    5b88:	mov.w	r9, #0
    5b8c:	mov	r6, r2
    5b8e:	mov	r7, r1
    5b90:	mov	r5, r0
               to_copy);
        data_buffer_->len += to_copy;
        pos += to_copy;
        if (data_buffer_->len == sizeof(data_buffer_->buf)) {
          usb_tx(MTP_TX_ENDPOINT, data_buffer_);
          data_buffer_ = NULL;
    5b92:	mov	r8, r9
    5b94:	b.n	5b9a <MTPD::write(char const*, int) [clone .part.2]+0x1a>
  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    } else {
      int pos = 0;
      while (pos < len) {
    5b96:	cmp	r6, r9
    5b98:	ble.n	5bde <MTPD::write(char const*, int) [clone .part.2]+0x5e>
        get_buffer();
    5b9a:	mov	r0, r5
    5b9c:	bl	5b68 <MTPD::get_buffer()>
        int avail = sizeof(data_buffer_->buf) - data_buffer_->len;
    5ba0:	ldr	r3, [r5, #4]
    5ba2:	ldrh.w	r0, [r3], #8
    5ba6:	rsb	r2, r9, r6
    5baa:	rsb	r4, r0, #64	; 0x40
    5bae:	cmp	r4, r2
    5bb0:	it	ge
    5bb2:	movge	r4, r2
        int to_copy = min(len - pos, avail);
        memcpy(data_buffer_->buf + data_buffer_->len,
               data + pos,
               to_copy);
    5bb4:	add.w	r1, r7, r9
    5bb8:	add	r0, r3
    5bba:	mov	r2, r4
    5bbc:	bl	d444 <memcpy>
        data_buffer_->len += to_copy;
    5bc0:	ldr	r1, [r5, #4]
    5bc2:	ldrh	r3, [r1, #0]
    5bc4:	add	r3, r4
    5bc6:	uxth	r3, r3
        pos += to_copy;
        if (data_buffer_->len == sizeof(data_buffer_->buf)) {
    5bc8:	cmp	r3, #64	; 0x40
        int to_copy = min(len - pos, avail);
        memcpy(data_buffer_->buf + data_buffer_->len,
               data + pos,
               to_copy);
        data_buffer_->len += to_copy;
        pos += to_copy;
    5bca:	add	r9, r4
        int avail = sizeof(data_buffer_->buf) - data_buffer_->len;
        int to_copy = min(len - pos, avail);
        memcpy(data_buffer_->buf + data_buffer_->len,
               data + pos,
               to_copy);
        data_buffer_->len += to_copy;
    5bcc:	strh	r3, [r1, #0]
        pos += to_copy;
        if (data_buffer_->len == sizeof(data_buffer_->buf)) {
    5bce:	bne.n	5b96 <MTPD::write(char const*, int) [clone .part.2]+0x16>
          usb_tx(MTP_TX_ENDPOINT, data_buffer_);
    5bd0:	movs	r0, #4
    5bd2:	bl	e208 <usb_tx>
  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    } else {
      int pos = 0;
      while (pos < len) {
    5bd6:	cmp	r6, r9
               to_copy);
        data_buffer_->len += to_copy;
        pos += to_copy;
        if (data_buffer_->len == sizeof(data_buffer_->buf)) {
          usb_tx(MTP_TX_ENDPOINT, data_buffer_);
          data_buffer_ = NULL;
    5bd8:	str.w	r8, [r5, #4]
  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    } else {
      int pos = 0;
      while (pos < len) {
    5bdc:	bgt.n	5b9a <MTPD::write(char const*, int) [clone .part.2]+0x1a>
    5bde:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    5be2:	bx	lr

00005be4 <MTPD::writestring(char const*)>:
  void MTPD::write64(uint64_t x) { write((char*)&x, sizeof(x)); }

#define Store2Storage(x) (x+1)
#define Storage2Store(x) (x-1)

  void MTPD::writestring(const char* str) {
    5be4:	push	{r4, r5, lr}
    if (*str) 
    5be6:	ldrb	r3, [r1, #0]
  void MTPD::write64(uint64_t x) { write((char*)&x, sizeof(x)); }

#define Store2Storage(x) (x+1)
#define Storage2Store(x) (x-1)

  void MTPD::writestring(const char* str) {
    5be8:	sub	sp, #12
    5bea:	mov	r4, r0
    if (*str) 
    5bec:	cbz	r3, 5c48 <MTPD::writestring(char const*)+0x64>
    { write8(strlen(str) + 1);
    5bee:	mov	r0, r1
    5bf0:	mov	r5, r1
    5bf2:	bl	10c00 <strlen>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5bf6:	ldrb	r1, [r4, #8]
    5bf8:	adds	r0, #1
    5bfa:	strb.w	r0, [sp, #3]
    5bfe:	cbz	r1, 5c5a <MTPD::writestring(char const*)+0x76>
      write_length_ += len;
    5c00:	ldr	r3, [r4, #12]
    5c02:	adds	r3, #1
    5c04:	str	r3, [r4, #12]
#define Storage2Store(x) (x-1)

  void MTPD::writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    5c06:	ldrb	r2, [r5, #0]
    5c08:	cbnz	r2, 5c18 <MTPD::writestring(char const*)+0x34>
    5c0a:	b.n	5c40 <MTPD::writestring(char const*)+0x5c>
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    5c0c:	ldr	r3, [r4, #12]
    5c0e:	adds	r3, #2
    5c10:	str	r3, [r4, #12]
#define Storage2Store(x) (x-1)

  void MTPD::writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    5c12:	ldrb.w	r2, [r5, #1]!
    5c16:	cbz	r2, 5c36 <MTPD::writestring(char const*)+0x52>
    5c18:	strh.w	r2, [sp, #6]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5c1c:	cmp	r1, #0
    5c1e:	bne.n	5c0c <MTPD::writestring(char const*)+0x28>
    5c20:	movs	r2, #2
    5c22:	add.w	r1, sp, #6
    5c26:	mov	r0, r4
    5c28:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
#define Storage2Store(x) (x-1)

  void MTPD::writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    5c2c:	ldrb.w	r2, [r5, #1]!
    5c30:	ldrb	r1, [r4, #8]
    5c32:	cmp	r2, #0
    5c34:	bne.n	5c18 <MTPD::writestring(char const*)+0x34>
    5c36:	movs	r3, #0
    5c38:	strh.w	r3, [sp, #4]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5c3c:	cbz	r1, 5c7e <MTPD::writestring(char const*)+0x9a>
    5c3e:	ldr	r3, [r4, #12]
      write_length_ += len;
    5c40:	adds	r3, #2
    5c42:	str	r3, [r4, #12]
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    } else 
    { write8(0);
    }
  }
    5c44:	add	sp, #12
    5c46:	pop	{r4, r5, pc}
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5c48:	ldrb	r2, [r0, #8]
    5c4a:	strb.w	r3, [sp, #2]
    5c4e:	cbz	r2, 5c70 <MTPD::writestring(char const*)+0x8c>
      write_length_ += len;
    5c50:	ldr	r3, [r0, #12]
    5c52:	adds	r3, #1
    5c54:	str	r3, [r0, #12]
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    } else 
    { write8(0);
    }
  }
    5c56:	add	sp, #12
    5c58:	pop	{r4, r5, pc}
    5c5a:	movs	r2, #1
    5c5c:	add.w	r1, sp, #3
    5c60:	mov	r0, r4
    5c62:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
#define Storage2Store(x) (x-1)

  void MTPD::writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    5c66:	ldrb	r2, [r5, #0]
    5c68:	ldrb	r1, [r4, #8]
    5c6a:	cmp	r2, #0
    5c6c:	bne.n	5c18 <MTPD::writestring(char const*)+0x34>
    5c6e:	b.n	5c36 <MTPD::writestring(char const*)+0x52>
    5c70:	movs	r2, #1
    5c72:	add.w	r1, sp, #2
    5c76:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    } else 
    { write8(0);
    }
  }
    5c7a:	add	sp, #12
    5c7c:	pop	{r4, r5, pc}
    5c7e:	mov	r0, r4
    5c80:	movs	r2, #2
    5c82:	add	r1, sp, #4
    5c84:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    5c88:	add	sp, #12
    5c8a:	pop	{r4, r5, pc}

00005c8c <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]>:
        writestring(MTP_NAME);
        break;
    }
  }

  void MTPD::GetDevicePropDesc(uint32_t prop) {
    5c8c:	push	{r4, r5, r6, lr}
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5c8e:	ldrb	r3, [r0, #8]
        writestring(MTP_NAME);
        break;
    }
  }

  void MTPD::GetDevicePropDesc(uint32_t prop) {
    5c90:	sub	sp, #8
    5c92:	mov	r4, r0
    5c94:	mov	r5, r1
    5c96:	strh.w	r1, [sp, #4]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5c9a:	cbz	r3, 5cd4 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0x48>
      write_length_ += len;
    5c9c:	ldr	r3, [r0, #12]
    5c9e:	movw	r2, #65535	; 0xffff
    5ca2:	adds	r3, #2
    5ca4:	str	r3, [r0, #12]
    5ca6:	strh.w	r2, [sp, #6]
    5caa:	adds	r3, #2
    5cac:	movs	r2, #0
    5cae:	str	r3, [r4, #12]
    5cb0:	strb.w	r2, [sp, #2]
    5cb4:	adds	r3, #1
    5cb6:	str	r3, [r4, #12]
      }
    }
  }

  void MTPD::GetDevicePropValue(uint32_t prop) {
    switch (prop) {
    5cb8:	movw	r3, #54274	; 0xd402
    5cbc:	cmp	r5, r3
    5cbe:	beq.n	5d10 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0x84>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5cc0:	ldrb	r3, [r4, #8]
    5cc2:	movs	r2, #0
    5cc4:	strb.w	r2, [sp, #3]
    5cc8:	cbz	r3, 5d2c <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0xa0>
      write_length_ += len;
    5cca:	ldr	r3, [r4, #12]
    5ccc:	adds	r3, #1
    5cce:	str	r3, [r4, #12]
        write8(0);       // read-only
        GetDevicePropValue(prop);
        GetDevicePropValue(prop);
        write8(0);       // no form
    }
  }
    5cd0:	add	sp, #8
    5cd2:	pop	{r4, r5, r6, pc}
    5cd4:	movs	r2, #2
    5cd6:	add	r1, sp, #4
    5cd8:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    5cdc:	ldrb	r6, [r4, #8]
    5cde:	movw	r3, #65535	; 0xffff
    5ce2:	strh.w	r3, [sp, #6]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5ce6:	cbnz	r6, 5d3c <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0xb0>
    5ce8:	movs	r2, #2
    5cea:	add.w	r1, sp, #6
    5cee:	mov	r0, r4
    5cf0:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    5cf4:	ldrb	r3, [r4, #8]
    5cf6:	strb.w	r6, [sp, #2]
    5cfa:	cbnz	r3, 5d40 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0xb4>
    5cfc:	movs	r2, #1
    5cfe:	add.w	r1, sp, #2
    5d02:	mov	r0, r4
    5d04:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
      }
    }
  }

  void MTPD::GetDevicePropValue(uint32_t prop) {
    switch (prop) {
    5d08:	movw	r3, #54274	; 0xd402
    5d0c:	cmp	r5, r3
    5d0e:	bne.n	5cc0 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0x34>
      case 0xd402: // friendly name
        // This is the name we'll actually see in the windows explorer.
        // Should probably be configurable.
        writestring(MTP_NAME);
    5d10:	ldr	r1, [pc, #48]	; (5d44 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0xb8>)
    5d12:	mov	r0, r4
    5d14:	bl	5be4 <MTPD::writestring(char const*)>
    5d18:	ldr	r1, [pc, #40]	; (5d44 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0xb8>)
    5d1a:	mov	r0, r4
    5d1c:	bl	5be4 <MTPD::writestring(char const*)>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5d20:	ldrb	r3, [r4, #8]
    5d22:	movs	r2, #0
    5d24:	strb.w	r2, [sp, #3]
    5d28:	cmp	r3, #0
    5d2a:	bne.n	5cca <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0x3e>
    5d2c:	mov	r0, r4
    5d2e:	movs	r2, #1
    5d30:	add.w	r1, sp, #3
    5d34:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
        write8(0);       // read-only
        GetDevicePropValue(prop);
        GetDevicePropValue(prop);
        write8(0);       // no form
    }
  }
    5d38:	add	sp, #8
    5d3a:	pop	{r4, r5, r6, pc}
    5d3c:	ldr	r3, [r4, #12]
    5d3e:	b.n	5caa <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0x1e>
    5d40:	ldr	r3, [r4, #12]
    5d42:	b.n	5cb4 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]+0x28>
    5d44:	.word	0x0001445c

00005d48 <MTPD::WriteDescriptor()>:
    } else 
    { write8(0);
    }
  }

  void MTPD::WriteDescriptor() {
    5d48:	push	{r4, r5, r6, r7, lr}
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5d4a:	ldrb	r3, [r0, #8]
    } else 
    { write8(0);
    }
  }

  void MTPD::WriteDescriptor() {
    5d4c:	sub	sp, #68	; 0x44
    5d4e:	movs	r5, #100	; 0x64
    5d50:	mov	r4, r0
    5d52:	strh.w	r5, [sp, #8]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5d56:	cmp	r3, #0
    5d58:	beq.w	5ea8 <MTPD::WriteDescriptor()+0x160>
      write_length_ += len;
    5d5c:	ldr	r3, [r0, #12]
    5d5e:	movs	r2, #6
    5d60:	adds	r3, #2
    5d62:	str	r3, [r0, #12]
    5d64:	str	r2, [sp, #24]
    5d66:	adds	r3, #4
    5d68:	movs	r2, #100	; 0x64
    5d6a:	str	r3, [r4, #12]
    5d6c:	strh.w	r2, [sp, #6]
    5d70:	adds	r3, #2
    5d72:	str	r3, [r4, #12]
  void MTPD::WriteDescriptor() {
    write16(100);  // MTP version
    write32(6);    // MTP extension
//    write32(0xFFFFFFFFUL);    // MTP extension
    write16(100);  // MTP version
    writestring("microsoft.com: 1.0;");
    5d74:	ldr	r1, [pc, #556]	; (5fa4 <MTPD::WriteDescriptor()+0x25c>)
    5d76:	mov	r0, r4
    5d78:	bl	5be4 <MTPD::writestring(char const*)>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5d7c:	ldrb	r3, [r4, #8]
    5d7e:	movs	r2, #0
    5d80:	strh.w	r2, [sp, #4]
    5d84:	cmp	r3, #0
    5d86:	beq.w	5f62 <MTPD::WriteDescriptor()+0x21a>
      write_length_ += len;
    5d8a:	ldr	r3, [r4, #12]
    5d8c:	movs	r2, #20
    5d8e:	adds	r3, #2
    5d90:	str	r3, [r4, #12]
    5d92:	str	r2, [sp, #20]
    5d94:	adds	r3, #4
    5d96:	str	r3, [r4, #12]
    5d98:	movs	r6, #1
    5d9a:	ldr	r5, [pc, #524]	; (5fa8 <MTPD::WriteDescriptor()+0x260>)
    5d9c:	movw	r3, #4097	; 0x1001
    5da0:	add.w	r7, r5, #38	; 0x26
    5da4:	b.n	5db6 <MTPD::WriteDescriptor()+0x6e>
    5da6:	ldr	r3, [r4, #12]
    writestring("microsoft.com: 1.0;");
    write16(0);    // functional mode

    // Supported operations (array of uint16)
    write32(supported_op_num);
    for(int ii=0; ii<supported_op_num;ii++) write16(supported_op[ii]);
    5da8:	cmp	r5, r7
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    5daa:	add.w	r3, r3, #2
    5dae:	str	r3, [r4, #12]
    writestring("microsoft.com: 1.0;");
    write16(0);    // functional mode

    // Supported operations (array of uint16)
    write32(supported_op_num);
    for(int ii=0; ii<supported_op_num;ii++) write16(supported_op[ii]);
    5db0:	beq.n	5dd0 <MTPD::WriteDescriptor()+0x88>
    5db2:	ldrh.w	r3, [r5, #2]!
    5db6:	strh.w	r3, [sp, #10]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5dba:	cmp	r6, #0
    5dbc:	bne.n	5da6 <MTPD::WriteDescriptor()+0x5e>
    5dbe:	movs	r2, #2
    5dc0:	add.w	r1, sp, #10
    5dc4:	mov	r0, r4
    5dc6:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    writestring("microsoft.com: 1.0;");
    write16(0);    // functional mode

    // Supported operations (array of uint16)
    write32(supported_op_num);
    for(int ii=0; ii<supported_op_num;ii++) write16(supported_op[ii]);
    5dca:	cmp	r5, r7
    5dcc:	ldrb	r6, [r4, #8]
    5dce:	bne.n	5db2 <MTPD::WriteDescriptor()+0x6a>
    5dd0:	movs	r2, #4
    5dd2:	str	r2, [sp, #28]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5dd4:	cmp	r6, #0
    5dd6:	beq.w	5f56 <MTPD::WriteDescriptor()+0x20e>
      write_length_ += len;
    5dda:	ldr	r3, [r4, #12]
    5ddc:	adds	r3, #4
    5dde:	str	r3, [r4, #12]
    5de0:	ldr	r5, [pc, #456]	; (5fac <MTPD::WriteDescriptor()+0x264>)
    5de2:	movw	r3, #16388	; 0x4004
    5de6:	adds	r7, r5, #6
    5de8:	strh.w	r3, [sp, #12]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5dec:	cbz	r6, 5e06 <MTPD::WriteDescriptor()+0xbe>
      write_length_ += len;
    5dee:	ldr	r3, [r4, #12]
    write32(supported_op_num);
    for(int ii=0; ii<supported_op_num;ii++) write16(supported_op[ii]);
    
    // Events (array of uint16)
    write32(supported_event_num);      
    for(int ii=0; ii<supported_event_num;ii++) write16(supported_events[ii]);
    5df0:	cmp	r7, r5
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    5df2:	add.w	r3, r3, #2
    5df6:	str	r3, [r4, #12]
    write32(supported_op_num);
    for(int ii=0; ii<supported_op_num;ii++) write16(supported_op[ii]);
    
    // Events (array of uint16)
    write32(supported_event_num);      
    for(int ii=0; ii<supported_event_num;ii++) write16(supported_events[ii]);
    5df8:	beq.n	5e16 <MTPD::WriteDescriptor()+0xce>
    5dfa:	ldrh.w	r3, [r5, #2]!
    5dfe:	strh.w	r3, [sp, #12]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5e02:	cmp	r6, #0
    5e04:	bne.n	5dee <MTPD::WriteDescriptor()+0xa6>
    5e06:	movs	r2, #2
    5e08:	add	r1, sp, #12
    5e0a:	mov	r0, r4
    5e0c:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    write32(supported_op_num);
    for(int ii=0; ii<supported_op_num;ii++) write16(supported_op[ii]);
    
    // Events (array of uint16)
    write32(supported_event_num);      
    for(int ii=0; ii<supported_event_num;ii++) write16(supported_events[ii]);
    5e10:	cmp	r7, r5
    5e12:	ldrb	r6, [r4, #8]
    5e14:	bne.n	5dfa <MTPD::WriteDescriptor()+0xb2>
    5e16:	movs	r3, #1
    5e18:	str	r3, [sp, #40]	; 0x28
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5e1a:	cmp	r6, #0
    5e1c:	beq.n	5edc <MTPD::WriteDescriptor()+0x194>
      write_length_ += len;
    5e1e:	ldr	r3, [r4, #12]
    5e20:	movw	r2, #54274	; 0xd402
    5e24:	adds	r3, #4
    5e26:	str	r3, [r4, #12]
    5e28:	strh.w	r2, [sp, #18]
    5e2c:	adds	r3, #2
    5e2e:	movs	r2, #0
    5e30:	str	r3, [r4, #12]
    5e32:	str	r2, [sp, #36]	; 0x24
    5e34:	adds	r3, #4
    5e36:	movs	r2, #2
    5e38:	str	r3, [r4, #12]
    5e3a:	str	r2, [sp, #32]
    5e3c:	adds	r3, #4
    5e3e:	mov.w	r2, #12288	; 0x3000
    5e42:	str	r3, [r4, #12]
    5e44:	strh.w	r2, [sp, #16]
    5e48:	adds	r3, #2
    5e4a:	movw	r2, #12289	; 0x3001
    5e4e:	str	r3, [r4, #12]
    5e50:	strh.w	r2, [sp, #14]
    5e54:	adds	r3, #2
    5e56:	str	r3, [r4, #12]

    write32(2);       // Playback formats (array of uint16)
    write16(0x3000);  // Undefined format
    write16(0x3001);  // Folders (associations)

    writestring(MTP_MANUF);     // Manufacturer
    5e58:	ldr	r1, [pc, #340]	; (5fb0 <MTPD::WriteDescriptor()+0x268>)
    5e5a:	mov	r0, r4
    5e5c:	bl	5be4 <MTPD::writestring(char const*)>
    writestring(MTP_MODEL);     // Model
    5e60:	ldr	r1, [pc, #336]	; (5fb4 <MTPD::WriteDescriptor()+0x26c>)
    5e62:	mov	r0, r4
    5e64:	bl	5be4 <MTPD::writestring(char const*)>
    //writestring(MTP_VERS);      // version
    //writestring(MTP_SERNR);     // serial
    
    char buf[20];    
    dtostrf( (float)(TEENSYDUINO / 100.0f), 3, 2, buf);
    5e68:	vldr	s0, [pc, #332]	; 5fb8 <MTPD::WriteDescriptor()+0x270>
    5e6c:	add	r2, sp, #44	; 0x2c
    5e6e:	movs	r1, #2
    5e70:	movs	r0, #3
    5e72:	bl	da18 <dtostrf>
    strlcat(buf, " / MTP " MTP_VERS, sizeof(buf) );
    5e76:	movs	r2, #20
    5e78:	ldr	r1, [pc, #320]	; (5fbc <MTPD::WriteDescriptor()+0x274>)
    5e7a:	add	r0, sp, #44	; 0x2c
    5e7c:	bl	10b4c <strlcat>
    writestring( buf );    
    5e80:	mov	r0, r4
    5e82:	add	r1, sp, #44	; 0x2c
    5e84:	bl	5be4 <MTPD::writestring(char const*)>
    5e88:	ldr	r2, [pc, #308]	; (5fc0 <MTPD::WriteDescriptor()+0x278>)
    5e8a:	add	r3, sp, #44	; 0x2c
    5e8c:	add.w	r0, sp, #54	; 0x36
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Warray-bounds"
    for (size_t i=0; i<10; i++) buf[i] = usb_string_serial_number.wString[i];
    5e90:	ldrh.w	r1, [r2, #2]!
    5e94:	strb.w	r1, [r3], #1
    5e98:	cmp	r3, r0
    5e9a:	bne.n	5e90 <MTPD::WriteDescriptor()+0x148>
    #pragma GCC diagnostic pop
    writestring(buf);    
    5e9c:	add	r1, sp, #44	; 0x2c
    5e9e:	mov	r0, r4
    5ea0:	bl	5be4 <MTPD::writestring(char const*)>
  }
    5ea4:	add	sp, #68	; 0x44
    5ea6:	pop	{r4, r5, r6, r7, pc}
    5ea8:	movs	r2, #2
    5eaa:	add	r1, sp, #8
    5eac:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    5eb0:	ldrb	r3, [r4, #8]
    5eb2:	movs	r2, #6
    5eb4:	str	r2, [sp, #24]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5eb6:	cmp	r3, #0
    5eb8:	bne.n	5f82 <MTPD::WriteDescriptor()+0x23a>
    5eba:	movs	r2, #4
    5ebc:	add	r1, sp, #24
    5ebe:	mov	r0, r4
    5ec0:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    5ec4:	ldrb	r3, [r4, #8]
    5ec6:	strh.w	r5, [sp, #6]
    5eca:	cmp	r3, #0
    5ecc:	bne.n	5f86 <MTPD::WriteDescriptor()+0x23e>
    5ece:	movs	r2, #2
    5ed0:	add.w	r1, sp, #6
    5ed4:	mov	r0, r4
    5ed6:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    5eda:	b.n	5d74 <MTPD::WriteDescriptor()+0x2c>
    5edc:	movs	r2, #4
    5ede:	add	r1, sp, #40	; 0x28
    5ee0:	mov	r0, r4
    5ee2:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    5ee6:	ldrb	r3, [r4, #8]
    5ee8:	movw	r2, #54274	; 0xd402
    5eec:	strh.w	r2, [sp, #18]
    5ef0:	cmp	r3, #0
    5ef2:	bne.n	5f8a <MTPD::WriteDescriptor()+0x242>
    5ef4:	movs	r2, #2
    5ef6:	add.w	r1, sp, #18
    5efa:	mov	r0, r4
    5efc:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    5f00:	ldrb	r3, [r4, #8]
    5f02:	str	r6, [sp, #36]	; 0x24
    5f04:	cmp	r3, #0
    5f06:	bne.n	5f8e <MTPD::WriteDescriptor()+0x246>
    5f08:	movs	r2, #4
    5f0a:	add	r1, sp, #36	; 0x24
    5f0c:	mov	r0, r4
    5f0e:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    5f12:	ldrb	r3, [r4, #8]
    5f14:	movs	r5, #2
    5f16:	str	r5, [sp, #32]
    5f18:	cmp	r3, #0
    5f1a:	bne.n	5f92 <MTPD::WriteDescriptor()+0x24a>
    5f1c:	movs	r2, #4
    5f1e:	add	r1, sp, #32
    5f20:	mov	r0, r4
    5f22:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    5f26:	ldrb	r3, [r4, #8]
    5f28:	mov.w	r2, #12288	; 0x3000
    5f2c:	strh.w	r2, [sp, #16]
    5f30:	cbnz	r3, 5f96 <MTPD::WriteDescriptor()+0x24e>
    5f32:	mov	r2, r5
    5f34:	add	r1, sp, #16
    5f36:	mov	r0, r4
    5f38:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    5f3c:	ldrb	r3, [r4, #8]
    5f3e:	movw	r2, #12289	; 0x3001
    5f42:	strh.w	r2, [sp, #14]
    5f46:	cbnz	r3, 5f9a <MTPD::WriteDescriptor()+0x252>
    5f48:	mov	r2, r5
    5f4a:	add.w	r1, sp, #14
    5f4e:	mov	r0, r4
    5f50:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    5f54:	b.n	5e58 <MTPD::WriteDescriptor()+0x110>
    5f56:	add	r1, sp, #28
    5f58:	mov	r0, r4
    5f5a:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    5f5e:	ldrb	r6, [r4, #8]
    5f60:	b.n	5de0 <MTPD::WriteDescriptor()+0x98>
    5f62:	movs	r2, #2
    5f64:	add	r1, sp, #4
    5f66:	mov	r0, r4
    5f68:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    5f6c:	ldrb	r3, [r4, #8]
    5f6e:	movs	r2, #20
    5f70:	str	r2, [sp, #20]
    5f72:	cbnz	r3, 5f9e <MTPD::WriteDescriptor()+0x256>
    5f74:	movs	r2, #4
    5f76:	add	r1, sp, #20
    5f78:	mov	r0, r4
    5f7a:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    5f7e:	ldrb	r6, [r4, #8]
    5f80:	b.n	5d9a <MTPD::WriteDescriptor()+0x52>
    5f82:	ldr	r3, [r4, #12]
    5f84:	b.n	5d66 <MTPD::WriteDescriptor()+0x1e>
    5f86:	ldr	r3, [r4, #12]
    5f88:	b.n	5d70 <MTPD::WriteDescriptor()+0x28>
    5f8a:	ldr	r3, [r4, #12]
    5f8c:	b.n	5e2c <MTPD::WriteDescriptor()+0xe4>
    5f8e:	ldr	r3, [r4, #12]
    5f90:	b.n	5e34 <MTPD::WriteDescriptor()+0xec>
    5f92:	ldr	r3, [r4, #12]
    5f94:	b.n	5e3c <MTPD::WriteDescriptor()+0xf4>
    5f96:	ldr	r3, [r4, #12]
    5f98:	b.n	5e48 <MTPD::WriteDescriptor()+0x100>
    5f9a:	ldr	r3, [r4, #12]
    5f9c:	b.n	5e54 <MTPD::WriteDescriptor()+0x10c>
    5f9e:	ldr	r3, [r4, #12]
    5fa0:	b.n	5d94 <MTPD::WriteDescriptor()+0x4c>
    5fa2:	nop
    5fa4:	.word	0x00014464
    5fa8:	.word	0x00014424
    5fac:	.word	0x000144ac
    5fb0:	.word	0x00014478
    5fb4:	.word	0x0001445c
    5fb8:	.word	0x3fc147ae
    5fbc:	.word	0x00014480
    5fc0:	.word	0x1fff0ab0

00005fc4 <MTPD::WriteStorageIDs()>:
    for (size_t i=0; i<10; i++) buf[i] = usb_string_serial_number.wString[i];
    #pragma GCC diagnostic pop
    writestring(buf);    
  }

  void MTPD::WriteStorageIDs() {
    5fc4:	push	{r4, r5, r6, lr}
    5fc6:	mov	r5, r0
    uint32_t num=storage_->get_FSCount();
    5fc8:	ldr	r0, [r0, #0]
    5fca:	ldr	r2, [pc, #92]	; (6028 <MTPD::WriteStorageIDs()+0x64>)
    5fcc:	ldr	r3, [r0, #0]
    5fce:	ldr	r3, [r3, #4]
    5fd0:	cmp	r3, r2
    for (size_t i=0; i<10; i++) buf[i] = usb_string_serial_number.wString[i];
    #pragma GCC diagnostic pop
    writestring(buf);    
  }

  void MTPD::WriteStorageIDs() {
    5fd2:	sub	sp, #8
    5fd4:	bne.n	6020 <MTPD::WriteStorageIDs()+0x5c>
    {
      for(int ii=0; ii<fsCount;ii++) if(!strcmp(name,sd_name[ii])) return ii;
      return 0xFFFFFFFFUL;
    }

    uint32_t sd_getFSCount(void) {return fsCount;}
    5fd6:	ldr	r6, [r0, #4]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5fd8:	ldrb	r3, [r5, #8]
    5fda:	str	r6, [sp, #0]
    5fdc:	cbz	r3, 6014 <MTPD::WriteStorageIDs()+0x50>
      write_length_ += len;
    5fde:	ldr	r3, [r5, #12]
    5fe0:	adds	r3, #4
    5fe2:	str	r3, [r5, #12]
  }

  void MTPD::WriteStorageIDs() {
    uint32_t num=storage_->get_FSCount();
    write32(num); // number of storages (disks)
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
    5fe4:	cbz	r6, 6010 <MTPD::WriteStorageIDs()+0x4c>
    5fe6:	movs	r4, #0
    5fe8:	b.n	5ff6 <MTPD::WriteStorageIDs()+0x32>
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    5fea:	ldr	r3, [r5, #12]
  }

  void MTPD::WriteStorageIDs() {
    uint32_t num=storage_->get_FSCount();
    write32(num); // number of storages (disks)
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
    5fec:	cmp	r6, r4
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    5fee:	add.w	r3, r3, #4
    5ff2:	str	r3, [r5, #12]
  }

  void MTPD::WriteStorageIDs() {
    uint32_t num=storage_->get_FSCount();
    write32(num); // number of storages (disks)
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
    5ff4:	beq.n	6010 <MTPD::WriteStorageIDs()+0x4c>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5ff6:	ldrb	r3, [r5, #8]
  }

  void MTPD::WriteStorageIDs() {
    uint32_t num=storage_->get_FSCount();
    write32(num); // number of storages (disks)
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
    5ff8:	adds	r4, #1
    5ffa:	str	r4, [sp, #4]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    5ffc:	cmp	r3, #0
    5ffe:	bne.n	5fea <MTPD::WriteStorageIDs()+0x26>
    6000:	movs	r2, #4
    6002:	add.w	r1, sp, r2
    6006:	mov	r0, r5
    6008:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
  }

  void MTPD::WriteStorageIDs() {
    uint32_t num=storage_->get_FSCount();
    write32(num); // number of storages (disks)
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
    600c:	cmp	r6, r4
    600e:	bne.n	5ff6 <MTPD::WriteStorageIDs()+0x32>
  }
    6010:	add	sp, #8
    6012:	pop	{r4, r5, r6, pc}
    6014:	movs	r2, #4
    6016:	mov	r1, sp
    6018:	mov	r0, r5
    601a:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    601e:	b.n	5fe4 <MTPD::WriteStorageIDs()+0x20>
    #pragma GCC diagnostic pop
    writestring(buf);    
  }

  void MTPD::WriteStorageIDs() {
    uint32_t num=storage_->get_FSCount();
    6020:	blx	r3
    6022:	mov	r6, r0
    6024:	b.n	5fd8 <MTPD::WriteStorageIDs()+0x14>
    6026:	nop
    6028:	.word	0x00001e71

0000602c <MTPD::GetObjectHandles(unsigned long, unsigned long)>:
    while (storage_->GetNextObjectHandle(store)) num++;
    return num;
  }

  void MTPD::GetObjectHandles(uint32_t storage, uint32_t parent) 
  { uint32_t store = Storage2Store(storage);
    602c:	push	{r4, r5, r6, lr}
    if (write_get_length_) {
    602e:	ldrb	r3, [r0, #8]
    while (storage_->GetNextObjectHandle(store)) num++;
    return num;
  }

  void MTPD::GetObjectHandles(uint32_t storage, uint32_t parent) 
  { uint32_t store = Storage2Store(storage);
    6030:	sub	sp, #8
    6032:	mov	r4, r0
    if (write_get_length_) {
    6034:	cbnz	r3, 6080 <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x54>
    6036:	mov	r5, r1
    6038:	mov	r6, r2
      write_length_ = GetNumObjects(storage, parent);
      write_length_++;
      write_length_ *= 4;
    }
    else{
      write32(GetNumObjects(storage, parent));
    603a:	bl	5b40 <MTPD::GetNumObjects(unsigned long, unsigned long)>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    603e:	ldrb	r3, [r4, #8]
    6040:	str	r0, [sp, #0]
    6042:	cbz	r3, 608e <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x62>
      write_length_ += len;
    6044:	ldr	r3, [r4, #12]
    6046:	adds	r3, #4
    6048:	str	r3, [r4, #12]
      write_length_ *= 4;
    }
    else{
      write32(GetNumObjects(storage, parent));
      int handle;
      storage_->StartGetObjectHandles(store, parent);
    604a:	ldr	r0, [r4, #0]
    604c:	ldr	r3, [r0, #0]
    while (storage_->GetNextObjectHandle(store)) num++;
    return num;
  }

  void MTPD::GetObjectHandles(uint32_t storage, uint32_t parent) 
  { uint32_t store = Storage2Store(storage);
    604e:	subs	r5, #1
      write_length_ *= 4;
    }
    else{
      write32(GetNumObjects(storage, parent));
      int handle;
      storage_->StartGetObjectHandles(store, parent);
    6050:	mov	r2, r6
    6052:	ldr	r3, [r3, #28]
    6054:	mov	r1, r5
    6056:	blx	r3
      while ((handle = storage_->GetNextObjectHandle(store))) write32(handle);
    6058:	ldr	r0, [r4, #0]
    605a:	ldr	r3, [r0, #0]
    605c:	mov	r1, r5
    605e:	ldr	r3, [r3, #32]
    6060:	blx	r3
    6062:	cbz	r0, 608a <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x5e>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    6064:	ldrb	r3, [r4, #8]
    6066:	str	r0, [sp, #4]
    6068:	cbz	r3, 6072 <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x46>
      write_length_ += len;
    606a:	ldr	r3, [r4, #12]
    606c:	adds	r3, #4
    606e:	str	r3, [r4, #12]
    6070:	b.n	6058 <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x2c>
    6072:	movs	r2, #4
    6074:	add.w	r1, sp, r2
    6078:	mov	r0, r4
    607a:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    607e:	b.n	6058 <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x2c>
  }

  void MTPD::GetObjectHandles(uint32_t storage, uint32_t parent) 
  { uint32_t store = Storage2Store(storage);
    if (write_get_length_) {
      write_length_ = GetNumObjects(storage, parent);
    6080:	bl	5b40 <MTPD::GetNumObjects(unsigned long, unsigned long)>
      write_length_++;
      write_length_ *= 4;
    6084:	adds	r0, #1
    6086:	lsls	r0, r0, #2
    6088:	str	r0, [r4, #12]
      write32(GetNumObjects(storage, parent));
      int handle;
      storage_->StartGetObjectHandles(store, parent);
      while ((handle = storage_->GetNextObjectHandle(store))) write32(handle);
    }
  }
    608a:	add	sp, #8
    608c:	pop	{r4, r5, r6, pc}
    608e:	movs	r2, #4
    6090:	mov	r1, sp
    6092:	mov	r0, r4
    6094:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6098:	b.n	604a <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x1e>
    609a:	nop

0000609c <MTPD::GetObjectInfo(unsigned long)>:
  
  void MTPD::GetObjectInfo(uint32_t handle) 
  {
    609c:	push	{r4, r5, r6, r7, lr}
    609e:	mov	r4, r0
    60a0:	sub	sp, #332	; 0x14c
    char filename[MAX_FILENAME_LEN];
    uint32_t size, parent;
    uint16_t store;
    storage_->GetObjectInfo(handle, filename, &size, &parent, &store);
    60a2:	ldr	r0, [r0, #0]
    60a4:	add.w	r6, sp, #10
    60a8:	add	r5, sp, #24
    60aa:	ldr	r3, [r0, #0]
    60ac:	stmia.w	sp, {r5, r6}
    60b0:	add	r2, sp, #72	; 0x48
    60b2:	ldr	r7, [r3, #36]	; 0x24
    60b4:	add	r3, sp, #20
    60b6:	blx	r7
    60b8:	ldrh	r3, [r6, #0]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    60ba:	ldrb	r2, [r4, #8]
    60bc:	adds	r3, #1
    60be:	str	r3, [sp, #28]
    60c0:	cmp	r2, #0
    60c2:	beq.n	6178 <MTPD::GetObjectInfo(unsigned long)+0xdc>
      write_length_ += len;
    60c4:	ldr	r3, [r4, #12]
    uint16_t store;
    storage_->GetObjectInfo(handle, filename, &size, &parent, &store);

    uint32_t storage = Store2Storage(store);
    write32(storage); // storage
    write16(size == 0xFFFFFFFFUL ? 0x3001 : 0x0000); // format
    60c6:	ldr	r2, [sp, #20]
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    60c8:	adds	r3, #4
    uint16_t store;
    storage_->GetObjectInfo(handle, filename, &size, &parent, &store);

    uint32_t storage = Store2Storage(store);
    write32(storage); // storage
    write16(size == 0xFFFFFFFFUL ? 0x3001 : 0x0000); // format
    60ca:	adds	r2, #1
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    60cc:	str	r3, [r4, #12]
    uint16_t store;
    storage_->GetObjectInfo(handle, filename, &size, &parent, &store);

    uint32_t storage = Store2Storage(store);
    write32(storage); // storage
    write16(size == 0xFFFFFFFFUL ? 0x3001 : 0x0000); // format
    60ce:	beq.w	62a8 <MTPD::GetObjectInfo(unsigned long)+0x20c>
    60d2:	movs	r2, #0
    60d4:	strh.w	r2, [sp, #16]
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    60d8:	adds	r3, #2
    60da:	movs	r2, #0
    60dc:	str	r3, [r4, #12]
    60de:	strh.w	r2, [sp, #14]
    60e2:	adds	r3, #2
    60e4:	ldr	r2, [sp, #20]
    60e6:	str	r3, [r4, #12]
    60e8:	str	r2, [sp, #60]	; 0x3c
    60ea:	adds	r3, #4
    60ec:	movs	r2, #0
    60ee:	str	r3, [r4, #12]
    60f0:	strh.w	r2, [sp, #12]
    60f4:	adds	r3, #2
    60f6:	movs	r2, #0
    60f8:	str	r3, [r4, #12]
    60fa:	str	r2, [sp, #56]	; 0x38
    60fc:	adds	r3, #4
    60fe:	movs	r2, #0
    6100:	str	r3, [r4, #12]
    6102:	str	r2, [sp, #52]	; 0x34
    6104:	adds	r3, #4
    6106:	movs	r2, #0
    6108:	str	r3, [r4, #12]
    610a:	str	r2, [sp, #48]	; 0x30
    610c:	adds	r3, #4
    610e:	movs	r2, #0
    6110:	str	r3, [r4, #12]
    6112:	str	r2, [sp, #44]	; 0x2c
    6114:	adds	r3, #4
    6116:	movs	r2, #0
    6118:	str	r3, [r4, #12]
    611a:	str	r2, [sp, #40]	; 0x28
    611c:	adds	r3, #4
    611e:	movs	r2, #0
    6120:	str	r3, [r4, #12]
    6122:	str	r2, [sp, #36]	; 0x24
    6124:	adds	r3, #4
    6126:	ldr	r2, [r5, #0]
    6128:	str	r3, [r4, #12]
    612a:	str	r2, [sp, #32]
    612c:	ldr	r2, [sp, #20]
    612e:	sub.w	r2, r2, #4294967295
    6132:	clz	r2, r2
    6136:	lsrs	r2, r2, #5
    6138:	adds	r3, #4
    613a:	str	r3, [r4, #12]
    613c:	strh.w	r2, [sp, #18]
    6140:	adds	r3, #2
    6142:	movs	r2, #0
    6144:	str	r3, [r4, #12]
    6146:	str	r2, [sp, #68]	; 0x44
    6148:	adds	r3, #4
    614a:	movs	r2, #0
    614c:	str	r3, [r4, #12]
    614e:	str	r2, [sp, #64]	; 0x40
    6150:	adds	r3, #4
    6152:	str	r3, [r4, #12]
    write32(0); // bit depth
    write32(parent); // parent
    write16(size == 0xFFFFFFFFUL ? 1 : 0); // association type
    write32(0); // association description
    write32(0);  // sequence number
    writestring(filename);
    6154:	add	r1, sp, #72	; 0x48
    6156:	mov	r0, r4
    6158:	bl	5be4 <MTPD::writestring(char const*)>
    writestring("");  // date created
    615c:	mov	r0, r4
    615e:	ldr	r1, [pc, #396]	; (62ec <MTPD::GetObjectInfo(unsigned long)+0x250>)
    6160:	bl	5be4 <MTPD::writestring(char const*)>
    writestring("");  // date modified
    6164:	mov	r0, r4
    6166:	ldr	r1, [pc, #388]	; (62ec <MTPD::GetObjectInfo(unsigned long)+0x250>)
    6168:	bl	5be4 <MTPD::writestring(char const*)>
    writestring("");  // keywords
    616c:	mov	r0, r4
    616e:	ldr	r1, [pc, #380]	; (62ec <MTPD::GetObjectInfo(unsigned long)+0x250>)
    6170:	bl	5be4 <MTPD::writestring(char const*)>
  }
    6174:	add	sp, #332	; 0x14c
    6176:	pop	{r4, r5, r6, r7, pc}
    6178:	add	r1, sp, #28
    617a:	movs	r2, #4
    617c:	mov	r0, r4
    617e:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    uint16_t store;
    storage_->GetObjectInfo(handle, filename, &size, &parent, &store);

    uint32_t storage = Store2Storage(store);
    write32(storage); // storage
    write16(size == 0xFFFFFFFFUL ? 0x3001 : 0x0000); // format
    6182:	ldr	r3, [sp, #20]
    6184:	ldrb	r6, [r4, #8]
    6186:	adds	r3, #1
    6188:	movw	r3, #12289	; 0x3001
    618c:	it	ne
    618e:	movne	r3, #0
    6190:	strh.w	r3, [sp, #16]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    6194:	cmp	r6, #0
    6196:	bne.w	62ba <MTPD::GetObjectInfo(unsigned long)+0x21e>
    619a:	add	r1, sp, #16
    619c:	movs	r2, #2
    619e:	mov	r0, r4
    61a0:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    61a4:	ldrb	r3, [r4, #8]
    61a6:	strh.w	r6, [sp, #14]
    61aa:	cmp	r3, #0
    61ac:	bne.w	62be <MTPD::GetObjectInfo(unsigned long)+0x222>
    61b0:	movs	r2, #2
    61b2:	add.w	r1, sp, #14
    61b6:	mov	r0, r4
    61b8:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    61bc:	ldrb	r3, [r4, #8]
    61be:	ldr	r2, [sp, #20]
    61c0:	str	r2, [sp, #60]	; 0x3c
    61c2:	cmp	r3, #0
    61c4:	bne.n	62c2 <MTPD::GetObjectInfo(unsigned long)+0x226>
    61c6:	add	r1, sp, #60	; 0x3c
    61c8:	movs	r2, #4
    61ca:	mov	r0, r4
    61cc:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    61d0:	ldrb	r3, [r4, #8]
    61d2:	strh.w	r6, [sp, #12]
    61d6:	cmp	r3, #0
    61d8:	bne.n	62c6 <MTPD::GetObjectInfo(unsigned long)+0x22a>
    61da:	add	r1, sp, #12
    61dc:	movs	r2, #2
    61de:	mov	r0, r4
    61e0:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    61e4:	ldrb	r3, [r4, #8]
    61e6:	str	r6, [sp, #56]	; 0x38
    61e8:	cmp	r3, #0
    61ea:	bne.n	62ca <MTPD::GetObjectInfo(unsigned long)+0x22e>
    61ec:	add	r1, sp, #56	; 0x38
    61ee:	movs	r2, #4
    61f0:	mov	r0, r4
    61f2:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    61f6:	ldrb	r3, [r4, #8]
    61f8:	str	r6, [sp, #52]	; 0x34
    61fa:	cmp	r3, #0
    61fc:	bne.n	62ce <MTPD::GetObjectInfo(unsigned long)+0x232>
    61fe:	add	r1, sp, #52	; 0x34
    6200:	movs	r2, #4
    6202:	mov	r0, r4
    6204:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6208:	ldrb	r3, [r4, #8]
    620a:	str	r6, [sp, #48]	; 0x30
    620c:	cmp	r3, #0
    620e:	bne.n	62d2 <MTPD::GetObjectInfo(unsigned long)+0x236>
    6210:	add	r1, sp, #48	; 0x30
    6212:	movs	r2, #4
    6214:	mov	r0, r4
    6216:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    621a:	ldrb	r3, [r4, #8]
    621c:	str	r6, [sp, #44]	; 0x2c
    621e:	cmp	r3, #0
    6220:	bne.n	62d6 <MTPD::GetObjectInfo(unsigned long)+0x23a>
    6222:	add	r1, sp, #44	; 0x2c
    6224:	movs	r2, #4
    6226:	mov	r0, r4
    6228:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    622c:	ldrb	r3, [r4, #8]
    622e:	str	r6, [sp, #40]	; 0x28
    6230:	cmp	r3, #0
    6232:	bne.n	62da <MTPD::GetObjectInfo(unsigned long)+0x23e>
    6234:	add	r1, sp, #40	; 0x28
    6236:	movs	r2, #4
    6238:	mov	r0, r4
    623a:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    623e:	ldrb	r3, [r4, #8]
    6240:	str	r6, [sp, #36]	; 0x24
    6242:	cmp	r3, #0
    6244:	bne.n	62de <MTPD::GetObjectInfo(unsigned long)+0x242>
    6246:	movs	r2, #4
    6248:	add	r1, sp, #36	; 0x24
    624a:	mov	r0, r4
    624c:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6250:	ldrb	r3, [r4, #8]
    6252:	ldr	r2, [r5, #0]
    6254:	str	r2, [sp, #32]
    6256:	cmp	r3, #0
    6258:	bne.n	62e2 <MTPD::GetObjectInfo(unsigned long)+0x246>
    625a:	add	r1, sp, #32
    625c:	movs	r2, #4
    625e:	mov	r0, r4
    6260:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6264:	ldr	r3, [sp, #20]
    6266:	ldrb	r6, [r4, #8]
    6268:	sub.w	r3, r3, #4294967295
    626c:	clz	r3, r3
    6270:	lsrs	r3, r3, #5
    6272:	strh.w	r3, [sp, #18]
    6276:	cmp	r6, #0
    6278:	bne.n	62e6 <MTPD::GetObjectInfo(unsigned long)+0x24a>
    627a:	add.w	r1, sp, #18
    627e:	movs	r2, #2
    6280:	mov	r0, r4
    6282:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6286:	ldrb	r5, [r4, #8]
    6288:	str	r6, [sp, #68]	; 0x44
    628a:	cbnz	r5, 62b6 <MTPD::GetObjectInfo(unsigned long)+0x21a>
    628c:	add	r1, sp, #68	; 0x44
    628e:	movs	r2, #4
    6290:	mov	r0, r4
    6292:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6296:	ldrb	r3, [r4, #8]
    6298:	str	r5, [sp, #64]	; 0x40
    629a:	cbnz	r3, 62b2 <MTPD::GetObjectInfo(unsigned long)+0x216>
    629c:	add	r1, sp, #64	; 0x40
    629e:	movs	r2, #4
    62a0:	mov	r0, r4
    62a2:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    62a6:	b.n	6154 <MTPD::GetObjectInfo(unsigned long)+0xb8>
    62a8:	movw	r2, #12289	; 0x3001
    62ac:	strh.w	r2, [sp, #16]
    62b0:	b.n	60d8 <MTPD::GetObjectInfo(unsigned long)+0x3c>
    62b2:	ldr	r3, [r4, #12]
    62b4:	b.n	6150 <MTPD::GetObjectInfo(unsigned long)+0xb4>
    62b6:	ldr	r3, [r4, #12]
    62b8:	b.n	6148 <MTPD::GetObjectInfo(unsigned long)+0xac>
    62ba:	ldr	r3, [r4, #12]
    62bc:	b.n	60d8 <MTPD::GetObjectInfo(unsigned long)+0x3c>
    62be:	ldr	r3, [r4, #12]
    62c0:	b.n	60e2 <MTPD::GetObjectInfo(unsigned long)+0x46>
    62c2:	ldr	r3, [r4, #12]
    62c4:	b.n	60ea <MTPD::GetObjectInfo(unsigned long)+0x4e>
    62c6:	ldr	r3, [r4, #12]
    62c8:	b.n	60f4 <MTPD::GetObjectInfo(unsigned long)+0x58>
    62ca:	ldr	r3, [r4, #12]
    62cc:	b.n	60fc <MTPD::GetObjectInfo(unsigned long)+0x60>
    62ce:	ldr	r3, [r4, #12]
    62d0:	b.n	6104 <MTPD::GetObjectInfo(unsigned long)+0x68>
    62d2:	ldr	r3, [r4, #12]
    62d4:	b.n	610c <MTPD::GetObjectInfo(unsigned long)+0x70>
    62d6:	ldr	r3, [r4, #12]
    62d8:	b.n	6114 <MTPD::GetObjectInfo(unsigned long)+0x78>
    62da:	ldr	r3, [r4, #12]
    62dc:	b.n	611c <MTPD::GetObjectInfo(unsigned long)+0x80>
    62de:	ldr	r3, [r4, #12]
    62e0:	b.n	6124 <MTPD::GetObjectInfo(unsigned long)+0x88>
    62e2:	ldr	r3, [r4, #12]
    62e4:	b.n	612c <MTPD::GetObjectInfo(unsigned long)+0x90>
    62e6:	ldr	r3, [r4, #12]
    62e8:	b.n	6140 <MTPD::GetObjectInfo(unsigned long)+0xa4>
    62ea:	nop
    62ec:	.word	0x000142d0

000062f0 <MTPD::getObjectPropsSupported(unsigned long)>:
        write8(0);       // no form
    }
  }

    void MTPD::getObjectPropsSupported(uint32_t p1)
    {
    62f0:	push	{r4, r5, r6, r7, lr}
      write32(propertyListNum);
    62f2:	ldr	r7, [pc, #96]	; (6354 <MTPD::getObjectPropsSupported(unsigned long)+0x64>)
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    62f4:	ldrb	r2, [r0, #8]
    }
  }

    void MTPD::getObjectPropsSupported(uint32_t p1)
    {
      write32(propertyListNum);
    62f6:	ldr	r3, [r7, #0]
        write8(0);       // no form
    }
  }

    void MTPD::getObjectPropsSupported(uint32_t p1)
    {
    62f8:	sub	sp, #12
    62fa:	mov	r4, r0
    62fc:	str	r3, [sp, #4]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    62fe:	cbz	r2, 6346 <MTPD::getObjectPropsSupported(unsigned long)+0x56>
      write_length_ += len;
    6300:	ldr	r2, [r0, #12]
    6302:	adds	r2, #4
    6304:	str	r2, [r0, #12]
  }

    void MTPD::getObjectPropsSupported(uint32_t p1)
    {
      write32(propertyListNum);
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    6306:	cbz	r3, 6342 <MTPD::getObjectPropsSupported(unsigned long)+0x52>
    6308:	ldr	r6, [pc, #76]	; (6358 <MTPD::getObjectPropsSupported(unsigned long)+0x68>)
    630a:	movw	r3, #56321	; 0xdc01
    630e:	movs	r5, #0
    6310:	b.n	6324 <MTPD::getObjectPropsSupported(unsigned long)+0x34>
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
      write_length_ += len;
    6312:	ldr	r3, [r4, #12]
    6314:	adds	r3, #2
    6316:	str	r3, [r4, #12]
  }

    void MTPD::getObjectPropsSupported(uint32_t p1)
    {
      write32(propertyListNum);
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    6318:	ldr	r3, [r7, #0]
    631a:	adds	r5, #1
    631c:	cmp	r3, r5
    631e:	bls.n	6342 <MTPD::getObjectPropsSupported(unsigned long)+0x52>
    6320:	ldrh.w	r3, [r6, #2]!
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    6324:	ldrb	r2, [r4, #8]
    6326:	strh.w	r3, [sp, #2]
    632a:	cmp	r2, #0
    632c:	bne.n	6312 <MTPD::getObjectPropsSupported(unsigned long)+0x22>
    632e:	movs	r2, #2
    6330:	add.w	r1, sp, r2
    6334:	mov	r0, r4
    6336:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
  }

    void MTPD::getObjectPropsSupported(uint32_t p1)
    {
      write32(propertyListNum);
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    633a:	ldr	r3, [r7, #0]
    633c:	adds	r5, #1
    633e:	cmp	r3, r5
    6340:	bhi.n	6320 <MTPD::getObjectPropsSupported(unsigned long)+0x30>
    }
    6342:	add	sp, #12
    6344:	pop	{r4, r5, r6, r7, pc}
    6346:	movs	r2, #4
    6348:	add.w	r1, sp, r2
    634c:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6350:	ldr	r3, [r7, #0]
    6352:	b.n	6306 <MTPD::getObjectPropsSupported(unsigned long)+0x16>
    6354:	.word	0x1fff095c
    6358:	.word	0x0001444c

0000635c <MTPD::getObjectPropValue(unsigned long, unsigned long)>:
          break;
      }
    }

    void MTPD::getObjectPropValue(uint32_t p1, uint32_t p2)
    { char name[MAX_FILENAME_LEN];
    635c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    6360:	mov	r5, r0
      uint32_t dir;
      uint32_t size;
      uint32_t parent;
      uint16_t store;
      storage_->GetObjectInfo(p1,name,&size,&parent, &store);
    6362:	ldr	r0, [r0, #0]
          break;
      }
    }

    void MTPD::getObjectPropValue(uint32_t p1, uint32_t p2)
    { char name[MAX_FILENAME_LEN];
    6364:	sub	sp, #316	; 0x13c
      uint32_t dir;
      uint32_t size;
      uint32_t parent;
      uint16_t store;
      storage_->GetObjectInfo(p1,name,&size,&parent, &store);
    6366:	ldr	r3, [r0, #0]
    6368:	add.w	r6, sp, #10
    636c:	add	r7, sp, #20
    636e:	str	r6, [sp, #4]
    6370:	str	r7, [sp, #0]
          break;
      }
    }

    void MTPD::getObjectPropValue(uint32_t p1, uint32_t p2)
    { char name[MAX_FILENAME_LEN];
    6372:	mov	r4, r2
      uint32_t dir;
      uint32_t size;
      uint32_t parent;
      uint16_t store;
      storage_->GetObjectInfo(p1,name,&size,&parent, &store);
    6374:	ldr.w	r8, [r3, #36]	; 0x24
    6378:	add	r2, sp, #56	; 0x38
    637a:	add	r3, sp, #16
          break;
      }
    }

    void MTPD::getObjectPropValue(uint32_t p1, uint32_t p2)
    { char name[MAX_FILENAME_LEN];
    637c:	mov	r9, r1
      uint32_t dir;
      uint32_t size;
      uint32_t parent;
      uint16_t store;
      storage_->GetObjectInfo(p1,name,&size,&parent, &store);
    637e:	blx	r8
      dir = size == 0xFFFFFFFFUL;
      uint32_t storage = Store2Storage(store);
      switch(p2)
    6380:	sub.w	r2, r4, #56320	; 0xdc00
      uint32_t size;
      uint32_t parent;
      uint16_t store;
      storage_->GetObjectInfo(p1,name,&size,&parent, &store);
      dir = size == 0xFFFFFFFFUL;
      uint32_t storage = Store2Storage(store);
    6384:	ldrh	r3, [r6, #0]
      uint32_t dir;
      uint32_t size;
      uint32_t parent;
      uint16_t store;
      storage_->GetObjectInfo(p1,name,&size,&parent, &store);
      dir = size == 0xFFFFFFFFUL;
    6386:	ldr	r1, [sp, #16]
      uint32_t storage = Store2Storage(store);
      switch(p2)
    6388:	subs	r2, #1
      uint32_t size;
      uint32_t parent;
      uint16_t store;
      storage_->GetObjectInfo(p1,name,&size,&parent, &store);
      dir = size == 0xFFFFFFFFUL;
      uint32_t storage = Store2Storage(store);
    638a:	adds	r4, r3, #1
      switch(p2)
    638c:	cmp	r2, #67	; 0x43
    638e:	bhi.n	63f4 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x98>
    6390:	tbb	[pc, r2]
    6394:	.word	0x776a4b41
    6398:	.word	0x333a3030
    639c:	.word	0x305c3033
    63a0:	.word	0x30303030
    63a4:	.word	0x30303030
    63a8:	.word	0x30303030
    63ac:	.word	0x30303030
    63b0:	.word	0x30303030
    63b4:	.word	0x30303030
    63b8:	.word	0x30303030
    63bc:	.word	0x30303030
    63c0:	.word	0x30303030
    63c4:	.word	0x30303030
    63c8:	.word	0x30303030
    63cc:	.word	0x30303030
    63d0:	.word	0x30303030
    63d4:	.word	0x3a303022
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    63d8:	ldrb	r3, [r5, #8]
    63da:	str.w	r9, [sp, #52]	; 0x34
    63de:	cmp	r3, #0
    63e0:	beq.n	6492 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x136>
      write_length_ += len;
    63e2:	ldr	r3, [r5, #12]
    63e4:	adds	r3, #4
    63e6:	str	r3, [r5, #12]
    63e8:	adds	r3, #4
    63ea:	str	r3, [r5, #12]
    63ec:	adds	r3, #4
    63ee:	str	r3, [r5, #12]
    63f0:	adds	r3, #4
    63f2:	str	r3, [r5, #12]
          writestring(name);
          break;
        default:
          break;
      }
    }
    63f4:	add	sp, #316	; 0x13c
    63f6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
          break;
        case MTP_PROPERTY_DATE_CREATED:       //0xDC08:
          writestring("");
          break;
        case MTP_PROPERTY_DATE_MODIFIED:      //0xDC09:
          writestring("");
    63fa:	mov	r0, r5
    63fc:	ldr	r1, [pc, #276]	; (6514 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x1b8>)
    63fe:	bl	5be4 <MTPD::writestring(char const*)>
          writestring(name);
          break;
        default:
          break;
      }
    }
    6402:	add	sp, #316	; 0x13c
    6404:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
          write32(parent);
          write32(storage);
          write32(0);
          break;
        case MTP_PROPERTY_NAME:               //0xDC44:
          writestring(name);
    6408:	add	r1, sp, #56	; 0x38
    640a:	mov	r0, r5
    640c:	bl	5be4 <MTPD::writestring(char const*)>
          break;
        default:
          break;
      }
    }
    6410:	add	sp, #316	; 0x13c
    6412:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    6416:	ldrb	r3, [r5, #8]
    6418:	str	r4, [sp, #24]
    641a:	cmp	r3, #0
    641c:	beq.n	64de <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x182>
      write_length_ += len;
    641e:	ldr	r3, [r5, #12]
    6420:	adds	r3, #4
    6422:	str	r3, [r5, #12]
          writestring(name);
          break;
        default:
          break;
      }
    }
    6424:	add	sp, #316	; 0x13c
    6426:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      {
        case MTP_PROPERTY_STORAGE_ID:         //0xDC01:
          write32(storage);
          break;
        case MTP_PROPERTY_OBJECT_FORMAT:      //0xDC02:
          write16(dir?0x3001:0x3000);
    642a:	adds	r1, #1
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    642c:	ldrb	r2, [r5, #8]
      {
        case MTP_PROPERTY_STORAGE_ID:         //0xDC01:
          write32(storage);
          break;
        case MTP_PROPERTY_OBJECT_FORMAT:      //0xDC02:
          write16(dir?0x3001:0x3000);
    642e:	movw	r3, #12289	; 0x3001
    6432:	it	ne
    6434:	movne.w	r3, #12288	; 0x3000
    6438:	strh.w	r3, [sp, #12]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    643c:	cmp	r2, #0
    643e:	beq.n	64d2 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x176>
      write_length_ += len;
    6440:	ldr	r3, [r5, #12]
    6442:	adds	r3, #2
    6444:	str	r3, [r5, #12]
          writestring(name);
          break;
        default:
          break;
      }
    }
    6446:	add	sp, #316	; 0x13c
    6448:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
          break;
        case MTP_PROPERTY_DATE_MODIFIED:      //0xDC09:
          writestring("");
          break;
        case MTP_PROPERTY_PARENT_OBJECT:      //0xDC0B:
          write32((store==parent)? 0: parent);
    644c:	ldr	r2, [r7, #0]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    644e:	ldrb	r1, [r5, #8]
          break;
        case MTP_PROPERTY_DATE_MODIFIED:      //0xDC09:
          writestring("");
          break;
        case MTP_PROPERTY_PARENT_OBJECT:      //0xDC0B:
          write32((store==parent)? 0: parent);
    6450:	cmp	r3, r2
    6452:	it	eq
    6454:	moveq	r2, #0
    6456:	str	r2, [sp, #36]	; 0x24
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    6458:	cmp	r1, #0
    645a:	bne.n	641e <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xc2>
    645c:	add	r1, sp, #36	; 0x24
    645e:	mov	r0, r5
    6460:	movs	r2, #4
    6462:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6466:	b.n	63f4 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x98>
    6468:	ldrb	r3, [r5, #8]
    646a:	movs	r2, #0
    646c:	strh.w	r2, [sp, #14]
    6470:	cmp	r3, #0
    6472:	bne.n	6440 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xe4>
    6474:	add.w	r1, sp, #14
    6478:	mov	r0, r5
    647a:	movs	r2, #2
    647c:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6480:	b.n	63f4 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x98>
    6482:	ldrb	r4, [r5, #8]
    6484:	str	r1, [sp, #32]
    6486:	cmp	r4, #0
    6488:	beq.n	64ea <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x18e>
      write_length_ += len;
    648a:	ldr	r3, [r5, #12]
    648c:	adds	r3, #4
    648e:	str	r3, [r5, #12]
    6490:	b.n	63f0 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x94>
    6492:	movs	r2, #4
    6494:	add	r1, sp, #52	; 0x34
    6496:	mov	r0, r5
    6498:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    649c:	ldrb	r3, [r5, #8]
    649e:	ldr	r2, [r7, #0]
    64a0:	str	r2, [sp, #48]	; 0x30
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    64a2:	cmp	r3, #0
    64a4:	bne.n	650e <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x1b2>
    64a6:	add	r1, sp, #48	; 0x30
    64a8:	movs	r2, #4
    64aa:	mov	r0, r5
    64ac:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    64b0:	ldrb	r6, [r5, #8]
    64b2:	str	r4, [sp, #44]	; 0x2c
    64b4:	cbnz	r6, 650a <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x1ae>
    64b6:	add	r1, sp, #44	; 0x2c
    64b8:	movs	r2, #4
    64ba:	mov	r0, r5
    64bc:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    64c0:	ldrb	r3, [r5, #8]
    64c2:	str	r6, [sp, #40]	; 0x28
    64c4:	cbnz	r3, 6506 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x1aa>
    64c6:	add	r1, sp, #40	; 0x28
    64c8:	mov	r0, r5
    64ca:	movs	r2, #4
    64cc:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    64d0:	b.n	63f4 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x98>
    64d2:	add	r1, sp, #12
    64d4:	mov	r0, r5
    64d6:	movs	r2, #2
    64d8:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    64dc:	b.n	63f4 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x98>
    64de:	add	r1, sp, #24
    64e0:	mov	r0, r5
    64e2:	movs	r2, #4
    64e4:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    64e8:	b.n	63f4 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x98>
    64ea:	add	r1, sp, #32
    64ec:	movs	r2, #4
    64ee:	mov	r0, r5
    64f0:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    64f4:	ldrb	r3, [r5, #8]
    64f6:	str	r4, [sp, #28]
    64f8:	cbnz	r3, 6506 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x1aa>
    64fa:	add	r1, sp, #28
    64fc:	mov	r0, r5
    64fe:	movs	r2, #4
    6500:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6504:	b.n	63f4 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x98>
    6506:	ldr	r3, [r5, #12]
    6508:	b.n	63f0 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x94>
    650a:	ldr	r3, [r5, #12]
    650c:	b.n	63ec <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x90>
    650e:	ldr	r3, [r5, #12]
    6510:	b.n	63e8 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x8c>
    6512:	nop
    6514:	.word	0x000142d0

00006518 <MTPD::GetStorageInfo(unsigned long)>:
    uint32_t num=storage_->get_FSCount();
    write32(num); // number of storages (disks)
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
  }

  void MTPD::GetStorageInfo(uint32_t storage) {
    6518:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    651c:	mov	r4, r0
    uint32_t store = Storage2Store(storage);
    write16(storage_->readonly(store) ? 0x0001 : 0x0004);   // storage type (removable RAM)
    651e:	ldr	r0, [r0, #0]
    6520:	ldr	r3, [r0, #0]
    write32(num); // number of storages (disks)
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
  }

  void MTPD::GetStorageInfo(uint32_t storage) {
    uint32_t store = Storage2Store(storage);
    6522:	subs	r5, r1, #1
    uint32_t num=storage_->get_FSCount();
    write32(num); // number of storages (disks)
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
  }

  void MTPD::GetStorageInfo(uint32_t storage) {
    6524:	sub	sp, #36	; 0x24
    uint32_t store = Storage2Store(storage);
    write16(storage_->readonly(store) ? 0x0001 : 0x0004);   // storage type (removable RAM)
    6526:	ldr	r3, [r3, #20]
    6528:	mov	r1, r5
    652a:	blx	r3
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    652c:	ldrb	r3, [r4, #8]
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
  }

  void MTPD::GetStorageInfo(uint32_t storage) {
    uint32_t store = Storage2Store(storage);
    write16(storage_->readonly(store) ? 0x0001 : 0x0004);   // storage type (removable RAM)
    652e:	cmp	r0, #0
    6530:	ite	eq
    6532:	moveq	r2, #4
    6534:	movne	r2, #1
    6536:	strh.w	r2, [sp, #6]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    653a:	cmp	r3, #0
    653c:	beq.n	65d8 <MTPD::GetStorageInfo(unsigned long)+0xc0>
      write_length_ += len;
    653e:	ldr	r3, [r4, #12]
    6540:	adds	r3, #2
    6542:	str	r3, [r4, #12]
  }

  void MTPD::GetStorageInfo(uint32_t storage) {
    uint32_t store = Storage2Store(storage);
    write16(storage_->readonly(store) ? 0x0001 : 0x0004);   // storage type (removable RAM)
    write16(storage_->has_directories(store) ? 0x0002: 0x0001);   // filesystem type (generic hierarchical)
    6544:	ldr	r0, [r4, #0]
    6546:	ldr	r3, [r0, #0]
    6548:	mov	r1, r5
    654a:	ldr	r3, [r3, #24]
    654c:	blx	r3
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    654e:	ldrb	r6, [r4, #8]
  }

  void MTPD::GetStorageInfo(uint32_t storage) {
    uint32_t store = Storage2Store(storage);
    write16(storage_->readonly(store) ? 0x0001 : 0x0004);   // storage type (removable RAM)
    write16(storage_->has_directories(store) ? 0x0002: 0x0001);   // filesystem type (generic hierarchical)
    6550:	cmp	r0, #0
    6552:	ite	eq
    6554:	moveq	r3, #1
    6556:	movne	r3, #2
    6558:	strh.w	r3, [sp, #10]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    655c:	cmp	r6, #0
    655e:	beq.n	6620 <MTPD::GetStorageInfo(unsigned long)+0x108>
      write_length_ += len;
    6560:	ldr	r3, [r4, #12]
    6562:	movs	r2, #0
    6564:	adds	r3, #2
    6566:	str	r3, [r4, #12]
    6568:	strh.w	r2, [sp, #8]
    656c:	adds	r3, #2
    656e:	str	r3, [r4, #12]
    uint32_t store = Storage2Store(storage);
    write16(storage_->readonly(store) ? 0x0001 : 0x0004);   // storage type (removable RAM)
    write16(storage_->has_directories(store) ? 0x0002: 0x0001);   // filesystem type (generic hierarchical)
    write16(0x0000);   // access capability (read-write)

    uint64_t ntotal = storage_->totalSize(store) ; 
    6570:	ldr	r0, [r4, #0]
    6572:	ldr	r3, [r0, #0]
    6574:	mov	r1, r5
    6576:	ldr	r3, [r3, #12]
    6578:	blx	r3
    657a:	mov	r6, r0
    uint64_t nused = storage_->usedSize(store) ; 
    657c:	ldr	r0, [r4, #0]
    657e:	ldr	r3, [r0, #0]
    uint32_t store = Storage2Store(storage);
    write16(storage_->readonly(store) ? 0x0001 : 0x0004);   // storage type (removable RAM)
    write16(storage_->has_directories(store) ? 0x0002: 0x0001);   // filesystem type (generic hierarchical)
    write16(0x0000);   // access capability (read-write)

    uint64_t ntotal = storage_->totalSize(store) ; 
    6580:	mov	r7, r1
    uint64_t nused = storage_->usedSize(store) ; 
    6582:	ldr	r3, [r3, #16]
    6584:	mov	r1, r5
    6586:	blx	r3
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    6588:	ldrb	r3, [r4, #8]
    write16(storage_->readonly(store) ? 0x0001 : 0x0004);   // storage type (removable RAM)
    write16(storage_->has_directories(store) ? 0x0002: 0x0001);   // filesystem type (generic hierarchical)
    write16(0x0000);   // access capability (read-write)

    uint64_t ntotal = storage_->totalSize(store) ; 
    uint64_t nused = storage_->usedSize(store) ; 
    658a:	mov	r8, r0
    658c:	mov	r9, r1
    658e:	strd	r6, r7, [sp, #24]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    6592:	cbz	r3, 65e6 <MTPD::GetStorageInfo(unsigned long)+0xce>
    6594:	subs	r6, r6, r0
      write_length_ += len;
    6596:	ldr	r3, [r4, #12]
    6598:	sbc.w	r7, r7, r1
    659c:	strd	r6, r7, [sp, #16]
    65a0:	adds	r3, #8
    65a2:	str	r3, [r4, #12]
    65a4:	adds	r3, #8
    65a6:	mov.w	r2, #4294967295
    65aa:	str	r3, [r4, #12]
    65ac:	str	r2, [sp, #12]
    65ae:	adds	r3, #4
    65b0:	str	r3, [r4, #12]

    write64(ntotal);  // max capacity
    write64((ntotal-nused));  // free space (100M)
    //
    write32(0xFFFFFFFFUL);  // free space (objects)
    const char *name = storage_->get_FSName(store);
    65b2:	ldr	r0, [r4, #0]
    65b4:	ldr	r2, [pc, #156]	; (6654 <MTPD::GetStorageInfo(unsigned long)+0x13c>)
    65b6:	ldr	r3, [r0, #0]
    65b8:	ldr	r3, [r3, #8]
    65ba:	cmp	r3, r2
    65bc:	bne.n	6640 <MTPD::GetStorageInfo(unsigned long)+0x128>
    const char *sd_getFSName(uint32_t store) { return sd_name[store];}
    65be:	add.w	r0, r0, r5, lsl #2
    65c2:	ldr	r1, [r0, #8]
    writestring(name);  // storage descriptor
    65c4:	mov	r0, r4
    65c6:	bl	5be4 <MTPD::writestring(char const*)>
    writestring("");  // volume identifier
    65ca:	mov	r0, r4
    65cc:	ldr	r1, [pc, #136]	; (6658 <MTPD::GetStorageInfo(unsigned long)+0x140>)
    65ce:	bl	5be4 <MTPD::writestring(char const*)>

    //printf("%d %d ",storage,store); Serial.println(name); Serial.flush();
  }
    65d2:	add	sp, #36	; 0x24
    65d4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    65d8:	movs	r2, #2
    65da:	add.w	r1, sp, #6
    65de:	mov	r0, r4
    65e0:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    65e4:	b.n	6544 <MTPD::GetStorageInfo(unsigned long)+0x2c>
    65e6:	movs	r2, #8
    65e8:	add	r1, sp, #24
    65ea:	mov	r0, r4
    65ec:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    65f0:	subs.w	r6, r6, r8
    65f4:	ldrb	r3, [r4, #8]
    65f6:	sbc.w	r7, r7, r9
    65fa:	strd	r6, r7, [sp, #16]
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    65fe:	cbnz	r3, 664c <MTPD::GetStorageInfo(unsigned long)+0x134>
    6600:	movs	r2, #8
    6602:	add	r1, sp, #16
    6604:	mov	r0, r4
    6606:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    660a:	ldrb	r3, [r4, #8]
    660c:	mov.w	r2, #4294967295
    6610:	str	r2, [sp, #12]
    6612:	cbnz	r3, 6648 <MTPD::GetStorageInfo(unsigned long)+0x130>
    6614:	movs	r2, #4
    6616:	add	r1, sp, #12
    6618:	mov	r0, r4
    661a:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    661e:	b.n	65b2 <MTPD::GetStorageInfo(unsigned long)+0x9a>
    6620:	movs	r2, #2
    6622:	add.w	r1, sp, #10
    6626:	mov	r0, r4
    6628:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    662c:	ldrb	r3, [r4, #8]
    662e:	strh.w	r6, [sp, #8]
    6632:	cbnz	r3, 6650 <MTPD::GetStorageInfo(unsigned long)+0x138>
    6634:	movs	r2, #2
    6636:	add	r1, sp, #8
    6638:	mov	r0, r4
    663a:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    663e:	b.n	6570 <MTPD::GetStorageInfo(unsigned long)+0x58>

    write64(ntotal);  // max capacity
    write64((ntotal-nused));  // free space (100M)
    //
    write32(0xFFFFFFFFUL);  // free space (objects)
    const char *name = storage_->get_FSName(store);
    6640:	mov	r1, r5
    6642:	blx	r3
    6644:	mov	r1, r0
    6646:	b.n	65c4 <MTPD::GetStorageInfo(unsigned long)+0xac>
    6648:	ldr	r3, [r4, #12]
    664a:	b.n	65ae <MTPD::GetStorageInfo(unsigned long)+0x96>
    664c:	ldr	r3, [r4, #12]
    664e:	b.n	65a4 <MTPD::GetStorageInfo(unsigned long)+0x8c>
    6650:	ldr	r3, [r4, #12]
    6652:	b.n	656c <MTPD::GetStorageInfo(unsigned long)+0x54>
    6654:	.word	0x00001e75
    6658:	.word	0x000142d0

0000665c <MTPD::getObjectPropDesc(unsigned long, unsigned long)>:
      write32(propertyListNum);
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    }

    void MTPD::getObjectPropDesc(uint32_t p1, uint32_t p2)
    {
    665c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
      switch(p1)
    6660:	sub.w	r1, r1, #56320	; 0xdc00
    6664:	subs	r1, #1
      write32(propertyListNum);
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    }

    void MTPD::getObjectPropDesc(uint32_t p1, uint32_t p2)
    {
    6666:	sub	sp, #148	; 0x94
    6668:	mov	r4, r0
      switch(p1)
    666a:	cmp	r1, #67	; 0x43
    666c:	bhi.n	6724 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    666e:	tbh	[pc, r1, lsl #1]
    6672:	.short	0x005c
    6674:	.word	0x0080006e
    6678:	.word	0x005900c6
    667c:	.word	0x00d80059
    6680:	.word	0x01690121
    6684:	.word	0x01b10059
    6688:	.word	0x00590059
    668c:	.word	0x00590059
    6690:	.word	0x00590059
    6694:	.word	0x00590059
    6698:	.word	0x00590059
    669c:	.word	0x00590059
    66a0:	.word	0x00590059
    66a4:	.word	0x00590059
    66a8:	.word	0x00590059
    66ac:	.word	0x00590059
    66b0:	.word	0x00590059
    66b4:	.word	0x00590059
    66b8:	.word	0x00590059
    66bc:	.word	0x00590059
    66c0:	.word	0x00590059
    66c4:	.word	0x00590059
    66c8:	.word	0x00590059
    66cc:	.word	0x00590059
    66d0:	.word	0x00590059
    66d4:	.word	0x00590059
    66d8:	.word	0x00590059
    66dc:	.word	0x00590059
    66e0:	.word	0x00590059
    66e4:	.word	0x00590059
    66e8:	.word	0x00590059
    66ec:	.word	0x00590059
    66f0:	.word	0x01f70059
    66f4:	.word	0x00590059
    66f8:	.short	0x0044
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    66fa:	ldrb	r3, [r0, #8]
    66fc:	movw	r2, #56388	; 0xdc44
    6700:	strh.w	r2, [sp, #70]	; 0x46
    6704:	cmp	r3, #0
    6706:	beq.w	6b84 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x528>
      write_length_ += len;
    670a:	ldr	r3, [r4, #12]
    670c:	adds	r3, #2
    670e:	str	r3, [r4, #12]
    6710:	adds	r3, #2
    6712:	str	r3, [r4, #12]
    6714:	adds	r3, #1
    6716:	str	r3, [r4, #12]
    6718:	adds	r3, #1
    671a:	str	r3, [r4, #12]
    671c:	adds	r3, #4
    671e:	str	r3, [r4, #12]
    6720:	adds	r3, #1
    6722:	str	r3, [r4, #12]
          write8(0);
          break;
        default:
          break;
      }
    }
    6724:	add	sp, #148	; 0x94
    6726:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    672a:	ldrb	r3, [r0, #8]
    672c:	movw	r2, #56321	; 0xdc01
    6730:	strh.w	r2, [sp, #30]
    6734:	cmp	r3, #0
    6736:	beq.w	6c98 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x63c>
      write_length_ += len;
    673a:	ldr	r3, [r4, #12]
    673c:	adds	r3, #2
    673e:	str	r3, [r4, #12]
    6740:	adds	r3, #2
    6742:	str	r3, [r4, #12]
    6744:	adds	r3, #1
    6746:	str	r3, [r4, #12]
    6748:	adds	r3, #4
    674a:	str	r3, [r4, #12]
    674c:	b.n	671c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc0>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    674e:	ldrb	r3, [r0, #8]
    6750:	movw	r2, #56322	; 0xdc02
    6754:	strh.w	r2, [sp, #36]	; 0x24
    6758:	cmp	r3, #0
    675a:	beq.w	6b06 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x4aa>
      write_length_ += len;
    675e:	ldr	r3, [r4, #12]
    6760:	adds	r3, #2
    6762:	str	r3, [r4, #12]
    6764:	adds	r3, #2
    6766:	str	r3, [r4, #12]
    6768:	adds	r3, #1
    676a:	str	r3, [r4, #12]
    676c:	adds	r3, #2
    676e:	str	r3, [r4, #12]
    6770:	b.n	671c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc0>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    6772:	ldrb	r3, [r0, #8]
    6774:	movw	r2, #56323	; 0xdc03
    6778:	strh.w	r2, [sp, #42]	; 0x2a
    677c:	cmp	r3, #0
    677e:	bne.n	675e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x102>
    6780:	movs	r2, #2
    6782:	add.w	r1, sp, #42	; 0x2a
    6786:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    678a:	ldrb	r7, [r4, #8]
    678c:	movs	r6, #4
    678e:	strh.w	r6, [sp, #40]	; 0x28
    6792:	cmp	r7, #0
    6794:	bne.w	6d2e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6d2>
    6798:	movs	r2, #2
    679a:	add	r1, sp, #40	; 0x28
    679c:	mov	r0, r4
    679e:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    67a2:	ldrb	r5, [r4, #8]
    67a4:	strb.w	r7, [sp, #9]
    67a8:	cmp	r5, #0
    67aa:	bne.w	6d2a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ce>
    67ae:	movs	r2, #1
    67b0:	add.w	r1, sp, #9
    67b4:	mov	r0, r4
    67b6:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    67ba:	ldrb	r7, [r4, #8]
    67bc:	strh.w	r5, [sp, #38]	; 0x26
    67c0:	cmp	r7, #0
    67c2:	bne.w	6d26 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ca>
    67c6:	movs	r2, #2
    67c8:	add.w	r1, sp, #38	; 0x26
    67cc:	mov	r0, r4
    67ce:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    67d2:	ldrb	r5, [r4, #8]
    67d4:	str	r7, [sp, #84]	; 0x54
    67d6:	cmp	r5, #0
    67d8:	bne.w	6d02 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    67dc:	mov	r2, r6
    67de:	add	r1, sp, #84	; 0x54
    67e0:	mov	r0, r4
    67e2:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    67e6:	ldrb	r3, [r4, #8]
    67e8:	strb.w	r5, [sp, #8]
    67ec:	cmp	r3, #0
    67ee:	bne.w	6cfe <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    67f2:	mov	r0, r4
    67f4:	movs	r2, #1
    67f6:	add	r1, sp, #8
    67f8:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    67fc:	b.n	6724 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    67fe:	ldrb	r3, [r0, #8]
    6800:	movw	r2, #56324	; 0xdc04
    6804:	strh.w	r2, [sp, #46]	; 0x2e
    6808:	cmp	r3, #0
    680a:	beq.w	6a84 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x428>
      write_length_ += len;
    680e:	ldr	r3, [r0, #12]
    6810:	adds	r3, #2
    6812:	str	r3, [r0, #12]
    6814:	adds	r3, #2
    6816:	str	r3, [r4, #12]
    6818:	adds	r3, #1
    681a:	str	r3, [r4, #12]
    681c:	adds	r3, #8
    681e:	str	r3, [r4, #12]
    6820:	b.n	671c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc0>
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    6822:	ldrb	r3, [r0, #8]
    6824:	movw	r2, #56327	; 0xdc07
    6828:	strh.w	r2, [sp, #50]	; 0x32
    682c:	cmp	r3, #0
    682e:	bne.w	670a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xae>
    6832:	movs	r2, #2
    6834:	add.w	r1, sp, #50	; 0x32
    6838:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    683c:	ldrb	r3, [r4, #8]
    683e:	movw	r2, #65535	; 0xffff
    6842:	strh.w	r2, [sp, #48]	; 0x30
    6846:	cmp	r3, #0
    6848:	bne.w	6d16 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ba>
    684c:	movs	r2, #2
    684e:	add	r1, sp, #48	; 0x30
    6850:	mov	r0, r4
    6852:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6856:	ldrb	r6, [r4, #8]
    6858:	movs	r5, #1
    685a:	strb.w	r5, [sp, #14]
    685e:	cmp	r6, #0
    6860:	bne.w	6d12 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6b6>
    6864:	mov	r2, r5
    6866:	add.w	r1, sp, #14
    686a:	mov	r0, r4
    686c:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6870:	ldrb	r7, [r4, #8]
    6872:	strb.w	r6, [sp, #13]
    6876:	cmp	r7, #0
    6878:	bne.w	6d22 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6c6>
    687c:	mov	r2, r5
    687e:	add.w	r1, sp, #13
    6882:	mov	r0, r4
    6884:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6888:	ldrb	r6, [r4, #8]
    688a:	str	r7, [sp, #92]	; 0x5c
    688c:	cmp	r6, #0
    688e:	bne.w	6d02 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    6892:	movs	r2, #4
    6894:	add	r1, sp, #92	; 0x5c
    6896:	mov	r0, r4
    6898:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    689c:	ldrb	r3, [r4, #8]
    689e:	strb.w	r6, [sp, #12]
    68a2:	cmp	r3, #0
    68a4:	bne.w	6cfe <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    68a8:	mov	r2, r5
    68aa:	mov	r0, r4
    68ac:	add	r1, sp, #12
    68ae:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    68b2:	b.n	6724 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    68b4:	ldrb	r3, [r0, #8]
    68b6:	movw	r2, #56328	; 0xdc08
    68ba:	strh.w	r2, [sp, #54]	; 0x36
    68be:	cmp	r3, #0
    68c0:	bne.w	670a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xae>
    68c4:	movs	r2, #2
    68c6:	add.w	r1, sp, #54	; 0x36
    68ca:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    68ce:	ldrb	r6, [r4, #8]
    68d0:	movw	r3, #65535	; 0xffff
    68d4:	strh.w	r3, [sp, #52]	; 0x34
    68d8:	cmp	r6, #0
    68da:	bne.w	6d16 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ba>
    68de:	movs	r2, #2
    68e0:	add	r1, sp, #52	; 0x34
    68e2:	mov	r0, r4
    68e4:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    68e8:	ldrb	r5, [r4, #8]
    68ea:	strb.w	r6, [sp, #17]
    68ee:	cmp	r5, #0
    68f0:	bne.w	6d12 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6b6>
    68f4:	movs	r2, #1
    68f6:	add.w	r1, sp, #17
    68fa:	mov	r0, r4
    68fc:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6900:	ldrb	r6, [r4, #8]
    6902:	strb.w	r5, [sp, #16]
    6906:	cmp	r6, #0
    6908:	bne.w	6d22 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6c6>
    690c:	movs	r2, #1
    690e:	add	r1, sp, #16
    6910:	mov	r0, r4
    6912:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6916:	ldrb	r5, [r4, #8]
    6918:	str	r6, [sp, #96]	; 0x60
    691a:	cmp	r5, #0
    691c:	bne.w	6d02 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    6920:	movs	r2, #4
    6922:	add	r1, sp, #96	; 0x60
    6924:	mov	r0, r4
    6926:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    692a:	ldrb	r3, [r4, #8]
    692c:	strb.w	r5, [sp, #15]
    6930:	cmp	r3, #0
    6932:	bne.w	6cfe <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    6936:	mov	r0, r4
    6938:	movs	r2, #1
    693a:	add.w	r1, sp, #15
    693e:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6942:	b.n	6724 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    6944:	ldrb	r3, [r0, #8]
    6946:	movw	r2, #56329	; 0xdc09
    694a:	strh.w	r2, [sp, #58]	; 0x3a
    694e:	cmp	r3, #0
    6950:	bne.w	670a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xae>
    6954:	movs	r2, #2
    6956:	add.w	r1, sp, #58	; 0x3a
    695a:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    695e:	ldrb	r6, [r4, #8]
    6960:	movw	r3, #65535	; 0xffff
    6964:	strh.w	r3, [sp, #56]	; 0x38
    6968:	cmp	r6, #0
    696a:	bne.w	6d16 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ba>
    696e:	movs	r2, #2
    6970:	add	r1, sp, #56	; 0x38
    6972:	mov	r0, r4
    6974:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6978:	ldrb	r5, [r4, #8]
    697a:	strb.w	r6, [sp, #20]
    697e:	cmp	r5, #0
    6980:	bne.w	6d12 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6b6>
    6984:	movs	r2, #1
    6986:	add	r1, sp, #20
    6988:	mov	r0, r4
    698a:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    698e:	ldrb	r6, [r4, #8]
    6990:	strb.w	r5, [sp, #19]
    6994:	cmp	r6, #0
    6996:	bne.w	6d22 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6c6>
    699a:	movs	r2, #1
    699c:	add.w	r1, sp, #19
    69a0:	mov	r0, r4
    69a2:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    69a6:	ldrb	r5, [r4, #8]
    69a8:	str	r6, [sp, #100]	; 0x64
    69aa:	cmp	r5, #0
    69ac:	bne.w	6d02 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    69b0:	movs	r2, #4
    69b2:	add	r1, sp, #100	; 0x64
    69b4:	mov	r0, r4
    69b6:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    69ba:	ldrb	r3, [r4, #8]
    69bc:	strb.w	r5, [sp, #18]
    69c0:	cmp	r3, #0
    69c2:	bne.w	6cfe <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    69c6:	mov	r0, r4
    69c8:	movs	r2, #1
    69ca:	add.w	r1, sp, #18
    69ce:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    69d2:	b.n	6724 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    69d4:	ldrb	r3, [r0, #8]
    69d6:	movw	r2, #56331	; 0xdc0b
    69da:	strh.w	r2, [sp, #62]	; 0x3e
    69de:	cmp	r3, #0
    69e0:	bne.w	673a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xde>
    69e4:	movs	r2, #2
    69e6:	add.w	r1, sp, #62	; 0x3e
    69ea:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    69ee:	ldrb	r6, [r4, #8]
    69f0:	movs	r3, #6
    69f2:	strh.w	r3, [sp, #60]	; 0x3c
    69f6:	cmp	r6, #0
    69f8:	bne.w	6d0e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6b2>
    69fc:	movs	r2, #2
    69fe:	add	r1, sp, #60	; 0x3c
    6a00:	mov	r0, r4
    6a02:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6a06:	ldrb	r5, [r4, #8]
    6a08:	strb.w	r6, [sp, #22]
    6a0c:	cmp	r5, #0
    6a0e:	bne.w	6d0a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ae>
    6a12:	movs	r2, #1
    6a14:	add.w	r1, sp, #22
    6a18:	mov	r0, r4
    6a1a:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6a1e:	ldrb	r6, [r4, #8]
    6a20:	str	r5, [sp, #108]	; 0x6c
    6a22:	cmp	r6, #0
    6a24:	bne.w	6d06 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6aa>
    6a28:	movs	r2, #4
    6a2a:	add	r1, sp, #108	; 0x6c
    6a2c:	mov	r0, r4
    6a2e:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6a32:	ldrb	r5, [r4, #8]
    6a34:	str	r6, [sp, #104]	; 0x68
    6a36:	cmp	r5, #0
    6a38:	bne.w	6d02 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    6a3c:	movs	r2, #4
    6a3e:	add	r1, sp, #104	; 0x68
    6a40:	mov	r0, r4
    6a42:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6a46:	ldrb	r3, [r4, #8]
    6a48:	strb.w	r5, [sp, #21]
    6a4c:	cmp	r3, #0
    6a4e:	bne.w	6cfe <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    6a52:	mov	r0, r4
    6a54:	movs	r2, #1
    6a56:	add.w	r1, sp, #21
    6a5a:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6a5e:	b.n	6724 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    6a60:	ldrb	r3, [r0, #8]
    6a62:	movw	r2, #56385	; 0xdc41
    6a66:	strh.w	r2, [sp, #66]	; 0x42
    6a6a:	cmp	r3, #0
    6a6c:	beq.w	6c06 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x5aa>
      write_length_ += len;
    6a70:	ldr	r3, [r0, #12]
    6a72:	adds	r3, #2
    6a74:	str	r3, [r0, #12]
    6a76:	adds	r3, #2
    6a78:	str	r3, [r4, #12]
    6a7a:	adds	r3, #1
    6a7c:	str	r3, [r4, #12]
    6a7e:	adds	r3, #8
    6a80:	str	r3, [r4, #12]
    6a82:	b.n	681c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1c0>
    6a84:	movs	r2, #2
    6a86:	add.w	r1, sp, #46	; 0x2e
    6a8a:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6a8e:	ldrb	r6, [r4, #8]
    6a90:	movs	r5, #8
    6a92:	strh.w	r5, [sp, #44]	; 0x2c
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::write(const char *data, int len) {
    if (write_get_length_) {
    6a96:	cmp	r6, #0
    6a98:	bne.w	6d1e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6c2>
    6a9c:	movs	r2, #2
    6a9e:	add	r1, sp, #44	; 0x2c
    6aa0:	mov	r0, r4
    6aa2:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6aa6:	ldrb	r3, [r4, #8]
    6aa8:	strb.w	r6, [sp, #11]
    6aac:	cmp	r3, #0
    6aae:	bne.w	6d1a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6be>
    6ab2:	movs	r2, #1
    6ab4:	add.w	r1, sp, #11
    6ab8:	mov	r0, r4
    6aba:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6abe:	ldrb	r6, [r4, #8]
    6ac0:	movs	r2, #0
    6ac2:	movs	r3, #0
    6ac4:	strd	r2, r3, [sp, #120]	; 0x78
    6ac8:	cmp	r6, #0
    6aca:	bne.w	6d32 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6d6>
    6ace:	mov	r2, r5
    6ad0:	add	r1, sp, #120	; 0x78
    6ad2:	mov	r0, r4
    6ad4:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6ad8:	ldrb	r5, [r4, #8]
    6ada:	str	r6, [sp, #88]	; 0x58
    6adc:	cmp	r5, #0
    6ade:	bne.w	6d02 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    6ae2:	movs	r2, #4
    6ae4:	add	r1, sp, #88	; 0x58
    6ae6:	mov	r0, r4
    6ae8:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6aec:	ldrb	r3, [r4, #8]
    6aee:	strb.w	r5, [sp, #10]
    6af2:	cmp	r3, #0
    6af4:	bne.w	6cfe <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    6af8:	mov	r0, r4
    6afa:	movs	r2, #1
    6afc:	add.w	r1, sp, #10
    6b00:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6b04:	b.n	6724 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    6b06:	movs	r2, #2
    6b08:	add	r1, sp, #36	; 0x24
    6b0a:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6b0e:	ldrb	r7, [r4, #8]
    6b10:	movs	r6, #4
    6b12:	strh.w	r6, [sp, #34]	; 0x22
    6b16:	cmp	r7, #0
    6b18:	bne.w	6d2e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6d2>
    6b1c:	movs	r2, #2
    6b1e:	add.w	r1, sp, #34	; 0x22
    6b22:	mov	r0, r4
    6b24:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6b28:	ldrb	r5, [r4, #8]
    6b2a:	strb.w	r7, [sp, #7]
    6b2e:	cmp	r5, #0
    6b30:	bne.w	6d2a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ce>
    6b34:	movs	r2, #1
    6b36:	add.w	r1, sp, #7
    6b3a:	mov	r0, r4
    6b3c:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6b40:	ldrb	r7, [r4, #8]
    6b42:	strh.w	r5, [sp, #32]
    6b46:	cmp	r7, #0
    6b48:	bne.w	6d26 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ca>
    6b4c:	movs	r2, #2
    6b4e:	add	r1, sp, #32
    6b50:	mov	r0, r4
    6b52:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6b56:	ldrb	r5, [r4, #8]
    6b58:	str	r7, [sp, #80]	; 0x50
    6b5a:	cmp	r5, #0
    6b5c:	bne.w	6d02 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    6b60:	mov	r2, r6
    6b62:	add	r1, sp, #80	; 0x50
    6b64:	mov	r0, r4
    6b66:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6b6a:	ldrb	r3, [r4, #8]
    6b6c:	strb.w	r5, [sp, #6]
    6b70:	cmp	r3, #0
    6b72:	bne.w	6cfe <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    6b76:	mov	r0, r4
    6b78:	movs	r2, #1
    6b7a:	add.w	r1, sp, #6
    6b7e:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6b82:	b.n	6724 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    6b84:	movs	r2, #2
    6b86:	add.w	r1, sp, #70	; 0x46
    6b8a:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6b8e:	ldrb	r6, [r4, #8]
    6b90:	movw	r3, #65535	; 0xffff
    6b94:	strh.w	r3, [sp, #68]	; 0x44
    6b98:	cmp	r6, #0
    6b9a:	bne.w	6d16 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ba>
    6b9e:	movs	r2, #2
    6ba0:	add	r1, sp, #68	; 0x44
    6ba2:	mov	r0, r4
    6ba4:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6ba8:	ldrb	r5, [r4, #8]
    6baa:	strb.w	r6, [sp, #27]
    6bae:	cmp	r5, #0
    6bb0:	bne.w	6d12 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6b6>
    6bb4:	movs	r2, #1
    6bb6:	add.w	r1, sp, #27
    6bba:	mov	r0, r4
    6bbc:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6bc0:	ldrb	r6, [r4, #8]
    6bc2:	strb.w	r5, [sp, #26]
    6bc6:	cmp	r6, #0
    6bc8:	bne.w	6d22 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6c6>
    6bcc:	movs	r2, #1
    6bce:	add.w	r1, sp, #26
    6bd2:	mov	r0, r4
    6bd4:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6bd8:	ldrb	r5, [r4, #8]
    6bda:	str	r6, [sp, #116]	; 0x74
    6bdc:	cmp	r5, #0
    6bde:	bne.w	6d02 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    6be2:	movs	r2, #4
    6be4:	add	r1, sp, #116	; 0x74
    6be6:	mov	r0, r4
    6be8:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6bec:	ldrb	r3, [r4, #8]
    6bee:	strb.w	r5, [sp, #25]
    6bf2:	cmp	r3, #0
    6bf4:	bne.w	6cfe <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    6bf8:	mov	r0, r4
    6bfa:	movs	r2, #1
    6bfc:	add.w	r1, sp, #25
    6c00:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6c04:	b.n	6724 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    6c06:	movs	r2, #2
    6c08:	add.w	r1, sp, #66	; 0x42
    6c0c:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6c10:	ldrb	r5, [r4, #8]
    6c12:	movs	r3, #10
    6c14:	strh.w	r3, [sp, #64]	; 0x40
    6c18:	cmp	r5, #0
    6c1a:	bne.w	6d3e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6e2>
    6c1e:	movs	r2, #2
    6c20:	add	r1, sp, #64	; 0x40
    6c22:	mov	r0, r4
    6c24:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6c28:	ldrb	r3, [r4, #8]
    6c2a:	strb.w	r5, [sp, #24]
    6c2e:	cmp	r3, #0
    6c30:	bne.w	6d3a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6de>
    6c34:	movs	r2, #1
    6c36:	add	r1, sp, #24
    6c38:	mov	r0, r4
    6c3a:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6c3e:	ldrb	r3, [r4, #8]
    6c40:	mov.w	r8, #0
    6c44:	mov.w	r9, #0
    6c48:	strd	r8, r9, [sp, #136]	; 0x88
    6c4c:	cmp	r3, #0
    6c4e:	bne.n	6d36 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6da>
    6c50:	movs	r2, #8
    6c52:	add	r1, sp, #136	; 0x88
    6c54:	mov	r0, r4
    6c56:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6c5a:	ldrb	r6, [r4, #8]
    6c5c:	strd	r8, r9, [sp, #128]	; 0x80
    6c60:	cmp	r6, #0
    6c62:	bne.n	6d32 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6d6>
    6c64:	movs	r2, #8
    6c66:	add	r1, sp, #128	; 0x80
    6c68:	mov	r0, r4
    6c6a:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6c6e:	ldrb	r5, [r4, #8]
    6c70:	str	r6, [sp, #112]	; 0x70
    6c72:	cmp	r5, #0
    6c74:	bne.n	6d02 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    6c76:	movs	r2, #4
    6c78:	add	r1, sp, #112	; 0x70
    6c7a:	mov	r0, r4
    6c7c:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6c80:	ldrb	r3, [r4, #8]
    6c82:	strb.w	r5, [sp, #23]
    6c86:	cmp	r3, #0
    6c88:	bne.n	6cfe <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    6c8a:	mov	r0, r4
    6c8c:	movs	r2, #1
    6c8e:	add.w	r1, sp, #23
    6c92:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6c96:	b.n	6724 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    6c98:	movs	r2, #2
    6c9a:	add.w	r1, sp, #30
    6c9e:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6ca2:	ldrb	r6, [r4, #8]
    6ca4:	movs	r3, #6
    6ca6:	strh.w	r3, [sp, #28]
    6caa:	cbnz	r6, 6d0e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6b2>
    6cac:	movs	r2, #2
    6cae:	add	r1, sp, #28
    6cb0:	mov	r0, r4
    6cb2:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6cb6:	ldrb	r5, [r4, #8]
    6cb8:	strb.w	r6, [sp, #5]
    6cbc:	cbnz	r5, 6d0a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ae>
    6cbe:	movs	r2, #1
    6cc0:	add.w	r1, sp, #5
    6cc4:	mov	r0, r4
    6cc6:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6cca:	ldrb	r6, [r4, #8]
    6ccc:	str	r5, [sp, #76]	; 0x4c
    6cce:	cbnz	r6, 6d06 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6aa>
    6cd0:	movs	r2, #4
    6cd2:	add	r1, sp, #76	; 0x4c
    6cd4:	mov	r0, r4
    6cd6:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6cda:	ldrb	r5, [r4, #8]
    6cdc:	str	r6, [sp, #72]	; 0x48
    6cde:	cbnz	r5, 6d02 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    6ce0:	movs	r2, #4
    6ce2:	add	r1, sp, #72	; 0x48
    6ce4:	mov	r0, r4
    6ce6:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6cea:	ldrb	r3, [r4, #8]
    6cec:	strb.w	r5, [sp, #4]
    6cf0:	cbnz	r3, 6cfe <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    6cf2:	mov	r0, r4
    6cf4:	movs	r2, #1
    6cf6:	add	r1, sp, #4
    6cf8:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    6cfc:	b.n	6724 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    6cfe:	ldr	r3, [r4, #12]
    6d00:	b.n	6720 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc4>
    6d02:	ldr	r3, [r4, #12]
    6d04:	b.n	671c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc0>
    6d06:	ldr	r3, [r4, #12]
    6d08:	b.n	6748 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xec>
    6d0a:	ldr	r3, [r4, #12]
    6d0c:	b.n	6744 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xe8>
    6d0e:	ldr	r3, [r4, #12]
    6d10:	b.n	6740 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xe4>
    6d12:	ldr	r3, [r4, #12]
    6d14:	b.n	6714 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb8>
    6d16:	ldr	r3, [r4, #12]
    6d18:	b.n	6710 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb4>
    6d1a:	ldr	r3, [r4, #12]
    6d1c:	b.n	6818 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1bc>
    6d1e:	ldr	r3, [r4, #12]
    6d20:	b.n	6814 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1b8>
    6d22:	ldr	r3, [r4, #12]
    6d24:	b.n	6718 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xbc>
    6d26:	ldr	r3, [r4, #12]
    6d28:	b.n	676c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x110>
    6d2a:	ldr	r3, [r4, #12]
    6d2c:	b.n	6768 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x10c>
    6d2e:	ldr	r3, [r4, #12]
    6d30:	b.n	6764 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x108>
    6d32:	ldr	r3, [r4, #12]
    6d34:	b.n	681c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1c0>
    6d36:	ldr	r3, [r4, #12]
    6d38:	b.n	6a7e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x422>
    6d3a:	ldr	r3, [r4, #12]
    6d3c:	b.n	6a7a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x41e>
    6d3e:	ldr	r3, [r4, #12]
    6d40:	b.n	6a76 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x41a>
    6d42:	nop

00006d44 <MTPD::receive_buffer()>:
      data_buffer_ = usb_malloc();
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::receive_buffer() {
    6d44:	push	{r4, lr}
    6d46:	mov	r4, r0
    6d48:	ldr	r3, [r4, #4]
    while (!data_buffer_) {
      data_buffer_ = usb_rx(MTP_RX_ENDPOINT);
    6d4a:	movs	r0, #5
      if (!data_buffer_) mtp_yield();
    }
  }

  void MTPD::receive_buffer() {
    while (!data_buffer_) {
    6d4c:	cbnz	r3, 6d56 <MTPD::receive_buffer()+0x12>
      data_buffer_ = usb_rx(MTP_RX_ENDPOINT);
    6d4e:	bl	e11c <usb_rx>
    6d52:	str	r0, [r4, #4]
      if (!data_buffer_) mtp_yield();
    6d54:	cbz	r0, 6d58 <MTPD::receive_buffer()+0x14>
    6d56:	pop	{r4, pc}
    6d58:	bl	2150 <mtp_yield()>
    6d5c:	b.n	6d48 <MTPD::receive_buffer()+0x4>
    6d5e:	nop

00006d60 <MTPD::GetObject(unsigned long)>:
        }
      }
    }
  }
  void MTPD::GetObject(uint32_t object_id) 
  {
    6d60:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    6d64:	mov	r6, r0
    uint32_t size = storage_->GetSize(object_id);
    6d66:	ldr	r0, [r0, #0]
    6d68:	ldr	r3, [r0, #0]
        }
      }
    }
  }
  void MTPD::GetObject(uint32_t object_id) 
  {
    6d6a:	sub	sp, #8
    uint32_t size = storage_->GetSize(object_id);
    6d6c:	ldr	r3, [r3, #40]	; 0x28
        }
      }
    }
  }
  void MTPD::GetObject(uint32_t object_id) 
  {
    6d6e:	mov	r8, r1
    uint32_t size = storage_->GetSize(object_id);
    6d70:	blx	r3
    if (write_get_length_) {
    6d72:	ldrb	r5, [r6, #8]
      }
    }
  }
  void MTPD::GetObject(uint32_t object_id) 
  {
    uint32_t size = storage_->GetSize(object_id);
    6d74:	mov	r7, r0
    if (write_get_length_) {
    6d76:	cbnz	r5, 6dd0 <MTPD::GetObject(unsigned long)+0x70>
      write_length_ += size;
    } else {
      uint32_t pos = 0;
      while (pos < size) {
    6d78:	cbz	r0, 6dca <MTPD::GetObject(unsigned long)+0x6a>
                    (char*)(data_buffer_->buf + data_buffer_->len), to_copy);
        pos += to_copy;
        data_buffer_->len += to_copy;
        if (data_buffer_->len == sizeof(data_buffer_->buf)) {
          usb_tx(MTP_TX_ENDPOINT, data_buffer_);
          data_buffer_ = NULL;
    6d7a:	mov	r9, r5
    6d7c:	b.n	6d82 <MTPD::GetObject(unsigned long)+0x22>
    uint32_t size = storage_->GetSize(object_id);
    if (write_get_length_) {
      write_length_ += size;
    } else {
      uint32_t pos = 0;
      while (pos < size) {
    6d7e:	cmp	r7, r5
    6d80:	bls.n	6dca <MTPD::GetObject(unsigned long)+0x6a>
        get_buffer();
    6d82:	mov	r0, r6
    6d84:	bl	5b68 <MTPD::get_buffer()>
        uint32_t avail = sizeof(data_buffer_->buf) - data_buffer_->len;
        uint32_t to_copy = min(size - pos, avail);
        // Read directly from storage into usb buffer.
        storage_->read(object_id, pos,
    6d88:	ldmia.w	r6, {r0, r3}
      write_length_ += size;
    } else {
      uint32_t pos = 0;
      while (pos < size) {
        get_buffer();
        uint32_t avail = sizeof(data_buffer_->buf) - data_buffer_->len;
    6d8c:	ldrh.w	r2, [r3], #8
        uint32_t to_copy = min(size - pos, avail);
        // Read directly from storage into usb buffer.
        storage_->read(object_id, pos,
                    (char*)(data_buffer_->buf + data_buffer_->len), to_copy);
    6d90:	ldr	r1, [r0, #0]
    6d92:	subs	r4, r7, r5
    6d94:	rsb	lr, r2, #64	; 0x40
    6d98:	cmp	r4, lr
    6d9a:	it	cs
    6d9c:	movcs	r4, lr
    6d9e:	str	r4, [sp, #0]
    6da0:	add	r3, r2
    6da2:	ldr.w	sl, [r1, #48]	; 0x30
    6da6:	mov	r2, r5
    6da8:	mov	r1, r8
    6daa:	blx	sl
        pos += to_copy;
        data_buffer_->len += to_copy;
    6dac:	ldr	r1, [r6, #4]
    6dae:	ldrh	r3, [r1, #0]
    6db0:	add	r3, r4
    6db2:	uxth	r3, r3
        if (data_buffer_->len == sizeof(data_buffer_->buf)) {
    6db4:	cmp	r3, #64	; 0x40
        uint32_t avail = sizeof(data_buffer_->buf) - data_buffer_->len;
        uint32_t to_copy = min(size - pos, avail);
        // Read directly from storage into usb buffer.
        storage_->read(object_id, pos,
                    (char*)(data_buffer_->buf + data_buffer_->len), to_copy);
        pos += to_copy;
    6db6:	add	r5, r4
        data_buffer_->len += to_copy;
    6db8:	strh	r3, [r1, #0]
        if (data_buffer_->len == sizeof(data_buffer_->buf)) {
    6dba:	bne.n	6d7e <MTPD::GetObject(unsigned long)+0x1e>
          usb_tx(MTP_TX_ENDPOINT, data_buffer_);
    6dbc:	movs	r0, #4
    6dbe:	bl	e208 <usb_tx>
    uint32_t size = storage_->GetSize(object_id);
    if (write_get_length_) {
      write_length_ += size;
    } else {
      uint32_t pos = 0;
      while (pos < size) {
    6dc2:	cmp	r7, r5
                    (char*)(data_buffer_->buf + data_buffer_->len), to_copy);
        pos += to_copy;
        data_buffer_->len += to_copy;
        if (data_buffer_->len == sizeof(data_buffer_->buf)) {
          usb_tx(MTP_TX_ENDPOINT, data_buffer_);
          data_buffer_ = NULL;
    6dc4:	str.w	r9, [r6, #4]
    uint32_t size = storage_->GetSize(object_id);
    if (write_get_length_) {
      write_length_ += size;
    } else {
      uint32_t pos = 0;
      while (pos < size) {
    6dc8:	bhi.n	6d82 <MTPD::GetObject(unsigned long)+0x22>
          usb_tx(MTP_TX_ENDPOINT, data_buffer_);
          data_buffer_ = NULL;
        }
      }
    }
  }
    6dca:	add	sp, #8
    6dcc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  }
  void MTPD::GetObject(uint32_t object_id) 
  {
    uint32_t size = storage_->GetSize(object_id);
    if (write_get_length_) {
      write_length_ += size;
    6dd0:	ldr	r3, [r6, #12]
    6dd2:	add	r7, r3
    6dd4:	str	r7, [r6, #12]
          usb_tx(MTP_TX_ENDPOINT, data_buffer_);
          data_buffer_ = NULL;
        }
      }
    }
  }
    6dd6:	add	sp, #8
    6dd8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00006ddc <MTPD::read(char*, unsigned long)>:
      printf("\n"); \
    }

  void MTPD::read(char* data, uint32_t size) 
  {
    while (size) {
    6ddc:	cbz	r2, 6e48 <MTPD::read(char*, unsigned long)+0x6c>
      if(CONTAINER->len>20) printf(" %x", CONTAINER->params[2]); \
      printf("\n"); \
    }

  void MTPD::read(char* data, uint32_t size) 
  {
    6dde:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6de2:	mov	r6, r0
    6de4:	mov	r5, r1
    while (size) {
    6de6:	mov	r8, r2
      }
      size -= to_copy;
      data_buffer_->index += to_copy;
      if (data_buffer_->index == data_buffer_->len) {
        usb_free(data_buffer_);
        data_buffer_ = NULL;
    6de8:	movs	r7, #0
    }

  void MTPD::read(char* data, uint32_t size) 
  {
    while (size) {
      receive_buffer();
    6dea:	mov	r0, r6
    6dec:	bl	6d44 <MTPD::receive_buffer()>
      uint32_t to_copy = data_buffer_->len - data_buffer_->index;
    6df0:	ldr	r3, [r6, #4]
    6df2:	ldrh.w	lr, [r3, #2]
    6df6:	ldrh.w	ip, [r3]
    6dfa:	rsb	r4, lr, ip
    6dfe:	cmp	r4, r8
    6e00:	it	cs
    6e02:	movcs	r4, r8
      to_copy = min(to_copy, size);
      if (data) {
        memcpy(data, data_buffer_->buf + data_buffer_->index, to_copy);
    6e04:	add.w	r1, r3, #8
    6e08:	add	r1, lr
    6e0a:	mov	r0, r5
    6e0c:	mov	r2, r4
        data += to_copy;
      }
      size -= to_copy;
    6e0e:	rsb	r8, r4, r8
  {
    while (size) {
      receive_buffer();
      uint32_t to_copy = data_buffer_->len - data_buffer_->index;
      to_copy = min(to_copy, size);
      if (data) {
    6e12:	cbz	r5, 6e24 <MTPD::read(char*, unsigned long)+0x48>
        memcpy(data, data_buffer_->buf + data_buffer_->index, to_copy);
    6e14:	bl	d444 <memcpy>
    6e18:	ldr	r3, [r6, #4]
    6e1a:	ldrh.w	lr, [r3, #2]
    6e1e:	ldrh.w	ip, [r3]
        data += to_copy;
    6e22:	add	r5, r4
      }
      size -= to_copy;
      data_buffer_->index += to_copy;
    6e24:	add	r4, lr
    6e26:	uxth	r4, r4
      if (data_buffer_->index == data_buffer_->len) {
    6e28:	cmp	ip, r4
      if (data) {
        memcpy(data, data_buffer_->buf + data_buffer_->index, to_copy);
        data += to_copy;
      }
      size -= to_copy;
      data_buffer_->index += to_copy;
    6e2a:	strh	r4, [r3, #2]
      if (data_buffer_->index == data_buffer_->len) {
    6e2c:	beq.n	6e38 <MTPD::read(char*, unsigned long)+0x5c>
      printf("\n"); \
    }

  void MTPD::read(char* data, uint32_t size) 
  {
    while (size) {
    6e2e:	cmp.w	r8, #0
    6e32:	bne.n	6dea <MTPD::read(char*, unsigned long)+0xe>
    6e34:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        data += to_copy;
      }
      size -= to_copy;
      data_buffer_->index += to_copy;
      if (data_buffer_->index == data_buffer_->len) {
        usb_free(data_buffer_);
    6e38:	mov	r0, r3
    6e3a:	bl	e0d0 <usb_free>
        data_buffer_ = NULL;
    6e3e:	str	r7, [r6, #4]
      printf("\n"); \
    }

  void MTPD::read(char* data, uint32_t size) 
  {
    while (size) {
    6e40:	cmp.w	r8, #0
    6e44:	bne.n	6dea <MTPD::read(char*, unsigned long)+0xe>
    6e46:	b.n	6e34 <MTPD::read(char*, unsigned long)+0x58>
    6e48:	bx	lr
    6e4a:	nop

00006e4c <MTPD::readstring(char*)>:

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }

  void MTPD::readstring(char* buffer) {
    6e4c:	push	{r4, r5, r6, lr}
    6e4e:	sub	sp, #8
      return header.len - 12;
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
    6e50:	movs	r2, #1
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }

  void MTPD::readstring(char* buffer) {
    6e52:	mov	r4, r1
      return header.len - 12;
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
    6e54:	add.w	r1, sp, #6
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }

  void MTPD::readstring(char* buffer) {
    6e58:	mov	r6, r0
      return header.len - 12;
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
    6e5a:	bl	6ddc <MTPD::read(char*, unsigned long)>
    6e5e:	ldrb.w	r2, [sp, #6]
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }

  void MTPD::readstring(char* buffer) {
    int len = read8();
    if (!buffer) {
    6e62:	cbz	r4, 6e84 <MTPD::readstring(char*)+0x38>
    6e64:	adds	r5, r4, r2
      read(NULL, len * 2);
    } else {
      for (int i = 0; i < len; i++) {
    6e66:	cbz	r2, 6e80 <MTPD::readstring(char*)+0x34>
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6e68:	movs	r2, #2
    6e6a:	add.w	r1, sp, #6
    6e6e:	mov	r0, r6
    6e70:	bl	6ddc <MTPD::read(char*, unsigned long)>
    6e74:	ldrh.w	r3, [sp, #6]
    if (!buffer) {
      read(NULL, len * 2);
    } else {
      for (int i = 0; i < len; i++) {
        int16_t c2;
        *(buffer++) = c2 = read16();
    6e78:	strb.w	r3, [r4], #1
  void MTPD::readstring(char* buffer) {
    int len = read8();
    if (!buffer) {
      read(NULL, len * 2);
    } else {
      for (int i = 0; i < len; i++) {
    6e7c:	cmp	r5, r4
    6e7e:	bne.n	6e68 <MTPD::readstring(char*)+0x1c>
        int16_t c2;
        *(buffer++) = c2 = read16();
      }
    }
  }
    6e80:	add	sp, #8
    6e82:	pop	{r4, r5, r6, pc}
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }

  void MTPD::readstring(char* buffer) {
    int len = read8();
    if (!buffer) {
      read(NULL, len * 2);
    6e84:	lsls	r2, r2, #1
    6e86:	mov	r1, r4
    6e88:	mov	r0, r6
    6e8a:	bl	6ddc <MTPD::read(char*, unsigned long)>
    6e8e:	b.n	6e80 <MTPD::readstring(char*)+0x34>

00006e90 <MTPD::setObjectPropValue(unsigned long, unsigned long) [clone .part.6]>:
    }
    storage_->close();
    return true;
  }
  
    uint32_t MTPD::setObjectPropValue(uint32_t p1, uint32_t p2)
    6e90:	push	{r4, r5, lr}
    6e92:	sub	sp, #260	; 0x104
    6e94:	mov	r4, r0
    6e96:	mov	r5, r1
  }

  uint32_t MTPD::ReadMTPHeader() 
  {
    MTPHeader header;
    read((char *)&header, sizeof(MTPHeader));
    6e98:	movs	r2, #12
    6e9a:	mov	r1, sp
    6e9c:	bl	6ddc <MTPD::read(char*, unsigned long)>
      receive_buffer();
      if(p2==0xDC07)
      {
        char filename[MAX_FILENAME_LEN];
        ReadMTPHeader();
        readstring(filename);
    6ea0:	mov	r1, sp
    6ea2:	mov	r0, r4
    6ea4:	bl	6e4c <MTPD::readstring(char*)>

        storage_->rename(p1,filename);
    6ea8:	ldr	r0, [r4, #0]
    6eaa:	ldr	r3, [r0, #0]
    6eac:	mov	r2, sp
    6eae:	mov	r1, r5
    6eb0:	ldr	r3, [r3, #72]	; 0x48
    6eb2:	blx	r3

        return 0x2001;
      }
      else
        return 0x2005;
    }
    6eb4:	movw	r0, #8193	; 0x2001
    6eb8:	add	sp, #260	; 0x104
    6eba:	pop	{r4, r5, pc}

00006ebc <MTPD::SendObjectInfo(unsigned long, unsigned long)>:
        data_buffer_ = NULL;
      }
    }
  }

  uint32_t MTPD::SendObjectInfo(uint32_t storage, uint32_t parent) {
    6ebc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6ec0:	sub	sp, #276	; 0x114
  }

  uint32_t MTPD::ReadMTPHeader() 
  {
    MTPHeader header;
    read((char *)&header, sizeof(MTPHeader));
    6ec2:	add	r7, sp, #16
        data_buffer_ = NULL;
      }
    }
  }

  uint32_t MTPD::SendObjectInfo(uint32_t storage, uint32_t parent) {
    6ec4:	mov	r9, r1
    6ec6:	mov	fp, r2
  }

  uint32_t MTPD::ReadMTPHeader() 
  {
    MTPHeader header;
    read((char *)&header, sizeof(MTPHeader));
    6ec8:	mov	r1, r7
    6eca:	movs	r2, #12
        data_buffer_ = NULL;
      }
    }
  }

  uint32_t MTPD::SendObjectInfo(uint32_t storage, uint32_t parent) {
    6ecc:	mov	r5, r0
  }

  uint32_t MTPD::ReadMTPHeader() 
  {
    MTPHeader header;
    read((char *)&header, sizeof(MTPHeader));
    6ece:	bl	6ddc <MTPD::read(char*, unsigned long)>
    // check that the type is data
    if(header.type==2)
    6ed2:	ldrh	r3, [r7, #4]
    6ed4:	cmp	r3, #2
    6ed6:	it	eq
    6ed8:	ldreq	r4, [r7, #0]
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6eda:	mov.w	r2, #4
    6ede:	mov	r1, r7
    6ee0:	mov	r0, r5
    6ee2:	ite	eq
    6ee4:	subeq	r4, #65	; 0x41
  uint32_t MTPD::ReadMTPHeader() 
  {
    MTPHeader header;
    read((char *)&header, sizeof(MTPHeader));
    // check that the type is data
    if(header.type==2)
    6ee6:	mvnne.w	r4, #52	; 0x34
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6eea:	bl	6ddc <MTPD::read(char*, unsigned long)>
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6eee:	movs	r2, #2
    6ef0:	mov	r1, r7
    6ef2:	mov	r0, r5
    6ef4:	bl	6ddc <MTPD::read(char*, unsigned long)>
    6ef8:	ldrh.w	sl, [r7]
    char filename[MAX_FILENAME_LEN];

    uint32_t store = Storage2Store(storage);

    read32(); len-=4; // storage
    bool dir = read16() == 0x3001; len-=2; // format
    6efc:	movw	r3, #12289	; 0x3001
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6f00:	movs	r2, #2
    6f02:	mov	r1, r7
    6f04:	mov	r0, r5
    char filename[MAX_FILENAME_LEN];

    uint32_t store = Storage2Store(storage);

    read32(); len-=4; // storage
    bool dir = read16() == 0x3001; len-=2; // format
    6f06:	rsb	sl, r3, sl
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6f0a:	bl	6ddc <MTPD::read(char*, unsigned long)>
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6f0e:	movs	r2, #4
    6f10:	mov	r1, r7
    6f12:	mov	r0, r5
    6f14:	bl	6ddc <MTPD::read(char*, unsigned long)>
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6f18:	movs	r2, #2
    6f1a:	mov	r1, r7
    6f1c:	mov	r0, r5
    6f1e:	bl	6ddc <MTPD::read(char*, unsigned long)>
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6f22:	movs	r2, #4
    6f24:	mov	r1, r7
    6f26:	mov	r0, r5
    6f28:	bl	6ddc <MTPD::read(char*, unsigned long)>
    6f2c:	movs	r2, #4
    6f2e:	mov	r1, r7
    6f30:	mov	r0, r5
    6f32:	bl	6ddc <MTPD::read(char*, unsigned long)>
    6f36:	movs	r2, #4
    6f38:	mov	r1, r7
    6f3a:	mov	r0, r5
    6f3c:	bl	6ddc <MTPD::read(char*, unsigned long)>
    6f40:	movs	r2, #4
    6f42:	mov	r1, r7
    6f44:	mov	r0, r5
    6f46:	bl	6ddc <MTPD::read(char*, unsigned long)>
    6f4a:	movs	r2, #4
    6f4c:	mov	r1, r7
    6f4e:	mov	r0, r5
    6f50:	bl	6ddc <MTPD::read(char*, unsigned long)>
    6f54:	movs	r2, #4
    6f56:	mov	r1, r7
    6f58:	mov	r0, r5
    6f5a:	bl	6ddc <MTPD::read(char*, unsigned long)>
    6f5e:	movs	r2, #4
    6f60:	mov	r1, r7
    6f62:	mov	r0, r5
    6f64:	bl	6ddc <MTPD::read(char*, unsigned long)>
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6f68:	movs	r2, #2
    6f6a:	mov	r1, r7
    6f6c:	mov	r0, r5
    6f6e:	bl	6ddc <MTPD::read(char*, unsigned long)>
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6f72:	movs	r2, #4
    6f74:	mov	r1, r7
    6f76:	mov	r0, r5
    6f78:	bl	6ddc <MTPD::read(char*, unsigned long)>
    6f7c:	movs	r2, #4
    6f7e:	mov	r1, r7
    6f80:	mov	r0, r5
    6f82:	bl	6ddc <MTPD::read(char*, unsigned long)>
    read32(); len-=4; // parent
    read16(); len-=2; // association type
    read32(); len-=4; // association description
    read32(); len-=4; // sequence number

    readstring(filename); len -= (2*(strlen(filename)+1)+1); 
    6f86:	mov	r1, r7
    6f88:	mov	r0, r5
    6f8a:	bl	6e4c <MTPD::readstring(char*)>
    6f8e:	mov	r0, r7
    6f90:	bl	10c00 <strlen>
    6f94:	adds	r0, #1
    6f96:	sub.w	r4, r4, r0, lsl #1
    char filename[MAX_FILENAME_LEN];

    uint32_t store = Storage2Store(storage);

    read32(); len-=4; // storage
    bool dir = read16() == 0x3001; len-=2; // format
    6f9a:	clz	sl, sl
    read32(); len-=4; // association description
    read32(); len-=4; // sequence number

    readstring(filename); len -= (2*(strlen(filename)+1)+1); 
    // ignore rest of ObjectInfo
    while(len>=4) { read32(); len-=4;}
    6f9e:	cmp	r4, #3
    char filename[MAX_FILENAME_LEN];

    uint32_t store = Storage2Store(storage);

    read32(); len-=4; // storage
    bool dir = read16() == 0x3001; len-=2; // format
    6fa0:	mov.w	sl, sl, lsr #5

  uint32_t MTPD::SendObjectInfo(uint32_t storage, uint32_t parent) {
    uint32_t len = ReadMTPHeader();
    char filename[MAX_FILENAME_LEN];

    uint32_t store = Storage2Store(storage);
    6fa4:	add.w	r9, r9, #4294967295
    read32(); len-=4; // association description
    read32(); len-=4; // sequence number

    readstring(filename); len -= (2*(strlen(filename)+1)+1); 
    // ignore rest of ObjectInfo
    while(len>=4) { read32(); len-=4;}
    6fa8:	bls.n	6fc4 <MTPD::SendObjectInfo(unsigned long, unsigned long)+0x108>
    6faa:	mov	r6, r4
    6fac:	add.w	r8, sp, #12
    6fb0:	subs	r6, #4
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
  uint16_t MTPD::read16() { uint16_t ret; read((char*)&ret, sizeof(ret)); return ret; }
  uint32_t MTPD::read32() { uint32_t ret; read((char*)&ret, sizeof(ret)); return ret; }
    6fb2:	movs	r2, #4
    6fb4:	mov	r1, r8
    6fb6:	mov	r0, r5
    6fb8:	bl	6ddc <MTPD::read(char*, unsigned long)>
    read32(); len-=4; // association description
    read32(); len-=4; // sequence number

    readstring(filename); len -= (2*(strlen(filename)+1)+1); 
    // ignore rest of ObjectInfo
    while(len>=4) { read32(); len-=4;}
    6fbc:	cmp	r6, #3
    6fbe:	bhi.n	6fb0 <MTPD::SendObjectInfo(unsigned long, unsigned long)+0xf4>
    6fc0:	and.w	r4, r4, #3
    6fc4:	add.w	r8, sp, #12
    while(len) {read8(); len--;}
    6fc8:	cbz	r4, 6fd8 <MTPD::SendObjectInfo(unsigned long, unsigned long)+0x11c>
      return header.len - 12;
    else
      return 0;
  }

  uint8_t MTPD::read8() { uint8_t ret; read((char*)&ret, sizeof(ret));  return ret;  }
    6fca:	movs	r2, #1
    6fcc:	mov	r1, r8
    6fce:	mov	r0, r5
    6fd0:	bl	6ddc <MTPD::read(char*, unsigned long)>
    read32(); len-=4; // sequence number

    readstring(filename); len -= (2*(strlen(filename)+1)+1); 
    // ignore rest of ObjectInfo
    while(len>=4) { read32(); len-=4;}
    while(len) {read8(); len--;}
    6fd4:	subs	r4, #1
    6fd6:	bne.n	6fca <MTPD::SendObjectInfo(unsigned long, unsigned long)+0x10e>
    
    return storage_->Create(store, parent, dir, filename);
    6fd8:	ldr	r0, [r5, #0]
    6fda:	ldr	r4, [r0, #0]
    6fdc:	str	r7, [sp, #0]
    6fde:	mov	r3, sl
    6fe0:	mov	r2, fp
    6fe2:	mov	r1, r9
    6fe4:	ldr	r4, [r4, #44]	; 0x2c
    6fe6:	blx	r4
  }
    6fe8:	add	sp, #276	; 0x114
    6fea:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6fee:	nop

00006ff0 <MTPD::SendObject()>:

  bool MTPD::SendObject() {
    6ff0:	push	{r4, r5, r6, r7, lr}
    6ff2:	sub	sp, #20
  }

  uint32_t MTPD::ReadMTPHeader() 
  {
    MTPHeader header;
    read((char *)&header, sizeof(MTPHeader));
    6ff4:	movs	r2, #12
    6ff6:	add	r1, sp, #4
    while(len) {read8(); len--;}
    
    return storage_->Create(store, parent, dir, filename);
  }

  bool MTPD::SendObject() {
    6ff8:	mov	r6, r0
  }

  uint32_t MTPD::ReadMTPHeader() 
  {
    MTPHeader header;
    read((char *)&header, sizeof(MTPHeader));
    6ffa:	bl	6ddc <MTPD::read(char*, unsigned long)>
    // check that the type is data
    if(header.type==2)
    6ffe:	ldrh.w	r3, [sp, #8]
    7002:	cmp	r3, #2
    7004:	beq.n	7014 <MTPD::SendObject()+0x24>
      {
        usb_free(data_buffer_);
        data_buffer_ = NULL;
      }
    }
    storage_->close();
    7006:	ldr	r0, [r6, #0]
    7008:	ldr	r3, [r0, #0]
    700a:	ldr	r3, [r3, #56]	; 0x38
    700c:	blx	r3
    return true;
    700e:	movs	r0, #1
  }
    7010:	add	sp, #20
    7012:	pop	{r4, r5, r6, r7, pc}
  {
    MTPHeader header;
    read((char *)&header, sizeof(MTPHeader));
    // check that the type is data
    if(header.type==2)
      return header.len - 12;
    7014:	ldr	r7, [sp, #4]
    return storage_->Create(store, parent, dir, filename);
  }

  bool MTPD::SendObject() {
    uint32_t len = ReadMTPHeader();
    while (len) 
    7016:	subs	r7, #12
    7018:	beq.n	7006 <MTPD::SendObject()+0x16>
      data_buffer_->index += to_copy;
      len -= to_copy;
      if (data_buffer_->index == data_buffer_->len) 
      {
        usb_free(data_buffer_);
        data_buffer_ = NULL;
    701a:	movs	r5, #0

  bool MTPD::SendObject() {
    uint32_t len = ReadMTPHeader();
    while (len) 
    { 
      receive_buffer();
    701c:	mov	r0, r6
    701e:	bl	6d44 <MTPD::receive_buffer()>
      uint32_t to_copy = data_buffer_->len - data_buffer_->index;
      to_copy = min(to_copy, len);
      if(!storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy)) return false;
    7022:	ldmia.w	r6, {r0, r1}
  bool MTPD::SendObject() {
    uint32_t len = ReadMTPHeader();
    while (len) 
    { 
      receive_buffer();
      uint32_t to_copy = data_buffer_->len - data_buffer_->index;
    7026:	ldrh	r2, [r1, #2]
    7028:	ldrh.w	r4, [r1], #8
      to_copy = min(to_copy, len);
      if(!storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy)) return false;
    702c:	ldr	r3, [r0, #0]
  bool MTPD::SendObject() {
    uint32_t len = ReadMTPHeader();
    while (len) 
    { 
      receive_buffer();
      uint32_t to_copy = data_buffer_->len - data_buffer_->index;
    702e:	subs	r4, r4, r2
    7030:	cmp	r4, r7
    7032:	it	cs
    7034:	movcs	r4, r7
      to_copy = min(to_copy, len);
      if(!storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy)) return false;
    7036:	add	r1, r2
    7038:	ldr	r3, [r3, #52]	; 0x34
    703a:	mov	r2, r4
    703c:	blx	r3
      data_buffer_->index += to_copy;
      len -= to_copy;
    703e:	subs	r7, r7, r4
    while (len) 
    { 
      receive_buffer();
      uint32_t to_copy = data_buffer_->len - data_buffer_->index;
      to_copy = min(to_copy, len);
      if(!storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy)) return false;
    7040:	cmp	r0, #0
    7042:	beq.n	7010 <MTPD::SendObject()+0x20>
      data_buffer_->index += to_copy;
    7044:	ldr	r0, [r6, #4]
    7046:	ldrh	r3, [r0, #2]
      len -= to_copy;
      if (data_buffer_->index == data_buffer_->len) 
    7048:	ldrh	r2, [r0, #0]
    { 
      receive_buffer();
      uint32_t to_copy = data_buffer_->len - data_buffer_->index;
      to_copy = min(to_copy, len);
      if(!storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy)) return false;
      data_buffer_->index += to_copy;
    704a:	add	r4, r3
    704c:	uxth	r4, r4
      len -= to_copy;
      if (data_buffer_->index == data_buffer_->len) 
    704e:	cmp	r2, r4
    { 
      receive_buffer();
      uint32_t to_copy = data_buffer_->len - data_buffer_->index;
      to_copy = min(to_copy, len);
      if(!storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy)) return false;
      data_buffer_->index += to_copy;
    7050:	strh	r4, [r0, #2]
      len -= to_copy;
      if (data_buffer_->index == data_buffer_->len) 
    7052:	beq.n	705a <MTPD::SendObject()+0x6a>
    return storage_->Create(store, parent, dir, filename);
  }

  bool MTPD::SendObject() {
    uint32_t len = ReadMTPHeader();
    while (len) 
    7054:	cmp	r7, #0
    7056:	bne.n	701c <MTPD::SendObject()+0x2c>
    7058:	b.n	7006 <MTPD::SendObject()+0x16>
      if(!storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy)) return false;
      data_buffer_->index += to_copy;
      len -= to_copy;
      if (data_buffer_->index == data_buffer_->len) 
      {
        usb_free(data_buffer_);
    705a:	bl	e0d0 <usb_free>
        data_buffer_ = NULL;
    705e:	str	r5, [r6, #4]
    return storage_->Create(store, parent, dir, filename);
  }

  bool MTPD::SendObject() {
    uint32_t len = ReadMTPHeader();
    while (len) 
    7060:	cmp	r7, #0
    7062:	bne.n	701c <MTPD::SendObject()+0x2c>
    7064:	b.n	7006 <MTPD::SendObject()+0x16>
    7066:	nop

00007068 <MTPD::loop()>:
      else
        return 0x2005;
    }

  void MTPD::loop(void) 
  {
    7068:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    706c:	mov	r5, r0
    706e:	sub	sp, #36	; 0x24
    usb_packet_t *receive_buffer;
    if ((receive_buffer = usb_rx(MTP_RX_ENDPOINT))) {
    7070:	movs	r0, #5
    7072:	bl	e11c <usb_rx>
    7076:	cmp	r0, #0
    7078:	beq.n	70de <MTPD::loop()+0x76>
      printContainer();
    707a:	ldr	r1, [r0, #16]
    707c:	ldr	r3, [r0, #8]
    707e:	ldrh	r2, [r0, #14]
    7080:	str	r1, [sp, #4]
    7082:	ldrh	r1, [r0, #12]
    7084:	str	r1, [sp, #0]
    7086:	mov	r4, r0
    7088:	ldr	r1, [pc, #764]	; (7388 <MTPD::loop()+0x320>)
    708a:	ldr	r0, [pc, #768]	; (738c <MTPD::loop()+0x324>)
    708c:	bl	ef0c <Print::printf(char const*, ...)>
    7090:	ldr	r3, [r4, #8]
    7092:	cmp	r3, #12
    7094:	bhi.n	7126 <MTPD::loop()+0xbe>
    7096:	ldr	r1, [pc, #760]	; (7390 <MTPD::loop()+0x328>)
    7098:	ldr	r0, [pc, #752]	; (738c <MTPD::loop()+0x324>)
    709a:	bl	ef0c <Print::printf(char const*, ...)>
        int len= CONTAINER->len;
        int typ= CONTAINER->type;
        TID=id;

      uint32_t return_code = 0;
      if (receive_buffer->len >= 12) {
    709e:	ldrh	r2, [r4, #0]
      
        int op = CONTAINER->op;
        int p1 = CONTAINER->params[0];
        int p2 = CONTAINER->params[1];
        int p3 = CONTAINER->params[2];
        int id = CONTAINER->transaction_id;
    70a0:	ldr	r6, [r4, #16]
  {
    usb_packet_t *receive_buffer;
    if ((receive_buffer = usb_rx(MTP_RX_ENDPOINT))) {
      printContainer();
      
        int op = CONTAINER->op;
    70a2:	ldrh	r0, [r4, #14]
        int p1 = CONTAINER->params[0];
        int p2 = CONTAINER->params[1];
        int p3 = CONTAINER->params[2];
        int id = CONTAINER->transaction_id;
        int len= CONTAINER->len;
    70a4:	ldr	r7, [r4, #8]
        int typ= CONTAINER->type;
    70a6:	ldrh	r1, [r4, #12]
      printContainer();
      
        int op = CONTAINER->op;
        int p1 = CONTAINER->params[0];
        int p2 = CONTAINER->params[1];
        int p3 = CONTAINER->params[2];
    70a8:	add.w	r3, r4, #20
        int len= CONTAINER->len;
        int typ= CONTAINER->type;
        TID=id;

      uint32_t return_code = 0;
      if (receive_buffer->len >= 12) {
    70ac:	cmp	r2, #11
      printContainer();
      
        int op = CONTAINER->op;
        int p1 = CONTAINER->params[0];
        int p2 = CONTAINER->params[1];
        int p3 = CONTAINER->params[2];
    70ae:	ldmia.w	r3, {r3, r9, fp}
        int id = CONTAINER->transaction_id;
        int len= CONTAINER->len;
        int typ= CONTAINER->type;
        TID=id;
    70b2:	str	r6, [r5, #16]

      uint32_t return_code = 0;
      if (receive_buffer->len >= 12) {
    70b4:	bls.n	711e <MTPD::loop()+0xb6>
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
    70b6:	mov.w	sl, #12
        
        if (typ == 1) { // command
    70ba:	cmp	r1, #1
        TID=id;

      uint32_t return_code = 0;
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
    70bc:	strh.w	sl, [r4]
    usb_packet_t *receive_buffer;
    if ((receive_buffer = usb_rx(MTP_RX_ENDPOINT))) {
      printContainer();
      
        int op = CONTAINER->op;
        int p1 = CONTAINER->params[0];
    70c0:	mov	r8, r3
      uint32_t return_code = 0;
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
        
        if (typ == 1) { // command
    70c2:	beq.n	717e <MTPD::loop()+0x116>
    70c4:	mov.w	r0, #8192	; 0x2000
        } else {
          return_code = 0x2000;  // undefined
        }
      }
      if (return_code) {
        CONTAINER->type=3;
    70c8:	movs	r3, #3
        CONTAINER->len=len;
        CONTAINER->op=return_code;
    70ca:	strh	r0, [r4, #14]
          return_code = 0x2000;  // undefined
        }
      }
      if (return_code) {
        CONTAINER->type=3;
        CONTAINER->len=len;
    70cc:	str	r7, [r4, #8]
        CONTAINER->op=return_code;
        CONTAINER->transaction_id=id;
    70ce:	str	r6, [r4, #16]
        CONTAINER->params[0]=p1;
    70d0:	str.w	r8, [r4, #20]
        } else {
          return_code = 0x2000;  // undefined
        }
      }
      if (return_code) {
        CONTAINER->type=3;
    70d4:	strh	r3, [r4, #12]
        CONTAINER->params[0]=p1;
        #if DEBUG>1
          printContainer();
        #endif

        usb_tx(MTP_TX_ENDPOINT, receive_buffer);
    70d6:	mov	r1, r4
    70d8:	movs	r0, #4
    70da:	bl	e208 <usb_tx>
      } else {
          usb_free(receive_buffer);
      }
    }
    // Maybe put event handling inside mtp_yield()?
    if ((receive_buffer = usb_rx(MTP_EVENT_ENDPOINT))) {
    70de:	movs	r0, #6
    70e0:	bl	e11c <usb_rx>
    70e4:	mov	r4, r0
    70e6:	cbz	r0, 7118 <MTPD::loop()+0xb0>
      printf("Event: "); printContainer();
    70e8:	ldr	r1, [pc, #680]	; (7394 <MTPD::loop()+0x32c>)
    70ea:	ldr	r0, [pc, #672]	; (738c <MTPD::loop()+0x324>)
    70ec:	bl	ef0c <Print::printf(char const*, ...)>
    70f0:	ldr	r1, [r4, #16]
    70f2:	ldr	r3, [r4, #8]
    70f4:	ldrh	r2, [r4, #14]
    70f6:	str	r1, [sp, #4]
    70f8:	ldrh	r1, [r4, #12]
    70fa:	str	r1, [sp, #0]
    70fc:	ldr	r0, [pc, #652]	; (738c <MTPD::loop()+0x324>)
    70fe:	ldr	r1, [pc, #648]	; (7388 <MTPD::loop()+0x320>)
    7100:	bl	ef0c <Print::printf(char const*, ...)>
    7104:	ldr	r3, [r4, #8]
    7106:	cmp	r3, #12
    7108:	bhi.n	7152 <MTPD::loop()+0xea>
    710a:	ldr	r1, [pc, #644]	; (7390 <MTPD::loop()+0x328>)
    710c:	ldr	r0, [pc, #636]	; (738c <MTPD::loop()+0x324>)
    710e:	bl	ef0c <Print::printf(char const*, ...)>
      usb_free(receive_buffer);
    7112:	mov	r0, r4
    7114:	bl	e0d0 <usb_free>
    }
  }
    7118:	add	sp, #36	; 0x24
    711a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        #endif

        usb_tx(MTP_TX_ENDPOINT, receive_buffer);
        receive_buffer = 0;
      } else {
          usb_free(receive_buffer);
    711e:	mov	r0, r4
    7120:	bl	e0d0 <usb_free>
    7124:	b.n	70de <MTPD::loop()+0x76>

  void MTPD::loop(void) 
  {
    usb_packet_t *receive_buffer;
    if ((receive_buffer = usb_rx(MTP_RX_ENDPOINT))) {
      printContainer();
    7126:	ldr	r2, [r4, #20]
    7128:	ldr	r1, [pc, #620]	; (7398 <MTPD::loop()+0x330>)
    712a:	ldr	r0, [pc, #608]	; (738c <MTPD::loop()+0x324>)
    712c:	bl	ef0c <Print::printf(char const*, ...)>
    7130:	ldr	r3, [r4, #8]
    7132:	cmp	r3, #16
    7134:	bls.n	7096 <MTPD::loop()+0x2e>
    7136:	ldr	r2, [r4, #24]
    7138:	ldr	r1, [pc, #604]	; (7398 <MTPD::loop()+0x330>)
    713a:	ldr	r0, [pc, #592]	; (738c <MTPD::loop()+0x324>)
    713c:	bl	ef0c <Print::printf(char const*, ...)>
    7140:	ldr	r3, [r4, #8]
    7142:	cmp	r3, #20
    7144:	bls.n	7096 <MTPD::loop()+0x2e>
    7146:	ldr	r2, [r4, #28]
    7148:	ldr	r1, [pc, #588]	; (7398 <MTPD::loop()+0x330>)
    714a:	ldr	r0, [pc, #576]	; (738c <MTPD::loop()+0x324>)
    714c:	bl	ef0c <Print::printf(char const*, ...)>
    7150:	b.n	7096 <MTPD::loop()+0x2e>
          usb_free(receive_buffer);
      }
    }
    // Maybe put event handling inside mtp_yield()?
    if ((receive_buffer = usb_rx(MTP_EVENT_ENDPOINT))) {
      printf("Event: "); printContainer();
    7152:	ldr	r2, [r4, #20]
    7154:	ldr	r1, [pc, #576]	; (7398 <MTPD::loop()+0x330>)
    7156:	ldr	r0, [pc, #564]	; (738c <MTPD::loop()+0x324>)
    7158:	bl	ef0c <Print::printf(char const*, ...)>
    715c:	ldr	r3, [r4, #8]
    715e:	cmp	r3, #16
    7160:	bls.n	710a <MTPD::loop()+0xa2>
    7162:	ldr	r2, [r4, #24]
    7164:	ldr	r1, [pc, #560]	; (7398 <MTPD::loop()+0x330>)
    7166:	ldr	r0, [pc, #548]	; (738c <MTPD::loop()+0x324>)
    7168:	bl	ef0c <Print::printf(char const*, ...)>
    716c:	ldr	r3, [r4, #8]
    716e:	cmp	r3, #20
    7170:	bls.n	710a <MTPD::loop()+0xa2>
    7172:	ldr	r2, [r4, #28]
    7174:	ldr	r1, [pc, #544]	; (7398 <MTPD::loop()+0x330>)
    7176:	ldr	r0, [pc, #532]	; (738c <MTPD::loop()+0x324>)
    7178:	bl	ef0c <Print::printf(char const*, ...)>
    717c:	b.n	710a <MTPD::loop()+0xa2>
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
        
        if (typ == 1) { // command
          switch (op) {
    717e:	movw	r2, #4108	; 0x100c
    7182:	cmp	r0, r2
    7184:	beq.w	74c2 <MTPD::loop()+0x45a>
    7188:	bhi.n	71c6 <MTPD::loop()+0x15e>
    718a:	movw	r2, #4101	; 0x1005
    718e:	cmp	r0, r2
    7190:	beq.w	75c8 <MTPD::loop()+0x560>
    7194:	bls.n	7250 <MTPD::loop()+0x1e8>
    7196:	movw	r2, #4104	; 0x1008
    719a:	cmp	r0, r2
    719c:	beq.w	7588 <MTPD::loop()+0x520>
    71a0:	bhi.w	731c <MTPD::loop()+0x2b4>
    71a4:	movw	r2, #4102	; 0x1006
    71a8:	cmp	r0, r2
    71aa:	beq.w	7408 <MTPD::loop()+0x3a0>
    71ae:	movw	r2, #4103	; 0x1007
    71b2:	cmp	r0, r2
    71b4:	bne.w	7316 <MTPD::loop()+0x2ae>
              } else {
                p1 = GetNumObjects(p1, p3);
              }
              break;
            case 0x1007:  // GetObjectHandles
              if (p2) {
    71b8:	cmp.w	r9, #0
    71bc:	beq.w	762c <MTPD::loop()+0x5c4>
              break;
            case 0x1009:  // GetObject
              TRANSMIT(GetObject(p1));
              break;
            case 0x100B:  // DeleteObject
              if (p2) {
    71c0:	movw	r0, #8212	; 0x2014
    71c4:	b.n	70c8 <MTPD::loop()+0x60>
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
        
        if (typ == 1) { // command
          switch (op) {
    71c6:	movw	r2, #4121	; 0x1019
    71ca:	cmp	r0, r2
    71cc:	beq.w	7560 <MTPD::loop()+0x4f8>
    71d0:	bls.n	72ac <MTPD::loop()+0x244>
    71d2:	movw	r2, #38914	; 0x9802
    71d6:	cmp	r0, r2
    71d8:	beq.w	74dc <MTPD::loop()+0x474>
    71dc:	bhi.w	7352 <MTPD::loop()+0x2ea>
    71e0:	movw	r2, #4122	; 0x101a
    71e4:	cmp	r0, r2
    71e6:	beq.w	7608 <MTPD::loop()+0x5a0>
    71ea:	movw	r2, #38913	; 0x9801
    71ee:	cmp	r0, r2
    71f0:	bne.w	7316 <MTPD::loop()+0x2ae>
              if(! return_code) { len  = receive_buffer->len = 12; return_code = 0x2005; }
              else {p1 = return_code; return_code=0x2001;}
              break;

          case 0x9801:  // getObjectPropsSupported
              TRANSMIT(getObjectPropsSupported(p1));
    71f4:	movs	r2, #1
    71f6:	mov.w	r9, #0
    71fa:	mov	r1, r3
    71fc:	strb	r2, [r5, #8]
    71fe:	mov	r0, r5
    7200:	str.w	r9, [r5, #12]
    7204:	str	r3, [sp, #12]
    7206:	bl	62f0 <MTPD::getObjectPropsSupported(unsigned long)>
    720a:	ldr	r2, [r5, #12]
    720c:	strb.w	r9, [r5, #8]
    7210:	adds	r2, #12
    7212:	movs	r1, #2
    7214:	strh.w	r1, [sp, #24]
    7218:	str	r2, [sp, #20]
    721a:	ldrh	r2, [r4, #14]
    721c:	strh.w	r2, [sp, #26]
    7220:	ldr	r2, [r4, #16]
    7222:	str	r2, [sp, #28]
    7224:	add	r1, sp, #20
    7226:	mov	r0, r5
    7228:	movs	r2, #12
    722a:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    722e:	ldr	r3, [sp, #12]
    7230:	mov	r0, r5
    7232:	mov	r1, r3
    7234:	bl	62f0 <MTPD::getObjectPropsSupported(unsigned long)>
    7238:	mov	r0, r5
    723a:	bl	5b68 <MTPD::get_buffer()>
    723e:	ldr	r1, [r5, #4]
    7240:	movs	r0, #4
    7242:	bl	e208 <usb_tx>
    7246:	str.w	r9, [r5, #4]
              break;
    724a:	movw	r0, #8193	; 0x2001
    724e:	b.n	70c8 <MTPD::loop()+0x60>
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
        
        if (typ == 1) { // command
          switch (op) {
    7250:	movw	r3, #4098	; 0x1002
    7254:	cmp	r0, r3
    7256:	beq.w	73f4 <MTPD::loop()+0x38c>
    725a:	bls.w	73b0 <MTPD::loop()+0x348>
    725e:	movw	r3, #4099	; 0x1003
    7262:	cmp	r0, r3
    7264:	beq.n	724a <MTPD::loop()+0x1e2>
    7266:	movw	r3, #4100	; 0x1004
    726a:	cmp	r0, r3
    726c:	bne.n	7316 <MTPD::loop()+0x2ae>
              openSession(p1);
              break;
            case 0x1003:  // CloseSession
              break;
            case 0x1004:  // GetStorageIDs
              TRANSMIT(WriteStorageIDs());
    726e:	mov.w	r9, #0
    7272:	movs	r3, #1
    7274:	strb	r3, [r5, #8]
    7276:	mov	r0, r5
    7278:	str.w	r9, [r5, #12]
    727c:	bl	5fc4 <MTPD::WriteStorageIDs()>
    7280:	ldr	r3, [r5, #12]
    7282:	strb.w	r9, [r5, #8]
    7286:	adds	r3, #12
    7288:	movs	r2, #2
    728a:	strh.w	r2, [sp, #24]
    728e:	str	r3, [sp, #20]
    7290:	ldrh	r3, [r4, #14]
    7292:	strh.w	r3, [sp, #26]
    7296:	ldr	r3, [r4, #16]
    7298:	str	r3, [sp, #28]
    729a:	mov	r0, r5
    729c:	movs	r2, #12
    729e:	add	r1, sp, #20
    72a0:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    72a4:	mov	r0, r5
    72a6:	bl	5fc4 <MTPD::WriteStorageIDs()>
    72aa:	b.n	7238 <MTPD::loop()+0x1d0>
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
        
        if (typ == 1) { // command
          switch (op) {
    72ac:	movw	r2, #4112	; 0x1010
    72b0:	cmp	r0, r2
    72b2:	beq.n	7316 <MTPD::loop()+0x2ae>
    72b4:	bls.n	739c <MTPD::loop()+0x334>
    72b6:	movw	r2, #4116	; 0x1014
    72ba:	cmp	r0, r2
    72bc:	beq.w	7422 <MTPD::loop()+0x3ba>
    72c0:	movw	r2, #4117	; 0x1015
    72c4:	cmp	r0, r2
    72c6:	bne.n	7316 <MTPD::loop()+0x2ae>
      }
    }
  }

  void MTPD::GetDevicePropValue(uint32_t prop) {
    switch (prop) {
    72c8:	movw	r2, #54274	; 0xd402
              break;
            case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
              break;
            case 0x1015:  // GetDevicePropvalue
              TRANSMIT(GetDevicePropValue(p1));
    72cc:	mov.w	r9, #0
    72d0:	movs	r1, #1
      }
    }
  }

  void MTPD::GetDevicePropValue(uint32_t prop) {
    switch (prop) {
    72d2:	cmp	r3, r2
              break;
            case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
              break;
            case 0x1015:  // GetDevicePropvalue
              TRANSMIT(GetDevicePropValue(p1));
    72d4:	str.w	r9, [r5, #12]
    72d8:	strb	r1, [r5, #8]
      }
    }
  }

  void MTPD::GetDevicePropValue(uint32_t prop) {
    switch (prop) {
    72da:	beq.w	7672 <MTPD::loop()+0x60a>
              break;
            case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
              break;
            case 0x1015:  // GetDevicePropvalue
              TRANSMIT(GetDevicePropValue(p1));
    72de:	movs	r3, #2
    72e0:	movs	r2, #12
    72e2:	strb.w	r9, [r5, #8]
    72e6:	str	r2, [sp, #20]
    72e8:	strh.w	r3, [sp, #24]
    72ec:	ldrh	r3, [r4, #14]
    72ee:	strh.w	r3, [sp, #26]
    72f2:	ldr	r3, [r4, #16]
    72f4:	str	r3, [sp, #28]
    72f6:	add	r1, sp, #20
    72f8:	mov	r0, r5
    72fa:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    72fe:	mov	r0, r5
    7300:	bl	5b68 <MTPD::get_buffer()>
    7304:	movs	r0, #4
    7306:	ldr	r1, [r5, #4]
    7308:	bl	e208 <usb_tx>
    730c:	movs	r3, #0
    730e:	str	r3, [r5, #4]
              break;
    7310:	movw	r0, #8193	; 0x2001
    7314:	b.n	70c8 <MTPD::loop()+0x60>
              return_code = setObjectPropValue(p1,p2);
              break;
              
            default:
              return_code = 0x2005;  // operation not supported
              break;
    7316:	movw	r0, #8197	; 0x2005
    731a:	b.n	70c8 <MTPD::loop()+0x60>
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
        
        if (typ == 1) { // command
          switch (op) {
    731c:	movw	r2, #4105	; 0x1009
    7320:	cmp	r0, r2
    7322:	beq.w	7520 <MTPD::loop()+0x4b8>
    7326:	movw	r2, #4107	; 0x100b
    732a:	cmp	r0, r2
    732c:	bne.n	7316 <MTPD::loop()+0x2ae>
              break;
            case 0x1009:  // GetObject
              TRANSMIT(GetObject(p1));
              break;
            case 0x100B:  // DeleteObject
              if (p2) {
    732e:	cmp.w	r9, #0
    7332:	bne.w	71c0 <MTPD::loop()+0x158>
                return_code = 0x2014; // spec by format unsupported
              } else {
                if (!storage_->DeleteObject(p1)) {
    7336:	ldr	r0, [r5, #0]
    7338:	ldr	r2, [r0, #0]
    733a:	mov	r1, r3
    733c:	ldr	r3, [r2, #60]	; 0x3c
    733e:	blx	r3
    7340:	movw	r3, #8210	; 0x2012
    7344:	movw	r2, #8193	; 0x2001
    7348:	cmp	r0, #0
    734a:	ite	eq
    734c:	moveq	r0, r3
    734e:	movne	r0, r2
    7350:	b.n	70c8 <MTPD::loop()+0x60>
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
        
        if (typ == 1) { // command
          switch (op) {
    7352:	movw	r2, #38915	; 0x9803
    7356:	cmp	r0, r2
    7358:	beq.w	746c <MTPD::loop()+0x404>
    735c:	movw	r2, #38916	; 0x9804
    7360:	cmp	r0, r2
    7362:	bne.n	7316 <MTPD::loop()+0x2ae>
    return true;
  }
  
    uint32_t MTPD::setObjectPropValue(uint32_t p1, uint32_t p2)
    {
      receive_buffer();
    7364:	mov	r0, r5
    7366:	str	r3, [sp, #12]
    7368:	bl	6d44 <MTPD::receive_buffer()>
      if(p2==0xDC07)
    736c:	movw	r2, #56327	; 0xdc07
    7370:	cmp	r9, r2
    7372:	ldr	r3, [sp, #12]
    7374:	bne.n	7316 <MTPD::loop()+0x2ae>
    7376:	mov	r1, r3
    7378:	mov	r0, r5
    737a:	bl	6e90 <MTPD::setObjectPropValue(unsigned long, unsigned long) [clone .part.6]>
          }
        } else {
          return_code = 0x2000;  // undefined
        }
      }
      if (return_code) {
    737e:	cmp	r0, #0
    7380:	beq.w	711e <MTPD::loop()+0xb6>
    7384:	uxth	r0, r0
    7386:	b.n	70c8 <MTPD::loop()+0x60>
    7388:	.word	0x0001448c
    738c:	.word	0x1fff0ad0
    7390:	.word	0x000144a0
    7394:	.word	0x000144a4
    7398:	.word	0x0001449c
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
        
        if (typ == 1) { // command
          switch (op) {
    739c:	movw	r3, #4109	; 0x100d
    73a0:	cmp	r0, r3
    73a2:	bne.n	7316 <MTPD::loop()+0x2ae>
              CONTAINER->params[1]=p2;
              CONTAINER->params[2]=p3;
              len = receive_buffer->len = 12 + 3 * 4;
              break;
            case 0x100D:  // SendObject
              SendObject();
    73a4:	mov	r0, r5
    73a6:	bl	6ff0 <MTPD::SendObject()>
              break;
    73aa:	movw	r0, #8193	; 0x2001
    73ae:	b.n	70c8 <MTPD::loop()+0x60>
      if (receive_buffer->len >= 12) {
        return_code = 0x2001;  // Ok
        receive_buffer->len = 12;
        
        if (typ == 1) { // command
          switch (op) {
    73b0:	movw	r3, #4097	; 0x1001
    73b4:	cmp	r0, r3
    73b6:	bne.n	7316 <MTPD::loop()+0x2ae>
            case 0x1001: // GetDescription
              TRANSMIT(WriteDescriptor());
    73b8:	mov.w	r9, #0
    73bc:	strb	r1, [r5, #8]
    73be:	mov	r0, r5
    73c0:	str.w	r9, [r5, #12]
    73c4:	bl	5d48 <MTPD::WriteDescriptor()>
    73c8:	ldr	r3, [r5, #12]
    73ca:	strb.w	r9, [r5, #8]
    73ce:	adds	r3, #12
    73d0:	movs	r2, #2
    73d2:	strh.w	r2, [sp, #24]
    73d6:	str	r3, [sp, #20]
    73d8:	ldrh	r3, [r4, #14]
    73da:	strh.w	r3, [sp, #26]
    73de:	ldr	r3, [r4, #16]
    73e0:	str	r3, [sp, #28]
    73e2:	mov	r0, r5
    73e4:	mov	r2, sl
    73e6:	add	r1, sp, #20
    73e8:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    73ec:	mov	r0, r5
    73ee:	bl	5d48 <MTPD::WriteDescriptor()>
    73f2:	b.n	7238 <MTPD::loop()+0x1d0>
    }
    
    void MTPD::openSession(uint32_t id)
    {
      sessionID_ = id;
      storage_->ResetIndex();
    73f4:	ldr	r0, [r5, #0]
      return storage_->copy(handle,store1,newHandle);
    }
    
    void MTPD::openSession(uint32_t id)
    {
      sessionID_ = id;
    73f6:	ldr	r2, [pc, #736]	; (76d8 <MTPD::loop()+0x670>)
      storage_->ResetIndex();
    73f8:	ldr	r3, [r0, #0]
      return storage_->copy(handle,store1,newHandle);
    }
    
    void MTPD::openSession(uint32_t id)
    {
      sessionID_ = id;
    73fa:	str.w	r8, [r2]
      storage_->ResetIndex();
    73fe:	ldr	r3, [r3, #68]	; 0x44
    7400:	blx	r3
    7402:	movw	r0, #8193	; 0x2001
    7406:	b.n	70c8 <MTPD::loop()+0x60>
              break;
            case 0x1005:  // GetStorageInfo
              TRANSMIT(GetStorageInfo(p1));
              break;
            case 0x1006:  // GetNumObjects
              if (p2) {
    7408:	cmp.w	r9, #0
    740c:	bne.w	71c0 <MTPD::loop()+0x158>
                return_code = 0x2014; // spec by format unsupported
              } else {
                p1 = GetNumObjects(p1, p3);
    7410:	mov	r2, fp
    7412:	mov	r1, r3
    7414:	mov	r0, r5
    7416:	bl	5b40 <MTPD::GetNumObjects(unsigned long, unsigned long)>
    741a:	mov	r8, r0
    741c:	movw	r0, #8193	; 0x2001
    7420:	b.n	70c8 <MTPD::loop()+0x60>
        break;
    }
  }

  void MTPD::GetDevicePropDesc(uint32_t prop) {
    switch (prop) {
    7422:	movw	r2, #54274	; 0xd402
              break;
            case 0x100D:  // SendObject
              SendObject();
              break;
            case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
    7426:	movs	r0, #0
        break;
    }
  }

  void MTPD::GetDevicePropDesc(uint32_t prop) {
    switch (prop) {
    7428:	cmp	r3, r2
              break;
            case 0x100D:  // SendObject
              SendObject();
              break;
            case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
    742a:	strb	r1, [r5, #8]
    742c:	str	r0, [r5, #12]
        break;
    }
  }

  void MTPD::GetDevicePropDesc(uint32_t prop) {
    switch (prop) {
    742e:	beq.w	76a8 <MTPD::loop()+0x640>
              break;
            case 0x100D:  // SendObject
              SendObject();
              break;
            case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
    7432:	movs	r2, #12
    7434:	movs	r0, #0
    7436:	movs	r1, #2
    7438:	strb	r0, [r5, #8]
    743a:	str	r2, [sp, #20]
    743c:	strh.w	r1, [sp, #24]
    7440:	ldrh	r1, [r4, #14]
    7442:	strh.w	r1, [sp, #26]
    7446:	ldr	r1, [r4, #16]
    7448:	str	r1, [sp, #28]
    744a:	mov	r0, r5
    744c:	add	r1, sp, #20
    744e:	str	r3, [sp, #12]
    7450:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
        break;
    }
  }

  void MTPD::GetDevicePropDesc(uint32_t prop) {
    switch (prop) {
    7454:	ldr	r3, [sp, #12]
    7456:	movw	r2, #54274	; 0xd402
    745a:	cmp	r3, r2
    745c:	bne.w	72fe <MTPD::loop()+0x296>
    7460:	movw	r1, #54274	; 0xd402
    7464:	mov	r0, r5
    7466:	bl	5c8c <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]>
    746a:	b.n	72fe <MTPD::loop()+0x296>
          case 0x9802:  // getObjectPropDesc
            TRANSMIT(getObjectPropDesc(p1,p2));
              break;

          case 0x9803:  // getObjectPropertyValue
            TRANSMIT(getObjectPropValue(p1,p2));
    746c:	mov.w	fp, #0
    7470:	strb	r1, [r5, #8]
    7472:	mov	r2, r9
    7474:	mov	r1, r3
    7476:	mov	r0, r5
    7478:	str.w	fp, [r5, #12]
    747c:	bl	635c <MTPD::getObjectPropValue(unsigned long, unsigned long)>
    7480:	ldr	r3, [r5, #12]
    7482:	strb.w	fp, [r5, #8]
    7486:	adds	r3, #12
    7488:	movs	r2, #2
    748a:	strh.w	r2, [sp, #24]
    748e:	str	r3, [sp, #20]
    7490:	ldrh	r3, [r4, #14]
    7492:	strh.w	r3, [sp, #26]
    7496:	mov	r2, sl
    7498:	ldr	r3, [r4, #16]
    749a:	str	r3, [sp, #28]
    749c:	add	r1, sp, #20
    749e:	mov	r0, r5
    74a0:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    74a4:	mov	r2, r9
    74a6:	mov	r1, r8
    74a8:	mov	r0, r5
    74aa:	bl	635c <MTPD::getObjectPropValue(unsigned long, unsigned long)>
    74ae:	mov	r0, r5
    74b0:	bl	5b68 <MTPD::get_buffer()>
    74b4:	ldr	r1, [r5, #4]
    74b6:	movs	r0, #4
    74b8:	bl	e208 <usb_tx>
    74bc:	str.w	fp, [r5, #4]
    74c0:	b.n	724a <MTPD::loop()+0x1e2>
                  return_code = 0x2012; // partial deletion
                }
              }
              break;
            case 0x100C:  // SendObjectInfo
              p3 =  SendObjectInfo(p1, // storage
    74c2:	mov	r0, r5
    74c4:	mov	r2, r9
    74c6:	mov	r1, r3
    74c8:	bl	6ebc <MTPD::SendObjectInfo(unsigned long, unsigned long)>
                                   p2); // parent
              CONTAINER->params[1]=p2;
              CONTAINER->params[2]=p3;
              len = receive_buffer->len = 12 + 3 * 4;
    74cc:	movs	r7, #24
              break;
            case 0x100C:  // SendObjectInfo
              p3 =  SendObjectInfo(p1, // storage
                                   p2); // parent
              CONTAINER->params[1]=p2;
              CONTAINER->params[2]=p3;
    74ce:	str	r0, [r4, #28]
              }
              break;
            case 0x100C:  // SendObjectInfo
              p3 =  SendObjectInfo(p1, // storage
                                   p2); // parent
              CONTAINER->params[1]=p2;
    74d0:	str.w	r9, [r4, #24]
              CONTAINER->params[2]=p3;
              len = receive_buffer->len = 12 + 3 * 4;
    74d4:	strh	r7, [r4, #0]
              break;
    74d6:	movw	r0, #8193	; 0x2001
    74da:	b.n	70c8 <MTPD::loop()+0x60>
          case 0x9801:  // getObjectPropsSupported
              TRANSMIT(getObjectPropsSupported(p1));
              break;

          case 0x9802:  // getObjectPropDesc
            TRANSMIT(getObjectPropDesc(p1,p2));
    74dc:	mov.w	fp, #0
    74e0:	strb	r1, [r5, #8]
    74e2:	mov	r2, r9
    74e4:	mov	r1, r3
    74e6:	mov	r0, r5
    74e8:	str.w	fp, [r5, #12]
    74ec:	bl	665c <MTPD::getObjectPropDesc(unsigned long, unsigned long)>
    74f0:	ldr	r3, [r5, #12]
    74f2:	strb.w	fp, [r5, #8]
    74f6:	adds	r3, #12
    74f8:	movs	r2, #2
    74fa:	strh.w	r2, [sp, #24]
    74fe:	str	r3, [sp, #20]
    7500:	ldrh	r3, [r4, #14]
    7502:	strh.w	r3, [sp, #26]
    7506:	mov	r2, sl
    7508:	ldr	r3, [r4, #16]
    750a:	str	r3, [sp, #28]
    750c:	add	r1, sp, #20
    750e:	mov	r0, r5
    7510:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    7514:	mov	r2, r9
    7516:	mov	r1, r8
    7518:	mov	r0, r5
    751a:	bl	665c <MTPD::getObjectPropDesc(unsigned long, unsigned long)>
    751e:	b.n	74ae <MTPD::loop()+0x446>
              break;
            case 0x1008:  // GetObjectInfo
              TRANSMIT(GetObjectInfo(p1));
              break;
            case 0x1009:  // GetObject
              TRANSMIT(GetObject(p1));
    7520:	mov.w	r9, #0
    7524:	strb	r1, [r5, #8]
    7526:	mov	r0, r5
    7528:	mov	r1, r3
    752a:	str.w	r9, [r5, #12]
    752e:	bl	6d60 <MTPD::GetObject(unsigned long)>
    7532:	ldr	r3, [r5, #12]
    7534:	strb.w	r9, [r5, #8]
    7538:	adds	r3, #12
    753a:	movs	r2, #2
    753c:	strh.w	r2, [sp, #24]
    7540:	str	r3, [sp, #20]
    7542:	ldrh	r3, [r4, #14]
    7544:	strh.w	r3, [sp, #26]
    7548:	ldr	r3, [r4, #16]
    754a:	str	r3, [sp, #28]
    754c:	add	r1, sp, #20
    754e:	mov	r0, r5
    7550:	mov	r2, sl
    7552:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    7556:	mov	r1, r8
    7558:	mov	r0, r5
    755a:	bl	6d60 <MTPD::GetObject(unsigned long)>
    755e:	b.n	7238 <MTPD::loop()+0x1d0>
        return 0x2001;
    }

    uint32_t MTPD::moveObject(uint32_t handle, uint32_t newStorage, uint32_t newHandle)
    { uint32_t store1=Storage2Store(newStorage);
      if(storage_->move(handle,store1,newHandle)) return 0x2001; else return  0x2005;
    7560:	ldr	r0, [r5, #0]
    7562:	ldr	r1, [r0, #0]
    7564:	mov	r3, fp
    7566:	add.w	r2, r9, #4294967295
    756a:	ldr	r5, [r1, #76]	; 0x4c
    756c:	mov	r1, r8
    756e:	blx	r5
    7570:	movw	r3, #8197	; 0x2005
    7574:	movw	r2, #8193	; 0x2001
              return_code = 0x2005;
              break;

          case 0x1019:  // MoveObject
              return_code = moveObject(p1,p2,p3);
              len  = receive_buffer->len = 12;
    7578:	strh.w	sl, [r4]
              break;
    757c:	mov	r7, sl
        return 0x2001;
    }

    uint32_t MTPD::moveObject(uint32_t handle, uint32_t newStorage, uint32_t newHandle)
    { uint32_t store1=Storage2Store(newStorage);
      if(storage_->move(handle,store1,newHandle)) return 0x2001; else return  0x2005;
    757e:	cmp	r0, #0
    7580:	ite	eq
    7582:	moveq	r0, r3
    7584:	movne	r0, r2
              break;

          case 0x1019:  // MoveObject
              return_code = moveObject(p1,p2,p3);
              len  = receive_buffer->len = 12;
              break;
    7586:	b.n	70c8 <MTPD::loop()+0x60>
              } else {
                TRANSMIT(GetObjectHandles(p1, p3));
              }
              break;
            case 0x1008:  // GetObjectInfo
              TRANSMIT(GetObjectInfo(p1));
    7588:	mov.w	r9, #0
    758c:	strb	r1, [r5, #8]
    758e:	mov	r0, r5
    7590:	mov	r1, r3
    7592:	str.w	r9, [r5, #12]
    7596:	bl	609c <MTPD::GetObjectInfo(unsigned long)>
    759a:	ldr	r3, [r5, #12]
    759c:	strb.w	r9, [r5, #8]
    75a0:	adds	r3, #12
    75a2:	movs	r2, #2
    75a4:	strh.w	r2, [sp, #24]
    75a8:	str	r3, [sp, #20]
    75aa:	ldrh	r3, [r4, #14]
    75ac:	strh.w	r3, [sp, #26]
    75b0:	ldr	r3, [r4, #16]
    75b2:	str	r3, [sp, #28]
    75b4:	add	r1, sp, #20
    75b6:	mov	r0, r5
    75b8:	mov	r2, sl
    75ba:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    75be:	mov	r1, r8
    75c0:	mov	r0, r5
    75c2:	bl	609c <MTPD::GetObjectInfo(unsigned long)>
    75c6:	b.n	7238 <MTPD::loop()+0x1d0>
              break;
            case 0x1004:  // GetStorageIDs
              TRANSMIT(WriteStorageIDs());
              break;
            case 0x1005:  // GetStorageInfo
              TRANSMIT(GetStorageInfo(p1));
    75c8:	mov.w	r9, #0
    75cc:	strb	r1, [r5, #8]
    75ce:	mov	r0, r5
    75d0:	mov	r1, r3
    75d2:	str.w	r9, [r5, #12]
    75d6:	bl	6518 <MTPD::GetStorageInfo(unsigned long)>
    75da:	ldr	r3, [r5, #12]
    75dc:	strb.w	r9, [r5, #8]
    75e0:	adds	r3, #12
    75e2:	movs	r2, #2
    75e4:	strh.w	r2, [sp, #24]
    75e8:	str	r3, [sp, #20]
    75ea:	ldrh	r3, [r4, #14]
    75ec:	strh.w	r3, [sp, #26]
    75f0:	ldr	r3, [r4, #16]
    75f2:	str	r3, [sp, #28]
    75f4:	add	r1, sp, #20
    75f6:	mov	r0, r5
    75f8:	mov	r2, sl
    75fa:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    75fe:	mov	r1, r8
    7600:	mov	r0, r5
    7602:	bl	6518 <MTPD::GetStorageInfo(unsigned long)>
    7606:	b.n	7238 <MTPD::loop()+0x1d0>
      if(storage_->move(handle,store1,newHandle)) return 0x2001; else return  0x2005;
    }
    
    uint32_t MTPD::copyObject(uint32_t handle, uint32_t newStorage, uint32_t newHandle)
    { uint32_t store1=Storage2Store(newStorage);
      return storage_->copy(handle,store1,newHandle);
    7608:	ldr	r0, [r5, #0]
    760a:	ldr	r1, [r0, #0]
    760c:	mov	r3, fp
    760e:	ldr	r5, [r1, #80]	; 0x50
    7610:	add.w	r2, r9, #4294967295
    7614:	mov	r1, r8
    7616:	blx	r5
              len  = receive_buffer->len = 12;
              break;

          case 0x101A:  // CopyObject
              return_code = copyObject(p1,p2,p3);
              if(! return_code) { len  = receive_buffer->len = 12; return_code = 0x2005; }
    7618:	cbnz	r0, 7624 <MTPD::loop()+0x5bc>
    761a:	movs	r7, #12
    761c:	strh	r7, [r4, #0]
    761e:	movw	r0, #8197	; 0x2005
    7622:	b.n	70c8 <MTPD::loop()+0x60>
              else {p1 = return_code; return_code=0x2001;}
    7624:	mov	r8, r0
    7626:	movw	r0, #8193	; 0x2001
    762a:	b.n	70c8 <MTPD::loop()+0x60>
              break;
            case 0x1007:  // GetObjectHandles
              if (p2) {
                return_code = 0x2014; // spec by format unsupported
              } else {
                TRANSMIT(GetObjectHandles(p1, p3));
    762c:	movs	r2, #1
    762e:	mov	r1, r3
    7630:	strb	r2, [r5, #8]
    7632:	mov	r0, r5
    7634:	mov	r2, fp
    7636:	str.w	r9, [r5, #12]
    763a:	str	r3, [sp, #12]
    763c:	bl	602c <MTPD::GetObjectHandles(unsigned long, unsigned long)>
    7640:	ldr	r2, [r5, #12]
    7642:	strb.w	r9, [r5, #8]
    7646:	adds	r2, #12
    7648:	movs	r1, #2
    764a:	strh.w	r1, [sp, #24]
    764e:	str	r2, [sp, #20]
    7650:	ldrh	r2, [r4, #14]
    7652:	strh.w	r2, [sp, #26]
    7656:	ldr	r2, [r4, #16]
    7658:	str	r2, [sp, #28]
    765a:	add	r1, sp, #20
    765c:	mov	r0, r5
    765e:	movs	r2, #12
    7660:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    7664:	ldr	r3, [sp, #12]
    7666:	mov	r2, fp
    7668:	mov	r1, r3
    766a:	mov	r0, r5
    766c:	bl	602c <MTPD::GetObjectHandles(unsigned long, unsigned long)>
    7670:	b.n	7238 <MTPD::loop()+0x1d0>
  void MTPD::GetDevicePropValue(uint32_t prop) {
    switch (prop) {
      case 0xd402: // friendly name
        // This is the name we'll actually see in the windows explorer.
        // Should probably be configurable.
        writestring(MTP_NAME);
    7672:	mov	r0, r5
    7674:	ldr	r1, [pc, #100]	; (76dc <MTPD::loop()+0x674>)
    7676:	bl	5be4 <MTPD::writestring(char const*)>
              break;
            case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
              break;
            case 0x1015:  // GetDevicePropvalue
              TRANSMIT(GetDevicePropValue(p1));
    767a:	ldr	r3, [r5, #12]
    767c:	strb.w	r9, [r5, #8]
    7680:	adds	r3, #12
    7682:	movs	r2, #2
    7684:	strh.w	r2, [sp, #24]
    7688:	str	r3, [sp, #20]
    768a:	ldrh	r3, [r4, #14]
    768c:	strh.w	r3, [sp, #26]
    7690:	ldr	r3, [r4, #16]
    7692:	str	r3, [sp, #28]
    7694:	add	r1, sp, #20
    7696:	mov	r0, r5
    7698:	movs	r2, #12
    769a:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
  void MTPD::GetDevicePropValue(uint32_t prop) {
    switch (prop) {
      case 0xd402: // friendly name
        // This is the name we'll actually see in the windows explorer.
        // Should probably be configurable.
        writestring(MTP_NAME);
    769e:	ldr	r1, [pc, #60]	; (76dc <MTPD::loop()+0x674>)
    76a0:	mov	r0, r5
    76a2:	bl	5be4 <MTPD::writestring(char const*)>
    76a6:	b.n	72fe <MTPD::loop()+0x296>
    76a8:	mov	r1, r2
    76aa:	mov	r0, r5
    76ac:	bl	5c8c <MTPD::GetDevicePropDesc(unsigned long) [clone .part.4]>
              break;
            case 0x100D:  // SendObject
              SendObject();
              break;
            case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
    76b0:	ldr	r3, [r5, #12]
    76b2:	movs	r1, #0
    76b4:	adds	r3, #12
    76b6:	movs	r2, #2
    76b8:	strb	r1, [r5, #8]
    76ba:	strh.w	r2, [sp, #24]
    76be:	str	r3, [sp, #20]
    76c0:	ldrh	r3, [r4, #14]
    76c2:	strh.w	r3, [sp, #26]
    76c6:	ldr	r3, [r4, #16]
    76c8:	str	r3, [sp, #28]
    76ca:	movs	r2, #12
    76cc:	add	r1, sp, #20
    76ce:	mov	r0, r5
    76d0:	bl	5b80 <MTPD::write(char const*, int) [clone .part.2]>
    76d4:	b.n	7460 <MTPD::loop()+0x3f8>
    76d6:	nop
    76d8:	.word	0x1fff6160
    76dc:	.word	0x0001445c

000076e0 <usb_init_events>:
  extern "C"
  {
    usb_packet_t *tx_event_packet=NULL;

    int usb_init_events(void)
    {
    76e0:	push	{r3, lr}
      tx_event_packet = usb_malloc();
    76e2:	bl	e090 <usb_malloc>
    76e6:	ldr	r2, [pc, #12]	; (76f4 <usb_init_events+0x14>)
    76e8:	mov	r3, r0
      if(tx_event_packet) return 1; else return 0; 
    }
    76ea:	adds	r0, #0
    76ec:	it	ne
    76ee:	movne	r0, #1
  {
    usb_packet_t *tx_event_packet=NULL;

    int usb_init_events(void)
    {
      tx_event_packet = usb_malloc();
    76f0:	str	r3, [r2, #0]
      if(tx_event_packet) return 1; else return 0; 
    }
    76f2:	pop	{r3, pc}
    76f4:	.word	0x1fff6164

000076f8 <usb_mtp_sendEvent>:


    int usb_mtp_sendEvent(const void *buffer, uint32_t len, uint32_t timeout)
    {
    76f8:	push	{r3, r4, r5, lr}
      if (!usb_configuration) return -1;
    76fa:	ldr	r3, [pc, #44]	; (7728 <usb_mtp_sendEvent+0x30>)
    76fc:	ldrb	r3, [r3, #0]
    76fe:	cbz	r3, 7720 <usb_mtp_sendEvent+0x28>
      memcpy(tx_event_packet->buf, buffer, len);
    7700:	ldr	r3, [pc, #40]	; (772c <usb_mtp_sendEvent+0x34>)
    7702:	ldr	r5, [r3, #0]
    7704:	mov	r4, r1
    7706:	mov	r2, r4
    7708:	mov	r1, r0
    770a:	add.w	r0, r5, #8
    770e:	bl	d444 <memcpy>
      tx_event_packet->len = len;
    7712:	strh	r4, [r5, #0]
      usb_tx(MTP_EVENT_ENDPOINT, tx_event_packet);
    7714:	mov	r1, r5
    7716:	movs	r0, #6
    7718:	bl	e208 <usb_tx>
      return len;
    771c:	mov	r0, r4
    771e:	pop	{r3, r4, r5, pc}
    }


    int usb_mtp_sendEvent(const void *buffer, uint32_t len, uint32_t timeout)
    {
      if (!usb_configuration) return -1;
    7720:	mov.w	r0, #4294967295
      memcpy(tx_event_packet->buf, buffer, len);
      tx_event_packet->len = len;
      usb_tx(MTP_EVENT_ENDPOINT, tx_event_packet);
      return len;
    }
    7724:	pop	{r3, r4, r5, pc}
    7726:	nop
    7728:	.word	0x1fff67b4
    772c:	.word	0x1fff6164

00007730 <MTPD::send_Event(unsigned short)>:

  #endif
  const uint32_t EVENT_TIMEOUT=60;

  int MTPD::send_Event(uint16_t eventCode)
  {
    7730:	push	{r4, r5, lr}
    7732:	sub	sp, #36	; 0x24
    MTPContainer event;
    event.len = 12;
    event.op =eventCode ;
    event.type = MTP_CONTAINER_TYPE_EVENT; 
    event.transaction_id=TID;
    7734:	ldr	r3, [r0, #16]

  int MTPD::send_Event(uint16_t eventCode)
  {
    MTPContainer event;
    event.len = 12;
    event.op =eventCode ;
    7736:	strh.w	r1, [sp, #6]
  const uint32_t EVENT_TIMEOUT=60;

  int MTPD::send_Event(uint16_t eventCode)
  {
    MTPContainer event;
    event.len = 12;
    773a:	movs	r4, #12
    event.op =eventCode ;
    event.type = MTP_CONTAINER_TYPE_EVENT; 
    event.transaction_id=TID;
    773c:	str	r3, [sp, #8]
    event.params[0]=0;
    event.params[1]=0;
    event.params[2]=0;
    return usb_mtp_sendEvent((const void *) &event, event.len, EVENT_TIMEOUT);
    773e:	mov	r1, r4
    MTPContainer event;
    event.len = 12;
    event.op =eventCode ;
    event.type = MTP_CONTAINER_TYPE_EVENT; 
    event.transaction_id=TID;
    event.params[0]=0;
    7740:	movs	r3, #0
  int MTPD::send_Event(uint16_t eventCode)
  {
    MTPContainer event;
    event.len = 12;
    event.op =eventCode ;
    event.type = MTP_CONTAINER_TYPE_EVENT; 
    7742:	movs	r5, #4
    event.transaction_id=TID;
    event.params[0]=0;
    event.params[1]=0;
    event.params[2]=0;
    return usb_mtp_sendEvent((const void *) &event, event.len, EVENT_TIMEOUT);
    7744:	movs	r2, #60	; 0x3c
    7746:	mov	r0, sp
  const uint32_t EVENT_TIMEOUT=60;

  int MTPD::send_Event(uint16_t eventCode)
  {
    MTPContainer event;
    event.len = 12;
    7748:	str	r4, [sp, #0]
    event.op =eventCode ;
    event.type = MTP_CONTAINER_TYPE_EVENT; 
    774a:	strh.w	r5, [sp, #4]
    event.transaction_id=TID;
    event.params[0]=0;
    774e:	str	r3, [sp, #12]
    event.params[1]=0;
    7750:	str	r3, [sp, #16]
    event.params[2]=0;
    7752:	str	r3, [sp, #20]
    return usb_mtp_sendEvent((const void *) &event, event.len, EVENT_TIMEOUT);
    7754:	bl	76f8 <usb_mtp_sendEvent>
  }
    7758:	add	sp, #36	; 0x24
    775a:	pop	{r4, r5, pc}

0000775c <MTPD::send_DeviceResetEvent()>:
    event.params[2]=p3;
    return usb_mtp_sendEvent((const void *) &event, event.len, EVENT_TIMEOUT);
  }

  int MTPD::send_DeviceResetEvent(void) 
  { return send_Event(MTP_EVENT_DEVICE_RESET); } 
    775c:	movw	r1, #16395	; 0x400b
    7760:	b.w	7730 <MTPD::send_Event(unsigned short)>

00007764 <EventResponder::triggerEvent(int, void*)>:
	}

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
    7764:	push	{r4}
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
    7766:	ldrb	r4, [r0, #28]

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
    7768:	str	r1, [r0, #4]
		_data = data;
		if (_type == EventTypeImmediate) {
    776a:	cmp	r4, #2
	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
    776c:	str	r2, [r0, #12]
		if (_type == EventTypeImmediate) {
    776e:	beq.n	7778 <EventResponder::triggerEvent(int, void*)+0x14>
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
		}
	}
    7770:	ldr.w	r4, [sp], #4
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
    7774:	b.w	edb0 <EventResponder::triggerEventNotImmediate()>
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    7778:	ldr	r3, [r0, #8]
		} else {
			triggerEventNotImmediate();
		}
	}
    777a:	ldr.w	r4, [sp], #4
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    777e:	bx	r3

00007780 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]>:
			}
		}
	}
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
    7780:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7784:	ldr	r4, [r0, #0]
{

	if (count == 0) return;
	if (!(port().CTAR0 & SPI_CTAR_LSBFE)) {
    7786:	ldr	r5, [r4, #12]
    7788:	tst.w	r5, #16777216	; 0x1000000
		const uint8_t *p_write = (const uint8_t *)buf;
		uint8_t *p_read = (uint8_t *)retbuf;
		size_t count_read = count;

		// Lets clear the reader queue
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);
    778c:	ldr	r5, [pc, #484]	; (7974 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1f4>)
    778e:	str	r5, [r4, #0]

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{

	if (count == 0) return;
	if (!(port().CTAR0 & SPI_CTAR_LSBFE)) {
    7790:	bne.n	7838 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xb8>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    7792:	lsls	r7, r3, #31
    7794:	bpl.w	78fe <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x17e>
		    if (p_write) {
    7798:	cmp	r1, #0
    779a:	beq.w	7964 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1e4>
				if (count > 1)
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    779e:	ldrb	r5, [r1, #0]
		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
		    if (p_write) {
				if (count > 1)
    77a0:	cmp	r3, #1
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    77a2:	it	ne
    77a4:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
    77a8:	str	r5, [r4, #52]	; 0x34
    77aa:	adds	r1, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    77ac:	ldrb.w	r8, [r0, #36]	; 0x24
				if (count > 1)
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
    77b0:	add.w	ip, r3, #4294967295
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    77b4:	orr.w	r8, r8, r8, lsl #8

		while (count > 0) {
    77b8:	cmp.w	ip, #0
    77bc:	beq.w	7910 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x190>
			// Push out the next byte; 
		    if (p_write) {
    77c0:	cbz	r1, 77cc <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x4c>
		    	w = (*p_write++) << 8;
				w |= *p_write++;
    77c2:	ldrb	r5, [r1, #1]
	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;

		while (count > 0) {
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
    77c4:	ldrb.w	r8, [r1], #2
				w |= *p_write++;
    77c8:	orr.w	r8, r5, r8, lsl #8
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    77cc:	ldr	r5, [r0, #4]
    77ce:	ldrb	r6, [r5, #8]
			if (count == 2)
    77d0:	cmp.w	ip, #2
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
				w |= *p_write++;
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    77d4:	add.w	r6, r6, #4294967295
    77d8:	mov.w	r6, r6, lsl #12
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
    77dc:	ite	eq
    77de:	orreq.w	r5, r8, #268435456	; 0x10000000
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    77e2:	orrne.w	r5, r8, #2415919104	; 0x90000000
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
				w |= *p_write++;
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    77e6:	uxth	r6, r6
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    77e8:	str	r5, [r4, #52]	; 0x34
			count -= 2; // how many bytes to output.
    77ea:	sub.w	ip, ip, #2
    77ee:	b.n	7802 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x82>
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
						if (p_read) {
    77f0:	cbz	r2, 77f6 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x76>
							*p_read++ = w;  // Read any pending RX bytes in
    77f2:	strb	r4, [r2, #0]
    77f4:	adds	r2, #1
						} 
						count_read--;
    77f6:	subs	r3, #1
							*p_read++ = (w & 0xff);
						}
						count_read -= 2;
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    77f8:	and.w	r5, r5, #61440	; 0xf000
    77fc:	cmp	r5, r6
    77fe:	bls.n	782e <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xae>
    7800:	ldr	r4, [r0, #0]
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
    7802:	ldr	r5, [r4, #44]	; 0x2c
				if (sr & 0xF0)  {
    7804:	tst.w	r5, #240	; 0xf0
    7808:	beq.n	77f8 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x78>
					uint16_t w = port().POPR;  // Read any pending RX bytes in
    780a:	ldr	r4, [r4, #56]	; 0x38
					if (count_read & 1) {
    780c:	tst.w	r3, #1
							*p_read++ = w;  // Read any pending RX bytes in
						} 
						count_read--;
					} else {
						if (p_read) {
							*p_read++ = w >> 8;
    7810:	mov	r7, r2
    7812:	mov.w	lr, r4, asr #8
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
    7816:	bne.n	77f0 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x70>
						if (p_read) {
							*p_read++ = w;  // Read any pending RX bytes in
						} 
						count_read--;
					} else {
						if (p_read) {
    7818:	cbz	r2, 7822 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xa2>
							*p_read++ = w >> 8;
    781a:	strb.w	lr, [r7], #2
							*p_read++ = (w & 0xff);
    781e:	strb	r4, [r2, #1]
    7820:	mov	r2, r7
						}
						count_read -= 2;
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    7822:	and.w	r5, r5, #61440	; 0xf000
    7826:	cmp	r5, r6
					} else {
						if (p_read) {
							*p_read++ = w >> 8;
							*p_read++ = (w & 0xff);
						}
						count_read -= 2;
    7828:	sub.w	r3, r3, #2
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    782c:	bhi.n	7800 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x80>
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;

		while (count > 0) {
    782e:	cmp.w	ip, #0
    7832:	beq.n	7910 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x190>
    7834:	ldr	r4, [r0, #0]
    7836:	b.n	77c0 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x40>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    7838:	lsls	r5, r3, #31
    783a:	bpl.n	78d6 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x156>
		    if (p_write) {
    783c:	cmp	r1, #0
    783e:	beq.w	7954 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1d4>
				if (count > 1)
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    7842:	ldrb	r5, [r1, #0]
		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
		    if (p_write) {
				if (count > 1)
    7844:	cmp	r3, #1
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    7846:	it	ne
    7848:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
    784c:	str	r5, [r4, #52]	; 0x34
    784e:	adds	r1, #1
				if (count > 1)
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
    7850:	add.w	lr, r3, #4294967295
		}

	    uint16_t w = _transferWriteFill;
    7854:	ldrb.w	ip, [r0, #36]	; 0x24

		while (count > 0) {
    7858:	cmp.w	lr, #0
    785c:	beq.n	78e2 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x162>
			// Push out the next byte; 
		    if (p_write) {
    785e:	cbz	r1, 786c <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xec>
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
    7860:	ldrb.w	ip, [r1, #1]
    7864:	ldrb	r5, [r1, #0]
    7866:	adds	r1, #2
    7868:	orr.w	ip, r5, ip, lsl #8
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    786c:	ldr	r5, [r0, #4]
    786e:	ldrb	r6, [r5, #8]
			if (count == 2)
    7870:	cmp.w	lr, #2
			// Push out the next byte; 
		    if (p_write) {
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    7874:	add.w	r6, r6, #4294967295
    7878:	mov.w	r6, r6, lsl #12
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
    787c:	ite	eq
    787e:	orreq.w	r5, ip, #268435456	; 0x10000000
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    7882:	orrne.w	r5, ip, #2415919104	; 0x90000000
			// Push out the next byte; 
		    if (p_write) {
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    7886:	uxth	r6, r6
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    7888:	str	r5, [r4, #52]	; 0x34
			count -= 2; // how many bytes to output.
    788a:	sub.w	lr, lr, #2
    788e:	b.n	78a2 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x122>
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
						if (p_read) {
    7890:	cbz	r2, 7896 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x116>
							*p_read++ = w;  // Read any pending RX bytes in
    7892:	strb	r4, [r2, #0]
    7894:	adds	r2, #1
						} 
						count_read--;
    7896:	subs	r3, #1
							*p_read++ = w >> 8;
						}
						count_read -= 2;
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    7898:	and.w	r5, r5, #61440	; 0xf000
    789c:	cmp	r5, r6
    789e:	bls.n	78cc <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x14c>
    78a0:	ldr	r4, [r0, #0]
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
    78a2:	ldr	r5, [r4, #44]	; 0x2c
				if (sr & 0xF0)  {
    78a4:	tst.w	r5, #240	; 0xf0
    78a8:	beq.n	7898 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x118>
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
    78aa:	tst.w	r3, #1
							*p_read++ = w;  // Read any pending RX bytes in
						} 
						count_read--;
					} else {
						if (p_read) {
							*p_read++ = (w & 0xff);
    78ae:	mov	r7, r2
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
    78b0:	ldr	r4, [r4, #56]	; 0x38
					if (count_read & 1) {
    78b2:	bne.n	7890 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x110>
						if (p_read) {
							*p_read++ = w;  // Read any pending RX bytes in
						} 
						count_read--;
					} else {
						if (p_read) {
    78b4:	cbz	r2, 78c0 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x140>
							*p_read++ = (w & 0xff);
    78b6:	strb.w	r4, [r7], #2
							*p_read++ = w >> 8;
    78ba:	asrs	r4, r4, #8
    78bc:	strb	r4, [r2, #1]
    78be:	mov	r2, r7
						}
						count_read -= 2;
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    78c0:	and.w	r5, r5, #61440	; 0xf000
    78c4:	cmp	r5, r6
					} else {
						if (p_read) {
							*p_read++ = (w & 0xff);
							*p_read++ = w >> 8;
						}
						count_read -= 2;
    78c6:	sub.w	r3, r3, #2
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    78ca:	bhi.n	78a0 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x120>
			count--;
		}

	    uint16_t w = _transferWriteFill;

		while (count > 0) {
    78cc:	cmp.w	lr, #0
    78d0:	beq.n	78e2 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x162>
    78d2:	ldr	r4, [r0, #0]
    78d4:	b.n	785e <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xde>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    78d6:	mov	lr, r3
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w = _transferWriteFill;
    78d8:	ldrb.w	ip, [r0, #36]	; 0x24

		while (count > 0) {
    78dc:	cmp.w	lr, #0
    78e0:	bne.n	785e <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xde>
			} while ((sr & (15 << 12)) > queue_full_status_mask);

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
    78e2:	cbz	r3, 792c <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1ac>
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    78e4:	ldr	r4, [r0, #0]
			sr = port().SR;
    78e6:	ldr	r1, [r4, #44]	; 0x2c
			if (sr & 0xF0)  {
    78e8:	tst.w	r1, #240	; 0xf0
    78ec:	beq.n	78e6 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x166>
				uint16_t w = port().POPR;  // Read any pending RX bytes in
    78ee:	ldr	r1, [r4, #56]	; 0x38
				if (count_read & 1) {
    78f0:	lsls	r4, r3, #31
    78f2:	bpl.n	7930 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1b0>
					if (p_read)
    78f4:	cbz	r2, 78fa <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x17a>
						*p_read++ = w;  // Read any pending RX bytes in
    78f6:	strb	r1, [r2, #0]
    78f8:	adds	r2, #1
					count_read--;
    78fa:	subs	r3, #1
    78fc:	b.n	78e2 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x162>
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    78fe:	ldrb.w	r8, [r0, #36]	; 0x24
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    7902:	mov	ip, r3
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    7904:	orr.w	r8, r8, r8, lsl #8

		while (count > 0) {
    7908:	cmp.w	ip, #0
    790c:	bne.w	77c0 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x40>
			} while ((sr & (15 << 12)) > queue_full_status_mask);

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
    7910:	cbz	r3, 792c <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1ac>
    7912:	ldr	r4, [r0, #0]
			sr = port().SR;
    7914:	ldr	r1, [r4, #44]	; 0x2c
			if (sr & 0xF0)  {
    7916:	tst.w	r1, #240	; 0xf0
    791a:	beq.n	7914 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x194>
				uint16_t w = port().POPR;  // Read any pending RX bytes in
				if (count_read & 1) {
    791c:	lsls	r6, r3, #31

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
			sr = port().SR;
			if (sr & 0xF0)  {
				uint16_t w = port().POPR;  // Read any pending RX bytes in
    791e:	ldr	r1, [r4, #56]	; 0x38
				if (count_read & 1) {
    7920:	bpl.n	7942 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1c2>
					if (p_read)
    7922:	cbz	r2, 7928 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1a8>
						*p_read++ = w;  // Read any pending RX bytes in
    7924:	strb	r1, [r2, #0]
    7926:	adds	r2, #1
					count_read--;
    7928:	subs	r3, #1
    792a:	b.n	7910 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x190>
    792c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				if (count_read & 1) {
					if (p_read)
						*p_read++ = w;  // Read any pending RX bytes in
					count_read--;
				} else {
					if (p_read) {
    7930:	cbz	r2, 793e <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1be>
						*p_read++ = (w & 0xff);
    7932:	mov	r4, r2
						*p_read++ = w >> 8;
    7934:	asrs	r5, r1, #8
					if (p_read)
						*p_read++ = w;  // Read any pending RX bytes in
					count_read--;
				} else {
					if (p_read) {
						*p_read++ = (w & 0xff);
    7936:	strb.w	r1, [r4], #2
						*p_read++ = w >> 8;
    793a:	strb	r5, [r2, #1]
    793c:	mov	r2, r4
					}
					count_read -= 2;
    793e:	subs	r3, #2
    7940:	b.n	78e2 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x162>
				if (count_read & 1) {
					if (p_read)
						*p_read++ = w;  // Read any pending RX bytes in
					count_read--;
				} else {
					if (p_read) {
    7942:	cbz	r2, 7950 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1d0>
						*p_read++ = w >> 8;
    7944:	mov	r4, r2
    7946:	asrs	r5, r1, #8
    7948:	strb.w	r5, [r4], #2
						*p_read++ = (w & 0xff);
    794c:	strb	r1, [r2, #1]
    794e:	mov	r2, r4
					}
					count_read -= 2;
    7950:	subs	r3, #2
    7952:	b.n	7910 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x190>
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
			} else {
				if (count > 1)
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    7954:	ldrb.w	r5, [r0, #36]	; 0x24
				if (count > 1)
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
			} else {
				if (count > 1)
    7958:	cmp	r3, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    795a:	it	ne
    795c:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
    7960:	str	r5, [r4, #52]	; 0x34
    7962:	b.n	7850 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xd0>
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
			} else {
				if (count > 1)
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    7964:	ldrb.w	r5, [r0, #36]	; 0x24
				if (count > 1)
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
			} else {
				if (count > 1)
    7968:	cmp	r3, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    796a:	it	ne
    796c:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
    7970:	str	r5, [r4, #52]	; 0x34
    7972:	b.n	77ac <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x2c>
    7974:	.word	0x801f0400

00007978 <_spi_dma_rxISR1()>:
SPIClass SPI((uintptr_t)&KINETISK_SPI0, (uintptr_t)&SPIClass::spi0_hardware);

#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
void _spi_dma_rxISR1(void) {SPI1.dma_rxisr();}
    7978:	push	{r4, r5, r6, r7}

//-------------------------------------------------------------------------
// DMA RX ISR
//-------------------------------------------------------------------------
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
    797a:	ldr	r3, [pc, #280]	; (7a94 <_spi_dma_rxISR1()+0x11c>)
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
    797c:	ldr	r2, [pc, #280]	; (7a98 <_spi_dma_rxISR1()+0x120>)
    797e:	ldr	r0, [r3, #48]	; 0x30
    7980:	ldr	r4, [r3, #44]	; 0x2c
    7982:	ldrb	r1, [r0, #4]
    7984:	strb	r1, [r2, #0]
	bool complete(void) {
		if (TCD->CSR & DMA_TCD_CSR_DONE) return true;
		return false;
	}
	void clearComplete(void) {
		DMA_CDNE = channel;
    7986:	ldr	r1, [pc, #276]	; (7a9c <_spi_dma_rxISR1()+0x124>)
    7988:	ldrb	r2, [r4, #4]
    798a:	strb	r2, [r1, #0]
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
	if (_dma_count_remaining) {
    798c:	ldr	r2, [r3, #40]	; 0x28
    798e:	ldrb	r0, [r0, #4]
    7990:	strb	r0, [r1, #0]
    7992:	cmp	r2, #0
    7994:	beq.n	7a24 <_spi_dma_rxISR1()+0xac>
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
    7996:	ldr	r1, [r3, #4]
    7998:	ldr	r1, [r1, #12]
    799a:	cmp	r2, r1
    799c:	bhi.n	7a1c <_spi_dma_rxISR1()+0xa4>
    799e:	ldr	r1, [r4, #0]

#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    79a0:	ldrh	r4, [r1, #30]
    79a2:	lsls	r4, r4, #16
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
			_dma_count_remaining -= hardware().max_dma_count;
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
    79a4:	add.w	r0, r2, #4294967295

#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    79a8:	bmi.n	7a76 <_spi_dma_rxISR1()+0xfe>
		tcd->BITER = len & 0x7fff;
    79aa:	ubfx	r0, r0, #0, #15
    79ae:	strh	r0, [r1, #30]
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
	}
	tcd->CITER = tcd->BITER; 
    79b0:	ldrh	r0, [r1, #30]
    79b2:	uxth	r0, r0
    79b4:	strh	r0, [r1, #22]
    79b6:	ldr	r1, [r3, #48]	; 0x30
    79b8:	ldr	r1, [r1, #0]

#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    79ba:	ldrh	r0, [r1, #30]
    79bc:	lsls	r0, r0, #16
    79be:	bmi.n	7a66 <_spi_dma_rxISR1()+0xee>
		tcd->BITER = len & 0x7fff;
    79c0:	ubfx	r0, r2, #0, #15
    79c4:	strh	r0, [r1, #30]
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
	}
	tcd->CITER = tcd->BITER; 
    79c6:	ldrh	r0, [r1, #30]
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
			if (_dma_count_remaining == 1) should_reenable_tx = false;

			_dma_count_remaining = 0;
    79c8:	movs	r4, #0
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
		tcd->BITER = len & 0x7fff;
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
	}
	tcd->CITER = tcd->BITER; 
    79ca:	uxth	r0, r0
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    79cc:	adds.w	r2, r2, #4294967295
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
		tcd->BITER = len & 0x7fff;
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
	}
	tcd->CITER = tcd->BITER; 
    79d0:	strh	r0, [r1, #22]
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    79d2:	it	ne
    79d4:	movne	r2, #1
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
			if (_dma_count_remaining == 1) should_reenable_tx = false;

			_dma_count_remaining = 0;
    79d6:	str	r4, [r3, #40]	; 0x28
		}
		// In some cases we need to again start the TX manually to get it to work...
		if (_dmaTX->TCD->SADDR == &_transferWriteFill) {
    79d8:	ldr	r1, [r3, #44]	; 0x2c
    79da:	ldr	r0, [pc, #184]	; (7a94 <_spi_dma_rxISR1()+0x11c>)
    79dc:	ldr	r1, [r1, #0]
    79de:	ldr	r5, [r1, #0]
    79e0:	add.w	r4, r0, #36	; 0x24
    79e4:	cmp	r5, r4
    79e6:	beq.n	7a56 <_spi_dma_rxISR1()+0xde>
    79e8:	ldr	r0, [r0, #0]
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
    79ea:	ldr	r4, [r0, #12]
    79ec:	tst.w	r4, #1073741824	; 0x40000000
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
    79f0:	ldr	r4, [r1, #0]
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
    79f2:	ldr	r5, [r1, #0]
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
    79f4:	itete	ne
    79f6:	ldrhne	r4, [r4, #0]
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
    79f8:	ldrbeq	r4, [r4, #0]
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
    79fa:	addne	r5, #2
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 1;
    79fc:	addeq	r5, #1
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    79fe:	orr.w	r4, r4, #2147483648	; 0x80000000
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 1;
    7a02:	str	r5, [r1, #0]
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    7a04:	str	r4, [r0, #52]	; 0x34
    7a06:	ldr	r1, [r3, #48]	; 0x30
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
    7a08:	ldr	r3, [pc, #148]	; (7aa0 <_spi_dma_rxISR1()+0x128>)
    7a0a:	ldrb	r1, [r1, #4]
    7a0c:	strb	r1, [r3, #0]
			}
		}
		_dmaRX->enable();
    7a0e:	ldr	r1, [pc, #132]	; (7a94 <_spi_dma_rxISR1()+0x11c>)
		if (should_reenable_tx)
    7a10:	cbz	r2, 7a18 <_spi_dma_rxISR1()+0xa0>
    7a12:	ldr	r2, [r1, #44]	; 0x2c
    7a14:	ldrb	r2, [r2, #4]
    7a16:	strb	r2, [r3, #0]
SPIClass SPI((uintptr_t)&KINETISK_SPI0, (uintptr_t)&SPIClass::spi0_hardware);

#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
void _spi_dma_rxISR1(void) {SPI1.dma_rxisr();}
    7a18:	pop	{r4, r5, r6, r7}
    7a1a:	bx	lr
	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
	if (_dma_count_remaining) {
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
			_dma_count_remaining -= hardware().max_dma_count;
    7a1c:	subs	r2, r2, r1
    7a1e:	str	r2, [r3, #40]	; 0x28
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    7a20:	movs	r2, #1
    7a22:	b.n	79d8 <_spi_dma_rxISR1()+0x60>
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    7a24:	ldr	r0, [r3, #52]	; 0x34
    7a26:	ldr	r1, [r3, #0]
    7a28:	ldr	r5, [r0, #0]
			_dmaTX->enable();
	} else {

		port().RSER = 0;
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
    7a2a:	ldr	r4, [pc, #120]	; (7aa4 <_spi_dma_rxISR1()+0x12c>)
		_dmaRX->enable();
		if (should_reenable_tx)
			_dmaTX->enable();
	} else {

		port().RSER = 0;
    7a2c:	str	r2, [r1, #48]	; 0x30
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
    7a2e:	str	r4, [r1, #44]	; 0x2c
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits
    7a30:	ldr	r4, [r1, #12]

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    7a32:	ldr	r5, [r5, #0]
    7a34:	ldr	r6, [pc, #112]	; (7aa8 <_spi_dma_rxISR1()+0x130>)
	} else {

		port().RSER = 0;
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits
    7a36:	bic.w	r4, r4, #1073741824	; 0x40000000

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
    7a3a:	movs	r7, #3
    7a3c:	cmp	r5, r6
	} else {

		port().RSER = 0;
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits
    7a3e:	str	r4, [r1, #12]

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
    7a40:	strb.w	r7, [r3, #37]	; 0x25
    7a44:	bne.n	7a86 <_spi_dma_rxISR1()+0x10e>
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
    7a46:	ldrb	r3, [r0, #28]

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
    7a48:	str	r2, [r0, #4]
		_data = data;
		if (_type == EventTypeImmediate) {
    7a4a:	cmp	r3, #2
	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
    7a4c:	str	r2, [r0, #12]
		if (_type == EventTypeImmediate) {
    7a4e:	beq.n	7a8e <_spi_dma_rxISR1()+0x116>
SPIClass SPI((uintptr_t)&KINETISK_SPI0, (uintptr_t)&SPIClass::spi0_hardware);

#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
void _spi_dma_rxISR1(void) {SPI1.dma_rxisr();}
    7a50:	pop	{r4, r5, r6, r7}
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
    7a52:	b.w	edb0 <EventResponder::triggerEventNotImmediate()>
    7a56:	ldr	r1, [r0, #0]
			_dma_count_remaining = 0;
		}
		// In some cases we need to again start the TX manually to get it to work...
		if (_dmaTX->TCD->SADDR == &_transferWriteFill) {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    7a58:	ldrb.w	r0, [r0, #36]	; 0x24

			_dma_count_remaining = 0;
		}
		// In some cases we need to again start the TX manually to get it to work...
		if (_dmaTX->TCD->SADDR == &_transferWriteFill) {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
    7a5c:	ldr	r4, [r1, #12]
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    7a5e:	orr.w	r0, r0, #2147483648	; 0x80000000
    7a62:	str	r0, [r1, #52]	; 0x34
    7a64:	b.n	7a06 <_spi_dma_rxISR1()+0x8e>
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
		tcd->BITER = len & 0x7fff;
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
    7a66:	ldrh	r4, [r1, #30]
    7a68:	ubfx	r0, r2, #0, #9
    7a6c:	and.w	r4, r4, #65024	; 0xfe00
    7a70:	orrs	r0, r4
    7a72:	strh	r0, [r1, #30]
    7a74:	b.n	79c6 <_spi_dma_rxISR1()+0x4e>
    7a76:	ldrh	r4, [r1, #30]
    7a78:	ubfx	r0, r0, #0, #9
    7a7c:	and.w	r4, r4, #65024	; 0xfe00
    7a80:	orrs	r0, r4
    7a82:	strh	r0, [r1, #30]
    7a84:	b.n	79b0 <_spi_dma_rxISR1()+0x38>
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    7a86:	mov	r3, r5
    7a88:	mov	r1, r2
SPIClass SPI((uintptr_t)&KINETISK_SPI0, (uintptr_t)&SPIClass::spi0_hardware);

#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
void _spi_dma_rxISR1(void) {SPI1.dma_rxisr();}
    7a8a:	pop	{r4, r5, r6, r7}
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    7a8c:	bx	r3
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    7a8e:	ldr	r3, [r0, #8]
SPIClass SPI((uintptr_t)&KINETISK_SPI0, (uintptr_t)&SPIClass::spi0_hardware);

#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
void _spi_dma_rxISR1(void) {SPI1.dma_rxisr();}
    7a90:	pop	{r4, r5, r6, r7}
    7a92:	bx	r3
    7a94:	.word	0x1fff0998
    7a98:	.word	0x4000801f
    7a9c:	.word	0x4000801c
    7aa0:	.word	0x4000801b
    7aa4:	.word	0xff0f0000
    7aa8:	.word	0x00007765

00007aac <_spi_dma_rxISR0()>:
};
SPIClass SPI((uintptr_t)&KINETISK_SPI0, (uintptr_t)&SPIClass::spi0_hardware);

#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    7aac:	push	{r4, r5, r6, r7}

//-------------------------------------------------------------------------
// DMA RX ISR
//-------------------------------------------------------------------------
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
    7aae:	ldr	r3, [pc, #280]	; (7bc8 <_spi_dma_rxISR0()+0x11c>)
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
    7ab0:	ldr	r2, [pc, #280]	; (7bcc <_spi_dma_rxISR0()+0x120>)
    7ab2:	ldr	r0, [r3, #48]	; 0x30
    7ab4:	ldr	r4, [r3, #44]	; 0x2c
    7ab6:	ldrb	r1, [r0, #4]
    7ab8:	strb	r1, [r2, #0]
	bool complete(void) {
		if (TCD->CSR & DMA_TCD_CSR_DONE) return true;
		return false;
	}
	void clearComplete(void) {
		DMA_CDNE = channel;
    7aba:	ldr	r1, [pc, #276]	; (7bd0 <_spi_dma_rxISR0()+0x124>)
    7abc:	ldrb	r2, [r4, #4]
    7abe:	strb	r2, [r1, #0]
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
	if (_dma_count_remaining) {
    7ac0:	ldr	r2, [r3, #40]	; 0x28
    7ac2:	ldrb	r0, [r0, #4]
    7ac4:	strb	r0, [r1, #0]
    7ac6:	cmp	r2, #0
    7ac8:	beq.n	7b58 <_spi_dma_rxISR0()+0xac>
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
    7aca:	ldr	r1, [r3, #4]
    7acc:	ldr	r1, [r1, #12]
    7ace:	cmp	r2, r1
    7ad0:	bhi.n	7b50 <_spi_dma_rxISR0()+0xa4>
    7ad2:	ldr	r1, [r4, #0]

#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    7ad4:	ldrh	r4, [r1, #30]
    7ad6:	lsls	r4, r4, #16
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
			_dma_count_remaining -= hardware().max_dma_count;
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
    7ad8:	add.w	r0, r2, #4294967295

#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    7adc:	bmi.n	7baa <_spi_dma_rxISR0()+0xfe>
		tcd->BITER = len & 0x7fff;
    7ade:	ubfx	r0, r0, #0, #15
    7ae2:	strh	r0, [r1, #30]
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
	}
	tcd->CITER = tcd->BITER; 
    7ae4:	ldrh	r0, [r1, #30]
    7ae6:	uxth	r0, r0
    7ae8:	strh	r0, [r1, #22]
    7aea:	ldr	r1, [r3, #48]	; 0x30
    7aec:	ldr	r1, [r1, #0]

#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    7aee:	ldrh	r0, [r1, #30]
    7af0:	lsls	r0, r0, #16
    7af2:	bmi.n	7b9a <_spi_dma_rxISR0()+0xee>
		tcd->BITER = len & 0x7fff;
    7af4:	ubfx	r0, r2, #0, #15
    7af8:	strh	r0, [r1, #30]
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
	}
	tcd->CITER = tcd->BITER; 
    7afa:	ldrh	r0, [r1, #30]
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
			if (_dma_count_remaining == 1) should_reenable_tx = false;

			_dma_count_remaining = 0;
    7afc:	movs	r4, #0
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
		tcd->BITER = len & 0x7fff;
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
	}
	tcd->CITER = tcd->BITER; 
    7afe:	uxth	r0, r0
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    7b00:	adds.w	r2, r2, #4294967295
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
		tcd->BITER = len & 0x7fff;
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
	}
	tcd->CITER = tcd->BITER; 
    7b04:	strh	r0, [r1, #22]
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    7b06:	it	ne
    7b08:	movne	r2, #1
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
			if (_dma_count_remaining == 1) should_reenable_tx = false;

			_dma_count_remaining = 0;
    7b0a:	str	r4, [r3, #40]	; 0x28
		}
		// In some cases we need to again start the TX manually to get it to work...
		if (_dmaTX->TCD->SADDR == &_transferWriteFill) {
    7b0c:	ldr	r1, [r3, #44]	; 0x2c
    7b0e:	ldr	r0, [pc, #184]	; (7bc8 <_spi_dma_rxISR0()+0x11c>)
    7b10:	ldr	r1, [r1, #0]
    7b12:	ldr	r5, [r1, #0]
    7b14:	add.w	r4, r0, #36	; 0x24
    7b18:	cmp	r5, r4
    7b1a:	beq.n	7b8a <_spi_dma_rxISR0()+0xde>
    7b1c:	ldr	r0, [r0, #0]
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
    7b1e:	ldr	r4, [r0, #12]
    7b20:	tst.w	r4, #1073741824	; 0x40000000
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
    7b24:	ldr	r4, [r1, #0]
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
    7b26:	ldr	r5, [r1, #0]
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
    7b28:	itete	ne
    7b2a:	ldrhne	r4, [r4, #0]
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
    7b2c:	ldrbeq	r4, [r4, #0]
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
    7b2e:	addne	r5, #2
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 1;
    7b30:	addeq	r5, #1
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    7b32:	orr.w	r4, r4, #2147483648	; 0x80000000
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 1;
    7b36:	str	r5, [r1, #0]
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    7b38:	str	r4, [r0, #52]	; 0x34
    7b3a:	ldr	r1, [r3, #48]	; 0x30
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
    7b3c:	ldr	r3, [pc, #148]	; (7bd4 <_spi_dma_rxISR0()+0x128>)
    7b3e:	ldrb	r1, [r1, #4]
    7b40:	strb	r1, [r3, #0]
			}
		}
		_dmaRX->enable();
    7b42:	ldr	r1, [pc, #132]	; (7bc8 <_spi_dma_rxISR0()+0x11c>)
		if (should_reenable_tx)
    7b44:	cbz	r2, 7b4c <_spi_dma_rxISR0()+0xa0>
    7b46:	ldr	r2, [r1, #44]	; 0x2c
    7b48:	ldrb	r2, [r2, #4]
    7b4a:	strb	r2, [r3, #0]
};
SPIClass SPI((uintptr_t)&KINETISK_SPI0, (uintptr_t)&SPIClass::spi0_hardware);

#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    7b4c:	pop	{r4, r5, r6, r7}
    7b4e:	bx	lr
	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
	if (_dma_count_remaining) {
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
			_dma_count_remaining -= hardware().max_dma_count;
    7b50:	subs	r2, r2, r1
    7b52:	str	r2, [r3, #40]	; 0x28
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    7b54:	movs	r2, #1
    7b56:	b.n	7b0c <_spi_dma_rxISR0()+0x60>
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    7b58:	ldr	r0, [r3, #52]	; 0x34
    7b5a:	ldr	r1, [r3, #0]
    7b5c:	ldr	r5, [r0, #0]
			_dmaTX->enable();
	} else {

		port().RSER = 0;
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
    7b5e:	ldr	r4, [pc, #120]	; (7bd8 <_spi_dma_rxISR0()+0x12c>)
		_dmaRX->enable();
		if (should_reenable_tx)
			_dmaTX->enable();
	} else {

		port().RSER = 0;
    7b60:	str	r2, [r1, #48]	; 0x30
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
    7b62:	str	r4, [r1, #44]	; 0x2c
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits
    7b64:	ldr	r4, [r1, #12]

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    7b66:	ldr	r5, [r5, #0]
    7b68:	ldr	r6, [pc, #112]	; (7bdc <_spi_dma_rxISR0()+0x130>)
	} else {

		port().RSER = 0;
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits
    7b6a:	bic.w	r4, r4, #1073741824	; 0x40000000

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
    7b6e:	movs	r7, #3
    7b70:	cmp	r5, r6
	} else {

		port().RSER = 0;
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits
    7b72:	str	r4, [r1, #12]

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
    7b74:	strb.w	r7, [r3, #37]	; 0x25
    7b78:	bne.n	7bba <_spi_dma_rxISR0()+0x10e>
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
    7b7a:	ldrb	r3, [r0, #28]

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
    7b7c:	str	r2, [r0, #4]
		_data = data;
		if (_type == EventTypeImmediate) {
    7b7e:	cmp	r3, #2
	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
    7b80:	str	r2, [r0, #12]
		if (_type == EventTypeImmediate) {
    7b82:	beq.n	7bc2 <_spi_dma_rxISR0()+0x116>
};
SPIClass SPI((uintptr_t)&KINETISK_SPI0, (uintptr_t)&SPIClass::spi0_hardware);

#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    7b84:	pop	{r4, r5, r6, r7}
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
    7b86:	b.w	edb0 <EventResponder::triggerEventNotImmediate()>
    7b8a:	ldr	r1, [r0, #0]
			_dma_count_remaining = 0;
		}
		// In some cases we need to again start the TX manually to get it to work...
		if (_dmaTX->TCD->SADDR == &_transferWriteFill) {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    7b8c:	ldrb.w	r0, [r0, #36]	; 0x24

			_dma_count_remaining = 0;
		}
		// In some cases we need to again start the TX manually to get it to work...
		if (_dmaTX->TCD->SADDR == &_transferWriteFill) {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
    7b90:	ldr	r4, [r1, #12]
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    7b92:	orr.w	r0, r0, #2147483648	; 0x80000000
    7b96:	str	r0, [r1, #52]	; 0x34
    7b98:	b.n	7b3a <_spi_dma_rxISR0()+0x8e>
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
		tcd->BITER = len & 0x7fff;
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
    7b9a:	ldrh	r4, [r1, #30]
    7b9c:	ubfx	r0, r2, #0, #9
    7ba0:	and.w	r4, r4, #65024	; 0xfe00
    7ba4:	orrs	r0, r4
    7ba6:	strh	r0, [r1, #30]
    7ba8:	b.n	7afa <_spi_dma_rxISR0()+0x4e>
    7baa:	ldrh	r4, [r1, #30]
    7bac:	ubfx	r0, r0, #0, #9
    7bb0:	and.w	r4, r4, #65024	; 0xfe00
    7bb4:	orrs	r0, r4
    7bb6:	strh	r0, [r1, #30]
    7bb8:	b.n	7ae4 <_spi_dma_rxISR0()+0x38>
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    7bba:	mov	r3, r5
    7bbc:	mov	r1, r2
};
SPIClass SPI((uintptr_t)&KINETISK_SPI0, (uintptr_t)&SPIClass::spi0_hardware);

#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    7bbe:	pop	{r4, r5, r6, r7}
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    7bc0:	bx	r3
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    7bc2:	ldr	r3, [r0, #8]
};
SPIClass SPI((uintptr_t)&KINETISK_SPI0, (uintptr_t)&SPIClass::spi0_hardware);

#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    7bc4:	pop	{r4, r5, r6, r7}
    7bc6:	bx	r3
    7bc8:	.word	0x1fff0960
    7bcc:	.word	0x4000801f
    7bd0:	.word	0x4000801c
    7bd4:	.word	0x4000801b
    7bd8:	.word	0xff0f0000
    7bdc:	.word	0x00007765

00007be0 <SPIClass::begin()>:
    7be0:	ldmia.w	r0, {r2, r3}
SPIClass SPI2((uintptr_t)&KINETISK_SPI2, (uintptr_t)&SPIClass::spi2_hardware);
#endif


void SPIClass::begin()
{
    7be4:	push	{r4, r5, r6, r7}
	volatile uint32_t *reg;

	hardware().clock_gate_register |= hardware().clock_gate_mask;
    7be6:	ldr	r4, [r3, #0]
    7be8:	ldr	r1, [r3, #4]
    7bea:	ldr	r5, [r4, #0]
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
    7bec:	ldr	r7, [pc, #88]	; (7c48 <SPIClass::begin()+0x68>)
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    7bee:	ldr	r6, [pc, #92]	; (7c4c <SPIClass::begin()+0x6c>)

void SPIClass::begin()
{
	volatile uint32_t *reg;

	hardware().clock_gate_register |= hardware().clock_gate_mask;
    7bf0:	orrs	r1, r5
    7bf2:	str	r1, [r4, #0]
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    7bf4:	ldr	r5, [pc, #88]	; (7c50 <SPIClass::begin()+0x70>)
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
    7bf6:	ldr	r1, [pc, #92]	; (7c54 <SPIClass::begin()+0x74>)
void SPIClass::begin()
{
	volatile uint32_t *reg;

	hardware().clock_gate_register |= hardware().clock_gate_mask;
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
    7bf8:	str	r7, [r2, #0]
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    7bfa:	str	r6, [r2, #12]
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    7bfc:	str	r5, [r2, #16]
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
    7bfe:	str	r1, [r2, #0]
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    7c00:	ldrb	r1, [r0, #9]
    7c02:	ldr	r2, [pc, #84]	; (7c58 <SPIClass::begin()+0x78>)
    7c04:	adds	r4, r3, r1
	*reg = hardware().mosi_mux[mosi_pin_index];
    7c06:	adds	r1, #12
	hardware().clock_gate_register |= hardware().clock_gate_mask;
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    7c08:	ldrb.w	r4, [r4, #44]	; 0x2c
	*reg = hardware().mosi_mux[mosi_pin_index];
    7c0c:	ldr.w	r5, [r3, r1, lsl #2]
	hardware().clock_gate_register |= hardware().clock_gate_mask;
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    7c10:	add.w	r1, r2, r4, lsl #3
    7c14:	ldr	r1, [r1, #4]
	*reg = hardware().mosi_mux[mosi_pin_index];
    7c16:	str	r5, [r1, #0]
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    7c18:	ldrb	r1, [r0, #8]
    7c1a:	adds	r4, r3, r1
	*reg= hardware().miso_mux[miso_pin_index];
    7c1c:	add.w	r1, r3, r1, lsl #2
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    7c20:	ldrb	r4, [r4, #24]
	*reg= hardware().miso_mux[miso_pin_index];
    7c22:	ldr	r5, [r1, #28]
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    7c24:	add.w	r1, r2, r4, lsl #3
    7c28:	ldr	r1, [r1, #4]
	*reg= hardware().miso_mux[miso_pin_index];
    7c2a:	str	r5, [r1, #0]
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    7c2c:	ldrb	r1, [r0, #10]
    7c2e:	adds	r0, r3, r1
	*reg = hardware().sck_mux[sck_pin_index];
    7c30:	add.w	r3, r3, r1, lsl #2
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
	*reg= hardware().miso_mux[miso_pin_index];
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    7c34:	ldrb.w	r0, [r0, #64]	; 0x40
	*reg = hardware().sck_mux[sck_pin_index];
    7c38:	ldr	r1, [r3, #68]	; 0x44
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
	*reg= hardware().miso_mux[miso_pin_index];
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    7c3a:	add.w	r2, r2, r0, lsl #3
	*reg = hardware().sck_mux[sck_pin_index];
}
    7c3e:	pop	{r4, r5, r6, r7}
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
	*reg= hardware().miso_mux[miso_pin_index];
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    7c40:	ldr	r3, [r2, #4]
	*reg = hardware().sck_mux[sck_pin_index];
    7c42:	str	r1, [r3, #0]
}
    7c44:	bx	lr
    7c46:	nop
    7c48:	.word	0x001f4001
    7c4c:	.word	0x38001001
    7c50:	.word	0x78001001
    7c54:	.word	0x801f0000
    7c58:	.word	0x0001479c

00007c5c <SPIClass::setMOSI(unsigned char)>:
	}
	return 0;
}

void SPIClass::setMOSI(uint8_t pin)
{
    7c5c:	push	{r4, r5, r6, r7}
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    7c5e:	ldr	r3, [pc, #148]	; (7cf4 <SPIClass::setMOSI(unsigned char)+0x98>)
    7c60:	ldr	r5, [r0, #4]
    7c62:	cmp	r3, r5
    7c64:	beq.n	7c8a <SPIClass::setMOSI(unsigned char)+0x2e>
		SPCR.setMOSI_soft(pin);
	}
	if (pin != hardware().mosi_pin[mosi_pin_index]) {
    7c66:	ldrb	r3, [r0, #9]
    7c68:	add	r3, r5
    7c6a:	ldrb.w	r6, [r3, #44]	; 0x2c
    7c6e:	cmp	r1, r6
    7c70:	beq.n	7c86 <SPIClass::setMOSI(unsigned char)+0x2a>
    7c72:	add.w	r2, r5, #43	; 0x2b
    7c76:	movs	r3, #0
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
			if  (pin == hardware().mosi_pin[i]) {
    7c78:	ldrb.w	r4, [r2, #1]!
    7c7c:	cmp	r4, r1
    7c7e:	beq.n	7cb6 <SPIClass::setMOSI(unsigned char)+0x5a>
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setMOSI_soft(pin);
	}
	if (pin != hardware().mosi_pin[mosi_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
    7c80:	adds	r3, #1
    7c82:	cmp	r3, #4
    7c84:	bne.n	7c78 <SPIClass::setMOSI(unsigned char)+0x1c>
				mosi_pin_index = i;
				return;
			}
		}
	}
}
    7c86:	pop	{r4, r5, r6, r7}
    7c88:	bx	lr
		pinout = newpinout;
#endif
	}
	inline void setMOSI_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 11) pinout &= ~3;
    7c8a:	cmp	r1, #11
    7c8c:	beq.n	7ce8 <SPIClass::setMOSI(unsigned char)+0x8c>
		if (pin == 7)  pinout = (pinout & ~0x3) | 1;
    7c8e:	cmp	r1, #7
    7c90:	beq.n	7ca6 <SPIClass::setMOSI(unsigned char)+0x4a>
		if (pin == 28) pinout = (pinout & ~0x3) | 2;
    7c92:	cmp	r1, #28
    7c94:	bne.n	7c66 <SPIClass::setMOSI(unsigned char)+0xa>
    7c96:	ldr	r2, [pc, #96]	; (7cf8 <SPIClass::setMOSI(unsigned char)+0x9c>)
    7c98:	ldrb	r3, [r2, #0]
    7c9a:	bic.w	r3, r3, #3
    7c9e:	orr.w	r3, r3, #2
    7ca2:	strb	r3, [r2, #0]
    7ca4:	b.n	7c66 <SPIClass::setMOSI(unsigned char)+0xa>
#endif
	}
	inline void setMOSI_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 11) pinout &= ~3;
		if (pin == 7)  pinout = (pinout & ~0x3) | 1;
    7ca6:	ldr	r2, [pc, #80]	; (7cf8 <SPIClass::setMOSI(unsigned char)+0x9c>)
    7ca8:	ldrb	r3, [r2, #0]
    7caa:	bic.w	r3, r3, #3
    7cae:	orr.w	r3, r3, #1
    7cb2:	strb	r3, [r2, #0]
    7cb4:	b.n	7c66 <SPIClass::setMOSI(unsigned char)+0xa>
		SPCR.setMOSI_soft(pin);
	}
	if (pin != hardware().mosi_pin[mosi_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
			if  (pin == hardware().mosi_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
    7cb6:	ldmia.w	r5, {r1, r2}
    7cba:	ldr	r1, [r1, #0]
    7cbc:	tst	r1, r2
    7cbe:	beq.n	7ce2 <SPIClass::setMOSI(unsigned char)+0x86>
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    7cc0:	ldr	r2, [pc, #56]	; (7cfc <SPIClass::setMOSI(unsigned char)+0xa0>)
    7cc2:	add.w	r6, r2, r6, lsl #3
					*reg = 0;
    7cc6:	movs	r7, #0
	if (pin != hardware().mosi_pin[mosi_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
			if  (pin == hardware().mosi_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    7cc8:	ldr	r4, [r6, #4]
					*reg = 0;
					reg = portConfigRegister(hardware().mosi_pin[i]);
    7cca:	adds	r1, r5, r3
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
			if  (pin == hardware().mosi_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
					*reg = 0;
    7ccc:	str	r7, [r4, #0]
					reg = portConfigRegister(hardware().mosi_pin[i]);
    7cce:	ldrb.w	r1, [r1, #44]	; 0x2c
    7cd2:	add.w	r2, r2, r1, lsl #3
					*reg = hardware().mosi_mux[i];
    7cd6:	add.w	r1, r3, #12
			if  (pin == hardware().mosi_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().mosi_pin[i]);
    7cda:	ldr	r4, [r2, #4]
					*reg = hardware().mosi_mux[i];
    7cdc:	ldr.w	r2, [r5, r1, lsl #2]
    7ce0:	str	r2, [r4, #0]
				}	
				mosi_pin_index = i;
    7ce2:	strb	r3, [r0, #9]
				return;
			}
		}
	}
}
    7ce4:	pop	{r4, r5, r6, r7}
    7ce6:	bx	lr
		pinout = newpinout;
#endif
	}
	inline void setMOSI_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 11) pinout &= ~3;
    7ce8:	ldr	r2, [pc, #12]	; (7cf8 <SPIClass::setMOSI(unsigned char)+0x9c>)
    7cea:	ldrb	r3, [r2, #0]
    7cec:	bic.w	r3, r3, #3
    7cf0:	strb	r3, [r2, #0]
    7cf2:	b.n	7c66 <SPIClass::setMOSI(unsigned char)+0xa>
    7cf4:	.word	0x00014578
    7cf8:	.word	0x1fff67d5
    7cfc:	.word	0x0001479c

00007d00 <SPIClass::setMISO(unsigned char)>:

void SPIClass::setMISO(uint8_t pin)
{
    7d00:	push	{r4, r5, r6, r7}
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    7d02:	ldr	r3, [pc, #144]	; (7d94 <SPIClass::setMISO(unsigned char)+0x94>)
    7d04:	ldr	r5, [r0, #4]
    7d06:	cmp	r3, r5
    7d08:	beq.n	7d2c <SPIClass::setMISO(unsigned char)+0x2c>
		SPCR.setMISO_soft(pin);
	}
	if (pin != hardware().miso_pin[miso_pin_index]) {
    7d0a:	ldrb	r3, [r0, #8]
    7d0c:	add	r3, r5
    7d0e:	ldrb	r6, [r3, #24]
    7d10:	cmp	r1, r6
    7d12:	beq.n	7d28 <SPIClass::setMISO(unsigned char)+0x28>
    7d14:	add.w	r2, r5, #23
    7d18:	movs	r3, #0
		for (unsigned int i = 0; i < sizeof(hardware().miso_pin); i++) {
			if  (pin == hardware().miso_pin[i]) {
    7d1a:	ldrb.w	r4, [r2, #1]!
    7d1e:	cmp	r4, r1
    7d20:	beq.n	7d58 <SPIClass::setMISO(unsigned char)+0x58>
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setMISO_soft(pin);
	}
	if (pin != hardware().miso_pin[miso_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().miso_pin); i++) {
    7d22:	adds	r3, #1
    7d24:	cmp	r3, #4
    7d26:	bne.n	7d1a <SPIClass::setMISO(unsigned char)+0x1a>
				miso_pin_index = i;
				return;
			}
		}
	}
}
    7d28:	pop	{r4, r5, r6, r7}
    7d2a:	bx	lr
		pinout = newpinout;
#endif
	}
	inline void setMISO_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 12) pinout &= ~0xc;
    7d2c:	cmp	r1, #12
    7d2e:	beq.n	7d86 <SPIClass::setMISO(unsigned char)+0x86>
		if (pin == 8)  pinout = (pinout & ~0xc) | 4;
    7d30:	cmp	r1, #8
    7d32:	beq.n	7d48 <SPIClass::setMISO(unsigned char)+0x48>
		if (pin == 39) pinout = (pinout & ~0xc) | 8;
    7d34:	cmp	r1, #39	; 0x27
    7d36:	bne.n	7d0a <SPIClass::setMISO(unsigned char)+0xa>
    7d38:	ldr	r2, [pc, #92]	; (7d98 <SPIClass::setMISO(unsigned char)+0x98>)
    7d3a:	ldrb	r3, [r2, #0]
    7d3c:	bic.w	r3, r3, #12
    7d40:	orr.w	r3, r3, #8
    7d44:	strb	r3, [r2, #0]
    7d46:	b.n	7d0a <SPIClass::setMISO(unsigned char)+0xa>
#endif
	}
	inline void setMISO_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 12) pinout &= ~0xc;
		if (pin == 8)  pinout = (pinout & ~0xc) | 4;
    7d48:	ldr	r2, [pc, #76]	; (7d98 <SPIClass::setMISO(unsigned char)+0x98>)
    7d4a:	ldrb	r3, [r2, #0]
    7d4c:	bic.w	r3, r3, #12
    7d50:	orr.w	r3, r3, #4
    7d54:	strb	r3, [r2, #0]
    7d56:	b.n	7d0a <SPIClass::setMISO(unsigned char)+0xa>
		SPCR.setMISO_soft(pin);
	}
	if (pin != hardware().miso_pin[miso_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().miso_pin); i++) {
			if  (pin == hardware().miso_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
    7d58:	ldmia.w	r5, {r1, r2}
    7d5c:	ldr	r1, [r1, #0]
    7d5e:	tst	r1, r2
    7d60:	beq.n	7d80 <SPIClass::setMISO(unsigned char)+0x80>
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    7d62:	ldr	r2, [pc, #56]	; (7d9c <SPIClass::setMISO(unsigned char)+0x9c>)
    7d64:	add.w	r6, r2, r6, lsl #3
					*reg = 0;
					reg = portConfigRegister(hardware().miso_pin[i]);
    7d68:	adds	r1, r5, r3
	if (pin != hardware().miso_pin[miso_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().miso_pin); i++) {
			if  (pin == hardware().miso_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    7d6a:	ldr	r4, [r6, #4]
					*reg = 0;
    7d6c:	movs	r7, #0
    7d6e:	str	r7, [r4, #0]
					reg = portConfigRegister(hardware().miso_pin[i]);
    7d70:	ldrb	r1, [r1, #24]
    7d72:	add.w	r2, r2, r1, lsl #3
					*reg = hardware().miso_mux[i];
    7d76:	add.w	r5, r5, r3, lsl #2
			if  (pin == hardware().miso_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().miso_pin[i]);
    7d7a:	ldr	r2, [r2, #4]
					*reg = hardware().miso_mux[i];
    7d7c:	ldr	r1, [r5, #28]
    7d7e:	str	r1, [r2, #0]
				}	
				miso_pin_index = i;
    7d80:	strb	r3, [r0, #8]
				return;
			}
		}
	}
}
    7d82:	pop	{r4, r5, r6, r7}
    7d84:	bx	lr
		pinout = newpinout;
#endif
	}
	inline void setMISO_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 12) pinout &= ~0xc;
    7d86:	ldr	r2, [pc, #16]	; (7d98 <SPIClass::setMISO(unsigned char)+0x98>)
    7d88:	ldrb	r3, [r2, #0]
    7d8a:	bic.w	r3, r3, #12
    7d8e:	strb	r3, [r2, #0]
    7d90:	b.n	7d0a <SPIClass::setMISO(unsigned char)+0xa>
    7d92:	nop
    7d94:	.word	0x00014578
    7d98:	.word	0x1fff67d5
    7d9c:	.word	0x0001479c

00007da0 <SPIClass::setSCK(unsigned char)>:

void SPIClass::setSCK(uint8_t pin)
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    7da0:	ldr	r2, [pc, #160]	; (7e44 <SPIClass::setSCK(unsigned char)+0xa4>)
    7da2:	ldr	r3, [r0, #4]
    7da4:	cmp	r2, r3
		}
	}
}

void SPIClass::setSCK(uint8_t pin)
{
    7da6:	push	{r4, r5, r6}
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    7da8:	beq.n	7dd6 <SPIClass::setSCK(unsigned char)+0x36>
		SPCR.setSCK_soft(pin);
	}
	if (pin != hardware().sck_pin[sck_pin_index]) {
    7daa:	ldrb	r2, [r0, #10]
    7dac:	add	r2, r3
    7dae:	ldrb.w	r2, [r2, #64]	; 0x40
    7db2:	cmp	r1, r2
    7db4:	beq.n	7dd2 <SPIClass::setSCK(unsigned char)+0x32>
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
			if  (pin == hardware().sck_pin[i]) {
    7db6:	ldrb.w	r4, [r3, #64]	; 0x40
    7dba:	cmp	r4, r1
    7dbc:	beq.n	7e3e <SPIClass::setSCK(unsigned char)+0x9e>
    7dbe:	ldrb.w	r4, [r3, #65]	; 0x41
    7dc2:	cmp	r4, r1
    7dc4:	beq.n	7e02 <SPIClass::setSCK(unsigned char)+0x62>
    7dc6:	ldrb.w	r4, [r3, #66]	; 0x42
    7dca:	cmp	r4, r1
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setSCK_soft(pin);
	}
	if (pin != hardware().sck_pin[sck_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
    7dcc:	it	eq
    7dce:	moveq	r1, #2
			if  (pin == hardware().sck_pin[i]) {
    7dd0:	beq.n	7e04 <SPIClass::setSCK(unsigned char)+0x64>
				sck_pin_index = i;
				return;
			}
		}
	}
}
    7dd2:	pop	{r4, r5, r6}
    7dd4:	bx	lr
		pinout = newpinout;
#endif
	}
	inline void setSCK_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 13) pinout &= ~0x30;
    7dd6:	cmp	r1, #13
    7dd8:	beq.n	7e32 <SPIClass::setSCK(unsigned char)+0x92>
		if (pin == 14) pinout = (pinout & ~0x30) | 0x10;
    7dda:	cmp	r1, #14
    7ddc:	beq.n	7df2 <SPIClass::setSCK(unsigned char)+0x52>
		if (pin == 27) pinout = (pinout & ~0x30) | 0x20;
    7dde:	cmp	r1, #27
    7de0:	bne.n	7daa <SPIClass::setSCK(unsigned char)+0xa>
    7de2:	ldr	r4, [pc, #100]	; (7e48 <SPIClass::setSCK(unsigned char)+0xa8>)
    7de4:	ldrb	r2, [r4, #0]
    7de6:	bic.w	r2, r2, #48	; 0x30
    7dea:	orr.w	r2, r2, #32
    7dee:	strb	r2, [r4, #0]
    7df0:	b.n	7daa <SPIClass::setSCK(unsigned char)+0xa>
#endif
	}
	inline void setSCK_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 13) pinout &= ~0x30;
		if (pin == 14) pinout = (pinout & ~0x30) | 0x10;
    7df2:	ldr	r4, [pc, #84]	; (7e48 <SPIClass::setSCK(unsigned char)+0xa8>)
    7df4:	ldrb	r2, [r4, #0]
    7df6:	bic.w	r2, r2, #48	; 0x30
    7dfa:	orr.w	r2, r2, #16
    7dfe:	strb	r2, [r4, #0]
    7e00:	b.n	7daa <SPIClass::setSCK(unsigned char)+0xa>
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setSCK_soft(pin);
	}
	if (pin != hardware().sck_pin[sck_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
    7e02:	movs	r1, #1
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
    7e04:	ldr	r5, [r3, #0]
    7e06:	ldr	r4, [r3, #4]
    7e08:	ldr	r5, [r5, #0]
    7e0a:	tst	r5, r4
    7e0c:	beq.n	7e2e <SPIClass::setSCK(unsigned char)+0x8e>
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    7e0e:	ldr	r4, [pc, #60]	; (7e4c <SPIClass::setSCK(unsigned char)+0xac>)
    7e10:	add.w	r2, r4, r2, lsl #3
					*reg = 0;
    7e14:	movs	r6, #0
	if (pin != hardware().sck_pin[sck_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    7e16:	ldr	r5, [r2, #4]
					*reg = 0;
					reg = portConfigRegister(hardware().sck_pin[i]);
    7e18:	adds	r2, r3, r1
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
					*reg = 0;
    7e1a:	str	r6, [r5, #0]
					reg = portConfigRegister(hardware().sck_pin[i]);
    7e1c:	ldrb.w	r2, [r2, #64]	; 0x40
    7e20:	add.w	r4, r4, r2, lsl #3
					*reg = hardware().sck_mux[i];
    7e24:	add.w	r3, r3, r1, lsl #2
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().sck_pin[i]);
    7e28:	ldr	r2, [r4, #4]
					*reg = hardware().sck_mux[i];
    7e2a:	ldr	r3, [r3, #68]	; 0x44
    7e2c:	str	r3, [r2, #0]
				}	
				sck_pin_index = i;
    7e2e:	strb	r1, [r0, #10]
				return;
    7e30:	b.n	7dd2 <SPIClass::setSCK(unsigned char)+0x32>
		pinout = newpinout;
#endif
	}
	inline void setSCK_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 13) pinout &= ~0x30;
    7e32:	ldr	r4, [pc, #20]	; (7e48 <SPIClass::setSCK(unsigned char)+0xa8>)
    7e34:	ldrb	r2, [r4, #0]
    7e36:	bic.w	r2, r2, #48	; 0x30
    7e3a:	strb	r2, [r4, #0]
    7e3c:	b.n	7daa <SPIClass::setSCK(unsigned char)+0xa>
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setSCK_soft(pin);
	}
	if (pin != hardware().sck_pin[sck_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
			if  (pin == hardware().sck_pin[i]) {
    7e3e:	movs	r1, #0
    7e40:	b.n	7e04 <SPIClass::setSCK(unsigned char)+0x64>
    7e42:	nop
    7e44:	.word	0x00014578
    7e48:	.word	0x1fff67d5
    7e4c:	.word	0x0001479c

00007e50 <SPIClass::transfer(void const*, void*, unsigned int)>:
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{

	if (count == 0) return;
    7e50:	cbz	r3, 7e56 <SPIClass::transfer(void const*, void*, unsigned int)+0x6>
    7e52:	b.w	7780 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]>
    7e56:	bx	lr

00007e58 <breakTime(long, tmElements_t&)>:
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
    7e58:	ldr	r2, [pc, #400]	; (7fec <breakTime(long, tmElements_t&)+0x194>)
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    7e5a:	ldr	r3, [pc, #404]	; (7ff0 <breakTime(long, tmElements_t&)+0x198>)
// leap year calculator expects year argument as years offset from 1970
#define LEAP_YEAR(Y)     ( ((1970+(Y))>0) && !((1970+(Y))%4) && ( ((1970+(Y))%100) || !((1970+(Y))%400) ) )

static  const uint8_t monthDays[]={31,28,31,30,31,30,31,31,30,31,30,31}; // API starts months from 1, this array starts from 0
 
void breakTime(time_t timeInput, tmElements_t &tm){
    7e5c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    7e60:	ldr	r6, [pc, #400]	; (7ff4 <breakTime(long, tmElements_t&)+0x19c>)
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    7e62:	ldr.w	sl, [pc, #416]	; 8004 <breakTime(long, tmElements_t&)+0x1ac>
  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    7e66:	ldr	r4, [pc, #400]	; (7ff8 <breakTime(long, tmElements_t&)+0x1a0>)
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
  
  year = 0;  
  days = 0;
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    7e68:	ldr.w	r9, [pc, #400]	; 7ffc <breakTime(long, tmElements_t&)+0x1a4>
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
    7e6c:	umull	r5, r2, r2, r0
    7e70:	mov.w	ip, r2, lsr #16
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    7e74:	add.w	r7, ip, #4
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    7e78:	umull	r2, r5, r3, r0
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    7e7c:	umull	r6, r2, r6, r0
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    7e80:	umull	sl, fp, r7, sl
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    7e84:	lsrs	r5, r5, #5
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    7e86:	lsrs	r2, r2, #11
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    7e88:	umull	r6, r3, r3, r5
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    7e8c:	umull	r6, r4, r4, r2
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    7e90:	rsb	r6, fp, r7
    7e94:	add.w	r6, fp, r6, lsr #1
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    7e98:	lsrs	r3, r3, #5
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    7e9a:	lsrs	r6, r6, #2
  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    7e9c:	lsrs	r4, r4, #4
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    7e9e:	rsb	r6, r6, r6, lsl #3
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    7ea2:	rsb	r3, r3, r3, lsl #4
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    7ea6:	add.w	r4, r4, r4, lsl #1
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    7eaa:	sub.w	r3, r5, r3, lsl #2
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    7eae:	subs	r6, r7, r6
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    7eb0:	rsb	r5, r5, r5, lsl #4
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    7eb4:	sub.w	r2, r2, r4, lsl #3
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    7eb8:	sub.w	r0, r0, r5, lsl #2
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    7ebc:	adds	r6, #1
    7ebe:	movs	r4, #0
  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    7ec0:	strb	r2, [r1, #2]
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    7ec2:	strb	r0, [r1, #0]
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    7ec4:	strb	r3, [r1, #1]
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    7ec6:	strb	r6, [r1, #3]
  
  year = 0;  
  days = 0;
    7ec8:	mov	r2, r4
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    7eca:	movw	fp, #365	; 0x16d
    7ece:	mov.w	r8, #100	; 0x64
    7ed2:	mov.w	sl, #400	; 0x190
    7ed6:	b.n	7ef6 <breakTime(long, tmElements_t&)+0x9e>
    7ed8:	rsb	r5, r6, r5, asr #7
    7edc:	mls	r5, sl, r5, r3
    7ee0:	cbnz	r0, 7f40 <breakTime(long, tmElements_t&)+0xe8>
    7ee2:	cmp	r5, #0
    7ee4:	ite	ne
    7ee6:	movne	r0, fp
    7ee8:	moveq.w	r0, #366	; 0x16e
    7eec:	add	r2, r0
    7eee:	cmp	ip, r2
    7ef0:	add.w	r4, r4, #1
    7ef4:	bcc.n	7f1e <breakTime(long, tmElements_t&)+0xc6>
    7ef6:	uxtb	r7, r4
    7ef8:	addw	r3, r7, #1970	; 0x7b2
    7efc:	smull	r0, r5, r9, r3
    7f00:	asrs	r6, r3, #31
    7f02:	rsb	r0, r6, r5, asr #5
    7f06:	ands.w	lr, r3, #3
    7f0a:	mls	r0, r8, r0, r3
    7f0e:	beq.n	7ed8 <breakTime(long, tmElements_t&)+0x80>
    7f10:	movw	r0, #365	; 0x16d
    7f14:	add	r2, r0
    7f16:	cmp	ip, r2
    7f18:	add.w	r4, r4, #1
    7f1c:	bcs.n	7ef6 <breakTime(long, tmElements_t&)+0x9e>
    year++;
  }
  tm.Year = year; // year is offset from 1970 
    7f1e:	strb	r7, [r1, #6]
  
  days -= LEAP_YEAR(year) ? 366 : 365;
    7f20:	cmp.w	lr, #0
    7f24:	bne.n	7f46 <breakTime(long, tmElements_t&)+0xee>
    7f26:	ldr	r0, [pc, #212]	; (7ffc <breakTime(long, tmElements_t&)+0x1a4>)
    7f28:	asrs	r6, r3, #31
    7f2a:	smull	r4, r0, r0, r3
    7f2e:	rsb	r4, r6, r0, asr #5
    7f32:	movs	r5, #100	; 0x64
    7f34:	mls	r4, r5, r4, r3
    7f38:	cbz	r4, 7faa <breakTime(long, tmElements_t&)+0x152>
    7f3a:	mov.w	r4, #366	; 0x16e
    7f3e:	b.n	7f4c <breakTime(long, tmElements_t&)+0xf4>
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
  
  year = 0;  
  days = 0;
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    7f40:	mov.w	r0, #366	; 0x16e
    7f44:	b.n	7eec <breakTime(long, tmElements_t&)+0x94>
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
    7f46:	movw	r4, #365	; 0x16d
    7f4a:	asrs	r6, r3, #31
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    7f4c:	ldr	r0, [pc, #172]	; (7ffc <breakTime(long, tmElements_t&)+0x1a4>)
        monthLength=29;
      } else {
        monthLength=28;
      }
    } else {
      monthLength = monthDays[month];
    7f4e:	ldr	r5, [pc, #176]	; (8000 <breakTime(long, tmElements_t&)+0x1a8>)
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    7f50:	smull	r7, r0, r0, r3
    7f54:	rsb	r8, r6, r0, asr #5
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
  time  -= days; // now it is days in this year, starting at 0
    7f58:	subs	r2, r2, r4
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    7f5a:	rsb	r6, r6, r0, asr #7
    7f5e:	movs	r4, #100	; 0x64
    7f60:	mov.w	r0, #400	; 0x190
    7f64:	mls	r6, r0, r6, r3
    7f68:	mls	r8, r4, r8, r3
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
  time  -= days; // now it is days in this year, starting at 0
    7f6c:	rsb	r2, r2, ip
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    7f70:	movs	r0, #1
    7f72:	movs	r3, #0
    7f74:	b.n	7f7c <breakTime(long, tmElements_t&)+0x124>
    7f76:	adds	r0, #1
    7f78:	uxtb	r0, r0
    7f7a:	adds	r3, #1
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
    7f7c:	cmp	r3, #1
    7f7e:	uxtb	r7, r3
    7f80:	beq.n	7fc4 <breakTime(long, tmElements_t&)+0x16c>
      }
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
    7f82:	ldrb	r4, [r3, r5]
    7f84:	cmp	r4, r2
    7f86:	bhi.n	7f9c <breakTime(long, tmElements_t&)+0x144>
  time  -= days; // now it is days in this year, starting at 0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    7f88:	cmp	r0, #12
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
      time -= monthLength;
    7f8a:	sub.w	r2, r2, r4
  time  -= days; // now it is days in this year, starting at 0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    7f8e:	bne.n	7f76 <breakTime(long, tmElements_t&)+0x11e>
    7f90:	movs	r7, #13
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
  tm.Day = time + 1;     // day of month
    7f92:	adds	r2, #1
    7f94:	strb	r2, [r1, #4]
      time -= monthLength;
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
    7f96:	strb	r7, [r1, #5]
  tm.Day = time + 1;     // day of month
}
    7f98:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7f9c:	adds	r7, #1
    7f9e:	uxtb	r7, r7
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
  tm.Day = time + 1;     // day of month
    7fa0:	adds	r2, #1
    7fa2:	strb	r2, [r1, #4]
      time -= monthLength;
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
    7fa4:	strb	r7, [r1, #5]
  tm.Day = time + 1;     // day of month
}
    7fa6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
    7faa:	mov.w	r4, #400	; 0x190
    7fae:	rsb	r0, r6, r0, asr #7
    7fb2:	mls	r0, r4, r0, r3
    7fb6:	cmp	r0, #0
    7fb8:	movw	r4, #365	; 0x16d
    7fbc:	it	eq
    7fbe:	moveq.w	r4, #366	; 0x16e
    7fc2:	b.n	7f4c <breakTime(long, tmElements_t&)+0xf4>
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    7fc4:	cmp.w	lr, #0
    7fc8:	bne.n	7fe0 <breakTime(long, tmElements_t&)+0x188>
    7fca:	cmp.w	r8, #0
    7fce:	bne.n	7fe8 <breakTime(long, tmElements_t&)+0x190>
    7fd0:	cmp	r6, #0
    7fd2:	ite	ne
    7fd4:	movne	r4, #28
    7fd6:	moveq	r4, #29
      }
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
    7fd8:	cmp	r2, r4
    7fda:	bcc.n	7fe4 <breakTime(long, tmElements_t&)+0x18c>
      time -= monthLength;
    7fdc:	subs	r2, r2, r4
    7fde:	b.n	7f76 <breakTime(long, tmElements_t&)+0x11e>
    7fe0:	movs	r4, #28
    7fe2:	b.n	7fd8 <breakTime(long, tmElements_t&)+0x180>
      }
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
    7fe4:	movs	r7, #2
    7fe6:	b.n	7f92 <breakTime(long, tmElements_t&)+0x13a>
    7fe8:	movs	r4, #29
    7fea:	b.n	7fd8 <breakTime(long, tmElements_t&)+0x180>
    7fec:	.word	0xc22e4507
    7ff0:	.word	0x88888889
    7ff4:	.word	0x91a2b3c5
    7ff8:	.word	0xaaaaaaab
    7ffc:	.word	0x51eb851f
    8000:	.word	0x00014668
    8004:	.word	0x24924925

00008008 <refreshCache(long) [clone .part.0]>:

static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
    8008:	push	{r4, lr}
  if (t != cacheTime) {
    breakTime(t, tm); 
    800a:	ldr	r1, [pc, #12]	; (8018 <refreshCache(long) [clone .part.0]+0x10>)

static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
    800c:	mov	r4, r0
  if (t != cacheTime) {
    breakTime(t, tm); 
    800e:	bl	7e58 <breakTime(long, tmElements_t&)>
    cacheTime = t; 
    8012:	ldr	r3, [pc, #8]	; (801c <refreshCache(long) [clone .part.0]+0x14>)
    8014:	str	r4, [r3, #0]
    8016:	pop	{r4, pc}
    8018:	.word	0x1fff616c
    801c:	.word	0x1fff6168

00008020 <now()>:
#ifdef TIME_DRIFT_INFO   // define this to get drift data
time_t sysUnsyncedTime = 0; // the time sysTime unadjusted by sync  
#endif


time_t now() {
    8020:	push	{r4, r5, r6, r7, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    8022:	ldr	r4, [pc, #128]	; (80a4 <now()+0x84>)
	// calculate number of seconds passed since last call to now()
  while (millis() - prevMillis >= 1000) {
    8024:	ldr	r6, [pc, #128]	; (80a8 <now()+0x88>)
    8026:	ldr	r3, [r4, #0]
    8028:	ldr	r2, [r6, #0]
    802a:	ldr	r5, [pc, #128]	; (80ac <now()+0x8c>)
#ifdef TIME_DRIFT_INFO   // define this to get drift data
time_t sysUnsyncedTime = 0; // the time sysTime unadjusted by sync  
#endif


time_t now() {
    802c:	sub	sp, #12
    802e:	ldr	r0, [r5, #0]
    8030:	str	r3, [sp, #0]
	return ret;
    8032:	ldr	r3, [sp, #0]
	// calculate number of seconds passed since last call to now()
  while (millis() - prevMillis >= 1000) {
    8034:	subs	r3, r3, r2
    8036:	cmp.w	r3, #1000	; 0x3e8
    803a:	bcc.n	805c <now()+0x3c>
    803c:	adds	r0, #1
    803e:	b.n	8042 <now()+0x22>
    8040:	mov	r0, r1
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    8042:	ldr	r3, [r4, #0]
    8044:	str	r3, [sp, #0]
	return ret;
    8046:	ldr	r3, [sp, #0]
		// millis() and prevMillis are both unsigned ints thus the subtraction will always be the absolute value of the difference
    sysTime++;
    prevMillis += 1000;	
    8048:	add.w	r2, r2, #1000	; 0x3e8
#endif


time_t now() {
	// calculate number of seconds passed since last call to now()
  while (millis() - prevMillis >= 1000) {
    804c:	subs	r3, r3, r2
    804e:	cmp.w	r3, #1000	; 0x3e8
    8052:	add.w	r1, r0, #1
    8056:	bcs.n	8040 <now()+0x20>
    8058:	str	r0, [r5, #0]
    805a:	str	r2, [r6, #0]
    prevMillis += 1000;	
#ifdef TIME_DRIFT_INFO
    sysUnsyncedTime++; // this can be compared to the synced time to measure long term drift     
#endif
  }
  if (nextSyncTime <= sysTime) {
    805c:	ldr	r7, [pc, #80]	; (80b0 <now()+0x90>)
    805e:	ldr	r3, [r7, #0]
    8060:	cmp	r0, r3
    8062:	bcc.n	8084 <now()+0x64>
    if (getTimePtr != 0) {
    8064:	ldr	r3, [pc, #76]	; (80b4 <now()+0x94>)
    8066:	ldr	r3, [r3, #0]
    8068:	cbz	r3, 8084 <now()+0x64>
      time_t t = getTimePtr();
    806a:	blx	r3
 if(sysUnsyncedTime == 0) 
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = (uint32_t)t;  
  nextSyncTime = (uint32_t)t + syncInterval;
    806c:	ldr	r3, [pc, #72]	; (80b8 <now()+0x98>)
#endif
  }
  if (nextSyncTime <= sysTime) {
    if (getTimePtr != 0) {
      time_t t = getTimePtr();
      if (t != 0) {
    806e:	cbnz	r0, 8088 <now()+0x68>
        setTime(t);
      } else {
        nextSyncTime = sysTime + syncInterval;
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
    8070:	ldr	r1, [pc, #72]	; (80bc <now()+0x9c>)
    if (getTimePtr != 0) {
      time_t t = getTimePtr();
      if (t != 0) {
        setTime(t);
      } else {
        nextSyncTime = sysTime + syncInterval;
    8072:	ldr	r2, [r3, #0]
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
    8074:	ldrb	r3, [r1, #0]
    if (getTimePtr != 0) {
      time_t t = getTimePtr();
      if (t != 0) {
        setTime(t);
      } else {
        nextSyncTime = sysTime + syncInterval;
    8076:	ldr	r0, [r5, #0]
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
    8078:	adds	r3, #0
    if (getTimePtr != 0) {
      time_t t = getTimePtr();
      if (t != 0) {
        setTime(t);
      } else {
        nextSyncTime = sysTime + syncInterval;
    807a:	add	r2, r0
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
    807c:	it	ne
    807e:	movne	r3, #1
    if (getTimePtr != 0) {
      time_t t = getTimePtr();
      if (t != 0) {
        setTime(t);
      } else {
        nextSyncTime = sysTime + syncInterval;
    8080:	str	r2, [r7, #0]
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
    8082:	strb	r3, [r1, #0]
      }
    }
  }  
  return (time_t)sysTime;
}
    8084:	add	sp, #12
    8086:	pop	{r4, r5, r6, r7, pc}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    8088:	ldr	r2, [r4, #0]
    808a:	str	r2, [sp, #4]
 if(sysUnsyncedTime == 0) 
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = (uint32_t)t;  
  nextSyncTime = (uint32_t)t + syncInterval;
    808c:	ldr	r3, [r3, #0]
  Status = timeSet;
    808e:	ldr	r2, [pc, #44]	; (80bc <now()+0x9c>)
	return ret;
    8090:	ldr	r4, [sp, #4]
#ifdef TIME_DRIFT_INFO
 if(sysUnsyncedTime == 0) 
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = (uint32_t)t;  
    8092:	str	r0, [r5, #0]
  nextSyncTime = (uint32_t)t + syncInterval;
    8094:	add	r3, r0
  Status = timeSet;
    8096:	movs	r1, #2
  prevMillis = millis();  // restart counting from now (thanks to Korman for this fix)
    8098:	str	r4, [r6, #0]
 if(sysUnsyncedTime == 0) 
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = (uint32_t)t;  
  nextSyncTime = (uint32_t)t + syncInterval;
    809a:	str	r3, [r7, #0]
  Status = timeSet;
    809c:	strb	r1, [r2, #0]
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
      }
    }
  }  
  return (time_t)sysTime;
}
    809e:	add	sp, #12
    80a0:	pop	{r4, r5, r6, r7, pc}
    80a2:	nop
    80a4:	.word	0x1fff66b0
    80a8:	.word	0x1fff6180
    80ac:	.word	0x1fff6174
    80b0:	.word	0x1fff6184
    80b4:	.word	0x1fff617c
    80b8:	.word	0x1fff09d0
    80bc:	.word	0x1fff6178

000080c0 <hour()>:
    breakTime(t, tm); 
    cacheTime = t; 
  }
}

int hour() { // the hour now 
    80c0:	push	{r3, lr}
  return hour(now()); 
    80c2:	bl	8020 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    80c6:	ldr	r3, [pc, #16]	; (80d8 <hour()+0x18>)
    80c8:	ldr	r3, [r3, #0]
    80ca:	cmp	r0, r3
    80cc:	beq.n	80d2 <hour()+0x12>
    80ce:	bl	8008 <refreshCache(long) [clone .part.0]>
  return hour(now()); 
}

int hour(time_t t) { // the hour for the given time
  refreshCache(t);
  return tm.Hour;  
    80d2:	ldr	r3, [pc, #8]	; (80dc <hour()+0x1c>)
  }
}

int hour() { // the hour now 
  return hour(now()); 
}
    80d4:	ldrb	r0, [r3, #2]
    80d6:	pop	{r3, pc}
    80d8:	.word	0x1fff6168
    80dc:	.word	0x1fff616c

000080e0 <minute()>:

uint8_t isPM(time_t t) { // returns true if PM
  return (hour(t) >= 12); 
}

int minute() {
    80e0:	push	{r3, lr}
  return minute(now()); 
    80e2:	bl	8020 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    80e6:	ldr	r3, [pc, #16]	; (80f8 <minute()+0x18>)
    80e8:	ldr	r3, [r3, #0]
    80ea:	cmp	r0, r3
    80ec:	beq.n	80f2 <minute()+0x12>
    80ee:	bl	8008 <refreshCache(long) [clone .part.0]>
  return minute(now()); 
}

int minute(time_t t) { // the minute for the given time
  refreshCache(t);
  return tm.Minute;  
    80f2:	ldr	r3, [pc, #8]	; (80fc <minute()+0x1c>)
  return (hour(t) >= 12); 
}

int minute() {
  return minute(now()); 
}
    80f4:	ldrb	r0, [r3, #1]
    80f6:	pop	{r3, pc}
    80f8:	.word	0x1fff6168
    80fc:	.word	0x1fff616c

00008100 <second()>:
int minute(time_t t) { // the minute for the given time
  refreshCache(t);
  return tm.Minute;  
}

int second() {
    8100:	push	{r3, lr}
  return second(now()); 
    8102:	bl	8020 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    8106:	ldr	r3, [pc, #16]	; (8118 <second()+0x18>)
    8108:	ldr	r3, [r3, #0]
    810a:	cmp	r0, r3
    810c:	beq.n	8112 <second()+0x12>
    810e:	bl	8008 <refreshCache(long) [clone .part.0]>
  return second(now()); 
}

int second(time_t t) {  // the second for the given time
  refreshCache(t);
  return tm.Second;
    8112:	ldr	r3, [pc, #8]	; (811c <second()+0x1c>)
  return tm.Minute;  
}

int second() {
  return second(now()); 
}
    8114:	ldrb	r0, [r3, #0]
    8116:	pop	{r3, pc}
    8118:	.word	0x1fff6168
    811c:	.word	0x1fff616c

00008120 <day()>:
int second(time_t t) {  // the second for the given time
  refreshCache(t);
  return tm.Second;
}

int day(){
    8120:	push	{r3, lr}
  return(day(now())); 
    8122:	bl	8020 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    8126:	ldr	r3, [pc, #16]	; (8138 <day()+0x18>)
    8128:	ldr	r3, [r3, #0]
    812a:	cmp	r0, r3
    812c:	beq.n	8132 <day()+0x12>
    812e:	bl	8008 <refreshCache(long) [clone .part.0]>
  return(day(now())); 
}

int day(time_t t) { // the day for the given time (0-6)
  refreshCache(t);
  return tm.Day;
    8132:	ldr	r3, [pc, #8]	; (813c <day()+0x1c>)
  return tm.Second;
}

int day(){
  return(day(now())); 
}
    8134:	ldrb	r0, [r3, #4]
    8136:	pop	{r3, pc}
    8138:	.word	0x1fff6168
    813c:	.word	0x1fff616c

00008140 <month()>:
int weekday(time_t t) {
  refreshCache(t);
  return tm.Wday;
}
   
int month(){
    8140:	push	{r3, lr}
  return month(now()); 
    8142:	bl	8020 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    8146:	ldr	r3, [pc, #16]	; (8158 <month()+0x18>)
    8148:	ldr	r3, [r3, #0]
    814a:	cmp	r0, r3
    814c:	beq.n	8152 <month()+0x12>
    814e:	bl	8008 <refreshCache(long) [clone .part.0]>
  return month(now()); 
}

int month(time_t t) {  // the month for the given time
  refreshCache(t);
  return tm.Month;
    8152:	ldr	r3, [pc, #8]	; (815c <month()+0x1c>)
  return tm.Wday;
}
   
int month(){
  return month(now()); 
}
    8154:	ldrb	r0, [r3, #5]
    8156:	pop	{r3, pc}
    8158:	.word	0x1fff6168
    815c:	.word	0x1fff616c

00008160 <year()>:
int month(time_t t) {  // the month for the given time
  refreshCache(t);
  return tm.Month;
}

int year() {  // as in Processing, the full four digit year: (2009, 2010 etc) 
    8160:	push	{r3, lr}
  return year(now()); 
    8162:	bl	8020 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    8166:	ldr	r3, [pc, #20]	; (817c <year()+0x1c>)
    8168:	ldr	r3, [r3, #0]
    816a:	cmp	r0, r3
    816c:	beq.n	8172 <year()+0x12>
    816e:	bl	8008 <refreshCache(long) [clone .part.0]>
  return year(now()); 
}

int year(time_t t) { // the year for the given time
  refreshCache(t);
  return tmYearToCalendar(tm.Year);
    8172:	ldr	r3, [pc, #12]	; (8180 <year()+0x20>)
  refreshCache(t);
  return tm.Month;
}

int year() {  // as in Processing, the full four digit year: (2009, 2010 etc) 
  return year(now()); 
    8174:	ldrb	r0, [r3, #6]
}
    8176:	addw	r0, r0, #1970	; 0x7b2
    817a:	pop	{r3, pc}
    817c:	.word	0x1fff6168
    8180:	.word	0x1fff616c

00008184 <setSyncProvider(long (*)())>:
  return Status;
}

void setSyncProvider( getExternalTime getTimeFunction){
  getTimePtr = getTimeFunction;  
  nextSyncTime = sysTime;
    8184:	ldr	r1, [pc, #12]	; (8194 <setSyncProvider(long (*)())+0x10>)
    8186:	ldr	r2, [pc, #16]	; (8198 <setSyncProvider(long (*)())+0x14>)
  now(); // required to actually update the status
  return Status;
}

void setSyncProvider( getExternalTime getTimeFunction){
  getTimePtr = getTimeFunction;  
    8188:	ldr	r3, [pc, #16]	; (819c <setSyncProvider(long (*)())+0x18>)
  nextSyncTime = sysTime;
    818a:	ldr	r1, [r1, #0]
    818c:	str	r1, [r2, #0]
  now(); // required to actually update the status
  return Status;
}

void setSyncProvider( getExternalTime getTimeFunction){
  getTimePtr = getTimeFunction;  
    818e:	str	r0, [r3, #0]
  nextSyncTime = sysTime;
  now(); // this will sync the clock
    8190:	b.w	8020 <now()>
    8194:	.word	0x1fff6174
    8198:	.word	0x1fff6184
    819c:	.word	0x1fff617c

000081a0 <FsCache::sync() [clone .part.0]>:

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
    81a0:	push	{r3, r4, r5, r6, r7, lr}
    81a2:	mov	r4, r0
  if (m_status & CACHE_STATUS_DIRTY) {
    if (!m_blockDev->writeSector(m_sector, m_buffer)) {
    81a4:	add.w	r6, r0, #16
    81a8:	ldr	r0, [r0, #4]
    81aa:	ldr	r1, [r4, #12]
    81ac:	ldr	r3, [r0, #0]
    81ae:	mov	r2, r6
    81b0:	ldr	r3, [r3, #28]
    81b2:	blx	r3
    81b4:	cbz	r0, 81c8 <FsCache::sync() [clone .part.0]+0x28>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
    81b6:	ldrb	r3, [r4, #0]
    81b8:	lsls	r2, r3, #30
    81ba:	mov	r5, r0
    81bc:	bmi.n	81ce <FsCache::sync() [clone .part.0]+0x2e>
      if (!m_blockDev->writeSector(sector, m_buffer)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status &= ~CACHE_STATUS_DIRTY;
    81be:	bic.w	r3, r3, #1
    81c2:	strb	r3, [r4, #0]
  }
  return true;

 fail:
  return false;
}
    81c4:	mov	r0, r5
    81c6:	pop	{r3, r4, r5, r6, r7, pc}
    m_status &= ~CACHE_STATUS_DIRTY;
  }
  return true;

 fail:
  return false;
    81c8:	movs	r5, #0
}
    81ca:	mov	r0, r5
    81cc:	pop	{r3, r4, r5, r6, r7, pc}
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
      uint32_t sector = m_sector + m_mirrorOffset;
      if (!m_blockDev->writeSector(sector, m_buffer)) {
    81ce:	ldr	r0, [r4, #4]
    81d0:	ldr	r1, [r4, #12]
    81d2:	ldr	r2, [r0, #0]
    81d4:	ldr	r3, [r4, #8]
    81d6:	ldr	r7, [r2, #28]
    81d8:	add	r1, r3
    81da:	mov	r2, r6
    81dc:	blx	r7
    81de:	cmp	r0, #0
    81e0:	beq.n	81c8 <FsCache::sync() [clone .part.0]+0x28>
    81e2:	ldrb	r3, [r4, #0]
    81e4:	b.n	81be <FsCache::sync() [clone .part.0]+0x1e>
    81e6:	nop

000081e8 <FsCache::get(unsigned long, unsigned char)>:
 * DEALINGS IN THE SOFTWARE.
 */
#include "DebugMacros.h"
#include "FsCache.h"
//------------------------------------------------------------------------------
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
    81e8:	push	{r3, r4, r5, r6, r7, lr}
  if (!m_blockDev) {
    81ea:	ldr	r5, [r0, #4]
    81ec:	cbz	r5, 822e <FsCache::get(unsigned long, unsigned char)+0x46>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_sector != sector) {
    81ee:	ldr	r3, [r0, #12]
    81f0:	cmp	r3, r1
    81f2:	mov	r4, r0
    81f4:	mov	r7, r2
    81f6:	mov	r6, r1
    81f8:	beq.n	8218 <FsCache::get(unsigned long, unsigned char)+0x30>
 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
  if (m_status & CACHE_STATUS_DIRTY) {
    81fa:	ldrb	r3, [r0, #0]
    81fc:	lsls	r2, r3, #31
    81fe:	bmi.n	8226 <FsCache::get(unsigned long, unsigned char)+0x3e>
  if (m_sector != sector) {
    if (!sync()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
    8200:	lsls	r3, r7, #29
    8202:	bpl.n	8232 <FsCache::get(unsigned long, unsigned char)+0x4a>
    8204:	add.w	r5, r4, #16
      }
    }
    m_status = 0;
    m_sector = sector;
  }
  m_status |= option & CACHE_STATUS_MASK;
    8208:	and.w	r2, r7, #3
    820c:	movs	r3, #0
    820e:	orrs	r3, r2
    8210:	strb	r3, [r4, #0]
    8212:	mov	r0, r5
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status = 0;
    m_sector = sector;
    8214:	str	r6, [r4, #12]
  m_status |= option & CACHE_STATUS_MASK;
  return m_buffer;

 fail:
  return nullptr;
}
    8216:	pop	{r3, r4, r5, r6, r7, pc}
    8218:	ldrsb.w	r3, [r0], #16
      }
    }
    m_status = 0;
    m_sector = sector;
  }
  m_status |= option & CACHE_STATUS_MASK;
    821c:	and.w	r2, r7, #3
    8220:	orrs	r3, r2
    8222:	strb	r3, [r4, #0]
  return m_buffer;

 fail:
  return nullptr;
}
    8224:	pop	{r3, r4, r5, r6, r7, pc}
    8226:	bl	81a0 <FsCache::sync() [clone .part.0]>
  if (!m_blockDev) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_sector != sector) {
    if (!sync()) {
    822a:	cmp	r0, #0
    822c:	bne.n	8200 <FsCache::get(unsigned long, unsigned char)+0x18>
  }
  m_status |= option & CACHE_STATUS_MASK;
  return m_buffer;

 fail:
  return nullptr;
    822e:	movs	r0, #0
    8230:	pop	{r3, r4, r5, r6, r7, pc}
    if (!sync()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
      if (!m_blockDev->readSector(sector, m_buffer)) {
    8232:	ldr	r0, [r4, #4]
    8234:	ldr	r3, [r0, #0]
    8236:	add.w	r5, r4, #16
    823a:	ldr	r3, [r3, #12]
    823c:	mov	r2, r5
    823e:	mov	r1, r6
    8240:	blx	r3
    8242:	cmp	r0, #0
    8244:	bne.n	8208 <FsCache::get(unsigned long, unsigned char)+0x20>
    8246:	b.n	822e <FsCache::get(unsigned long, unsigned char)+0x46>

00008248 <FsCache::sync()>:
 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
  if (m_status & CACHE_STATUS_DIRTY) {
    8248:	ldrb	r3, [r0, #0]
    824a:	lsls	r3, r3, #31
    824c:	bmi.n	8252 <FsCache::sync()+0xa>
  }
  return true;

 fail:
  return false;
}
    824e:	movs	r0, #1
    8250:	bx	lr
    8252:	b.w	81a0 <FsCache::sync() [clone .part.0]>
    8256:	nop

00008258 <ExFatFile::close()>:
#include "../common/DebugMacros.h"
#include "ExFatFile.h"
#include "ExFatVolume.h"
#include "upcase.h"
//------------------------------------------------------------------------------
bool ExFatFile::close() {
    8258:	push	{r4, lr}
    825a:	mov	r4, r0
  bool rtn = sync();
    825c:	bl	944c <ExFatFile::sync()>
  m_attributes = FILE_ATTR_CLOSED;
    8260:	movs	r3, #0
    8262:	strb.w	r3, [r4, #49]	; 0x31
  m_flags = 0;
    8266:	strb.w	r3, [r4, #51]	; 0x33
  return rtn;
}
    826a:	pop	{r4, pc}

0000826c <ExFatFile::getName(char*, unsigned int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName(ExChar_t* name, size_t length) {
    826c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  DirName_t* dn;
  DirPos_t pos = m_dirPos;
    8270:	add.w	r3, r0, #36	; 0x24

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName(ExChar_t* name, size_t length) {
    8274:	mov	r9, r0
    8276:	mov	r7, r1
    8278:	mov	r5, r2
  DirName_t* dn;
  DirPos_t pos = m_dirPos;
    827a:	ldmia.w	r3, {r0, r1, r2}

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName(ExChar_t* name, size_t length) {
    827e:	sub	sp, #20
  DirName_t* dn;
  DirPos_t pos = m_dirPos;
  size_t n = 0;
  if (!isOpen()) {
    8280:	ldrb.w	r3, [r9, #49]	; 0x31
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName(ExChar_t* name, size_t length) {
  DirName_t* dn;
  DirPos_t pos = m_dirPos;
    8284:	add	r6, sp, #4
    8286:	stmia.w	r6, {r0, r1, r2}
  size_t n = 0;
  if (!isOpen()) {
    828a:	cmp	r3, #0
    828c:	beq.n	830c <ExFatFile::getName(char*, unsigned int)+0xa0>
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 1; is < m_setCount; is++) {
    828e:	ldrb.w	r3, [r9, #48]	; 0x30
    8292:	cmp	r3, #1
    8294:	bls.n	8316 <ExFatFile::getName(char*, unsigned int)+0xaa>
    8296:	mov.w	r8, #1
    829a:	movs	r4, #0
    if (m_vol->dirSeek(&pos, is == 1 ? 64: 32) != 1) {
    829c:	cmp.w	r8, #1
    82a0:	ite	ne
    82a2:	movne	r2, #32
    82a4:	moveq	r2, #64	; 0x40
    82a6:	mov	r1, r6
    82a8:	ldr.w	r0, [r9, #32]
    82ac:	bl	8e38 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
    82b0:	cmp	r0, #1
    82b2:	bne.n	830c <ExFatFile::getName(char*, unsigned int)+0xa0>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dn = reinterpret_cast<DirName_t*>
         (m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ));
    82b4:	movs	r2, #0
    82b6:	mov	r1, r6
    82b8:	ldr.w	r0, [r9, #32]
    82bc:	bl	8e04 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
    82c0:	cbz	r0, 830c <ExFatFile::getName(char*, unsigned int)+0xa0>
    82c2:	ldrb	r3, [r0, #0]
    82c4:	cmp	r3, #193	; 0xc1
    82c6:	bne.n	830c <ExFatFile::getName(char*, unsigned int)+0xa0>
    82c8:	adds	r1, r7, r4
    82ca:	add.w	lr, r4, #15
    82ce:	b.n	82d2 <ExFatFile::getName(char*, unsigned int)+0x66>
    82d0:	mov	r4, r2
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    82d2:	ldrh.w	r3, [r0, #2]!
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
      uint16_t c = getLe16(dn->unicode + 2*in);
      if (c == 0 || (n + 1) >= length) {
    82d6:	adds	r2, r4, #1
    82d8:	cbz	r3, 8300 <ExFatFile::getName(char*, unsigned int)+0x94>
    82da:	cmp	r2, r5
    82dc:	bcs.n	8300 <ExFatFile::getName(char*, unsigned int)+0x94>
        goto done;
      }
      name[n++] = sizeof(ExChar_t) > 1 || c < 0X7F ? c : '?';
    82de:	cmp	r3, #126	; 0x7e
    82e0:	ite	ls
    82e2:	uxtbls	r3, r3
    82e4:	movhi	r3, #63	; 0x3f
         (m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ));
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
    82e6:	cmp	r2, lr
      uint16_t c = getLe16(dn->unicode + 2*in);
      if (c == 0 || (n + 1) >= length) {
        goto done;
      }
      name[n++] = sizeof(ExChar_t) > 1 || c < 0X7F ? c : '?';
    82e8:	strb.w	r3, [r1], #1
         (m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ));
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
    82ec:	bne.n	82d0 <ExFatFile::getName(char*, unsigned int)+0x64>
  size_t n = 0;
  if (!isOpen()) {
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 1; is < m_setCount; is++) {
    82ee:	add.w	r8, r8, #1
    82f2:	ldrb.w	r3, [r9, #48]	; 0x30
    82f6:	uxtb.w	r8, r8
    82fa:	cmp	r3, r8
    82fc:	mov	r4, r2
    82fe:	bhi.n	829c <ExFatFile::getName(char*, unsigned int)+0x30>
      }
      name[n++] = sizeof(ExChar_t) > 1 || c < 0X7F ? c : '?';
    }
  }
 done:
  name[n] = 0;
    8300:	movs	r3, #0
  return n;
    8302:	mov	r0, r4
      }
      name[n++] = sizeof(ExChar_t) > 1 || c < 0X7F ? c : '?';
    }
  }
 done:
  name[n] = 0;
    8304:	strb	r3, [r7, r4]
  return n;

 fail:
  *name = 0;
  return 0;
}
    8306:	add	sp, #20
    8308:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 done:
  name[n] = 0;
  return n;

 fail:
  *name = 0;
    830c:	movs	r0, #0
    830e:	strb	r0, [r7, #0]
  return 0;
}
    8310:	add	sp, #20
    8312:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  size_t n = 0;
  if (!isOpen()) {
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 1; is < m_setCount; is++) {
    8316:	movs	r4, #0
    8318:	b.n	8300 <ExFatFile::getName(char*, unsigned int)+0x94>
    831a:	nop

0000831c <ExFatFile::openRoot(ExFatVolume*)>:
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRoot(ExFatVolume* vol) {
  if (isOpen()) {
    831c:	ldrb.w	r2, [r0, #49]	; 0x31
    8320:	cbz	r2, 8326 <ExFatFile::openRoot(ExFatVolume*)+0xa>
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
  return true;

 fail:
  return false;
    8322:	movs	r0, #0
    8324:	bx	lr
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRoot(ExFatVolume* vol) {
    8326:	push	{r3, r4, r5, lr}
    8328:	mov	r4, r0
    832a:	mov	r5, r1
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
    832c:	mov	r1, r2
    832e:	movs	r2, #56	; 0x38
    8330:	bl	1059c <memset>
  m_attributes = FILE_ATTR_ROOT;
    8334:	movs	r3, #64	; 0x40
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    8336:	movs	r0, #1
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
    8338:	strb.w	r3, [r4, #49]	; 0x31
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    833c:	strb.w	r0, [r4, #51]	; 0x33
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
  m_vol = vol;
    8340:	str	r5, [r4, #32]
    8342:	pop	{r3, r4, r5, pc}

00008344 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::parsePathName(const ExChar_t* path,
                            ExName_t* fname, const ExChar_t** ptr) {
    8344:	push	{r4, r5, r6, r7, lr}
  ExChar_t c;
  int end;
  int len = 0;

  // Skip leading spaces.
  while (*path == ' ') {
    8346:	ldrb	r0, [r1, #0]
    8348:	cmp	r0, #32
    834a:	bne.n	8354 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x10>
    834c:	ldrb.w	r0, [r1, #1]!
    8350:	cmp	r0, #32
    8352:	beq.n	834c <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x8>
    path++;
  }
  fname->lfn = path;
    8354:	str	r1, [r2, #4]

  for (len = 0; ; len++) {
    c = path[len];
    8356:	ldrb	r0, [r1, #0]
    if (c == 0 || isDirSeparator(c)) {
    8358:	cmp	r0, #0
    835a:	beq.n	8400 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xbc>
    835c:	cmp	r0, #47	; 0x2f
    835e:	beq.n	83b8 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x74>
 * \param[in] c character to be tested.
 *
 * \return true for legal character else false.
 */
inline bool lfnLegalChar(ExChar_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    8360:	cmp	r0, #92	; 0x5c
    8362:	beq.n	83a6 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x62>
    8364:	sub.w	r4, r0, #34	; 0x22
    8368:	uxtb	r4, r4
    836a:	cmp	r4, #29
    836c:	bls.n	83aa <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x66>
    836e:	ldr.w	lr, [pc, #148]	; 8404 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xc0>
    8372:	adds	r6, r1, #1
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    8374:	movs	r4, #0
      c == ':' || c == '<' || c == '>' || c == '?' || c == '|') {
    8376:	cmp	r0, #124	; 0x7c
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
    8378:	sub.w	r5, r0, #32
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    c = path[len];
    837c:	mov	r7, r6
    837e:	beq.n	83a6 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x62>
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
    8380:	cmp	r5, #94	; 0x5e
    8382:	bhi.n	83a6 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x62>
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    c = path[len];
    8384:	ldrb.w	r0, [r6], #1
 * \param[in] c character to be tested.
 *
 * \return true for legal character else false.
 */
inline bool lfnLegalChar(ExChar_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    8388:	sub.w	r5, r0, #34	; 0x22
    838c:	uxtb	r5, r5
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    838e:	adds	r4, #1
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
    8390:	cbz	r0, 83f2 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xae>
    8392:	cmp	r0, #47	; 0x2f
    8394:	beq.n	83ba <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x76>
    8396:	cmp	r0, #92	; 0x5c
    8398:	lsr.w	r7, lr, r5
    839c:	beq.n	83a6 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x62>
    839e:	cmp	r5, #29
    83a0:	bhi.n	8376 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x32>
    83a2:	lsls	r5, r7, #31
    83a4:	bpl.n	8376 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x32>
      break;
    }
    if (!lfnLegalChar(c)) {
      return false;
    83a6:	movs	r0, #0
    83a8:	pop	{r4, r5, r6, r7, pc}
    83aa:	ldr	r5, [pc, #88]	; (8404 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xc0>)
    83ac:	lsr.w	r4, r5, r4
    83b0:	lsls	r6, r4, #31
    83b2:	bpl.n	836e <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x2a>
    83b4:	movs	r0, #0
    83b6:	pop	{r4, r5, r6, r7, pc}
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    83b8:	movs	r4, #0
    83ba:	adds	r7, r1, r4
    83bc:	mov	r6, r7
    83be:	mov	r5, r4
    83c0:	movs	r0, #47	; 0x2f
    83c2:	b.n	83ca <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x86>
    83c4:	ldrb.w	r0, [r6, #1]!
    if (!lfnLegalChar(c)) {
      return false;
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
    83c8:	adds	r5, #1
    83ca:	cmp	r0, #32
    83cc:	beq.n	83c4 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x80>
    83ce:	cmp	r0, #47	; 0x2f
    83d0:	beq.n	83c4 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x80>
  *ptr = &path[end];
    83d2:	add	r1, r5
    83d4:	str	r1, [r3, #0]

  // Back over spaces and dots.
  while (len) {
    83d6:	cbz	r4, 83ea <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xa6>
    83d8:	mov	r1, r7
    c = path[len - 1];
    83da:	ldrb.w	r3, [r1, #-1]!
    if (c != '.' && c != ' ') {
    83de:	cmp	r3, #46	; 0x2e
    83e0:	beq.n	83e6 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xa2>
    83e2:	cmp	r3, #32
    83e4:	bne.n	83f8 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xb4>
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];

  // Back over spaces and dots.
  while (len) {
    83e6:	subs	r4, #1
    83e8:	bne.n	83da <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x96>
    83ea:	mov	r0, r4
  }
  // Max length of LFN is 255.
  if (len > EXFAT_MAX_NAME_LENGTH) {
    return false;
  }
  fname->len = len;
    83ec:	str	r0, [r2, #0]
  return true;
    83ee:	movs	r0, #1
    83f0:	pop	{r4, r5, r6, r7, pc}
      return false;
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];
    83f2:	str	r7, [r3, #0]
    83f4:	adds	r7, r1, r4
    83f6:	b.n	83d8 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x94>
      break;
    }
    len--;
  }
  // Max length of LFN is 255.
  if (len > EXFAT_MAX_NAME_LENGTH) {
    83f8:	cmp	r4, #255	; 0xff
    83fa:	ble.n	83ea <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xa6>
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
      return false;
    83fc:	movs	r0, #0
    83fe:	pop	{r4, r5, r6, r7, pc}
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];
    8400:	str	r1, [r3, #0]
    8402:	b.n	83ec <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xa8>
    8404:	.word	0x35000101

00008408 <ExFatFile::read(void*, unsigned int)>:
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    8408:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    840c:	ldrb.w	r3, [r0, #51]	; 0x33
  uint8_t* cache;
  uint16_t sectorOffset;
  uint32_t sector;
  uint32_t clusterOffset;

  if (!isReadable()) {
    8410:	lsls	r6, r3, #31
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    8412:	sub	sp, #12
    8414:	mov	r4, r0
  uint8_t* cache;
  uint16_t sectorOffset;
  uint32_t sector;
  uint32_t clusterOffset;

  if (!isReadable()) {
    8416:	bpl.n	84ce <ExFatFile::read(void*, unsigned int)+0xc6>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isContiguous() || isFile()) {
    8418:	lsls	r5, r3, #25
    841a:	mov	r6, r1
    841c:	mov	fp, r2
    841e:	bpl.w	8592 <ExFatFile::read(void*, unsigned int)+0x18a>
    if ((m_curPosition + count) > m_validLength) {
    8422:	ldrd	r0, r1, [r4]
    8426:	ldrd	r2, r3, [r4, #16]
    842a:	adds.w	r8, r0, fp
    842e:	adc.w	r9, r1, #0
    8432:	cmp	r3, r9
    8434:	it	eq
    8436:	cmpeq	r2, r8
    8438:	bcc.w	859e <ExFatFile::read(void*, unsigned int)+0x196>
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
    843c:	cmp.w	fp, #0
    8440:	beq.n	8520 <ExFatFile::read(void*, unsigned int)+0x118>
    8442:	mov	r9, r4
    8444:	ldrd	r0, r1, [r9], #24
    8448:	mov	r5, fp
    clusterOffset = m_curPosition & m_vol->clusterMask();
    844a:	ldr	r7, [r4, #32]
    844c:	ldr.w	r3, [r7, #1080]	; 0x438
    8450:	ands	r3, r0
    sectorOffset = clusterOffset & m_vol->sectorMask();
    8452:	ubfx	sl, r3, #0, #9
    if (clusterOffset == 0) {
    8456:	cmp	r3, #0
    8458:	bne.n	852c <ExFatFile::read(void*, unsigned int)+0x124>
      if (m_curPosition == 0) {
    845a:	orrs.w	r2, r0, r1
    845e:	bne.n	854c <ExFatFile::read(void*, unsigned int)+0x144>
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
    8460:	ldrb.w	r2, [r4, #49]	; 0x31
    8464:	lsls	r1, r2, #25
    8466:	ite	mi
    8468:	ldrmi.w	r2, [r7, #1076]	; 0x434
    846c:	ldrpl	r2, [r4, #28]
      } else if (isContiguous()) {
        m_curCluster++;
    846e:	str	r2, [r4, #24]
          goto fail;
        }
      }
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    8470:	ldr.w	r0, [r7, #1068]	; 0x42c
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    8474:	ldrb.w	lr, [r7, #1093]	; 0x445
    8478:	lsrs	r3, r3, #9
    847a:	subs	r2, #2
    847c:	adds	r1, r3, r0
    847e:	lsl.w	r2, r2, lr
    8482:	add	r1, r2
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
                          || sector == m_vol->dataCacheSector()) {
    8484:	cmp.w	sl, #0
    8488:	bne.n	84e4 <ExFatFile::read(void*, unsigned int)+0xdc>
        }
      }
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
    848a:	cmp.w	r5, #512	; 0x200
    848e:	bcc.n	84e4 <ExFatFile::read(void*, unsigned int)+0xdc>
    8490:	ldr.w	r2, [r7, #540]	; 0x21c
                          || sector == m_vol->dataCacheSector()) {
    8494:	cmp	r1, r2
    8496:	beq.n	84e4 <ExFatFile::read(void*, unsigned int)+0xdc>
        goto fail;
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
    8498:	cmp.w	r5, #1024	; 0x400
    849c:	bcc.n	855a <ExFatFile::read(void*, unsigned int)+0x152>
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
      // Limit reads to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    849e:	mov.w	r8, #1
    84a2:	lsl.w	r8, r8, lr
    84a6:	rsb	r3, r3, r8
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
    84aa:	mov.w	r8, r5, lsr #9
    84ae:	cmp	r8, r3
    84b0:	it	cs
    84b2:	movcs	r8, r3
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    84b4:	cmp	r1, r2
    84b6:	bhi.n	8530 <ExFatFile::read(void*, unsigned int)+0x128>
    84b8:	add.w	r3, r8, r1
    84bc:	cmp	r2, r3
    84be:	bcs.n	8530 <ExFatFile::read(void*, unsigned int)+0x128>
   * \param[in] count Number of sectors to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool cacheSafeRead(uint32_t sector, uint8_t* dst, size_t count) {
    if (isCached(sector, count) && !sync()) {
    84c0:	add.w	r0, r7, #528	; 0x210
    84c4:	str	r1, [sp, #4]
    84c6:	bl	8248 <FsCache::sync()>
    84ca:	ldr	r1, [sp, #4]
    84cc:	cbnz	r0, 8530 <ExFatFile::read(void*, unsigned int)+0x128>
    toRead -= n;
  }
  return count - toRead;

 fail:
  m_error |= READ_ERROR;
    84ce:	ldrb.w	r3, [r4, #50]	; 0x32
  return -1;
    84d2:	mov.w	r0, #4294967295
    toRead -= n;
  }
  return count - toRead;

 fail:
  m_error |= READ_ERROR;
    84d6:	orr.w	r3, r3, #2
    84da:	strb.w	r3, [r4, #50]	; 0x32
  return -1;
}
    84de:	add	sp, #12
    84e0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    84e4:	add.w	r0, r7, #528	; 0x210
    84e8:	movs	r2, #0
    84ea:	bl	81e8 <FsCache::get(unsigned long, unsigned char)>
      if (n > toRead) {
        n = toRead;
      }
      // read sector to cache and copy data to caller
      cache = m_vol->dataCacheGet(sector, FsCache::CACHE_FOR_READ);
      if (!cache) {
    84ee:	cmp	r0, #0
    84f0:	beq.n	84ce <ExFatFile::read(void*, unsigned int)+0xc6>
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
                          || sector == m_vol->dataCacheSector()) {
      n = m_vol->bytesPerSector() - sectorOffset;
    84f2:	rsb	r8, sl, #512	; 0x200
    84f6:	cmp	r8, r5
    84f8:	it	cs
    84fa:	movcs	r8, r5
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
    84fc:	add.w	r1, r0, sl
    8500:	mov	r2, r8
    8502:	mov	r0, r6
    8504:	bl	d444 <memcpy>
    8508:	mov	r2, r8
    850a:	movs	r3, #0
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    850c:	ldrd	r0, r1, [r4]
    8510:	adds	r0, r0, r2
    8512:	adcs	r1, r3
  if (isContiguous() || isFile()) {
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
    8514:	subs.w	r5, r5, r8
      if (!m_vol->cacheSafeRead(sector, dst)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    8518:	add	r6, r8
    m_curPosition += n;
    851a:	strd	r0, r1, [r4]
  if (isContiguous() || isFile()) {
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
    851e:	bne.n	844a <ExFatFile::read(void*, unsigned int)+0x42>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    8520:	movs	r5, #0
    }
    dst += n;
    m_curPosition += n;
    toRead -= n;
  }
  return count - toRead;
    8522:	rsb	r0, r5, fp

 fail:
  m_error |= READ_ERROR;
  return -1;
}
    8526:	add	sp, #12
    8528:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    852c:	ldr	r2, [r4, #24]
    852e:	b.n	8470 <ExFatFile::read(void*, unsigned int)+0x68>
      return false;
    }
    return m_blockDev->readSectors(sector, dst, count);
    8530:	ldr.w	r0, [r7, #532]	; 0x214
    8534:	ldr	r3, [r0, #0]
    8536:	mov	r2, r6
    8538:	ldr	r7, [r3, #16]
    853a:	mov	r3, r8
    853c:	blx	r7
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
     if (!m_vol->cacheSafeRead(sector, dst, ns)) {
    853e:	cmp	r0, #0
    8540:	beq.n	84ce <ExFatFile::read(void*, unsigned int)+0xc6>
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
    8542:	mov.w	r8, r8, lsl #9
    8546:	mov	r2, r8
    8548:	movs	r3, #0
    854a:	b.n	850c <ExFatFile::read(void*, unsigned int)+0x104>
    sectorOffset = clusterOffset & m_vol->sectorMask();
    if (clusterOffset == 0) {
      if (m_curPosition == 0) {
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
      } else if (isContiguous()) {
    854c:	ldrb.w	r2, [r4, #51]	; 0x33
    8550:	lsls	r2, r2, #25
    8552:	bpl.n	8576 <ExFatFile::read(void*, unsigned int)+0x16e>
        m_curCluster++;
    8554:	ldr	r2, [r4, #24]
    8556:	adds	r2, #1
    8558:	b.n	846e <ExFatFile::read(void*, unsigned int)+0x66>
  bool cacheSafeRead(uint32_t sector, uint8_t* dst) {
    if (isCached(sector)) {
      memcpy(dst, m_buffer, 512);
      return true;
    }
    return m_blockDev->readSector(sector, dst);
    855a:	ldr.w	r0, [r7, #532]	; 0x214
    855e:	ldr	r3, [r0, #0]
    8560:	mov	r2, r6
    8562:	ldr	r3, [r3, #12]
    8564:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeRead(sector, dst)) {
    8566:	cmp	r0, #0
    8568:	beq.n	84ce <ExFatFile::read(void*, unsigned int)+0xc6>
    856a:	mov.w	r2, #512	; 0x200
    856e:	movs	r3, #0
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    8570:	mov.w	r8, #512	; 0x200
    8574:	b.n	850c <ExFatFile::read(void*, unsigned int)+0x104>
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
      } else if (isContiguous()) {
        m_curCluster++;
      } else {
        fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    8576:	mov	r0, r7
    8578:	mov	r2, r9
    857a:	ldr	r1, [r4, #24]
    857c:	str	r3, [sp, #4]
    857e:	bl	8e90 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    8582:	sxtb	r0, r0
        if (fg < 0) {
    8584:	cmp	r0, #0
    8586:	blt.n	84ce <ExFatFile::read(void*, unsigned int)+0xc6>
          DBG_FAIL_MACRO;
          goto fail;
        }
        if (fg == 0) {
    8588:	beq.n	85a4 <ExFatFile::read(void*, unsigned int)+0x19c>
    858a:	ldr	r7, [r4, #32]
    858c:	ldr	r2, [r4, #24]
    858e:	ldr	r3, [sp, #4]
    8590:	b.n	8470 <ExFatFile::read(void*, unsigned int)+0x68>

  if (!isReadable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isContiguous() || isFile()) {
    8592:	ldrb.w	r3, [r0, #49]	; 0x31
    8596:	lsls	r0, r3, #28
    8598:	bmi.w	8422 <ExFatFile::read(void*, unsigned int)+0x1a>
    859c:	b.n	843c <ExFatFile::read(void*, unsigned int)+0x34>
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    859e:	rsb	fp, r0, r2
    85a2:	b.n	843c <ExFatFile::read(void*, unsigned int)+0x34>
          DBG_FAIL_MACRO;
          goto fail;
        }
        if (fg == 0) {
          // EOF if directory.
          if (isDir()) {
    85a4:	ldrb.w	r3, [r4, #49]	; 0x31
    85a8:	tst.w	r3, #80	; 0x50
    85ac:	bne.n	8522 <ExFatFile::read(void*, unsigned int)+0x11a>
    85ae:	b.n	84ce <ExFatFile::read(void*, unsigned int)+0xc6>

000085b0 <ExFatFile::peek()>:
  }
  fname->len = len;
  return true;
}
//------------------------------------------------------------------------------
int ExFatFile::peek() {
    85b0:	push	{r4, r5, r6, r7, lr}
    85b2:	sub	sp, #12
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
    85b4:	movs	r2, #1
    85b6:	add.w	r1, sp, #7
    85ba:	mov	r4, r0
  uint64_t curPosition = m_curPosition;
    85bc:	ldrd	r6, r7, [r0]
  uint32_t curCluster = m_curCluster;
    85c0:	ldr	r5, [r0, #24]
    85c2:	bl	8408 <ExFatFile::read(void*, unsigned int)>
    85c6:	cmp	r0, #1
    85c8:	it	eq
    85ca:	ldrbeq.w	r0, [sp, #7]
  int c = read();
  m_curPosition = curPosition;
  m_curCluster = curCluster;
    85ce:	str	r5, [r4, #24]
    85d0:	it	ne
    85d2:	movne.w	r0, #4294967295
//------------------------------------------------------------------------------
int ExFatFile::peek() {
  uint64_t curPosition = m_curPosition;
  uint32_t curCluster = m_curCluster;
  int c = read();
  m_curPosition = curPosition;
    85d6:	strd	r6, r7, [r4]
  m_curCluster = curCluster;
  return c;
}
    85da:	add	sp, #12
    85dc:	pop	{r4, r5, r6, r7, pc}
    85de:	nop

000085e0 <ExFatFile::seekSet(unsigned long long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::seekSet(uint64_t pos) {
    85e0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    85e4:	ldrb.w	lr, [r0, #49]	; 0x31
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
    85e8:	ldr	r5, [r0, #24]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::seekSet(uint64_t pos) {
    85ea:	sub	sp, #12
    85ec:	mov	r4, r0
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    85ee:	cmp.w	lr, #0
    85f2:	beq.n	862c <ExFatFile::seekSet(unsigned long long)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    85f4:	ldrd	r0, r1, [r0]
    85f8:	cmp	r1, r3
    85fa:	it	eq
    85fc:	cmpeq	r0, r2
    85fe:	mov	r6, r2
    8600:	mov	r7, r3
    8602:	beq.n	867c <ExFatFile::seekSet(unsigned long long)+0x9c>
    return true;
  }
  if (pos == 0) {
    8604:	orrs.w	r3, r6, r7
    8608:	bne.n	861a <ExFatFile::seekSet(unsigned long long)+0x3a>
    // set position to start of file
    m_curCluster = 0;
    860a:	movs	r3, #0
    860c:	str	r3, [r4, #24]
    }
  }

 done:
  m_curPosition = pos;
  return true;
    860e:	movs	r0, #1
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    8610:	strd	r6, r7, [r4]
  return true;

 fail:
  m_curCluster = tmp;
  return false;
}
    8614:	add	sp, #12
    8616:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    goto done;
  }
  if (isFile()) {
    861a:	tst.w	lr, #8
    861e:	beq.n	8636 <ExFatFile::seekSet(unsigned long long)+0x56>
    if (pos > m_validLength) {
    8620:	ldrd	r2, r3, [r4, #16]
    8624:	cmp	r3, r7
    8626:	it	eq
    8628:	cmpeq	r2, r6
    862a:	bcs.n	8636 <ExFatFile::seekSet(unsigned long long)+0x56>
 done:
  m_curPosition = pos;
  return true;

 fail:
  m_curCluster = tmp;
    862c:	str	r5, [r4, #24]
  return false;
    862e:	movs	r0, #0
}
    8630:	add	sp, #12
    8632:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
    8636:	ldr	r3, [r4, #32]
    8638:	str	r3, [sp, #4]
    863a:	ldrb.w	ip, [r3, #1093]	; 0x445
  if (isContiguous()) {
    863e:	ldrb.w	sl, [r4, #51]	; 0x33
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
    8642:	add.w	ip, ip, #9
    8646:	uxtb.w	ip, ip
    864a:	adds.w	r2, r6, #4294967295
    864e:	adc.w	r3, r7, #4294967295
    8652:	rsb	r8, ip, #32
    8656:	lsl.w	fp, r3, r8
    865a:	lsr.w	r2, r2, ip
    865e:	orr.w	r2, r2, fp
    8662:	sub.w	fp, ip, #32
    8666:	lsr.w	r3, r3, fp
  if (isContiguous()) {
    866a:	tst.w	sl, #64	; 0x40
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
    866e:	orr.w	r2, r2, r3
  if (isContiguous()) {
    8672:	beq.n	8680 <ExFatFile::seekSet(unsigned long long)+0xa0>
    m_curCluster = m_firstCluster + nNew;
    8674:	ldr	r3, [r4, #28]
    8676:	add	r2, r3
    8678:	str	r2, [r4, #24]
    goto done;
    867a:	b.n	860e <ExFatFile::seekSet(unsigned long long)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    return true;
    867c:	movs	r0, #1
    867e:	b.n	8630 <ExFatFile::seekSet(unsigned long long)+0x50>
  if (isContiguous()) {
    m_curCluster = m_firstCluster + nNew;
    goto done;
  }
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> m_vol->bytesPerClusterShift();
    8680:	adds.w	r9, r0, #4294967295
    8684:	adc.w	sl, r1, #4294967295
    8688:	lsr.w	ip, r9, ip
    868c:	lsl.w	r8, sl, r8
    8690:	orr.w	ip, ip, r8
    8694:	lsr.w	fp, sl, fp
    8698:	orr.w	ip, ip, fp
  if (nNew < nCur || m_curPosition == 0) {
    869c:	cmp	r2, ip
  if (isContiguous()) {
    m_curCluster = m_firstCluster + nNew;
    goto done;
  }
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> m_vol->bytesPerClusterShift();
    869e:	mov	r3, sl
  if (nNew < nCur || m_curPosition == 0) {
    86a0:	bcs.n	86d2 <ExFatFile::seekSet(unsigned long long)+0xf2>
    // must follow chain from first cluster
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
    86a2:	tst.w	lr, #64	; 0x40
    86a6:	itet	ne
    86a8:	ldrne	r3, [sp, #4]
    86aa:	ldreq	r3, [r4, #28]
    86ac:	ldrne.w	r3, [r3, #1076]	; 0x434
    86b0:	str	r3, [r4, #24]
    86b2:	mov	r8, r2
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    86b4:	add.w	r9, r4, #24
    86b8:	mov	r2, r9
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    86ba:	cmp.w	r8, #0
    86be:	beq.n	860e <ExFatFile::seekSet(unsigned long long)+0x2e>
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    86c0:	ldr	r1, [r4, #24]
    86c2:	ldr	r0, [r4, #32]
    86c4:	bl	8e90 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    86c8:	add.w	r8, r8, #4294967295
    86cc:	cmp	r0, #0
    86ce:	bne.n	86b8 <ExFatFile::seekSet(unsigned long long)+0xd8>
    86d0:	b.n	862c <ExFatFile::seekSet(unsigned long long)+0x4c>
    m_curCluster = m_firstCluster + nNew;
    goto done;
  }
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> m_vol->bytesPerClusterShift();
  if (nNew < nCur || m_curPosition == 0) {
    86d2:	orrs.w	r3, r0, r1
    86d6:	beq.n	86a2 <ExFatFile::seekSet(unsigned long long)+0xc2>
    // must follow chain from first cluster
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
    86d8:	rsb	r2, ip, r2
    86dc:	b.n	86b2 <ExFatFile::seekSet(unsigned long long)+0xd2>
    86de:	nop

000086e0 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRootFile(ExFatFile* dir, const ExChar_t* name,
                          uint8_t nameLength, oflag_t oflag) {
    86e0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    86e4:	mov	r6, r1
    86e6:	sub	sp, #76	; 0x4c
  uint8_t freeCount = 0;
  uint8_t freeNeed;
  bool inSet = false;

  // error if already open
  if (isOpen() || !dir->isDir()) {
    86e8:	ldrb.w	r1, [r0, #49]	; 0x31
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRootFile(ExFatFile* dir, const ExChar_t* name,
                          uint8_t nameLength, oflag_t oflag) {
    86ec:	str	r2, [sp, #0]
    86ee:	mov	r5, r0
  uint8_t freeCount = 0;
  uint8_t freeNeed;
  bool inSet = false;

  // error if already open
  if (isOpen() || !dir->isDir()) {
    86f0:	cbnz	r1, 86fe <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    86f2:	mov	sl, r3
    86f4:	ldrb.w	r3, [r6, #49]	; 0x31
    86f8:	tst.w	r3, #80	; 0x50
    86fc:	bne.n	870e <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x2e>
  return sync();
#endif  // READ_ONLY
 fail:

  // close file
  m_attributes = FILE_ATTR_CLOSED;
    86fe:	movs	r0, #0
    8700:	strb.w	r0, [r5, #49]	; 0x31
  m_flags = 0;
    8704:	strb.w	r0, [r5, #51]	; 0x33
  return false;
}
    8708:	add	sp, #76	; 0x4c
    870a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  // error if already open
  if (isOpen() || !dir->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  switch (oflag & O_ACCMODE) {
    870e:	ldr	r3, [sp, #112]	; 0x70
    8710:	and.w	r3, r3, #3
    8714:	cmp	r3, #1
    8716:	beq.n	8726 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x46>
    8718:	cmp	r3, #2
    871a:	beq.w	8930 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x250>
    871e:	cmp	r3, #0
    8720:	bne.n	86fe <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    8722:	movs	r3, #1
    8724:	b.n	8728 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x48>
    8726:	movs	r3, #2
      break;
    default:
      DBG_FAIL_MACRO;
      goto fail;
  }
  modeFlags |= oflag & O_APPEND ? FILE_FLAG_APPEND : 0;
    8728:	ldr	r2, [sp, #112]	; 0x70
    872a:	and.w	r2, r2, #8
    872e:	orrs	r3, r2
    8730:	str	r3, [sp, #4]
  if (name) {
    8732:	ldr	r3, [sp, #0]
    8734:	cmp	r3, #0
    8736:	beq.w	8934 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x254>
    nameHash = exFatHashName(name, nameLength, 0);
    873a:	mov	r0, r3
    873c:	movs	r2, #0
    873e:	mov	r1, sl
    8740:	bl	910c <exFatHashName(char const*, unsigned int, unsigned short)>
bool ExFatFile::seekSet(uint64_t pos) {
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    8744:	ldrb.w	r3, [r6, #49]	; 0x31
      DBG_FAIL_MACRO;
      goto fail;
  }
  modeFlags |= oflag & O_APPEND ? FILE_FLAG_APPEND : 0;
  if (name) {
    nameHash = exFatHashName(name, nameLength, 0);
    8748:	str	r0, [sp, #8]
bool ExFatFile::seekSet(uint64_t pos) {
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    874a:	cbz	r3, 8760 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x80>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    874c:	ldrd	r2, r3, [r6]
    8750:	orrs	r3, r2
    8752:	beq.n	8760 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x80>
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    8754:	movs	r2, #0
    8756:	movs	r3, #0
    8758:	strd	r2, r3, [r6]
  if (pos == m_curPosition) {
    return true;
  }
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    875c:	movs	r1, #0
    875e:	str	r1, [r6, #24]
  modeFlags |= oflag & O_APPEND ? FILE_FLAG_APPEND : 0;
  if (name) {
    nameHash = exFatHashName(name, nameLength, 0);
    dir->rewind();
  }
  freeNeed = 2 + (nameLength + 14)/15;
    8760:	ldr	r2, [pc, #736]	; (8a44 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x364>)
    8762:	add.w	r3, sl, #14
    8766:	smull	r1, r2, r2, r3
    876a:	add	r2, r3
    876c:	asrs	r3, r3, #31
    876e:	rsb	r3, r3, r2, asr #3
    8772:	uxtb	r3, r3
  DirStream_t* dirStream;
  DirName_t*   dirName;
  uint8_t buf[32];
  uint8_t freeCount = 0;
  uint8_t freeNeed;
  bool inSet = false;
    8774:	mov.w	r9, #0
  modeFlags |= oflag & O_APPEND ? FILE_FLAG_APPEND : 0;
  if (name) {
    nameHash = exFatHashName(name, nameLength, 0);
    dir->rewind();
  }
  freeNeed = 2 + (nameLength + 14)/15;
    8778:	str	r3, [sp, #12]
    877a:	adds	r3, #2
    877c:	uxtb.w	fp, r3

  DirFile_t*   dirFile;
  DirStream_t* dirStream;
  DirName_t*   dirName;
  uint8_t buf[32];
  uint8_t freeCount = 0;
    8780:	mov	r4, r9
}
//------------------------------------------------------------------------------
bool ExFatFile::openRootFile(ExFatFile* dir, const ExChar_t* name,
                          uint8_t nameLength, oflag_t oflag) {
  int n;
  uint8_t nameOffset = 0;
    8782:	mov	r7, r9
    dir->rewind();
  }
  freeNeed = 2 + (nameLength + 14)/15;

  while (1) {
    n = dir->read(buf, 32);
    8784:	movs	r2, #32
    8786:	add	r1, sp, #40	; 0x28
    8788:	mov	r0, r6
    878a:	bl	8408 <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    878e:	cmp	r0, #0
    8790:	beq.n	880e <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x12e>
      goto create;
    }
    if (n != 32) {
    8792:	cmp	r0, #32
    8794:	bne.n	86fe <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(buf[0] & 0x80)) {
    8796:	ldrb.w	r3, [sp, #40]	; 0x28
    879a:	lsls	r2, r3, #24
    879c:	bmi.n	886c <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x18c>
      if (freeCount == 0) {
    879e:	cmp	r4, #0
    87a0:	bne.n	8866 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x186>
        freePos.position = dir->curPosition() - 32;
    87a2:	ldr	r2, [r6, #0]
        freePos.cluster = dir->curCluster();
    87a4:	ldr	r1, [r6, #24]
    87a6:	str	r1, [sp, #28]
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(buf[0] & 0x80)) {
      if (freeCount == 0) {
        freePos.position = dir->curPosition() - 32;
    87a8:	subs	r2, #32
    87aa:	str	r2, [sp, #32]
        freePos.cluster = dir->curCluster();
      }
      if (freeCount < freeNeed) {
        freeCount++;
    87ac:	adds	r4, #1
    87ae:	uxtb	r4, r4
      }
      if (!buf[0]) {
    87b0:	cbz	r3, 880e <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x12e>
      if (buf[0] != EXFAT_TYPE_FILE) {
        continue;
      }
      inSet = true;
    }
    switch (buf[0]) {
    87b2:	cmp	r3, #192	; 0xc0
    87b4:	beq.w	88de <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1fe>
    87b8:	cmp	r3, #193	; 0xc1
    87ba:	beq.n	8882 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1a2>
    87bc:	cmp	r3, #133	; 0x85
    87be:	bne.n	8784 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa4>
      case EXFAT_TYPE_FILE:
        memset(this, 0, sizeof(ExFatFile));
    87c0:	movs	r2, #56	; 0x38
    87c2:	movs	r1, #0
    87c4:	mov	r0, r5
    87c6:	bl	1059c <memset>
        dirFile = reinterpret_cast<DirFile_t*>(buf);
        m_setCount = dirFile->setCount;
        m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
    87ca:	ldrb.w	r3, [sp, #44]	; 0x2c
    }
    switch (buf[0]) {
      case EXFAT_TYPE_FILE:
        memset(this, 0, sizeof(ExFatFile));
        dirFile = reinterpret_cast<DirFile_t*>(buf);
        m_setCount = dirFile->setCount;
    87ce:	ldrb.w	r2, [sp, #41]	; 0x29
    87d2:	strb.w	r2, [r5, #48]	; 0x30
        m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
        if (!(m_attributes & EXFAT_ATTRIB_DIRECTORY)) {
    87d6:	lsls	r0, r3, #27
    switch (buf[0]) {
      case EXFAT_TYPE_FILE:
        memset(this, 0, sizeof(ExFatFile));
        dirFile = reinterpret_cast<DirFile_t*>(buf);
        m_setCount = dirFile->setCount;
        m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
    87d8:	and.w	r2, r3, #55	; 0x37
        if (!(m_attributes & EXFAT_ATTRIB_DIRECTORY)) {
          m_attributes |= FILE_ATTR_FILE;
    87dc:	it	pl
    87de:	orrpl.w	r2, r2, #8
    87e2:	strb.w	r2, [r5, #49]	; 0x31
        }
        m_vol = dir->volume();

        m_dirPos.cluster = dir->curCluster();
        m_dirPos.position = dir->curPosition() - 32;
    87e6:	ldr	r3, [r6, #0]
    87e8:	ldr	r1, [r6, #32]
    87ea:	ldr	r2, [r6, #24]
        if (!(m_attributes & EXFAT_ATTRIB_DIRECTORY)) {
          m_attributes |= FILE_ATTR_FILE;
        }
        m_vol = dir->volume();

        m_dirPos.cluster = dir->curCluster();
    87ec:	str	r2, [r5, #36]	; 0x24
        m_dirPos.position = dir->curPosition() - 32;
    87ee:	subs	r3, #32
        m_setCount = dirFile->setCount;
        m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
        if (!(m_attributes & EXFAT_ATTRIB_DIRECTORY)) {
          m_attributes |= FILE_ATTR_FILE;
        }
        m_vol = dir->volume();
    87f0:	str	r1, [r5, #32]

        m_dirPos.cluster = dir->curCluster();
        m_dirPos.position = dir->curPosition() - 32;
    87f2:	str	r3, [r5, #40]	; 0x28
        m_dirPos.isContiguous = dir->isContiguous();
    87f4:	ldrb.w	r3, [r6, #51]	; 0x33
    87f8:	ubfx	r3, r3, #6, #1
    87fc:	strb.w	r3, [r5, #44]	; 0x2c
    dir->rewind();
  }
  freeNeed = 2 + (nameLength + 14)/15;

  while (1) {
    n = dir->read(buf, 32);
    8800:	movs	r2, #32
    8802:	add	r1, sp, #40	; 0x28
    8804:	mov	r0, r6
    8806:	bl	8408 <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    880a:	cmp	r0, #0
    880c:	bne.n	8792 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xb2>
#if READ_ONLY
  DBG_FAIL_MACRO;
  goto fail;
#else  // READ_ONLY
  // don't create unless O_CREAT and write
  if (!(oflag & O_CREAT) || !(modeFlags & FILE_FLAG_WRITE) || !name) {
    880e:	ldr	r3, [sp, #112]	; 0x70
    8810:	lsls	r1, r3, #22
    8812:	bpl.w	86fe <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    8816:	ldr	r3, [sp, #4]
    8818:	lsls	r2, r3, #30
    881a:	bpl.w	86fe <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    881e:	ldr	r3, [sp, #0]
    8820:	cmp	r3, #0
    8822:	beq.w	86fe <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (freeCount < freeNeed) {
    8826:	cmp	r4, fp
    8828:	bcc.n	8844 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x164>
    882a:	b.n	893a <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x25a>
        goto fail;
      }
      dir->m_curCluster = curCluster;
      continue;
    }
    if (n != 32) {
    882c:	cmp	r0, #32
    882e:	bne.w	86fe <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (freeCount == 0) {
    8832:	cbnz	r4, 883e <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x15e>
      freePos.position = dir->curPosition() - 32;
    8834:	ldr	r2, [r6, #0]
      freePos.cluster = dir->curCluster();
    8836:	ldr	r1, [r6, #24]
    8838:	str	r1, [sp, #28]
    if (n != 32) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (freeCount == 0) {
      freePos.position = dir->curPosition() - 32;
    883a:	subs	r2, #32
    883c:	str	r2, [sp, #32]
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
    883e:	uxtb	r4, r3
  // don't create unless O_CREAT and write
  if (!(oflag & O_CREAT) || !(modeFlags & FILE_FLAG_WRITE) || !name) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (freeCount < freeNeed) {
    8840:	cmp	fp, r4
    8842:	bls.n	893a <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x25a>
    n = dir->read(buf, 32);
    8844:	movs	r2, #32
    8846:	add	r1, sp, #40	; 0x28
    8848:	mov	r0, r6
    884a:	bl	8408 <ExFatFile::read(void*, unsigned int)>
    }
    if (freeCount == 0) {
      freePos.position = dir->curPosition() - 32;
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
    884e:	adds	r3, r4, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (freeCount < freeNeed) {
    n = dir->read(buf, 32);
    if (n == 0) {
    8850:	cmp	r0, #0
    8852:	bne.n	882c <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x14c>
      curCluster = dir->m_curCluster;
      if (!dir->addDirCluster()) {
    8854:	mov	r0, r6
    goto fail;
  }
  while (freeCount < freeNeed) {
    n = dir->read(buf, 32);
    if (n == 0) {
      curCluster = dir->m_curCluster;
    8856:	ldr	r7, [r6, #24]
      if (!dir->addDirCluster()) {
    8858:	bl	94ac <ExFatFile::addDirCluster()>
    885c:	cmp	r0, #0
    885e:	beq.w	86fe <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
        DBG_FAIL_MACRO;
        goto fail;
      }
      dir->m_curCluster = curCluster;
    8862:	str	r7, [r6, #24]
      continue;
    8864:	b.n	8840 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x160>
    if (!(buf[0] & 0x80)) {
      if (freeCount == 0) {
        freePos.position = dir->curPosition() - 32;
        freePos.cluster = dir->curCluster();
      }
      if (freeCount < freeNeed) {
    8866:	cmp	r4, fp
    8868:	bcs.n	87b0 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xd0>
    886a:	b.n	87ac <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xcc>
        freeCount++;
      }
      if (!buf[0]) {
        goto create;
      }
    } else if (!inSet) {
    886c:	cmp.w	r9, #0
    8870:	bne.n	87b2 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xd2>
      if (freeCount < freeNeed) {
        freeCount = 0;
    8872:	cmp	r4, fp
    8874:	it	cc
    8876:	movcc	r4, #0
      }
      if (buf[0] != EXFAT_TYPE_FILE) {
    8878:	cmp	r3, #133	; 0x85
    887a:	bne.n	8784 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa4>
        continue;
      }
      inSet = true;
    887c:	mov.w	r9, #1
    8880:	b.n	87c0 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xe0>
        }
        break;

      case EXFAT_TYPE_NAME:
        dirName = reinterpret_cast<DirName_t*>(buf);
        nCmp = nameLength - nameOffset;
    8882:	rsb	r8, r7, sl
    8886:	uxtb.w	r8, r8
    888a:	cmp.w	r8, #15
    888e:	it	cs
    8890:	movcs.w	r8, #15
        if (nCmp > 15) {
          nCmp = 15;
        }
        if (!exFatCmpName(dirName, name, nameOffset, nCmp)) {
    8894:	mov	r3, r8
    8896:	mov	r2, r7
    8898:	ldr	r1, [sp, #0]
    889a:	add	r0, sp, #40	; 0x28
    889c:	bl	90b4 <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)>
    88a0:	cmp	r0, #0
    88a2:	beq.n	891e <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x23e>
          inSet = false;
          break;
        }
        nameOffset += nCmp;
    88a4:	add	r7, r8
    88a6:	uxtb	r7, r7

        if (nameOffset == nameLength) {
    88a8:	cmp	sl, r7
    88aa:	bne.w	8784 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa4>
    }
  }

 found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
    88ae:	ldr	r3, [sp, #112]	; 0x70
    88b0:	lsls	r3, r3, #20
    88b2:	bmi.w	86fe <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Write, truncate, or at end is an error for a directory or read-only file.
  if ((oflag & (O_TRUNC | O_AT_END)) || (m_flags & FILE_FLAG_WRITE)) {
    88b6:	ldr	r3, [sp, #112]	; 0x70
    88b8:	tst.w	r3, #17408	; 0x4400
    88bc:	bne.w	8a00 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x320>
    88c0:	ldrb.w	r3, [r5, #51]	; 0x33
    88c4:	lsls	r7, r3, #30
    88c6:	bmi.w	8a00 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x320>
      goto fail;
    }
  }

#if !READ_ONLY
  if (oflag & O_TRUNC) {
    88ca:	ldr	r3, [sp, #112]	; 0x70
    88cc:	lsls	r3, r3, #21
    88ce:	bmi.w	86fe <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    }
    if (!truncate(0)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if ((oflag & O_AT_END) && !seekSet(fileSize())) {
    88d2:	ldr	r3, [sp, #112]	; 0x70
    88d4:	lsls	r0, r3, #17
    88d6:	bmi.w	8a48 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x368>
    DBG_FAIL_MACRO;
    goto fail;
  }
#endif  // READ_ONLY
  return true;
    88da:	movs	r0, #1
    88dc:	b.n	8708 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x28>
        break;

      case EXFAT_TYPE_STREAM:
        dirStream = reinterpret_cast<DirStream_t*>(buf);
        m_flags = modeFlags;
        if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
    88de:	ldrb.w	r3, [sp, #41]	; 0x29
        m_dirPos.isContiguous = dir->isContiguous();
        break;

      case EXFAT_TYPE_STREAM:
        dirStream = reinterpret_cast<DirStream_t*>(buf);
        m_flags = modeFlags;
    88e2:	ldr	r2, [sp, #4]
    88e4:	strb.w	r2, [r5, #51]	; 0x33
        if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
    88e8:	lsls	r1, r3, #30
    88ea:	bpl.n	88f4 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x214>
          m_flags |= FILE_FLAG_CONTIGUOUS;
    88ec:	orr.w	r3, r2, #64	; 0x40
    88f0:	strb.w	r3, [r5, #51]	; 0x33
        }
        nameOffset = 0;
        m_validLength = getLe64(dirStream->validLength);
    88f4:	ldrd	r2, r3, [sp, #48]	; 0x30
        m_firstCluster = getLe32(dirStream->firstCluster);
        m_dataLength = getLe64(dirStream->dataLength);
    88f8:	ldrd	r0, r1, [sp, #64]	; 0x40
        m_flags = modeFlags;
        if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
          m_flags |= FILE_FLAG_CONTIGUOUS;
        }
        nameOffset = 0;
        m_validLength = getLe64(dirStream->validLength);
    88fc:	strd	r2, r3, [r5, #16]
        m_firstCluster = getLe32(dirStream->firstCluster);
    8900:	ldr	r3, [sp, #60]	; 0x3c
    8902:	str	r3, [r5, #28]
        m_dataLength = getLe64(dirStream->dataLength);
        if (!name) {
    8904:	ldr	r3, [sp, #0]
          m_flags |= FILE_FLAG_CONTIGUOUS;
        }
        nameOffset = 0;
        m_validLength = getLe64(dirStream->validLength);
        m_firstCluster = getLe32(dirStream->firstCluster);
        m_dataLength = getLe64(dirStream->dataLength);
    8906:	strd	r0, r1, [r5, #8]
        if (!name) {
    890a:	cmp	r3, #0
    890c:	beq.n	88ae <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1ce>
          goto found;
        }
        if (nameLength != dirStream->nameLength ||
    890e:	ldrb.w	r3, [sp, #43]	; 0x2b
    8912:	cmp	r3, sl
    8914:	beq.n	8922 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x242>
            nameHash != getLe16(dirStream->nameHash)) {
          inSet = false;
    8916:	mov.w	r9, #0
        dirStream = reinterpret_cast<DirStream_t*>(buf);
        m_flags = modeFlags;
        if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
          m_flags |= FILE_FLAG_CONTIGUOUS;
        }
        nameOffset = 0;
    891a:	mov	r7, r9
    891c:	b.n	8784 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa4>
        nCmp = nameLength - nameOffset;
        if (nCmp > 15) {
          nCmp = 15;
        }
        if (!exFatCmpName(dirName, name, nameOffset, nCmp)) {
          inSet = false;
    891e:	mov	r9, r0
    8920:	b.n	8784 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa4>
        m_firstCluster = getLe32(dirStream->firstCluster);
        m_dataLength = getLe64(dirStream->dataLength);
        if (!name) {
          goto found;
        }
        if (nameLength != dirStream->nameLength ||
    8922:	ldrh.w	r3, [sp, #44]	; 0x2c
    8926:	ldr	r2, [sp, #8]
    8928:	cmp	r3, r2
    892a:	bne.n	8916 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x236>
        dirStream = reinterpret_cast<DirStream_t*>(buf);
        m_flags = modeFlags;
        if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
          m_flags |= FILE_FLAG_CONTIGUOUS;
        }
        nameOffset = 0;
    892c:	movs	r7, #0
    892e:	b.n	8784 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa4>
  // error if already open
  if (isOpen() || !dir->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  switch (oflag & O_ACCMODE) {
    8930:	movs	r3, #3
    8932:	b.n	8728 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x48>
                          uint8_t nameLength, oflag_t oflag) {
  int n;
  uint8_t nameOffset = 0;
  uint8_t nCmp;
  uint8_t modeFlags;
  uint16_t nameHash = 0;
    8934:	ldr	r3, [sp, #0]
    8936:	str	r3, [sp, #8]
    8938:	b.n	8760 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x80>
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }

  freePos.isContiguous = dir->isContiguous();
    893a:	ldrb.w	r3, [r6, #51]	; 0x33
  memset(this, 0, sizeof(ExFatFile));
    893e:	movs	r2, #56	; 0x38
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }

  freePos.isContiguous = dir->isContiguous();
    8940:	ubfx	r3, r3, #6, #1
  memset(this, 0, sizeof(ExFatFile));
    8944:	movs	r1, #0
    8946:	mov	r0, r5
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
    8948:	add.w	r8, sp, #28
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }

  freePos.isContiguous = dir->isContiguous();
    894c:	strb.w	r3, [sp, #36]	; 0x24
  memset(this, 0, sizeof(ExFatFile));
    8950:	bl	1059c <memset>
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    8954:	ldr	r4, [sp, #12]
    8956:	ldr	r3, [r6, #32]
    8958:	str.w	sl, [sp, #12]

  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
    895c:	ldmia.w	r8, {r0, r1, r2}
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    8960:	add.w	r9, r4, #1
  }

  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
    8964:	movs	r4, #8
    8966:	strb.w	r4, [r5, #49]	; 0x31
    896a:	add.w	r7, sl, #30
  m_dirPos = freePos;
    896e:	add.w	r4, r5, #36	; 0x24
    8972:	ldr.w	sl, [sp]
    freeCount++;
  }

  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
    8976:	str	r3, [r5, #32]
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    8978:	uxtb.w	r9, r9

  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
    897c:	stmia.w	r4, {r0, r1, r2}
    8980:	uxtb	r7, r7
  for (uint8_t i = 0; i < freeNeed; i++) {
    8982:	movs	r6, #0
    8984:	mov	r0, r3
      if (1 != m_vol->dirSeek(&freePos, 32)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    cache = m_vol->dirCache(&freePos, FsCache::CACHE_FOR_WRITE);
    8986:	movs	r2, #1
    8988:	mov	r1, r8
    898a:	bl	8e04 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
    if (!cache || (cache[0] & 0x80)) {
    898e:	mov	r4, r0
    8990:	cmp	r0, #0
    8992:	beq.w	86fe <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    8996:	ldrsb.w	r3, [r0]
    899a:	cmp	r3, #0
    899c:	blt.w	86fe <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memset(cache, 0 , 32);
    89a0:	movs	r2, #32
    89a2:	movs	r1, #0
    89a4:	bl	1059c <memset>
    if (i == 0) {
    89a8:	cmp	r6, #0
    89aa:	beq.n	8a7a <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x39a>
         setLe16(dirFile->createTime, FS_DEFAULT_TIME);
         setLe16(dirFile->modifyTime, FS_DEFAULT_TIME);
         setLe16(dirFile->accessTime, FS_DEFAULT_TIME);
       }
      }
    } else if (i == 1) {
    89ac:	cmp	r6, #1
    89ae:	beq.n	8a5a <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x37a>
    89b0:	rsb	r3, r6, r6, lsl #4
    89b4:	cmp	r7, #15
    89b6:	sub.w	r3, r3, #30

      dirStream->nameLength = nameLength;
      setLe16(dirStream->nameHash, nameHash);
    } else {
      dirName = reinterpret_cast<DirName_t*>(cache);
      dirName->type = EXFAT_TYPE_NAME;
    89ba:	mov.w	r2, #193	; 0xc1
    89be:	mov	r1, r7
    89c0:	it	cs
    89c2:	movcs	r1, #15
    89c4:	uxtb	r3, r3
    89c6:	strb	r2, [r4, #0]
      nameOffset = 15*(i - 2);
      nCmp = nameLength - nameOffset;
      if (nCmp > 15) {
        nCmp = 15;
      }
      for (size_t k = 0; k < nCmp; k++) {
    89c8:	cbz	r1, 89e0 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x300>
    89ca:	adds	r4, #2
    89cc:	sxth	r1, r1
    89ce:	add.w	r1, r4, r1, lsl #1
    89d2:	add	r3, sl
        setLe16(dirName->unicode + 2*k, name[k + nameOffset]);
    89d4:	ldrb.w	r2, [r3], #1
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    89d8:	strh.w	r2, [r4], #2
      nameOffset = 15*(i - 2);
      nCmp = nameLength - nameOffset;
      if (nCmp > 15) {
        nCmp = 15;
      }
      for (size_t k = 0; k < nCmp; k++) {
    89dc:	cmp	r1, r4
    89de:	bne.n	89d4 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x2f4>
  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
  for (uint8_t i = 0; i < freeNeed; i++) {
    89e0:	adds	r6, #1
    89e2:	uxtb	r6, r6
    89e4:	cmp	fp, r6
    89e6:	bls.n	8a3c <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x35c>
    if (i) {
      if (1 != m_vol->dirSeek(&freePos, 32)) {
    89e8:	movs	r2, #32
    89ea:	mov	r1, r8
    89ec:	ldr	r0, [r5, #32]
    89ee:	bl	8e38 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
    89f2:	cmp	r0, #1
    89f4:	bne.w	86fe <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    89f8:	subs	r7, #15
    89fa:	uxtb	r7, r7
    89fc:	ldr	r0, [r5, #32]
    89fe:	b.n	8986 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x2a6>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Write, truncate, or at end is an error for a directory or read-only file.
  if ((oflag & (O_TRUNC | O_AT_END)) || (m_flags & FILE_FLAG_WRITE)) {
    if (isSubDir() || isReadOnly() || READ_ONLY) {
    8a00:	ldrb.w	r3, [r5, #49]	; 0x31
    8a04:	tst.w	r3, #17
    8a08:	bne.w	86fe <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
      goto fail;
    }
  }

#if !READ_ONLY
  if (oflag & O_TRUNC) {
    8a0c:	ldr	r3, [sp, #112]	; 0x70
    8a0e:	lsls	r6, r3, #21
    8a10:	bpl.w	88d2 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1f2>
    if (!(m_flags & FILE_FLAG_WRITE)) {
    8a14:	ldrb.w	r3, [r5, #51]	; 0x33
    8a18:	lsls	r4, r3, #30
    8a1a:	bpl.w	86fe <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return seekSet(length) && truncate();
    8a1e:	movs	r2, #0
    8a20:	movs	r3, #0
    8a22:	mov	r0, r5
    8a24:	bl	85e0 <ExFatFile::seekSet(unsigned long long)>
    8a28:	cmp	r0, #0
    8a2a:	beq.w	86fe <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    8a2e:	mov	r0, r5
    8a30:	bl	9774 <ExFatFile::truncate()>
    8a34:	cmp	r0, #0
    8a36:	beq.w	86fe <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
    8a3a:	b.n	88da <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1fa>
      for (size_t k = 0; k < nCmp; k++) {
        setLe16(dirName->unicode + 2*k, name[k + nameOffset]);
      }
    }
  }
  return sync();
    8a3c:	mov	r0, r5
    8a3e:	bl	944c <ExFatFile::sync()>
    8a42:	b.n	8708 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x28>
    8a44:	.word	0x88888889
    }
    if (!truncate(0)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if ((oflag & O_AT_END) && !seekSet(fileSize())) {
    8a48:	ldrd	r2, r3, [r5, #16]
    8a4c:	mov	r0, r5
    8a4e:	bl	85e0 <ExFatFile::seekSet(unsigned long long)>
    8a52:	cmp	r0, #0
    8a54:	bne.w	88da <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1fa>
    8a58:	b.n	86fe <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
         setLe16(dirFile->accessTime, FS_DEFAULT_TIME);
       }
      }
    } else if (i == 1) {
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
    8a5a:	movs	r3, #192	; 0xc0
    8a5c:	strb	r3, [r4, #0]
      dirStream->flags = EXFAT_FLAG_ALWAYS1 | EXFAT_FLAG_CONTIGUOUS;
      m_flags = modeFlags | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    8a5e:	ldr	r3, [sp, #4]
       }
      }
    } else if (i == 1) {
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
      dirStream->flags = EXFAT_FLAG_ALWAYS1 | EXFAT_FLAG_CONTIGUOUS;
    8a60:	movs	r2, #3
      m_flags = modeFlags | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    8a62:	orn	r3, r3, #63	; 0x3f
       }
      }
    } else if (i == 1) {
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
      dirStream->flags = EXFAT_FLAG_ALWAYS1 | EXFAT_FLAG_CONTIGUOUS;
    8a66:	strb	r2, [r4, #1]
      m_flags = modeFlags | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    8a68:	strb.w	r3, [r5, #51]	; 0x33

      dirStream->nameLength = nameLength;
    8a6c:	ldrb.w	r3, [sp, #12]
    8a70:	strb	r3, [r4, #3]
    8a72:	ldrh.w	r3, [sp, #8]
    8a76:	strh	r3, [r4, #4]
    8a78:	b.n	89e0 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x300>
      goto fail;
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
    8a7a:	movs	r3, #133	; 0x85
    8a7c:	strb	r3, [r4, #0]
      m_setCount = freeNeed - 1;
      dirFile->setCount = m_setCount;

      if (FsDateTime::callback) {
    8a7e:	ldr	r3, [pc, #56]	; (8ab8 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x3d8>)
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    8a80:	strb.w	r9, [r5, #48]	; 0x30
      dirFile->setCount = m_setCount;
    8a84:	strb.w	r9, [r4, #1]

      if (FsDateTime::callback) {
    8a88:	ldr	r3, [r3, #0]
    8a8a:	cbz	r3, 8aac <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x3cc>
        uint16_t date, time;
        uint8_t ms10;
        FsDateTime::callback(&date, &time, &ms10);
    8a8c:	add.w	r2, sp, #23
    8a90:	add.w	r1, sp, #26
    8a94:	add	r0, sp, #24
    8a96:	blx	r3
    8a98:	ldrh.w	r1, [sp, #24]
    8a9c:	ldrh.w	r2, [sp, #26]
        setLe16(dirFile->createDate, date);
        setLe16(dirFile->createTime, time);
        dirFile->createTimeMs = ms10;
    8aa0:	ldrb.w	r3, [sp, #23]
    8aa4:	strh	r1, [r4, #10]
    8aa6:	strh	r2, [r4, #8]
    8aa8:	strb	r3, [r4, #20]
    8aaa:	b.n	89e0 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x300>
    8aac:	movw	r3, #21025	; 0x5221
    8ab0:	strh	r3, [r4, #10]
    8ab2:	strh	r3, [r4, #14]
    8ab4:	strh	r3, [r4, #18]
    8ab6:	b.n	89e0 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x300>
    8ab8:	.word	0x1fff6188

00008abc <ExFatFile::open(ExFatFile*, char const*, int)>:
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const ExChar_t* path, int oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const ExChar_t* path, oflag_t oflag) {
    8abc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    8ac0:	mov	r6, r0
    8ac2:	sub	sp, #84	; 0x54
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    8ac4:	ldrb.w	r4, [r6, #49]	; 0x31
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const ExChar_t* path, int oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const ExChar_t* path, oflag_t oflag) {
    8ac8:	str	r2, [sp, #12]
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    8aca:	movs	r0, #0
    8acc:	strb.w	r0, [sp, #73]	; 0x49
    8ad0:	strb.w	r0, [sp, #74]	; 0x4a
    8ad4:	strb.w	r0, [sp, #75]	; 0x4b
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    8ad8:	cbnz	r4, 8ae8 <ExFatFile::open(ExFatFile*, char const*, int)+0x2c>
    8ada:	mov	r9, r3
    8adc:	ldrb.w	r3, [r1, #49]	; 0x31
    8ae0:	tst.w	r3, #80	; 0x50
    8ae4:	mov	r5, r1
    8ae6:	bne.n	8af0 <ExFatFile::open(ExFatFile*, char const*, int)+0x34>
    close();
  }
  return open(dirFile, &fname, oflag);

 fail:
  return false;
    8ae8:	movs	r0, #0
}
    8aea:	add	sp, #84	; 0x54
    8aec:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    8af0:	ldrb	r3, [r2, #0]
    8af2:	cmp	r3, #47	; 0x2f
    8af4:	mov	r4, r2
    8af6:	beq.n	8b5e <ExFatFile::open(ExFatFile*, char const*, int)+0xa2>
  uint8_t setCount() const {return m_setCount;}
  bool mkdir(ExFatFile* parent, ExName_t* fname);
  bool openRootFile(ExFatFile* dir,
                    const ExChar_t* name, uint8_t nameLength, oflag_t oflag);
  bool open(ExFatFile* dirFile, ExName_t* fname, oflag_t oflag) {
    return openRootFile(dirFile, fname->lfn, fname->len, oflag);
    8af8:	mov.w	r8, #0
      goto fail;
    }
    dirFile = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    8afc:	mov	r1, r4
    8afe:	add	r3, sp, #12
    8b00:	add	r2, sp, #16
    8b02:	mov	r0, r6
    8b04:	bl	8344 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>
    8b08:	cmp	r0, #0
    8b0a:	beq.n	8ae8 <ExFatFile::open(ExFatFile*, char const*, int)+0x2c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    8b0c:	ldr	r3, [sp, #12]
    8b0e:	ldrb	r3, [r3, #0]
    8b10:	cmp	r3, #0
    8b12:	beq.n	8b88 <ExFatFile::open(ExFatFile*, char const*, int)+0xcc>
    8b14:	ldrb.w	r3, [sp, #16]
    8b18:	ldr	r2, [sp, #20]
    8b1a:	str.w	r8, [sp]
    8b1e:	mov	r1, r5
    8b20:	mov	r0, r6
    8b22:	bl	86e0 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    8b26:	cmp	r0, #0
    8b28:	beq.n	8ae8 <ExFatFile::open(ExFatFile*, char const*, int)+0x2c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    8b2a:	mov	r4, r6
    8b2c:	add	r7, sp, #24
    8b2e:	add.w	lr, r6, #48	; 0x30
    8b32:	ldr	r0, [r4, #0]
    8b34:	ldr	r1, [r4, #4]
    8b36:	ldr	r2, [r4, #8]
    8b38:	ldr	r3, [r4, #12]
    8b3a:	mov	r5, r7
    8b3c:	stmia	r5!, {r0, r1, r2, r3}
    8b3e:	adds	r4, #16
    8b40:	cmp	r4, lr
    8b42:	mov	r7, r5
    8b44:	bne.n	8b32 <ExFatFile::open(ExFatFile*, char const*, int)+0x76>
    8b46:	ldr	r0, [r4, #0]
    8b48:	str	r0, [r5, #0]
#include "ExFatFile.h"
#include "ExFatVolume.h"
#include "upcase.h"
//------------------------------------------------------------------------------
bool ExFatFile::close() {
  bool rtn = sync();
    8b4a:	mov	r0, r6
    8b4c:	bl	944c <ExFatFile::sync()>
    if (!open(dirFile, &fname, O_RDONLY)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    dirFile = &tmpDir;
    8b50:	add	r5, sp, #24
#include "ExFatVolume.h"
#include "upcase.h"
//------------------------------------------------------------------------------
bool ExFatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
    8b52:	strb.w	r8, [r6, #49]	; 0x31
  m_flags = 0;
    8b56:	strb.w	r8, [r6, #51]	; 0x33
    8b5a:	ldr	r4, [sp, #12]
    8b5c:	b.n	8afc <ExFatFile::open(ExFatFile*, char const*, int)+0x40>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    8b5e:	adds	r4, #1
    8b60:	str	r4, [sp, #12]
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    8b62:	ldrb	r1, [r4, #0]
    8b64:	cmp	r1, #47	; 0x2f
    8b66:	beq.n	8b5e <ExFatFile::open(ExFatFile*, char const*, int)+0xa2>
      path++;
    }
    if (*path == 0) {
    8b68:	cbz	r1, 8ba0 <ExFatFile::open(ExFatFile*, char const*, int)+0xe4>
bool ExFatFile::openRoot(ExFatVolume* vol) {
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
    8b6a:	movs	r2, #56	; 0x38
    8b6c:	add	r0, sp, #24
    8b6e:	movs	r1, #0
      path++;
    }
    if (*path == 0) {
      return openRoot(dirFile->m_vol);
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
    8b70:	ldr	r7, [r5, #32]
bool ExFatFile::openRoot(ExFatVolume* vol) {
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
    8b72:	bl	1059c <memset>
  m_attributes = FILE_ATTR_ROOT;
    8b76:	movs	r2, #64	; 0x40
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    8b78:	movs	r3, #1
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
    8b7a:	add	r5, sp, #24
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
  m_vol = vol;
    8b7c:	str	r7, [sp, #56]	; 0x38
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
    8b7e:	strb.w	r2, [sp, #73]	; 0x49
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    8b82:	strb.w	r3, [sp, #75]	; 0x4b
    8b86:	b.n	8af8 <ExFatFile::open(ExFatFile*, char const*, int)+0x3c>
    8b88:	ldrb.w	r3, [sp, #16]
    8b8c:	ldr	r2, [sp, #20]
    8b8e:	str.w	r9, [sp]
    8b92:	mov	r1, r5
    8b94:	mov	r0, r6
    8b96:	bl	86e0 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>
  }
  return open(dirFile, &fname, oflag);

 fail:
  return false;
}
    8b9a:	add	sp, #84	; 0x54
    8b9c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
bool ExFatFile::openRoot(ExFatVolume* vol) {
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
    8ba0:	movs	r2, #56	; 0x38
    8ba2:	mov	r0, r6
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    }
    if (*path == 0) {
      return openRoot(dirFile->m_vol);
    8ba4:	ldr	r4, [r5, #32]
bool ExFatFile::openRoot(ExFatVolume* vol) {
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
    8ba6:	bl	1059c <memset>
  m_attributes = FILE_ATTR_ROOT;
    8baa:	movs	r3, #64	; 0x40
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    8bac:	movs	r0, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
  m_vol = vol;
    8bae:	str	r4, [r6, #32]
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
    8bb0:	strb.w	r3, [r6, #49]	; 0x31
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    8bb4:	strb.w	r0, [r6, #51]	; 0x33
    8bb8:	b.n	8aea <ExFatFile::open(ExFatFile*, char const*, int)+0x2e>
    8bba:	nop

00008bbc <ExFatFile::open(ExFatVolume*, char const*, int)>:
bool ExFatFile::open(const ExChar_t* path, int oflag) {
  return open(ExFatVolume::cwv(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const ExChar_t* path, int oflag) {
  return vol && open(vol->vwd(), path, oflag);
    8bbc:	cbz	r1, 8bc6 <ExFatFile::open(ExFatVolume*, char const*, int)+0xa>
    8bbe:	add.w	r1, r1, #1096	; 0x448
    8bc2:	b.w	8abc <ExFatFile::open(ExFatFile*, char const*, int)>
}
    8bc6:	mov	r0, r1
    8bc8:	bx	lr
    8bca:	nop

00008bcc <ExFatFile::openNext(ExFatFile*, int)>:
  }
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    8bcc:	ldrb.w	r3, [r0, #49]	; 0x31
    8bd0:	cbnz	r3, 8be8 <ExFatFile::openNext(ExFatFile*, int)+0x1c>
    DBG_FAIL_MACRO;
  }
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
    8bd2:	push	{r4, r5, lr}
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    8bd4:	ldrb.w	r4, [r1, #49]	; 0x31
    8bd8:	ands.w	r4, r4, #80	; 0x50
    DBG_FAIL_MACRO;
  }
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
    8bdc:	sub	sp, #12
    8bde:	mov	r5, r1
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    8be0:	bne.n	8bec <ExFatFile::openNext(ExFatFile*, int)+0x20>
    goto fail;
  }
  return openRootFile(dir, nullptr, 0, oflag);

 fail:
  return false;
    8be2:	mov	r0, r4
}
    8be4:	add	sp, #12
    8be6:	pop	{r4, r5, pc}
    goto fail;
  }
  return openRootFile(dir, nullptr, 0, oflag);

 fail:
  return false;
    8be8:	movs	r0, #0
}
    8bea:	bx	lr
  }
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    8bec:	ldrd	r4, r5, [r5]
    8bf0:	movs	r5, #0
    8bf2:	and.w	r4, r4, #31
    8bf6:	orrs	r4, r5
    8bf8:	beq.n	8c00 <ExFatFile::openNext(ExFatFile*, int)+0x34>
    goto fail;
  }
  return openRootFile(dir, nullptr, 0, oflag);

 fail:
  return false;
    8bfa:	mov	r0, r3
}
    8bfc:	add	sp, #12
    8bfe:	pop	{r4, r5, pc}
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  return openRootFile(dir, nullptr, 0, oflag);
    8c00:	str	r2, [sp, #0]
    8c02:	mov	r2, r3
    8c04:	bl	86e0 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>

 fail:
  return false;
}
    8c08:	add	sp, #12
    8c0a:	pop	{r4, r5, pc}

00008c0c <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]>:
    }
  }
  return 1;
}
//------------------------------------------------------------------------------
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    8c0c:	push	{r3, r4, r5, lr}
    8c0e:	mov	r4, r1
    8c10:	ldr.w	r1, [r0, #1060]	; 0x424
    8c14:	mov	r5, r2
    8c16:	add.w	r1, r1, r4, lsr #7
    8c1a:	add.w	r0, r0, #528	; 0x210
    8c1e:	movs	r2, #0
    8c20:	bl	81e8 <FsCache::get(unsigned long, unsigned char)>
    return -1;
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));

  cache = dataCacheGet(sector, FsCache::CACHE_FOR_READ);
  if (!cache) {
    8c24:	cbz	r0, 8c38 <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]+0x2c>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    8c26:	lsls	r4, r4, #2
    8c28:	ubfx	r4, r4, #0, #9
    8c2c:	ldr	r3, [r0, r4]
    return -1;
  }
  next = getLe32(cache + ((cluster << 2) & m_sectorMask));

  if (next == EXFAT_EOC) {
    8c2e:	adds	r2, r3, #1
    8c30:	beq.n	8c3c <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]+0x30>
    return 0;
  }
  *value = next;
    8c32:	str	r3, [r5, #0]
  return 1;
    8c34:	movs	r0, #1
    8c36:	pop	{r3, r4, r5, pc}
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));

  cache = dataCacheGet(sector, FsCache::CACHE_FOR_READ);
  if (!cache) {
    return -1;
    8c38:	movs	r0, #255	; 0xff
    8c3a:	pop	{r3, r4, r5, pc}
  }
  next = getLe32(cache + ((cluster << 2) & m_sectorMask));

  if (next == EXFAT_EOC) {
    return 0;
    8c3c:	movs	r0, #0
  }
  *value = next;
  return 1;
}
    8c3e:	pop	{r3, r4, r5, pc}

00008c40 <ExFatPartition::fatPut(unsigned long, unsigned long) [clone .part.4]>:
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
    8c40:	push	{r3, r4, r5, lr}
    8c42:	mov	r4, r1
    8c44:	ldr.w	r1, [r0, #1060]	; 0x424
    8c48:	mov	r5, r2
    8c4a:	add.w	r1, r1, r4, lsr #7
    8c4e:	add.w	r0, r0, #528	; 0x210
    8c52:	movs	r2, #1
    8c54:	bl	81e8 <FsCache::get(unsigned long, unsigned char)>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
  cache = dataCacheGet(sector, FsCache::CACHE_FOR_WRITE);
  if (!cache) {
    8c58:	mov	r3, r0
    8c5a:	cbz	r0, 8c68 <ExFatPartition::fatPut(unsigned long, unsigned long) [clone .part.4]+0x28>
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    8c5c:	lsls	r4, r4, #2
    8c5e:	ubfx	r4, r4, #0, #9
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe32(cache + ((cluster << 2) & m_sectorMask), value);
  return true;
    8c62:	movs	r0, #1
    8c64:	str	r5, [r3, r4]
    8c66:	pop	{r3, r4, r5, pc}

 fail:
  return false;
}
    8c68:	pop	{r3, r4, r5, pc}
    8c6a:	nop

00008c6c <ExFatPartition::bitmapFind(unsigned long, unsigned long)>:
#include "../common/DebugMacros.h"
#include "ExFatVolume.h"
#include "../common/FsStructs.h"
//------------------------------------------------------------------------------
// return 0 if error, 1 if no space, else start cluster.
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
    8c6c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8c70:	mov	r8, r0
    8c72:	mov	r9, r2
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
    8c74:	mov	fp, r1
    8c76:	cmp	r1, #0
    8c78:	beq.n	8d04 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x98>
    8c7a:	subs	r7, r1, #2
  if (start >= m_clusterCount) {
    8c7c:	ldr.w	r3, [r8, #1072]	; 0x430
    8c80:	cmp	r7, r3
    8c82:	bcs.n	8cfc <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x90>
    8c84:	and.w	r5, r7, #7
    8c88:	movs	r3, #1
    8c8a:	lsl.w	r5, r3, r5
    8c8e:	uxtb	r5, r5
    8c90:	ubfx	sl, r7, #3, #9
    start = 0;
  }
  uint32_t endAlloc = start;
  uint32_t bgnAlloc = start;
    8c94:	mov	r6, r7
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
  if (start >= m_clusterCount) {
    start = 0;
  }
  uint32_t endAlloc = start;
    8c96:	mov	r4, r7
  bool bitmapModify(uint32_t cluster, uint32_t count, bool value);
  //----------------------------------------------------------------------------
  // Cache functions.
  uint8_t* bitmapCacheGet(uint32_t sector, uint8_t option) {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.get(sector, option);
    8c98:	ldr.w	r1, [r8, #1068]	; 0x42c
    8c9c:	movs	r2, #0
    8c9e:	add.w	r1, r1, r4, lsr #12
    8ca2:	mov	r0, r8
    8ca4:	bl	81e8 <FsCache::get(unsigned long, unsigned char)>
  uint8_t mask = 1 << (start & 7);
  while (true) {
    uint32_t sector = m_clusterHeapStartSector +
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
    8ca8:	cbz	r0, 8cdc <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x70>
    8caa:	ldrb.w	r1, [r0, sl]
    8cae:	b.n	8cc6 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x5a>
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
        if (!(mask & cache[i])) {
          if ((endAlloc - bgnAlloc) == count) {
    8cb0:	cmp	r2, r9
    8cb2:	beq.n	8d0a <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x9e>
            return bgnAlloc + 2;
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
    8cb4:	cmp	r7, r4
    8cb6:	beq.n	8cda <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x6e>
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
    8cb8:	ldr.w	r2, [r8, #1072]	; 0x430
    8cbc:	cmp	r4, r2
    8cbe:	bcs.n	8cf0 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x84>
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
    8cc0:	ands.w	r5, r3, #255	; 0xff
    8cc4:	beq.n	8ce0 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x74>
        endAlloc++;
    8cc6:	adds	r4, #1
        if (!(mask & cache[i])) {
    8cc8:	tst	r5, r1
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
    8cca:	mov.w	r3, r5, lsl #1
        endAlloc++;
        if (!(mask & cache[i])) {
          if ((endAlloc - bgnAlloc) == count) {
    8cce:	sub.w	r2, r4, r6
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
        if (!(mask & cache[i])) {
    8cd2:	beq.n	8cb0 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x44>
            return bgnAlloc + 2;
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
    8cd4:	cmp	r7, r4
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
    8cd6:	mov	r6, r4
            return bgnAlloc + 2;
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
    8cd8:	bne.n	8cb8 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x4c>
          return 1;
    8cda:	movs	r0, #1
      mask = 1;
    }
    i = 0;
  }
  return 0;
}
    8cdc:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8ce0:	add.w	sl, sl, #1
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
    8ce4:	cmp.w	sl, #512	; 0x200
          endAlloc = bgnAlloc = 0;
          i = sectorSize;
          break;
        }
      }
      mask = 1;
    8ce8:	mov.w	r5, #1
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
    8cec:	bne.n	8caa <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x3e>
    8cee:	b.n	8cf4 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x88>
        }
        if (endAlloc == start) {
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
          endAlloc = bgnAlloc = 0;
    8cf0:	movs	r6, #0
    8cf2:	mov	r4, r6
          break;
        }
      }
      mask = 1;
    }
    i = 0;
    8cf4:	mov.w	sl, #0
    8cf8:	movs	r5, #1
    8cfa:	b.n	8c98 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x2c>
    8cfc:	movs	r7, #0
//------------------------------------------------------------------------------
// return 0 if error, 1 if no space, else start cluster.
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
  if (start >= m_clusterCount) {
    start = 0;
    8cfe:	mov	sl, r7
    8d00:	movs	r5, #1
    8d02:	b.n	8c94 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x28>
#include "ExFatVolume.h"
#include "../common/FsStructs.h"
//------------------------------------------------------------------------------
// return 0 if error, 1 if no space, else start cluster.
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
    8d04:	ldr.w	r7, [r0, #1056]	; 0x420
    8d08:	b.n	8c7c <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x10>
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
        if (!(mask & cache[i])) {
          if ((endAlloc - bgnAlloc) == count) {
            if (cluster == 0 && count == 1) {
    8d0a:	cmp.w	fp, #0
    8d0e:	bne.n	8d1a <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0xae>
    8d10:	cmp.w	r9, #1
              // Start at found sector.  bitmapModify may increase this.
              m_bitmapStart = bgnAlloc;
    8d14:	it	eq
    8d16:	streq.w	r6, [r8, #1056]	; 0x420
            }
            return bgnAlloc + 2;
    8d1a:	adds	r0, r6, #2
    8d1c:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

00008d20 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>:
  }
  return 0;
}
//------------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    8d20:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  uint32_t sector;
  uint32_t start = cluster - 2;
    8d24:	subs	r1, #2
  }
  return 0;
}
//------------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    8d26:	mov	r8, r0
  uint32_t start = cluster - 2;
  size_t i;
  uint8_t* cache;
  uint8_t mask;
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    8d28:	ldr.w	r0, [r0, #1072]	; 0x430
  }
  return 0;
}
//------------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    8d2c:	mov	r5, r2
  uint32_t start = cluster - 2;
  size_t i;
  uint8_t* cache;
  uint8_t mask;
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    8d2e:	adds	r2, r1, r2
    8d30:	cmp	r2, r0
    8d32:	bhi.n	8da6 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x86>
    8d34:	mov	sl, r3
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (value) {
    if (start  <= m_bitmapStart && m_bitmapStart < (start + count)) {
    8d36:	ldr.w	r3, [r8, #1056]	; 0x420
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (value) {
    8d3a:	cmp.w	sl, #0
    8d3e:	bne.n	8dac <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x8c>
    if (start  <= m_bitmapStart && m_bitmapStart < (start + count)) {
      m_bitmapStart = (start + count) < m_clusterCount ? start + count : 0;
    }
  } else {
    if (start < m_bitmapStart) {
    8d40:	cmp	r1, r3
      m_bitmapStart = start;
    8d42:	it	cc
    8d44:	strcc.w	r1, [r8, #1056]	; 0x420
    }
  }
  mask = 1 << (start & 7);
    8d48:	and.w	r4, r1, #7
    8d4c:	movs	r2, #1
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
    8d4e:	ldr.w	r3, [r8, #1068]	; 0x42c
  } else {
    if (start < m_bitmapStart) {
      m_bitmapStart = start;
    }
  }
  mask = 1 << (start & 7);
    8d52:	lsl.w	r4, r2, r4
    8d56:	uxtb	r4, r4
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
    8d58:	add.w	r9, r3, r1, lsr #12
  i = (start >> 3) & m_sectorMask;
    8d5c:	ubfx	r6, r1, #3, #9
    8d60:	movs	r2, #1
    8d62:	mov	r1, r9
    8d64:	mov	r0, r8
  while (true) {
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    8d66:	add	r9, r2
    8d68:	bl	81e8 <FsCache::get(unsigned long, unsigned char)>
    if (!cache) {
    8d6c:	cbz	r0, 8da6 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x86>
    8d6e:	adds	r7, r0, r6
    8d70:	add.w	r0, r0, #512	; 0x200
    8d74:	ldrb.w	r2, [r7], #1
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
        if (value == static_cast<bool>(cache[i] & mask)) {
    8d78:	tst	r2, r4
    8d7a:	ite	ne
    8d7c:	movne	r6, #1
    8d7e:	moveq	r6, #0
    8d80:	cmp	r6, sl
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
    8d82:	eor.w	r2, r2, r4
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
    8d86:	mov.w	r4, r4, lsl #1
        if (value == static_cast<bool>(cache[i] & mask)) {
    8d8a:	beq.n	8da6 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x86>
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
        if (--count == 0) {
    8d8c:	subs	r5, #1
      for (; mask; mask <<= 1) {
        if (value == static_cast<bool>(cache[i] & mask)) {
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
    8d8e:	strb.w	r2, [r7, #-1]
        if (--count == 0) {
    8d92:	beq.n	8dc0 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0xa0>
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
    8d94:	ands.w	r4, r4, #255	; 0xff
    8d98:	bne.n	8d78 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x58>
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
    8d9a:	cmp	r0, r7
          return true;
        }
      }
      mask = 1;
    }
    i = 0;
    8d9c:	mov	r6, r4
    8d9e:	mov.w	r4, #1
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
    8da2:	bne.n	8d74 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x54>
    8da4:	b.n	8d60 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x40>
    }
    i = 0;
  }

 fail:
  return false;
    8da6:	movs	r0, #0
    8da8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  if ((start + count) > m_clusterCount) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (value) {
    if (start  <= m_bitmapStart && m_bitmapStart < (start + count)) {
    8dac:	cmp	r1, r3
    8dae:	bhi.n	8d48 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x28>
    8db0:	cmp	r2, r3
    8db2:	bls.n	8d48 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x28>
      m_bitmapStart = (start + count) < m_clusterCount ? start + count : 0;
    8db4:	cmp	r2, r0
    8db6:	it	cs
    8db8:	movcs	r2, #0
    8dba:	str.w	r2, [r8, #1056]	; 0x420
    8dbe:	b.n	8d48 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x28>
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
        if (--count == 0) {
          return true;
    8dc0:	movs	r0, #1
    i = 0;
  }

 fail:
  return false;
}
    8dc2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    8dc6:	nop

00008dc8 <ExFatPartition::chainSize(unsigned long)>:
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
    8dc8:	push	{r4, r5, r6, lr}
    8dca:	sub	sp, #8
    8dcc:	add	r6, sp, #8
    8dce:	mov	r5, r0
    8dd0:	str.w	r1, [r6, #-4]!
  uint32_t n = 0;
    8dd4:	movs	r4, #0
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    8dd6:	ldr.w	r3, [r5, #1072]	; 0x430
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    status = fatGet(cluster, & cluster);
    8dda:	ldr	r1, [sp, #4]
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    8ddc:	adds	r3, #1
    8dde:	cmp	r1, r3
    8de0:	bls.n	8de8 <ExFatPartition::chainSize(unsigned long)+0x20>
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    status = fatGet(cluster, & cluster);
    if (status < 0) return 0;
    8de2:	movs	r0, #0
    n++;
  } while (status);
  return n;
}
    8de4:	add	sp, #8
    8de6:	pop	{r4, r5, r6, pc}
    8de8:	mov	r2, r6
    8dea:	mov	r0, r5
    8dec:	bl	8c0c <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]>
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    status = fatGet(cluster, & cluster);
    8df0:	sxtb	r0, r0
    if (status < 0) return 0;
    8df2:	cmp	r0, #0
    8df4:	blt.n	8de2 <ExFatPartition::chainSize(unsigned long)+0x1a>
    n++;
    8df6:	add.w	r4, r4, #1
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    8dfa:	bne.n	8dd6 <ExFatPartition::chainSize(unsigned long)+0xe>
    status = fatGet(cluster, & cluster);
    if (status < 0) return 0;
    n++;
    8dfc:	mov	r0, r4
  } while (status);
  return n;
}
    8dfe:	add	sp, #8
    8e00:	pop	{r4, r5, r6, pc}
    8e02:	nop

00008e04 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>:
//------------------------------------------------------------------------------
uint8_t* ExFatPartition::dirCache(DirPos_t* pos, uint8_t options) {
    8e04:	push	{r3, r4, r5, r6, r7, lr}
    8e06:	mov	r6, r1
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    8e08:	ldmia.w	r6, {r3, r5}
    8e0c:	ldr.w	r1, [r0, #1080]	; 0x438
    8e10:	ldr.w	r4, [r0, #1068]	; 0x42c
    8e14:	ldrb.w	r7, [r0, #1093]	; 0x445
    8e18:	ands	r1, r5
    8e1a:	subs	r3, #2
    8e1c:	add.w	r1, r4, r1, lsr #9
    8e20:	lsls	r3, r7
    8e22:	add	r1, r3
    8e24:	add.w	r0, r0, #528	; 0x210
    8e28:	bl	81e8 <FsCache::get(unsigned long, unsigned char)>
  uint32_t sector = clusterStartSector(pos->cluster);
  sector += (m_clusterMask & pos->position) >> m_bytesPerSectorShift;
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
    8e2c:	cbz	r0, 8e36 <ExFatPartition::dirCache(DirPos_t*, unsigned char)+0x32>
    8e2e:	ldr	r3, [r6, #4]
    8e30:	ubfx	r3, r3, #0, #9
    8e34:	add	r0, r3
}
    8e36:	pop	{r3, r4, r5, r6, r7, pc}

00008e38 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>:
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    8e38:	push	{r4, r5, r6, lr}
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
    8e3a:	ldr	r4, [r1, #4]
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    8e3c:	mov	r5, r1
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
  pos->position += offset;
    8e3e:	adds	r3, r4, r2
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
    8e40:	ldr.w	r1, [r0, #1080]	; 0x438
  pos->position += offset;
    8e44:	str	r3, [r5, #4]
  tmp >>= bytesPerClusterShift();
    8e46:	ldrb.w	r3, [r0, #1093]	; 0x445
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
    8e4a:	ands	r4, r1
  pos->position += offset;
  tmp >>= bytesPerClusterShift();
    8e4c:	adds	r3, #9
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
    8e4e:	add	r2, r4
  pos->position += offset;
  tmp >>= bytesPerClusterShift();
    8e50:	uxtb	r3, r3
    8e52:	lsr.w	r4, r2, r3
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    8e56:	mov	r6, r0
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
  pos->position += offset;
  tmp >>= bytesPerClusterShift();
  while (tmp--) {
    8e58:	cbz	r4, 8e6a <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x32>
    if (pos->isContiguous) {
    8e5a:	ldrb	r3, [r5, #8]
    8e5c:	cbz	r3, 8e6e <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x36>
      pos->cluster++;
    8e5e:	ldr	r3, [r5, #0]
    8e60:	adds	r3, #1
    8e62:	str	r3, [r5, #0]
    8e64:	subs	r4, #1
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
  pos->position += offset;
  tmp >>= bytesPerClusterShift();
  while (tmp--) {
    8e66:	cmp	r4, #0
    8e68:	bne.n	8e5a <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x22>
      if (status != 1) {
        return status;
      }
    }
  }
  return 1;
    8e6a:	movs	r0, #1
    8e6c:	pop	{r4, r5, r6, pc}
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    8e6e:	ldr.w	r3, [r6, #1072]	; 0x430
  tmp >>= bytesPerClusterShift();
  while (tmp--) {
    if (pos->isContiguous) {
      pos->cluster++;
    } else {
      status = fatGet(pos->cluster, &pos->cluster);
    8e72:	ldr	r1, [r5, #0]
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    8e74:	adds	r3, #1
    8e76:	cmp	r1, r3
    8e78:	bls.n	8e80 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x48>
  tmp >>= bytesPerClusterShift();
  while (tmp--) {
    if (pos->isContiguous) {
      pos->cluster++;
    } else {
      status = fatGet(pos->cluster, &pos->cluster);
    8e7a:	mov.w	r0, #4294967295
        return status;
      }
    }
  }
  return 1;
}
    8e7e:	pop	{r4, r5, r6, pc}
    8e80:	mov	r2, r5
    8e82:	mov	r0, r6
    8e84:	bl	8c0c <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]>
  tmp >>= bytesPerClusterShift();
  while (tmp--) {
    if (pos->isContiguous) {
      pos->cluster++;
    } else {
      status = fatGet(pos->cluster, &pos->cluster);
    8e88:	sxtb	r0, r0
      if (status != 1) {
    8e8a:	cmp	r0, #1
    8e8c:	beq.n	8e64 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x2c>
    8e8e:	pop	{r4, r5, r6, pc}

00008e90 <ExFatPartition::fatGet(unsigned long, unsigned long*)>:
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    8e90:	ldr.w	r3, [r0, #1072]	; 0x430
    8e94:	adds	r3, #1
    8e96:	cmp	r3, r1
    8e98:	bcs.n	8e9e <ExFatPartition::fatGet(unsigned long, unsigned long*)+0xe>
  if (next == EXFAT_EOC) {
    return 0;
  }
  *value = next;
  return 1;
}
    8e9a:	movs	r0, #255	; 0xff
    8e9c:	bx	lr
    8e9e:	b.w	8c0c <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]>
    8ea2:	nop

00008ea4 <ExFatPartition::fatPut(unsigned long, unsigned long)>:
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    8ea4:	cmp	r1, #1
    8ea6:	bls.n	8ec4 <ExFatPartition::fatPut(unsigned long, unsigned long)+0x20>
    8ea8:	ldr.w	r3, [r0, #1072]	; 0x430
    8eac:	adds	r3, #1
    8eae:	cmp	r1, r3
  }
  *value = next;
  return 1;
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
    8eb0:	push	{r4}
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    8eb2:	bls.n	8ebc <ExFatPartition::fatPut(unsigned long, unsigned long)+0x18>
  setLe32(cache + ((cluster << 2) & m_sectorMask), value);
  return true;

 fail:
  return false;
}
    8eb4:	movs	r0, #0
    8eb6:	ldr.w	r4, [sp], #4
    8eba:	bx	lr
    8ebc:	ldr.w	r4, [sp], #4
    8ec0:	b.w	8c40 <ExFatPartition::fatPut(unsigned long, unsigned long) [clone .part.4]>
    8ec4:	movs	r0, #0
    8ec6:	bx	lr

00008ec8 <ExFatPartition::freeChain(unsigned long)>:
//------------------------------------------------------------------------------
bool ExFatPartition::freeChain(uint32_t cluster) {
    8ec8:	push	{r4, r5, r6, r7, lr}
    8eca:	mov	r4, r1
    8ecc:	sub	sp, #12
    8ece:	mov	r5, r0
  uint32_t next;
  uint32_t start = cluster;
    8ed0:	mov	r6, r1
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    8ed2:	ldr.w	r3, [r5, #1072]	; 0x430
    8ed6:	adds	r3, #1
    8ed8:	cmp	r4, r3
    8eda:	bls.n	8ee2 <ExFatPartition::freeChain(unsigned long)+0x1a>
  } while (status);

  return true;

 fail:
  return false;
    8edc:	movs	r0, #0
}
    8ede:	add	sp, #12
    8ee0:	pop	{r4, r5, r6, r7, pc}
    8ee2:	add	r2, sp, #4
    8ee4:	mov	r1, r4
    8ee6:	mov	r0, r5
    8ee8:	bl	8c0c <ExFatPartition::fatGet(unsigned long, unsigned long*) [clone .part.3]>
bool ExFatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  uint32_t start = cluster;
  int8_t status;
  do {
    status = fatGet(cluster, &next);
    8eec:	sxtb	r7, r0
    if (status < 0) {
    8eee:	cmp	r7, #0
    8ef0:	blt.n	8edc <ExFatPartition::freeChain(unsigned long)+0x14>
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    8ef2:	cmp	r4, #1
    8ef4:	bls.n	8edc <ExFatPartition::freeChain(unsigned long)+0x14>
    8ef6:	ldr.w	r3, [r5, #1072]	; 0x430
    8efa:	adds	r3, #1
    8efc:	cmp	r4, r3
    8efe:	bhi.n	8edc <ExFatPartition::freeChain(unsigned long)+0x14>
    8f00:	movs	r2, #0
    8f02:	mov	r1, r4
    8f04:	mov	r0, r5
    8f06:	bl	8c40 <ExFatPartition::fatPut(unsigned long, unsigned long) [clone .part.4]>
    status = fatGet(cluster, &next);
    if (status < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!fatPut(cluster, 0)) {
    8f0a:	cmp	r0, #0
    8f0c:	beq.n	8edc <ExFatPartition::freeChain(unsigned long)+0x14>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if ((cluster + 1) != next || status == 0) {
    8f0e:	ldr	r3, [sp, #4]
    8f10:	adds	r4, #1
    8f12:	cmp	r4, r3
    8f14:	bne.n	8f2e <ExFatPartition::freeChain(unsigned long)+0x66>
    8f16:	cmp	r7, #0
    8f18:	bne.n	8ed2 <ExFatPartition::freeChain(unsigned long)+0xa>
      if (!bitmapModify(start, cluster - start + 1, 0)) {
    8f1a:	mov	r3, r7
    8f1c:	subs	r2, r4, r6
    8f1e:	mov	r1, r6
    8f20:	mov	r0, r5
    8f22:	bl	8d20 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    8f26:	cmp	r0, #0
    8f28:	beq.n	8edc <ExFatPartition::freeChain(unsigned long)+0x14>

  return true;

 fail:
  return false;
}
    8f2a:	add	sp, #12
    8f2c:	pop	{r4, r5, r6, r7, pc}
    if (!fatPut(cluster, 0)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if ((cluster + 1) != next || status == 0) {
      if (!bitmapModify(start, cluster - start + 1, 0)) {
    8f2e:	subs	r2, r4, r6
    8f30:	mov	r1, r6
    8f32:	movs	r3, #0
    8f34:	mov	r0, r5
    8f36:	bl	8d20 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    8f3a:	cmp	r0, #0
    8f3c:	beq.n	8edc <ExFatPartition::freeChain(unsigned long)+0x14>
        DBG_FAIL_MACRO;
        goto fail;
      }
      start = next;
    8f3e:	ldr	r4, [sp, #4]
//------------------------------------------------------------------------------
bool ExFatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  uint32_t start = cluster;
  int8_t status;
  do {
    8f40:	cmp	r7, #0
    8f42:	beq.n	8ede <ExFatPartition::freeChain(unsigned long)+0x16>
    if ((cluster + 1) != next || status == 0) {
      if (!bitmapModify(start, cluster - start + 1, 0)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      start = next;
    8f44:	mov	r6, r4
    8f46:	b.n	8ed2 <ExFatPartition::freeChain(unsigned long)+0xa>

00008f48 <ExFatPartition::freeClusterCount()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
    8f48:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  uint32_t nc = 0;
  uint32_t sector = m_clusterHeapStartSector;
  uint32_t usedCount = 0;
    8f4c:	movs	r4, #0
  return false;
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
  uint32_t nc = 0;
  uint32_t sector = m_clusterHeapStartSector;
    8f4e:	ldr.w	r6, [r0, #1068]	; 0x42c

 fail:
  return false;
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
    8f52:	mov	r8, r0
    8f54:	add.w	r7, r0, #528	; 0x210
  uint32_t nc = 0;
    8f58:	mov	r5, r4
    8f5a:	mov	r1, r6
    8f5c:	movs	r2, #0
    8f5e:	mov	r0, r7
  uint32_t sector = m_clusterHeapStartSector;
  uint32_t usedCount = 0;
  uint8_t* cache;

  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    8f60:	adds	r6, #1
    8f62:	bl	81e8 <FsCache::get(unsigned long, unsigned char)>
    if (!cache) {
    8f66:	cbz	r0, 8fb6 <ExFatPartition::freeClusterCount()+0x6e>
    8f68:	add.w	lr, r0, #4294967295
    8f6c:	ldr.w	ip, [r8, #1072]	; 0x430
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
    8f70:	ldrb.w	r0, [lr, #1]!
    8f74:	cmp	r0, #255	; 0xff
    8f76:	add.w	r9, r5, #4096	; 0x1000
    8f7a:	beq.n	8fa4 <ExFatPartition::freeClusterCount()+0x5c>
        usedCount+= 8;
      } else if (cache[i]) {
    8f7c:	cbz	r0, 8f92 <ExFatPartition::freeClusterCount()+0x4a>
    8f7e:	movs	r2, #8
    8f80:	movs	r3, #1
        for (uint8_t mask = 1; mask ; mask <<=1) {
          if ((mask & cache[i])) {
    8f82:	tst	r0, r3
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
        usedCount+= 8;
      } else if (cache[i]) {
        for (uint8_t mask = 1; mask ; mask <<=1) {
    8f84:	mov.w	r1, r3, lsl #1
          if ((mask & cache[i])) {
            usedCount++;
    8f88:	it	ne
    8f8a:	addne	r4, #1
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
        usedCount+= 8;
      } else if (cache[i]) {
        for (uint8_t mask = 1; mask ; mask <<=1) {
    8f8c:	subs	r2, #1
    8f8e:	uxtb	r3, r1
    8f90:	bne.n	8f82 <ExFatPartition::freeClusterCount()+0x3a>
          if ((mask & cache[i])) {
            usedCount++;
          }
        }
      }
      nc += 8;
    8f92:	adds	r5, #8
      if (nc >= m_clusterCount) {
    8f94:	cmp	ip, r5
    8f96:	bls.n	8fae <ExFatPartition::freeClusterCount()+0x66>
  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
    8f98:	cmp	r5, r9
    8f9a:	beq.n	8f5a <ExFatPartition::freeClusterCount()+0x12>
      if (cache[i] == 0XFF) {
    8f9c:	ldrb.w	r0, [lr, #1]!
    8fa0:	cmp	r0, #255	; 0xff
    8fa2:	bne.n	8f7c <ExFatPartition::freeClusterCount()+0x34>
          if ((mask & cache[i])) {
            usedCount++;
          }
        }
      }
      nc += 8;
    8fa4:	adds	r5, #8
      if (nc >= m_clusterCount) {
    8fa6:	cmp	ip, r5
    if (!cache) {
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
        usedCount+= 8;
    8fa8:	add.w	r4, r4, #8
            usedCount++;
          }
        }
      }
      nc += 8;
      if (nc >= m_clusterCount) {
    8fac:	bhi.n	8f98 <ExFatPartition::freeClusterCount()+0x50>
        return m_clusterCount - usedCount;
    8fae:	rsb	r0, r4, ip
    8fb2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      }
    }
  }
}
    8fb6:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    8fba:	nop

00008fbc <ExFatPartition::init(BlockDeviceInterface*, unsigned char)>:
//------------------------------------------------------------------------------
bool ExFatPartition::init(BlockDevice* dev, uint8_t part) {
    8fbc:	push	{r3, r4, r5, r6, r7, lr}
    8fbe:	mov	r4, r0
  pbs_t* pbs;
  BpbExFat_t* bpb;
  MbrSector_t* mbr;
  MbrPart_t* mp;

  m_fatType = 0;
    8fc0:	movs	r3, #0
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    8fc2:	mov.w	r6, #4294967295
    8fc6:	add.w	r7, r0, #528	; 0x210
  m_blockDev = dev;
    8fca:	str.w	r1, [r0, #1088]	; 0x440
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    8fce:	str	r1, [r0, #4]
    8fd0:	str.w	r1, [r0, #532]	; 0x214
      }
    }
  }
}
//------------------------------------------------------------------------------
bool ExFatPartition::init(BlockDevice* dev, uint8_t part) {
    8fd4:	mov	r5, r2
    8fd6:	mov	r0, r7
  pbs_t* pbs;
  BpbExFat_t* bpb;
  MbrSector_t* mbr;
  MbrPart_t* mp;

  m_fatType = 0;
    8fd8:	strb.w	r3, [r4, #1092]	; 0x444
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    8fdc:	strb	r3, [r4, #0]
    8fde:	strb.w	r3, [r4, #528]	; 0x210
    m_sector = 0XFFFFFFFF;
    8fe2:	str	r6, [r4, #12]
    8fe4:	str.w	r6, [r4, #540]	; 0x21c
    8fe8:	mov	r2, r3
    8fea:	mov	r1, r3
    8fec:	bl	81e8 <FsCache::get(unsigned long, unsigned char)>
  m_blockDev = dev;
  cacheInit(m_blockDev);
  cache = dataCacheGet(0, FsCache::CACHE_FOR_READ);
  if (part > 4 || !cache) {
    8ff0:	cmp	r5, #4
    8ff2:	bhi.n	900e <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x52>
    8ff4:	mov	r6, r0
    8ff6:	cbz	r0, 900e <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x52>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (part >= 1) {
    8ff8:	cbnz	r5, 9012 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x56>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  pbs = reinterpret_cast<pbs_t*>(cache);
  if (strncmp(pbs->oemName, "EXFAT", 5)) {
    8ffa:	movs	r2, #5
    8ffc:	ldr	r1, [pc, #152]	; (9098 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0xdc>)
    8ffe:	adds	r0, r6, #3
    9000:	bl	10cdc <strncmp>
    9004:	cbnz	r0, 900e <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x52>
    DBG_FAIL_MACRO;
    goto fail;
  }
  bpb = reinterpret_cast<BpbExFat_t*>(pbs->bpb);
  if (bpb->bytesPerSectorShift != m_bytesPerSectorShift) {
    9006:	ldrb.w	r3, [r6, #108]	; 0x6c
    900a:	cmp	r3, #9
    900c:	beq.n	9042 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x86>
  bitmapFind(0, 1);
  m_fatType = FAT_TYPE_EXFAT;
  return true;

 fail:
  return false;
    900e:	movs	r0, #0
    9010:	pop	{r3, r4, r5, r6, r7, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (part >= 1) {
    mbr = reinterpret_cast<MbrSector_t*>(cache);
    mp = &mbr->part[part - 1];
    9012:	subs	r3, r5, #1
    if ((mp->boot != 0 && mp->boot != 0X80) || mp->type == 0) {
    9014:	add.w	r3, r0, r3, lsl #4
    9018:	ldrb.w	r2, [r3, #446]	; 0x1be
    901c:	ands.w	r2, r2, #127	; 0x7f
    9020:	bne.n	900e <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x52>
    9022:	ldrb.w	r3, [r3, #450]	; 0x1c2
    9026:	cmp	r3, #0
    9028:	beq.n	900e <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x52>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    902a:	add.w	r5, r0, r5, lsl #4
    902e:	mov	r0, r7
    9030:	ldr.w	r5, [r5, #438]	; 0x1b6
    9034:	mov	r1, r5
    9036:	bl	81e8 <FsCache::get(unsigned long, unsigned char)>
      DBG_FAIL_MACRO;
      goto fail;
    }
    volStart = getLe32(mp->relativeSectors);
    cache = dataCacheGet(volStart, FsCache::CACHE_FOR_READ);
    if (!cache) {
    903a:	mov	r6, r0
    903c:	cmp	r0, #0
    903e:	bne.n	8ffa <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x3e>
    9040:	b.n	900e <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x52>
  bpb = reinterpret_cast<BpbExFat_t*>(pbs->bpb);
  if (bpb->bytesPerSectorShift != m_bytesPerSectorShift) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_fatStartSector = volStart + getLe32(bpb->fatOffset);
    9042:	ldr	r3, [r6, #80]	; 0x50
    9044:	add	r3, r5
    9046:	str.w	r3, [r4, #1060]	; 0x424
    904a:	ldr	r3, [r6, #84]	; 0x54
  m_fatLength = getLe32(bpb->fatLength);
    904c:	str.w	r3, [r4, #1064]	; 0x428
  m_clusterHeapStartSector = volStart + getLe32(bpb->clusterHeapOffset);
    9050:	ldr	r3, [r6, #88]	; 0x58
    9052:	add	r5, r3
    9054:	str.w	r5, [r4, #1068]	; 0x42c
    9058:	ldr	r3, [r6, #92]	; 0x5c
  m_clusterCount = getLe32(bpb->clusterCount);
    905a:	str.w	r3, [r4, #1072]	; 0x430
    905e:	ldr	r3, [r6, #96]	; 0x60
  m_rootDirectoryCluster = getLe32(bpb->rootDirectoryCluster);
    9060:	str.w	r3, [r4, #1076]	; 0x434
  m_sectorsPerClusterShift = bpb->sectorsPerClusterShift;
    9064:	ldrb.w	r3, [r6, #109]	; 0x6d
    9068:	strb.w	r3, [r4, #1093]	; 0x445
  m_bytesPerCluster = 1UL << (m_bytesPerSectorShift + m_sectorsPerClusterShift);
    906c:	movs	r5, #1
    906e:	adds	r3, #9
    9070:	lsl.w	r3, r5, r3
  m_clusterMask = m_bytesPerCluster - 1;
    9074:	subs	r2, r3, #1
  // Set m_bitmapStart to first free cluster.
  m_bitmapStart = 0;
    9076:	str.w	r0, [r4, #1056]	; 0x420
  bitmapFind(0, 1);
    907a:	mov	r1, r0
  m_fatLength = getLe32(bpb->fatLength);
  m_clusterHeapStartSector = volStart + getLe32(bpb->clusterHeapOffset);
  m_clusterCount = getLe32(bpb->clusterCount);
  m_rootDirectoryCluster = getLe32(bpb->rootDirectoryCluster);
  m_sectorsPerClusterShift = bpb->sectorsPerClusterShift;
  m_bytesPerCluster = 1UL << (m_bytesPerSectorShift + m_sectorsPerClusterShift);
    907c:	str.w	r3, [r4, #1084]	; 0x43c
  m_clusterMask = m_bytesPerCluster - 1;
    9080:	str.w	r2, [r4, #1080]	; 0x438
  // Set m_bitmapStart to first free cluster.
  m_bitmapStart = 0;
  bitmapFind(0, 1);
    9084:	mov	r0, r4
    9086:	mov	r2, r5
    9088:	bl	8c6c <ExFatPartition::bitmapFind(unsigned long, unsigned long)>
  m_fatType = FAT_TYPE_EXFAT;
    908c:	movs	r3, #64	; 0x40
    908e:	strb.w	r3, [r4, #1092]	; 0x444
  return true;
    9092:	mov	r0, r5

 fail:
  return false;
}
    9094:	pop	{r3, r4, r5, r6, r7, pc}
    9096:	nop
    9098:	.word	0x00014674

0000909c <ExFatPartition::rootLength()>:
//------------------------------------------------------------------------------
uint32_t ExFatPartition::rootLength() {
    909c:	push	{r4, lr}
    909e:	mov	r4, r0
  uint32_t nc = chainSize(m_rootDirectoryCluster);
    90a0:	ldr.w	r1, [r0, #1076]	; 0x434
    90a4:	bl	8dc8 <ExFatPartition::chainSize(unsigned long)>
  return nc << bytesPerClusterShift();
    90a8:	ldrb.w	r3, [r4, #1093]	; 0x445
    90ac:	adds	r3, #9
    90ae:	uxtb	r3, r3
}
    90b0:	lsls	r0, r3
    90b2:	pop	{r4, pc}

000090b4 <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)>:
}
//------------------------------------------------------------------------------
bool exFatCmpName(const DirName_t* unicode,
                  const char* name, size_t offset, size_t n) {
  uint16_t u;
  for (size_t i = 0; i < n; i++) {
    90b4:	cbz	r3, 9108 <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)+0x54>
  }
  return true;
}
//------------------------------------------------------------------------------
bool exFatCmpName(const DirName_t* unicode,
                  const char* name, size_t offset, size_t n) {
    90b6:	push	{r4, r5, r6}
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    90b8:	ldrh	r4, [r0, #2]
  uint16_t u;
  for (size_t i = 0; i < n; i++) {
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
    90ba:	cmp	r4, #126	; 0x7e
    90bc:	bhi.n	90fc <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)+0x48>
    90be:	add	r3, r2
    90c0:	adds	r5, r1, r3
    90c2:	add	r2, r1
    90c4:	adds	r0, #2
    90c6:	ldrb.w	r3, [r2], #1
    90ca:	uxtb	r4, r4
  }
  return left;
}
//------------------------------------------------------------------------------
static char toUpper(char c) {
  return c - ('a' <= c && c <= 'z' ? 'a' - 'A' : 0);
    90cc:	sub.w	r1, r3, #97	; 0x61
    90d0:	cmp	r1, #25
    90d2:	sub.w	r1, r4, #97	; 0x61
    90d6:	ite	ls
    90d8:	movls	r6, #32
    90da:	movhi	r6, #0
    90dc:	cmp	r1, #25
    90de:	ite	ls
    90e0:	movls	r1, #32
    90e2:	movhi	r1, #0
    90e4:	subs	r3, r3, r6
bool exFatCmpName(const DirName_t* unicode,
                  const char* name, size_t offset, size_t n) {
  uint16_t u;
  for (size_t i = 0; i < n; i++) {
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
    90e6:	subs	r4, r4, r1
  }
  return left;
}
//------------------------------------------------------------------------------
static char toUpper(char c) {
  return c - ('a' <= c && c <= 'z' ? 'a' - 'A' : 0);
    90e8:	uxtb	r3, r3
bool exFatCmpName(const DirName_t* unicode,
                  const char* name, size_t offset, size_t n) {
  uint16_t u;
  for (size_t i = 0; i < n; i++) {
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
    90ea:	uxtb	r4, r4
    90ec:	cmp	r4, r3
    90ee:	bne.n	90fc <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)+0x48>
}
//------------------------------------------------------------------------------
bool exFatCmpName(const DirName_t* unicode,
                  const char* name, size_t offset, size_t n) {
  uint16_t u;
  for (size_t i = 0; i < n; i++) {
    90f0:	cmp	r2, r5
    90f2:	beq.n	9102 <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)+0x4e>
    90f4:	ldrh.w	r4, [r0, #2]!
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
    90f8:	cmp	r4, #126	; 0x7e
    90fa:	bls.n	90c6 <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)+0x12>
      return false;
    90fc:	movs	r0, #0
    }
  }
  return true;
}
    90fe:	pop	{r4, r5, r6}
    9100:	bx	lr
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
      return false;
    }
  }
  return true;
    9102:	movs	r0, #1
}
    9104:	pop	{r4, r5, r6}
    9106:	bx	lr
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
      return false;
    }
  }
  return true;
    9108:	movs	r0, #1
}
    910a:	bx	lr

0000910c <exFatHashName(char const*, unsigned int, unsigned short)>:
  }
  return hash;
}
//------------------------------------------------------------------------------
uint16_t exFatHashName(const char* name, size_t n, uint16_t hash) {
  for (size_t i = 0; i < n; i++) {
    910c:	cbz	r1, 9142 <exFatHashName(char const*, unsigned int, unsigned short)+0x36>
    hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
  }
  return hash;
}
//------------------------------------------------------------------------------
uint16_t exFatHashName(const char* name, size_t n, uint16_t hash) {
    910e:	push	{r4}
    9110:	add	r1, r0
    9112:	lsls	r3, r2, #15
    9114:	orr.w	r3, r3, r2, lsr #1
  for (size_t i = 0; i < n; i++) {
    uint8_t c = name[i];
    9118:	ldrb.w	r2, [r0], #1
    if ('a' <= c && c <= 'z') {
    911c:	sub.w	r4, r2, #97	; 0x61
    9120:	cmp	r4, #25
      c -= 'a' - 'A';
    9122:	itt	ls
    9124:	subls	r2, #32
    9126:	uxtbls	r2, r2
    }
    hash = ((hash << 15) | (hash >> 1)) + c;
    9128:	uxtah	r2, r2, r3
    912c:	uxth	r2, r2
    912e:	lsls	r3, r2, #15
    9130:	orr.w	r2, r3, r2, lsr #1
  }
  return hash;
}
//------------------------------------------------------------------------------
uint16_t exFatHashName(const char* name, size_t n, uint16_t hash) {
  for (size_t i = 0; i < n; i++) {
    9134:	cmp	r1, r0
    9136:	uxth	r2, r2
    9138:	bne.n	9112 <exFatHashName(char const*, unsigned int, unsigned short)+0x6>
    }
    hash = ((hash << 15) | (hash >> 1)) + c;
    hash = ((hash << 15) | (hash >> 1));
  }
  return hash;
}
    913a:	mov	r0, r2
    913c:	ldr.w	r4, [sp], #4
    9140:	bx	lr
    9142:	mov	r0, r2
    9144:	bx	lr
    9146:	nop

00009148 <ExFatFile::addCluster()>:
  }
  return checksum;
}
//------------------------------------------------------------------------------
bool ExFatFile::addCluster() {
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    9148:	ldr	r1, [r0, #24]
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
  }
  return checksum;
}
//------------------------------------------------------------------------------
bool ExFatFile::addCluster() {
    914a:	push	{r3, r4, r5, r6, r7, lr}
    914c:	mov	r4, r0
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    914e:	ldr	r0, [r0, #32]
    9150:	cbz	r1, 9154 <ExFatFile::addCluster()+0xc>
    9152:	adds	r1, #1
    9154:	movs	r2, #1
    9156:	bl	8c6c <ExFatPartition::bitmapFind(unsigned long, unsigned long)>
  if (find < 2) {
    915a:	cmp	r0, #1
  }
  return checksum;
}
//------------------------------------------------------------------------------
bool ExFatFile::addCluster() {
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    915c:	mov	r6, r0
  if (find < 2) {
    915e:	bls.n	91c0 <ExFatFile::addCluster()+0x78>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!m_vol->bitmapModify(find, 1, 1)) {
    9160:	movs	r3, #1
    9162:	mov	r1, r0
    9164:	mov	r2, r3
    9166:	ldr	r0, [r4, #32]
    9168:	bl	8d20 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    916c:	mov	r7, r0
    916e:	cbz	r0, 91c0 <ExFatFile::addCluster()+0x78>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    9170:	ldr	r0, [r4, #24]
    m_flags |= FILE_FLAG_CONTIGUOUS;
    9172:	ldrb.w	r3, [r4, #51]	; 0x33
  }
  if (!m_vol->bitmapModify(find, 1, 1)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    9176:	cbz	r0, 91c6 <ExFatFile::addCluster()+0x7e>
    m_flags |= FILE_FLAG_CONTIGUOUS;
    goto done;
  }
  if (isContiguous()) {
    9178:	lsls	r2, r3, #25
    917a:	bpl.n	91a4 <ExFatFile::addCluster()+0x5c>
    if (find == (m_curCluster + 1)) {
    917c:	adds	r2, r0, #1
    917e:	cmp	r6, r2
    9180:	beq.n	91ce <ExFatFile::addCluster()+0x86>
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    9182:	bic.w	r2, r3, #64	; 0x40
    9186:	strb.w	r2, [r4, #51]	; 0x33

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    918a:	ldr	r3, [r4, #28]
    918c:	b.n	919a <ExFatFile::addCluster()+0x52>
      if (!m_vol->fatPut(c, c + 1)) {
    918e:	ldr	r0, [r4, #32]
    9190:	bl	8ea4 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    9194:	cbz	r0, 91c0 <ExFatFile::addCluster()+0x78>
    9196:	ldr	r0, [r4, #24]
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    9198:	mov	r3, r5
      if (!m_vol->fatPut(c, c + 1)) {
    919a:	adds	r5, r3, #1
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    919c:	cmp	r3, r0
      if (!m_vol->fatPut(c, c + 1)) {
    919e:	mov	r1, r3
    91a0:	mov	r2, r5
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    91a2:	bcc.n	918e <ExFatFile::addCluster()+0x46>
        goto fail;
      }
    }
  }
  // New cluster is EOC.
  if (!m_vol->fatPut(find, EXFAT_EOC)) {
    91a4:	mov.w	r2, #4294967295
    91a8:	mov	r1, r6
    91aa:	ldr	r0, [r4, #32]
    91ac:	bl	8ea4 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    91b0:	cbz	r0, 91c0 <ExFatFile::addCluster()+0x78>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Connect new cluster to existing chain.
  if (m_curCluster) {
    91b2:	ldr	r1, [r4, #24]
    91b4:	cbz	r1, 91ce <ExFatFile::addCluster()+0x86>
    if (!m_vol->fatPut(m_curCluster, find)) {
    91b6:	mov	r2, r6
    91b8:	ldr	r0, [r4, #32]
    91ba:	bl	8ea4 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    91be:	cbnz	r0, 91ce <ExFatFile::addCluster()+0x86>
 done:
  m_curCluster = find;
  return true;

 fail:
  return false;
    91c0:	movs	r7, #0
}
    91c2:	mov	r0, r7
    91c4:	pop	{r3, r4, r5, r6, r7, pc}
  if (!m_vol->bitmapModify(find, 1, 1)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    m_flags |= FILE_FLAG_CONTIGUOUS;
    91c6:	orr.w	r3, r3, #64	; 0x40
    91ca:	strb.w	r3, [r4, #51]	; 0x33
      goto fail;
    }
  }

 done:
  m_curCluster = find;
    91ce:	str	r6, [r4, #24]
  return true;

 fail:
  return false;
}
    91d0:	mov	r0, r7
    91d2:	pop	{r3, r4, r5, r6, r7, pc}

000091d4 <ExFatFile::remove()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    91d4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  DirPos_t pos = m_dirPos;
    91d8:	add.w	r3, r0, #36	; 0x24

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    91dc:	mov	r5, r0
  DirPos_t pos = m_dirPos;
    91de:	ldmia.w	r3, {r0, r1, r2}

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    91e2:	sub	sp, #20
    91e4:	ldrb.w	r3, [r5, #51]	; 0x33
  DirPos_t pos = m_dirPos;
    91e8:	add	r6, sp, #4
    91ea:	stmia.w	r6, {r0, r1, r2}
  uint8_t* cache;
  if (!isWritable()) {
    91ee:	lsls	r2, r3, #30
    91f0:	bpl.n	922a <ExFatFile::remove()+0x56>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    91f2:	ldr	r1, [r5, #28]
    91f4:	cbnz	r1, 9232 <ExFatFile::remove()+0x5e>

  // Write entry to device.
  return m_vol->cacheSync();

 fail:
  return false;
    91f6:	movs	r4, #0
  for (uint8_t i = 0; i <= m_setCount; i++) {
    if (i && m_vol->dirSeek(&pos, 32) != 1) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    cache = m_vol->dirCache(&pos, FsCache::CACHE_FOR_WRITE);
    91f8:	movs	r2, #1
    91fa:	mov	r1, r6
    91fc:	ldr	r0, [r5, #32]
    91fe:	bl	8e04 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
        goto fail;
      }
    }
  }

  for (uint8_t i = 0; i <= m_setCount; i++) {
    9202:	adds	r4, #1
    9204:	uxtb	r4, r4
    if (i && m_vol->dirSeek(&pos, 32) != 1) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    cache = m_vol->dirCache(&pos, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
    9206:	cbz	r0, 922a <ExFatFile::remove()+0x56>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Mark entry not used.
    cache[0] &= 0x7F;
    9208:	ldrb	r3, [r0, #0]
    920a:	and.w	r3, r3, #127	; 0x7f
    920e:	strb	r3, [r0, #0]
        goto fail;
      }
    }
  }

  for (uint8_t i = 0; i <= m_setCount; i++) {
    9210:	ldrb.w	r3, [r5, #48]	; 0x30
    9214:	cmp	r3, r4
    9216:	bcc.n	927c <ExFatFile::remove()+0xa8>
    if (i && m_vol->dirSeek(&pos, 32) != 1) {
    9218:	cmp	r4, #0
    921a:	beq.n	91f8 <ExFatFile::remove()+0x24>
    921c:	movs	r2, #32
    921e:	mov	r1, r6
    9220:	ldr	r0, [r5, #32]
    9222:	bl	8e38 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
    9226:	cmp	r0, #1
    9228:	beq.n	91f8 <ExFatFile::remove()+0x24>

  // Write entry to device.
  return m_vol->cacheSync();

 fail:
  return false;
    922a:	movs	r0, #0
}
    922c:	add	sp, #20
    922e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    if (isContiguous()) {
    9232:	lsls	r3, r3, #25
      uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    9234:	ldr	r0, [r5, #32]
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    if (isContiguous()) {
    9236:	bpl.n	9272 <ExFatFile::remove()+0x9e>
      uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
      if (!m_vol->bitmapModify(m_firstCluster, nc, 0)) {
    9238:	ldrd	r2, r3, [r5, #8]
    923c:	ldrb.w	r4, [r0, #1093]	; 0x445
    9240:	adds	r4, #9
    9242:	uxtb	r4, r4
    9244:	adds.w	r8, r2, #4294967295
    9248:	adc.w	r9, r3, #4294967295
    924c:	rsb	r7, r4, #32
    9250:	lsl.w	r7, r9, r7
    9254:	lsr.w	r2, r8, r4
    9258:	sub.w	r3, r4, #32
    925c:	lsr.w	r3, r9, r3
    9260:	orrs	r2, r7
    9262:	orrs	r2, r3
    9264:	adds	r2, #1
    9266:	movs	r3, #0
    9268:	bl	8d20 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    926c:	cmp	r0, #0
    926e:	bne.n	91f6 <ExFatFile::remove()+0x22>
    9270:	b.n	922a <ExFatFile::remove()+0x56>
        DBG_FAIL_MACRO;
        goto fail;
      }
    } else {
      if (!m_vol->freeChain(m_firstCluster)) {
    9272:	bl	8ec8 <ExFatPartition::freeChain(unsigned long)>
    9276:	cmp	r0, #0
    9278:	bne.n	91f6 <ExFatFile::remove()+0x22>
    927a:	b.n	922a <ExFatFile::remove()+0x56>
  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;

  // Write entry to device.
  return m_vol->cacheSync();
    927c:	ldr	r4, [r5, #32]
    }
    // Mark entry not used.
    cache[0] &= 0x7F;
  }
  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    927e:	movs	r3, #0
#endif  // USE_EXFAT_BITMAP_CACHE
    m_dataCache.init(dev);
  }
  bool cacheSync() {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
    9280:	mov	r0, r4
    9282:	strb.w	r3, [r5, #49]	; 0x31
  m_flags = 0;
    9286:	strb.w	r3, [r5, #51]	; 0x33
    928a:	bl	8248 <FsCache::sync()>
    928e:	cmp	r0, #0
    9290:	beq.n	922a <ExFatFile::remove()+0x56>
    9292:	add.w	r0, r4, #528	; 0x210
    9296:	bl	8248 <FsCache::sync()>
    929a:	cmp	r0, #0
    929c:	beq.n	922a <ExFatFile::remove()+0x56>
    929e:	ldr.w	r0, [r4, #1088]	; 0x440
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() const {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    92a2:	ldr	r3, [r0, #0]
    92a4:	ldr	r3, [r3, #24]
    92a6:	blx	r3
    92a8:	b.n	922c <ExFatFile::remove()+0x58>
    92aa:	nop

000092ac <ExFatFile::rmdir()>:
//------------------------------------------------------------------------------
bool ExFatFile::rmdir() {
  int n;
  uint8_t dir[32];
  // must be open subdirectory
  if (!isSubDir()) {
    92ac:	ldrb.w	r3, [r0, #49]	; 0x31
    92b0:	lsls	r1, r3, #27
    92b2:	bmi.n	92b8 <ExFatFile::rmdir()+0xc>
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();

 fail:
  return false;
    92b4:	movs	r0, #0
}
    92b6:	bx	lr

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::rmdir() {
    92b8:	push	{r4, lr}
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const ExChar_t* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    92ba:	movs	r2, #0
    92bc:	sub	sp, #32
    92be:	movs	r3, #0
    92c0:	mov	r4, r0
    92c2:	bl	85e0 <ExFatFile::seekSet(unsigned long long)>
    92c6:	b.n	92d6 <ExFatFile::rmdir()+0x2a>
  while (1) {
    n = read(dir, 32);
    if (n == 0) {
      break;
    }
    if (n != 32 || dir[0] & 0X80) {
    92c8:	cmp	r0, #32
    92ca:	bne.n	9300 <ExFatFile::rmdir()+0x54>
    92cc:	ldrb.w	r3, [sp]
    92d0:	lsls	r2, r3, #24
    92d2:	bmi.n	9300 <ExFatFile::rmdir()+0x54>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (dir[0] == 0) {
    92d4:	cbz	r3, 92e4 <ExFatFile::rmdir()+0x38>
  }
  rewind();

  // make sure directory is empty
  while (1) {
    n = read(dir, 32);
    92d6:	movs	r2, #32
    92d8:	mov	r1, sp
    92da:	mov	r0, r4
    92dc:	bl	8408 <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    92e0:	cmp	r0, #0
    92e2:	bne.n	92c8 <ExFatFile::rmdir()+0x1c>
      break;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
    92e4:	ldrb.w	r3, [r4, #51]	; 0x33
    if (dir[0] == 0) {
      break;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    92e8:	movs	r2, #8
  m_flags |= FILE_FLAG_WRITE;
    92ea:	orr.w	r3, r3, #2
    92ee:	strb.w	r3, [r4, #51]	; 0x33
    if (dir[0] == 0) {
      break;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    92f2:	strb.w	r2, [r4, #49]	; 0x31
  m_flags |= FILE_FLAG_WRITE;
  return remove();
    92f6:	mov	r0, r4
    92f8:	bl	91d4 <ExFatFile::remove()>

 fail:
  return false;
}
    92fc:	add	sp, #32
    92fe:	pop	{r4, pc}
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();

 fail:
  return false;
    9300:	movs	r0, #0
}
    9302:	add	sp, #32
    9304:	pop	{r4, pc}
    9306:	nop

00009308 <ExFatFile::syncDir()>:
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    9308:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
  uint8_t setCount = 0;

  DirPos_t pos = m_dirPos;
    930c:	add.w	fp, r0, #36	; 0x24
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    9310:	mov	r6, r0
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
  uint8_t setCount = 0;

  DirPos_t pos = m_dirPos;
    9312:	ldmia.w	fp, {r0, r1, r2}
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    9316:	sub	sp, #28
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
  uint8_t setCount = 0;

  DirPos_t pos = m_dirPos;
    9318:	add.w	r8, sp, #12
    931c:	stmia.w	r8, {r0, r1, r2}
    9320:	movs	r7, #0
bool ExFatFile::syncDir() {
  DirFile_t* df;
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
  uint8_t setCount = 0;
    9322:	mov	sl, r7
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
  DirFile_t* df;
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
    9324:	mov	r4, r7
  uint8_t setCount = 0;

  DirPos_t pos = m_dirPos;

  for (uint8_t i = 0;; i++) {
    cache = m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ);
    9326:	movs	r2, #0
    9328:	mov	r1, r8
    932a:	ldr	r0, [r6, #32]
    932c:	bl	8e04 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
    9330:	uxtb.w	r9, r7
    if (!cache) {
    9334:	mov	r5, r0
    9336:	cbz	r0, 9346 <ExFatFile::syncDir()+0x3e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    switch (cache[0]) {
    9338:	ldrb	r3, [r0, #0]
    933a:	cmp	r3, #192	; 0xc0
    933c:	beq.n	93e2 <ExFatFile::syncDir()+0xda>
    933e:	cmp	r3, #193	; 0xc1
    9340:	beq.n	93de <ExFatFile::syncDir()+0xd6>
    9342:	cmp	r3, #133	; 0x85
    9344:	beq.n	935a <ExFatFile::syncDir()+0x52>
    goto fail;
  }
  return true;

 fail:
  m_error |= WRITE_ERROR;
    9346:	ldrb.w	r3, [r6, #50]	; 0x32
    934a:	orr.w	r3, r3, #1
    934e:	strb.w	r3, [r6, #50]	; 0x32
  return false;
    9352:	movs	r0, #0
}
    9354:	add	sp, #28
    9356:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    switch (cache[0]) {
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setCount = df->setCount;
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
    935a:	ldr	r3, [pc, #236]	; (9448 <ExFatFile::syncDir()+0x140>)
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    935c:	ldrb.w	r2, [r6, #49]	; 0x31
    9360:	ldr	r3, [r3, #0]
      goto fail;
    }
    switch (cache[0]) {
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setCount = df->setCount;
    9362:	ldrb.w	sl, [r0, #1]
    9366:	and.w	r2, r2, #55	; 0x37
    936a:	strh	r2, [r0, #4]
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
    936c:	cbz	r3, 9390 <ExFatFile::syncDir()+0x88>
          uint16_t date, time;
          uint8_t ms10;
          FsDateTime::callback(&date, &time, &ms10);
    936e:	add.w	r2, sp, #7
    9372:	add.w	r1, sp, #10
    9376:	add	r0, sp, #8
    9378:	blx	r3
          df->modifyTimeMs = ms10;
          setLe16(df->modifyTime, time);
    937a:	ldrh.w	r2, [sp, #10]
          setLe16(df->modifyDate, date);
    937e:	ldrh.w	r3, [sp, #8]
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
          uint16_t date, time;
          uint8_t ms10;
          FsDateTime::callback(&date, &time, &ms10);
          df->modifyTimeMs = ms10;
    9382:	ldrb.w	r1, [sp, #7]
    9386:	strb	r1, [r5, #21]
    9388:	strh	r2, [r5, #12]
    938a:	strh	r2, [r5, #16]
    938c:	strh	r3, [r5, #14]
    938e:	strh	r3, [r5, #18]
          ds->flags &= ~EXFAT_FLAG_CONTIGUOUS;
        }
        setLe64(ds->validLength, m_validLength);
        setLe32(ds->firstCluster, m_firstCluster);
        setLe64(ds->dataLength, m_dataLength);
        m_vol->dataCacheDirty();
    9390:	ldr	r2, [r6, #32]
    invalidate();
    return m_buffer;
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    9392:	ldrb.w	r3, [r2, #528]	; 0x210
    9396:	orr.w	r3, r3, #1
    939a:	strb.w	r3, [r2, #528]	; 0x210
    939e:	ldrb	r0, [r5, #0]
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    93a0:	movs	r1, #0
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
    93a2:	ldrb	r2, [r5, r1]
    93a4:	lsls	r3, r4, #15
    93a6:	orr.w	r4, r3, r4, lsr #1
    93aa:	uxtah	r4, r2, r4
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    93ae:	cmp	r1, #1
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
    93b0:	uxth	r4, r4
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    93b2:	add.w	r1, r1, #1
    93b6:	beq.n	93d4 <ExFatFile::syncDir()+0xcc>
    93b8:	cmp	r1, #31
    93ba:	bls.n	93a2 <ExFatFile::syncDir()+0x9a>
        DBG_FAIL_MACRO;
        goto fail;
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
    if (i == setCount) break;
    93bc:	cmp	sl, r9
    93be:	beq.n	940e <ExFatFile::syncDir()+0x106>
    if (m_vol->dirSeek(&pos, 32) != 1) {
    93c0:	movs	r2, #32
    93c2:	mov	r1, r8
    93c4:	ldr	r0, [r6, #32]
    93c6:	bl	8e38 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
    93ca:	cmp	r0, #1
    93cc:	add.w	r7, r7, #1
    93d0:	beq.n	9326 <ExFatFile::syncDir()+0x1e>
    93d2:	b.n	9346 <ExFatFile::syncDir()+0x3e>
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    93d4:	cmp	r0, #133	; 0x85
    93d6:	ite	eq
    93d8:	moveq	r1, #4
    93da:	movne	r1, #2
    93dc:	b.n	93a2 <ExFatFile::syncDir()+0x9a>
    cache = m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    switch (cache[0]) {
    93de:	mov	r0, r3
    93e0:	b.n	93a0 <ExFatFile::syncDir()+0x98>
        m_vol->dataCacheDirty();
        break;

      case EXFAT_TYPE_STREAM:
        ds = reinterpret_cast<DirStream_t*>(cache);
        if (isContiguous()) {
    93e2:	ldrb.w	r3, [r6, #51]	; 0x33
    93e6:	tst.w	r3, #64	; 0x40
          ds->flags |= EXFAT_FLAG_CONTIGUOUS;
    93ea:	ldrb	r3, [r0, #1]
    93ec:	ite	ne
    93ee:	orrne.w	r3, r3, #2
        } else {
          ds->flags &= ~EXFAT_FLAG_CONTIGUOUS;
    93f2:	biceq.w	r3, r3, #2
    93f6:	strb	r3, [r0, #1]
        }
        setLe64(ds->validLength, m_validLength);
    93f8:	ldrd	r2, r3, [r6, #16]

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    93fc:	strd	r2, r3, [r0, #8]
        setLe32(ds->firstCluster, m_firstCluster);
        setLe64(ds->dataLength, m_dataLength);
    9400:	ldrd	r2, r3, [r6, #8]
          ds->flags |= EXFAT_FLAG_CONTIGUOUS;
        } else {
          ds->flags &= ~EXFAT_FLAG_CONTIGUOUS;
        }
        setLe64(ds->validLength, m_validLength);
        setLe32(ds->firstCluster, m_firstCluster);
    9404:	ldr	r1, [r6, #28]
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    9406:	str	r1, [r0, #20]
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    9408:	strd	r2, r3, [r0, #24]
    940c:	b.n	9390 <ExFatFile::syncDir()+0x88>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  df = reinterpret_cast<DirFile_t*>
       (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_WRITE));
    940e:	mov	r1, fp
    9410:	movs	r2, #1
    9412:	ldr	r0, [r6, #32]
    9414:	bl	8e04 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    9418:	cmp	r0, #0
    941a:	beq.n	9346 <ExFatFile::syncDir()+0x3e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe16(df->setChecksum, checksum);
  if (!m_vol->cacheSync()) {
    941c:	ldr	r5, [r6, #32]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    941e:	strh	r4, [r0, #2]
#endif  // USE_EXFAT_BITMAP_CACHE
    m_dataCache.init(dev);
  }
  bool cacheSync() {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
    9420:	mov	r0, r5
    9422:	bl	8248 <FsCache::sync()>
    9426:	cmp	r0, #0
    9428:	beq.n	9346 <ExFatFile::syncDir()+0x3e>
    942a:	add.w	r0, r5, #528	; 0x210
    942e:	bl	8248 <FsCache::sync()>
    9432:	cmp	r0, #0
    9434:	beq.n	9346 <ExFatFile::syncDir()+0x3e>
    9436:	ldr.w	r0, [r5, #1088]	; 0x440
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() const {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    943a:	ldr	r3, [r0, #0]
    943c:	ldr	r3, [r3, #24]
    943e:	blx	r3
#endif  // USE_EXFAT_BITMAP_CACHE
    m_dataCache.init(dev);
  }
  bool cacheSync() {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
    9440:	cmp	r0, #0
    9442:	beq.n	9346 <ExFatFile::syncDir()+0x3e>
    9444:	b.n	9354 <ExFatFile::syncDir()+0x4c>
    9446:	nop
    9448:	.word	0x1fff6188

0000944c <ExFatFile::sync()>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
  if (!isOpen()) {
    944c:	ldrb.w	r2, [r0, #49]	; 0x31
    9450:	cbz	r2, 9478 <ExFatFile::sync()+0x2c>

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
    9452:	push	{r3, r4, r5, lr}
  if (!isOpen()) {
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    9454:	ldrb.w	r2, [r0, #51]	; 0x33
    9458:	lsls	r1, r2, #24
    945a:	bmi.n	947c <ExFatFile::sync()+0x30>
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    return syncDir();
  }
  if (!m_vol->cacheSync()) {
    945c:	ldr	r5, [r0, #32]
    945e:	mov	r4, r0
    9460:	mov	r0, r5
    9462:	bl	8248 <FsCache::sync()>
    9466:	cbnz	r0, 948c <ExFatFile::sync()+0x40>
    goto fail;
  }
  return true;

 fail:
  m_error |= WRITE_ERROR;
    9468:	ldrb.w	r3, [r4, #50]	; 0x32
    946c:	orr.w	r3, r3, #1
    9470:	strb.w	r3, [r4, #50]	; 0x32
  return false;
    9474:	movs	r0, #0
}
    9476:	pop	{r3, r4, r5, pc}
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
  if (!isOpen()) {
    return true;
    9478:	movs	r0, #1
  return true;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    947a:	bx	lr
  if (!isOpen()) {
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    947c:	and.w	r2, r2, #127	; 0x7f
    9480:	strb.w	r2, [r0, #51]	; 0x33
  return true;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    9484:	ldmia.w	sp!, {r3, r4, r5, lr}
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    return syncDir();
    9488:	b.w	9308 <ExFatFile::syncDir()>
    948c:	add.w	r0, r5, #528	; 0x210
    9490:	bl	8248 <FsCache::sync()>
    9494:	cmp	r0, #0
    9496:	beq.n	9468 <ExFatFile::sync()+0x1c>
    9498:	ldr.w	r0, [r5, #1088]	; 0x440
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() const {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    949c:	ldr	r3, [r0, #0]
    949e:	ldr	r3, [r3, #24]
    94a0:	blx	r3
#endif  // USE_EXFAT_BITMAP_CACHE
    m_dataCache.init(dev);
  }
  bool cacheSync() {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
    94a2:	cmp	r0, #0
    94a4:	beq.n	9468 <ExFatFile::sync()+0x1c>
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
  if (!isOpen()) {
    return true;
    94a6:	movs	r0, #1
    94a8:	pop	{r3, r4, r5, pc}
    94aa:	nop

000094ac <ExFatFile::addDirCluster()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
    94ac:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    94b0:	ldrb.w	r3, [r0, #49]	; 0x31
    94b4:	lsls	r1, r3, #25

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
    94b6:	mov	r4, r0
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    94b8:	bmi.n	957c <ExFatFile::addDirCluster()+0xd0>
    94ba:	ldr	r0, [r0, #8]
    94bc:	ldr	r3, [r4, #32]
  uint8_t* cache;
  dl += m_vol->bytesPerCluster();
  if (dl >= 0X4000000) {
    94be:	ldr.w	r3, [r3, #1084]	; 0x43c
    94c2:	add	r0, r3
    94c4:	cmp.w	r0, #67108864	; 0x4000000
    94c8:	bcc.n	94d0 <ExFatFile::addDirCluster()+0x24>
  }
  return sync();

 fail:
  return false;
}
    94ca:	movs	r0, #0
    94cc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  dl += m_vol->bytesPerCluster();
  if (dl >= 0X4000000) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
    94d0:	mov	r0, r4
    94d2:	bl	9148 <ExFatFile::addCluster()>
    94d6:	cmp	r0, #0
    94d8:	beq.n	94ca <ExFatFile::addDirCluster()+0x1e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  cache =  m_vol->cacheClear();
    94da:	ldr	r6, [r4, #32]
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    if (isDirty() && !sync()) {
    94dc:	ldrb.w	r3, [r6, #528]	; 0x210
    94e0:	lsls	r2, r3, #31
    94e2:	bmi.n	9584 <ExFatFile::addDirCluster()+0xd8>
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    94e4:	mov.w	r3, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    94e8:	movs	r5, #0
  uint8_t* clear() {
    if (isDirty() && !sync()) {
      return nullptr;
    }
    invalidate();
    return m_buffer;
    94ea:	add.w	r8, r6, #544	; 0x220
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    94ee:	str.w	r3, [r6, #540]	; 0x21c
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    94f2:	strb.w	r5, [r6, #528]	; 0x210
  if (!cache) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(cache, 0, m_vol->bytesPerSector());
    94f6:	mov	r1, r5
    94f8:	mov.w	r2, #512	; 0x200
    94fc:	mov	r0, r8
    94fe:	bl	1059c <memset>
  sector = m_vol->clusterStartSector(m_curCluster);
    9502:	ldr	r2, [r4, #32]
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    9504:	ldr	r3, [r4, #24]
    9506:	ldrb.w	r0, [r2, #1093]	; 0x445
    950a:	ldr.w	r1, [r2, #1068]	; 0x42c
    950e:	subs	r3, #2
    9510:	lsls	r3, r0
  for (uint32_t i = 0; i < m_vol->sectorsPerCluster(); i++) {
    9512:	movs	r6, #1
    9514:	adds	r7, r3, r1
    9516:	lsls.w	r3, r6, r0
    951a:	beq.n	953e <ExFatFile::addDirCluster()+0x92>
    951c:	ldr.w	r0, [r2, #1088]	; 0x440
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool writeSector(uint32_t sector, const uint8_t* src) {
    return m_blockDev->writeSector(sector, src);
    9520:	ldr	r3, [r0, #0]
    9522:	adds	r1, r7, r5
    9524:	ldr	r3, [r3, #28]
    9526:	mov	r2, r8
    9528:	blx	r3
    952a:	adds	r5, #1
    if (!m_vol->writeSector(sector + i, cache)) {
    952c:	cmp	r0, #0
    952e:	beq.n	94ca <ExFatFile::addDirCluster()+0x1e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(cache, 0, m_vol->bytesPerSector());
  sector = m_vol->clusterStartSector(m_curCluster);
  for (uint32_t i = 0; i < m_vol->sectorsPerCluster(); i++) {
    9530:	ldr	r2, [r4, #32]
    9532:	ldrb.w	r3, [r2, #1093]	; 0x445
    9536:	lsl.w	r3, r6, r3
    953a:	cmp	r3, r5
    953c:	bhi.n	951c <ExFatFile::addDirCluster()+0x70>
    if (!m_vol->writeSector(sector + i, cache)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  if (!isRoot()) {
    953e:	ldrb.w	r3, [r4, #49]	; 0x31
    9542:	lsls	r3, r3, #25
    9544:	bmi.n	9572 <ExFatFile::addDirCluster()+0xc6>
    m_flags |= FILE_FLAG_DIR_DIRTY;
    9546:	ldrb.w	r3, [r4, #51]	; 0x33
    954a:	orn	r3, r3, #127	; 0x7f
    954e:	strb.w	r3, [r4, #51]	; 0x33
    m_dataLength  += m_vol->bytesPerCluster();
    9552:	ldr.w	r6, [r2, #1084]	; 0x43c
    9556:	ldrd	r2, r3, [r4, #8]
    m_validLength += m_vol->bytesPerCluster();
    955a:	ldrd	r0, r1, [r4, #16]
      goto fail;
    }
  }
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    m_dataLength  += m_vol->bytesPerCluster();
    955e:	adds	r2, r2, r6
    9560:	mov.w	r7, #0
    9564:	adcs	r3, r7
    m_validLength += m_vol->bytesPerCluster();
    9566:	adds	r0, r0, r6
    9568:	adcs	r1, r7
      goto fail;
    }
  }
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    m_dataLength  += m_vol->bytesPerCluster();
    956a:	strd	r2, r3, [r4, #8]
    m_validLength += m_vol->bytesPerCluster();
    956e:	strd	r0, r1, [r4, #16]
  }
  return sync();
    9572:	mov	r0, r4

 fail:
  return false;
}
    9574:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    m_dataLength  += m_vol->bytesPerCluster();
    m_validLength += m_vol->bytesPerCluster();
  }
  return sync();
    9578:	b.w	944c <ExFatFile::sync()>
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    957c:	ldr	r0, [r0, #32]
    957e:	bl	909c <ExFatPartition::rootLength()>
    9582:	b.n	94bc <ExFatFile::addDirCluster()+0x10>
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    if (isDirty() && !sync()) {
    9584:	add.w	r0, r6, #528	; 0x210
    9588:	bl	8248 <FsCache::sync()>
    958c:	cmp	r0, #0
    958e:	bne.n	94e4 <ExFatFile::addDirCluster()+0x38>
    9590:	b.n	94ca <ExFatFile::addDirCluster()+0x1e>
    9592:	nop

00009594 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, ExName_t* fname) {
  if (!parent->isDir()) {
    9594:	ldrb.w	r3, [r1, #49]	; 0x31
    9598:	tst.w	r3, #80	; 0x50
    959c:	bne.n	95a2 <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0xe>
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
}
    959e:	movs	r0, #0
    95a0:	bx	lr

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, ExName_t* fname) {
    95a2:	push	{r4, r5, lr}
    95a4:	sub	sp, #12
  uint8_t setCount() const {return m_setCount;}
  bool mkdir(ExFatFile* parent, ExName_t* fname);
  bool openRootFile(ExFatFile* dir,
                    const ExChar_t* name, uint8_t nameLength, oflag_t oflag);
  bool open(ExFatFile* dirFile, ExName_t* fname, oflag_t oflag) {
    return openRootFile(dirFile, fname->lfn, fname->len, oflag);
    95a6:	movw	r5, #2562	; 0xa02
    95aa:	ldrb	r3, [r2, #0]
    95ac:	ldr	r2, [r2, #4]
    95ae:	str	r5, [sp, #0]
    95b0:	mov	r4, r0
    95b2:	bl	86e0 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>
  if (!parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // create a normal file
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    95b6:	cbnz	r0, 95be <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x2a>
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
}
    95b8:	movs	r0, #0
    95ba:	add	sp, #12
    95bc:	pop	{r4, r5, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory

  m_attributes = FILE_ATTR_SUBDIR;
    95be:	movs	r3, #16
    95c0:	strb.w	r3, [r4, #49]	; 0x31

  // allocate and zero first cluster
  if (!addDirCluster()) {
    95c4:	mov	r0, r4
    95c6:	bl	94ac <ExFatFile::addDirCluster()>
    95ca:	cmp	r0, #0
    95cc:	beq.n	95b8 <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x24>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_firstCluster = m_curCluster;
    95ce:	ldr	r3, [r4, #24]
    95d0:	str	r3, [r4, #28]
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const ExChar_t* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    95d2:	movs	r2, #0
    95d4:	movs	r3, #0
    95d6:	mov	r0, r4
    95d8:	bl	85e0 <ExFatFile::seekSet(unsigned long long)>

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    95dc:	movs	r3, #193	; 0xc1
  return sync();
    95de:	mov	r0, r4
  }
  m_firstCluster = m_curCluster;

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    95e0:	strb.w	r3, [r4, #51]	; 0x33
  return sync();

 fail:
  return false;
}
    95e4:	add	sp, #12
    95e6:	ldmia.w	sp!, {r4, r5, lr}
  m_firstCluster = m_curCluster;

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
  return sync();
    95ea:	b.w	944c <ExFatFile::sync()>
    95ee:	nop

000095f0 <ExFatFile::mkdir(ExFatFile*, char const*, bool)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, const ExChar_t* path, bool pFlag) {
    95f0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    95f4:	mov	r6, r0
    95f6:	sub	sp, #84	; 0x54
  ExName_t fname;
  ExFatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    95f8:	ldrb.w	r5, [r6, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, const ExChar_t* path, bool pFlag) {
    95fc:	str	r2, [sp, #12]
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    95fe:	movs	r0, #0
    9600:	strb.w	r0, [sp, #73]	; 0x49
    9604:	strb.w	r0, [sp, #74]	; 0x4a
    9608:	strb.w	r0, [sp, #75]	; 0x4b
  ExName_t fname;
  ExFatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    960c:	cbnz	r5, 961c <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x2c>
    960e:	mov	r9, r3
    9610:	ldrb.w	r3, [r1, #49]	; 0x31
    9614:	tst.w	r3, #80	; 0x50
    9618:	mov	r4, r1
    961a:	bne.n	9624 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x34>
    close();
  }
  return mkdir(parent, &fname);

 fail:
  return false;
    961c:	movs	r0, #0
}
    961e:	add	sp, #84	; 0x54
    9620:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    9624:	ldrb	r3, [r2, #0]
    9626:	cmp	r3, #47	; 0x2f
    9628:	mov	r1, r2
    962a:	beq.n	969a <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xaa>
  uint8_t setCount() const {return m_setCount;}
  bool mkdir(ExFatFile* parent, ExName_t* fname);
  bool openRootFile(ExFatFile* dir,
                    const ExChar_t* name, uint8_t nameLength, oflag_t oflag);
  bool open(ExFatFile* dirFile, ExName_t* fname, oflag_t oflag) {
    return openRootFile(dirFile, fname->lfn, fname->len, oflag);
    962c:	mov.w	r8, #0
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    9630:	add	r3, sp, #12
    9632:	add	r2, sp, #16
    9634:	mov	r0, r6
    9636:	bl	8344 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>
    963a:	cmp	r0, #0
    963c:	beq.n	961c <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x2c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    963e:	ldr	r3, [sp, #12]
    9640:	ldrb	r3, [r3, #0]
    9642:	cmp	r3, #0
    9644:	beq.n	96b6 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xc6>
    9646:	ldrb.w	r3, [sp, #16]
    964a:	ldr	r2, [sp, #20]
    964c:	str.w	r8, [sp]
    9650:	mov	r1, r4
    9652:	mov	r0, r6
    9654:	bl	86e0 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    9658:	cbnz	r0, 966e <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x7e>
      if (!pFlag || !mkdir(parent, &fname)) {
    965a:	cmp.w	r9, #0
    965e:	beq.n	961c <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x2c>
    9660:	mov	r1, r4
    9662:	add	r2, sp, #16
    9664:	mov	r0, r6
    9666:	bl	9594 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>
    966a:	cmp	r0, #0
    966c:	beq.n	961c <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x2c>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    966e:	mov	r4, r6
    9670:	add	r7, sp, #24
    9672:	add.w	lr, r6, #48	; 0x30
    9676:	ldr	r0, [r4, #0]
    9678:	ldr	r1, [r4, #4]
    967a:	ldr	r2, [r4, #8]
    967c:	ldr	r3, [r4, #12]
    967e:	mov	r5, r7
    9680:	stmia	r5!, {r0, r1, r2, r3}
    9682:	adds	r4, #16
    9684:	cmp	r4, lr
    9686:	mov	r7, r5
    9688:	bne.n	9676 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x86>
    968a:	ldr	r0, [r4, #0]
    968c:	str	r0, [r5, #0]
    parent = &tmpDir;
    close();
    968e:	mov	r0, r6
    9690:	bl	8258 <ExFatFile::close()>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    parent = &tmpDir;
    9694:	add	r4, sp, #24
    9696:	ldr	r1, [sp, #12]
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    9698:	b.n	9630 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x40>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    969a:	adds	r1, #1
    969c:	str	r1, [sp, #12]
  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    969e:	ldrb	r3, [r1, #0]
    96a0:	cmp	r3, #47	; 0x2f
    96a2:	beq.n	969a <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xaa>
      path++;
    }
    if (!tmpDir.openRoot(parent->m_vol)) {
    96a4:	ldr	r1, [r4, #32]
    96a6:	add	r0, sp, #24
    96a8:	bl	831c <ExFatFile::openRoot(ExFatVolume*)>
    96ac:	cmp	r0, #0
    96ae:	beq.n	961c <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x2c>
    96b0:	ldr	r1, [sp, #12]
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
    96b2:	add	r4, sp, #24
    96b4:	b.n	962c <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x3c>
    }
    tmpDir = *this;
    parent = &tmpDir;
    close();
  }
  return mkdir(parent, &fname);
    96b6:	add	r2, sp, #16
    96b8:	mov	r1, r4
    96ba:	mov	r0, r6
    96bc:	bl	9594 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>

 fail:
  return false;
}
    96c0:	add	sp, #84	; 0x54
    96c2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    96c6:	nop

000096c8 <ExFatFile::rename(ExFatFile*, char const*)>:
//------------------------------------------------------------------------------
bool ExFatFile::rename(const ExChar_t* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool ExFatFile::rename(ExFatFile* dirFile, const ExChar_t* newPath) {
    96c8:	push	{r4, r5, r6, r7, lr}
  ExFatFile file;
  ExFatFile oldFile;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    96ca:	ldrb.w	r4, [r0, #49]	; 0x31
//------------------------------------------------------------------------------
bool ExFatFile::rename(const ExChar_t* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool ExFatFile::rename(ExFatFile* dirFile, const ExChar_t* newPath) {
    96ce:	sub	sp, #116	; 0x74
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    96d0:	movs	r3, #0
  ExFatFile file;
  ExFatFile oldFile;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    96d2:	tst.w	r4, #24
    96d6:	strb.w	r3, [sp, #49]	; 0x31
    96da:	strb.w	r3, [sp, #50]	; 0x32
    96de:	strb.w	r3, [sp, #51]	; 0x33
    96e2:	strb.w	r3, [sp, #105]	; 0x69
    96e6:	strb.w	r3, [sp, #106]	; 0x6a
    96ea:	strb.w	r3, [sp, #107]	; 0x6b
    96ee:	beq.n	96f8 <ExFatFile::rename(ExFatFile*, char const*)+0x30>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    96f0:	ldr	r3, [r1, #32]
    96f2:	ldr	r4, [r0, #32]
    96f4:	cmp	r4, r3
    96f6:	beq.n	96fe <ExFatFile::rename(ExFatFile*, char const*)+0x36>
  oldFile.m_flags = FILE_FLAG_WRITE;
  oldFile.m_attributes = FILE_ATTR_FILE;
  return oldFile.remove();

 fail:
  return false;
    96f8:	movs	r0, #0
}
    96fa:	add	sp, #116	; 0x74
    96fc:	pop	{r4, r5, r6, r7, pc}
    96fe:	mov	r4, r0
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    9700:	movw	r3, #2561	; 0xa01
    9704:	mov	r0, sp
    9706:	bl	8abc <ExFatFile::open(ExFatFile*, char const*, int)>
    970a:	cmp	r0, #0
    970c:	beq.n	96f8 <ExFatFile::rename(ExFatFile*, char const*)+0x30>
    DBG_FAIL_MACRO;
    goto fail;
  }
  oldFile = *this;
    970e:	add	r7, sp, #56	; 0x38
    9710:	mov	r5, r4
    9712:	add.w	lr, r4, #48	; 0x30
    9716:	ldr	r0, [r5, #0]
    9718:	ldr	r1, [r5, #4]
    971a:	ldr	r2, [r5, #8]
    971c:	ldr	r3, [r5, #12]
    971e:	mov	r6, r7
    9720:	stmia	r6!, {r0, r1, r2, r3}
    9722:	adds	r5, #16
    9724:	cmp	r5, lr
    9726:	mov	r7, r6
    9728:	bne.n	9716 <ExFatFile::rename(ExFatFile*, char const*)+0x4e>
    972a:	ldr	r0, [r5, #0]
    972c:	str	r0, [r6, #0]
  m_dirPos = file.m_dirPos;
    972e:	add	r3, sp, #36	; 0x24
    9730:	ldmia.w	r3, {r0, r1, r2}
    9734:	add.w	r3, r4, #36	; 0x24
    9738:	stmia.w	r3, {r0, r1, r2}
  m_setCount = file.m_setCount;
  m_flags |= FILE_FLAG_DIR_DIRTY;
    973c:	ldrb.w	r3, [r4, #51]	; 0x33
    DBG_FAIL_MACRO;
    goto fail;
  }
  oldFile = *this;
  m_dirPos = file.m_dirPos;
  m_setCount = file.m_setCount;
    9740:	ldrb.w	r2, [sp, #48]	; 0x30
    9744:	strb.w	r2, [r4, #48]	; 0x30
  m_flags |= FILE_FLAG_DIR_DIRTY;
    9748:	orn	r3, r3, #127	; 0x7f
    974c:	strb.w	r3, [r4, #51]	; 0x33
  if (!sync()) {
    9750:	mov	r0, r4
    9752:	bl	944c <ExFatFile::sync()>
    9756:	cmp	r0, #0
    9758:	beq.n	96f8 <ExFatFile::rename(ExFatFile*, char const*)+0x30>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    975a:	movs	r1, #0
  oldFile.m_flags = FILE_FLAG_WRITE;
    975c:	movs	r2, #2
  oldFile.m_attributes = FILE_ATTR_FILE;
    975e:	movs	r3, #8
  return oldFile.remove();
    9760:	add	r0, sp, #56	; 0x38
  if (!sync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    9762:	str	r1, [sp, #84]	; 0x54
  oldFile.m_flags = FILE_FLAG_WRITE;
    9764:	strb.w	r2, [sp, #107]	; 0x6b
  oldFile.m_attributes = FILE_ATTR_FILE;
    9768:	strb.w	r3, [sp, #105]	; 0x69
  return oldFile.remove();
    976c:	bl	91d4 <ExFatFile::remove()>
    9770:	b.n	96fa <ExFatFile::rename(ExFatFile*, char const*)+0x32>
    9772:	nop

00009774 <ExFatFile::truncate()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    9774:	ldrb.w	r3, [r0, #51]	; 0x33
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    9778:	lsls	r2, r3, #30
    977a:	bpl.n	97ae <ExFatFile::truncate()+0x3a>

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    977c:	push	{r4, r5, r6, r7, lr}
  // error if not a normal file or read-only
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
    977e:	ldr	r5, [r0, #28]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    9780:	sub	sp, #12
  // error if not a normal file or read-only
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
    9782:	cbz	r5, 97a8 <ExFatFile::truncate()+0x34>
      return true;
  }
  if (isContiguous()) {
    9784:	and.w	r3, r3, #64	; 0x40
    9788:	mov	r4, r0
    978a:	and.w	r0, r3, #255	; 0xff
    978e:	cbnz	r3, 97b2 <ExFatFile::truncate()+0x3e>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else {
    // need to free chain
    if (m_curCluster) {
    9790:	ldr	r1, [r4, #24]
    9792:	cmp	r1, #0
    9794:	bne.n	981a <ExFatFile::truncate()+0xa6>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
    } else {
      toFree = m_firstCluster;
    9796:	str	r5, [sp, #4]
      m_firstCluster = 0;
    9798:	str	r1, [r4, #28]
    }
    if (toFree) {
      if (!m_vol->freeChain(toFree)) {
    979a:	mov	r1, r5
    979c:	ldr	r0, [r4, #32]
    979e:	bl	8ec8 <ExFatPartition::freeChain(unsigned long)>
    97a2:	cbnz	r0, 97f2 <ExFatFile::truncate()+0x7e>
  m_validLength = m_curPosition;
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
    97a4:	movs	r0, #0
    97a6:	b.n	97aa <ExFatFile::truncate()+0x36>
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
    97a8:	movs	r0, #1
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
}
    97aa:	add	sp, #12
    97ac:	pop	{r4, r5, r6, r7, pc}
  m_validLength = m_curPosition;
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
    97ae:	movs	r0, #0
}
    97b0:	bx	lr
    97b2:	ldr	r0, [r4, #32]
  if (m_firstCluster == 0) {
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
    97b4:	ldr	r1, [r4, #24]
  }
  if (m_firstCluster == 0) {
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    97b6:	ldrb.w	r3, [r0, #1093]	; 0x445
    97ba:	ldrd	r6, r7, [r4, #8]
    97be:	adds	r3, #9
    97c0:	uxtb	r3, r3
    97c2:	adds.w	r6, r6, #4294967295
    97c6:	rsb	lr, r3, #32
    97ca:	adc.w	r7, r7, #4294967295
    97ce:	lsr.w	r2, r6, r3
    97d2:	lsl.w	lr, r7, lr
    97d6:	subs	r3, #32
    97d8:	orr.w	r2, r2, lr
    97dc:	lsr.w	r3, r7, r3
    97e0:	orrs	r2, r3
    97e2:	adds	r2, #1
    if (m_curCluster) {
    97e4:	cbz	r1, 9814 <ExFatFile::truncate()+0xa0>
      toFree = m_curCluster + 1;
      nc -= 1 + m_curCluster - m_firstCluster;
    97e6:	subs	r5, #1
    97e8:	subs	r5, r5, r1
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
    97ea:	adds	r1, #1
      nc -= 1 + m_curCluster - m_firstCluster;
    97ec:	add	r2, r5
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
    97ee:	str	r1, [sp, #4]
      nc -= 1 + m_curCluster - m_firstCluster;
    } else {
      toFree = m_firstCluster;
      m_firstCluster = 0;
    }
    if (nc && !m_vol->bitmapModify(toFree, nc, 0)) {
    97f0:	cbnz	r2, 9836 <ExFatFile::truncate()+0xc2>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  }
  m_dataLength = m_curPosition;
    97f2:	ldrd	r0, r1, [r4]
  m_validLength = m_curPosition;
  m_flags |= FILE_FLAG_DIR_DIRTY;
    97f6:	ldrb.w	r3, [r4, #51]	; 0x33
    97fa:	orn	r3, r3, #127	; 0x7f
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  }
  m_dataLength = m_curPosition;
    97fe:	strd	r0, r1, [r4, #8]
  m_validLength = m_curPosition;
    9802:	strd	r0, r1, [r4, #16]
  m_flags |= FILE_FLAG_DIR_DIRTY;
    9806:	strb.w	r3, [r4, #51]	; 0x33
  return sync();
    980a:	mov	r0, r4
    980c:	bl	944c <ExFatFile::sync()>

 fail:
  return false;
}
    9810:	add	sp, #12
    9812:	pop	{r4, r5, r6, r7, pc}
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
      nc -= 1 + m_curCluster - m_firstCluster;
    } else {
      toFree = m_firstCluster;
    9814:	str	r5, [sp, #4]
      m_firstCluster = 0;
    9816:	str	r1, [r4, #28]
    9818:	b.n	97f0 <ExFatFile::truncate()+0x7c>
      goto fail;
    }
  } else {
    // need to free chain
    if (m_curCluster) {
      toFree = 0;
    981a:	add	r2, sp, #8
    981c:	str.w	r0, [r2, #-4]!
      int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    9820:	ldr	r0, [r4, #32]
    9822:	bl	8e90 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    9826:	sxtb	r0, r0
      if (fg < 0) {
    9828:	cmp	r0, #0
    982a:	blt.n	97a4 <ExFatFile::truncate()+0x30>
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (fg) {
    982c:	bne.n	9844 <ExFatFile::truncate()+0xd0>
      }
    } else {
      toFree = m_firstCluster;
      m_firstCluster = 0;
    }
    if (toFree) {
    982e:	ldr	r5, [sp, #4]
    9830:	cmp	r5, #0
    9832:	beq.n	97f2 <ExFatFile::truncate()+0x7e>
    9834:	b.n	979a <ExFatFile::truncate()+0x26>
      nc -= 1 + m_curCluster - m_firstCluster;
    } else {
      toFree = m_firstCluster;
      m_firstCluster = 0;
    }
    if (nc && !m_vol->bitmapModify(toFree, nc, 0)) {
    9836:	movs	r3, #0
    9838:	ldr	r1, [sp, #4]
    983a:	bl	8d20 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    983e:	cmp	r0, #0
    9840:	bne.n	97f2 <ExFatFile::truncate()+0x7e>
    9842:	b.n	97a4 <ExFatFile::truncate()+0x30>
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (fg) {
        // current cluster is end of chain
        if (!m_vol->fatPut(m_curCluster, EXFAT_EOC)) {
    9844:	mov.w	r2, #4294967295
    9848:	ldr	r1, [r4, #24]
    984a:	ldr	r0, [r4, #32]
    984c:	bl	8ea4 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    9850:	cmp	r0, #0
    9852:	bne.n	982e <ExFatFile::truncate()+0xba>
    9854:	b.n	97a4 <ExFatFile::truncate()+0x30>
    9856:	nop

00009858 <ExFatFile::write(void const*, unsigned int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    9858:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    985c:	ldrb.w	r3, [r0, #51]	; 0x33
    9860:	sub	sp, #12

  // number of bytes left to write  -  must be before goto statements
  size_t toWrite = nbyte;
  size_t n;
  // error if not an open file or is read-only
  if (!isWritable()) {
    9862:	lsls	r5, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    9864:	mov	r4, r0
    9866:	str	r2, [sp, #0]

  // number of bytes left to write  -  must be before goto statements
  size_t toWrite = nbyte;
  size_t n;
  // error if not an open file or is read-only
  if (!isWritable()) {
    9868:	bmi.n	9880 <ExFatFile::write(void const*, unsigned int)+0x28>
  }
  return nbyte;

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
    986a:	ldrb.w	r3, [r4, #50]	; 0x32
    986e:	orr.w	r3, r3, #1
    9872:	strb.w	r3, [r4, #50]	; 0x32
  return -1;
    9876:	mov.w	r0, #4294967295
}
    987a:	add	sp, #12
    987c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    9880:	lsls	r2, r3, #28
    9882:	mov	r9, r1
    9884:	bmi.w	9a8a <ExFatFile::write(void const*, unsigned int)+0x232>
    if (!seekSet(m_validLength)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    9888:	ldr	r3, [sp, #0]
    988a:	cmp	r3, #0
    988c:	beq.w	9ab2 <ExFatFile::write(void const*, unsigned int)+0x25a>
    9890:	mov	r1, r4
    9892:	ldrd	r2, r3, [r1], #24
    9896:	ldr.w	r8, [sp]
    989a:	str	r1, [sp, #4]
      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    989c:	mov.w	fp, #1
    98a0:	mov	sl, r9
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    clusterOffset = m_curPosition & m_vol->clusterMask();
    98a2:	ldr	r0, [r4, #32]
    98a4:	ldr.w	r5, [r0, #1080]	; 0x438
    98a8:	ands	r5, r2
    sectorOffset = clusterOffset & m_vol->sectorMask();
    98aa:	ubfx	r9, r5, #0, #9
    if (clusterOffset == 0) {
    98ae:	cbnz	r5, 9902 <ExFatFile::write(void const*, unsigned int)+0xaa>
      // start of new cluster
      if (m_curCluster != 0) {
    98b0:	ldr	r1, [r4, #24]
    98b2:	cmp	r1, #0
    98b4:	beq.w	9a14 <ExFatFile::write(void const*, unsigned int)+0x1bc>
        int fg;

        if (isContiguous()) {
    98b8:	ldrb.w	r3, [r4, #51]	; 0x33
    98bc:	lsls	r3, r3, #25
    98be:	bpl.w	9a5c <ExFatFile::write(void const*, unsigned int)+0x204>
          uint32_t lc = m_firstCluster;
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
    98c2:	ldrd	r6, r7, [r4, #8]
    98c6:	ldrb.w	r2, [r0, #1093]	; 0x445
      // start of new cluster
      if (m_curCluster != 0) {
        int fg;

        if (isContiguous()) {
          uint32_t lc = m_firstCluster;
    98ca:	ldr	r3, [r4, #28]
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
    98cc:	adds	r2, #9
    98ce:	uxtb	r2, r2
    98d0:	adds.w	r6, r6, #4294967295
    98d4:	adc.w	r7, r7, #4294967295
    98d8:	rsb	lr, r2, #32
    98dc:	lsrs	r6, r2
    98de:	lsl.w	lr, r7, lr
    98e2:	subs	r2, #32
    98e4:	orr.w	r6, r6, lr
    98e8:	lsr.w	r2, r7, r2
    98ec:	orrs	r6, r2
    98ee:	add	r3, r6
    98f0:	cmp	r1, r3
    98f2:	bcc.w	9a42 <ExFatFile::write(void const*, unsigned int)+0x1ea>
            goto fail;
          }
        }
        if (fg == 0) {
          // add cluster if at end of chain
          if (!addCluster()) {
    98f6:	mov	r0, r4
    98f8:	bl	9148 <ExFatFile::addCluster()>
    98fc:	cmp	r0, #0
    98fe:	beq.n	986a <ExFatFile::write(void const*, unsigned int)+0x12>
    9900:	ldr	r0, [r4, #32]
    9902:	ldr	r6, [r4, #24]
        }
      }
    }
    // sector for data write
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    9904:	ldr.w	r7, [r0, #1068]	; 0x42c
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    9908:	ldrb.w	lr, [r0, #1093]	; 0x445
    990c:	lsrs	r5, r5, #9
    990e:	subs	r6, #2
    9910:	adds	r1, r5, r7
    9912:	lsl.w	r6, r6, lr
    9916:	add	r1, r6

    if (sectorOffset != 0 || toWrite < m_vol->bytesPerSector()) {
    9918:	cmp.w	r9, #0
    991c:	bne.n	9a06 <ExFatFile::write(void const*, unsigned int)+0x1ae>
    991e:	cmp.w	r8, #512	; 0x200
    9922:	bcs.n	99c0 <ExFatFile::write(void const*, unsigned int)+0x168>
      // lesser of space and amount to write
      if (n > toWrite) {
        n = toWrite;
      }

      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
    9924:	ldrd	r2, r3, [r4, #16]
    9928:	ldrd	r6, r7, [r4]
    992c:	cmp.w	r8, #512	; 0x200
    9930:	mov	r5, r8
    9932:	it	cs
    9934:	movcs.w	r5, #512	; 0x200
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    9938:	cmp	r7, r3
    993a:	it	eq
    993c:	cmpeq	r6, r2
    993e:	ite	cc
    9940:	movcc	r2, #1
    9942:	movcs	r2, #5
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    9944:	add.w	r0, r0, #528	; 0x210
    9948:	bl	81e8 <FsCache::get(unsigned long, unsigned char)>
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
      }
      cache = m_vol->dataCacheGet(sector, cacheOption);
      if (!cache) {
    994c:	cmp	r0, #0
    994e:	beq.n	986a <ExFatFile::write(void const*, unsigned int)+0x12>
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
    9950:	add	r0, r9
    9952:	mov	r2, r5
    9954:	mov	r1, sl
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    9956:	add	r9, r5
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
    9958:	bl	d444 <memcpy>
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    995c:	cmp.w	r9, #512	; 0x200
    9960:	beq.w	9a78 <ExFatFile::write(void const*, unsigned int)+0x220>
    9964:	mov	r0, r5
    9966:	movs	r1, #0
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    9968:	ldrd	r2, r3, [r4]
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
    996c:	ldrd	r6, r7, [r4, #16]
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    9970:	adds	r2, r2, r0
    9972:	adcs	r3, r1
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
    9974:	cmp	r7, r3
    9976:	it	eq
    9978:	cmpeq	r6, r2
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    src += n;
    997a:	add	sl, r5
    toWrite -= n;
    997c:	rsb	r8, r5, r8
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    9980:	strd	r2, r3, [r4]
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
    9984:	bcs.n	9996 <ExFatFile::write(void const*, unsigned int)+0x13e>
      m_flags |= FILE_FLAG_DIR_DIRTY;
    9986:	ldrb.w	r1, [r4, #51]	; 0x33
      m_validLength = m_curPosition;
    998a:	strd	r2, r3, [r4, #16]
    }
    m_curPosition += n;
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
      m_flags |= FILE_FLAG_DIR_DIRTY;
    998e:	orn	r1, r1, #127	; 0x7f
    9992:	strb.w	r1, [r4, #51]	; 0x33
    if (!seekSet(m_validLength)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    9996:	cmp.w	r8, #0
    999a:	bne.n	98a2 <ExFatFile::write(void const*, unsigned int)+0x4a>
    if (m_curPosition > m_validLength) {
      m_flags |= FILE_FLAG_DIR_DIRTY;
      m_validLength = m_curPosition;
    }
  }
  if (m_curPosition > m_dataLength) {
    999c:	ldrd	r0, r1, [r4, #8]
    99a0:	cmp	r1, r3
    99a2:	it	eq
    99a4:	cmpeq	r0, r2
    99a6:	bcc.n	9a9a <ExFatFile::write(void const*, unsigned int)+0x242>
    m_dataLength = m_curPosition;
    // update fileSize and insure sync will update dir entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    99a8:	ldr	r3, [pc, #268]	; (9ab8 <ExFatFile::write(void const*, unsigned int)+0x260>)
    99aa:	ldr	r3, [r3, #0]
    99ac:	cmp	r3, #0
    99ae:	beq.n	9aae <ExFatFile::write(void const*, unsigned int)+0x256>
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
    99b0:	ldrb.w	r3, [r4, #51]	; 0x33
    99b4:	ldr	r0, [sp, #0]
    99b6:	orn	r3, r3, #127	; 0x7f
    99ba:	strb.w	r3, [r4, #51]	; 0x33
    99be:	b.n	987a <ExFatFile::write(void const*, unsigned int)+0x22>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (toWrite >= 2*m_vol->bytesPerSector()) {
    99c0:	cmp.w	r8, #1024	; 0x400
    99c4:	bcc.n	9a1c <ExFatFile::write(void const*, unsigned int)+0x1c4>
      // use multiple sector write command
      uint32_t ns = toWrite >> m_vol->bytesPerSectorShift();
      // Limit writes to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    99c6:	lsl.w	r3, fp, lr
    99ca:	subs	r5, r3, r5
    99cc:	ldr.w	r2, [r0, #540]	; 0x21c
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (toWrite >= 2*m_vol->bytesPerSector()) {
      // use multiple sector write command
      uint32_t ns = toWrite >> m_vol->bytesPerSectorShift();
    99d0:	mov.w	r3, r8, lsr #9
    99d4:	cmp	r3, r5
    99d6:	it	cs
    99d8:	movcs	r3, r5
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    99da:	cmp	r1, r2
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
    99dc:	mov.w	r5, r3, lsl #9
    99e0:	bhi.n	99f4 <ExFatFile::write(void const*, unsigned int)+0x19c>
    99e2:	adds	r6, r1, r3
    99e4:	cmp	r2, r6
    99e6:	bcs.n	99f4 <ExFatFile::write(void const*, unsigned int)+0x19c>
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    99e8:	mov.w	r2, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    99ec:	strb.w	r9, [r0, #528]	; 0x210
    m_sector = 0XFFFFFFFF;
    99f0:	str.w	r2, [r0, #540]	; 0x21c
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src, size_t count) {
     if (isCached(sector, count)) {
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
    99f4:	ldr.w	r0, [r0, #532]	; 0x214
    99f8:	ldr	r6, [r0, #0]
    99fa:	mov	r2, sl
    99fc:	ldr	r6, [r6, #32]
    99fe:	blx	r6
      if (!m_vol->cacheSafeWrite(sector, src, ns)) {
    9a00:	cmp	r0, #0
    9a02:	bne.n	9964 <ExFatFile::write(void const*, unsigned int)+0x10c>
    9a04:	b.n	986a <ExFatFile::write(void const*, unsigned int)+0x12>
             (clusterOffset >> m_vol->bytesPerSectorShift());

    if (sectorOffset != 0 || toWrite < m_vol->bytesPerSector()) {
      // partial sector - must use cache
      // max space in sector
      n = m_vol->bytesPerSector() - sectorOffset;
    9a06:	rsb	r5, r9, #512	; 0x200
    9a0a:	cmp	r5, r8
    9a0c:	it	cs
    9a0e:	movcs	r5, r8
      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    9a10:	movs	r2, #1
    9a12:	b.n	9944 <ExFatFile::write(void const*, unsigned int)+0xec>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      } else {
        if (m_firstCluster == 0) {
    9a14:	ldr	r6, [r4, #28]
    9a16:	cbz	r6, 9a48 <ExFatFile::write(void const*, unsigned int)+0x1f0>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
        } else {
          m_curCluster = m_firstCluster;
    9a18:	str	r6, [r4, #24]
    9a1a:	b.n	9904 <ExFatFile::write(void const*, unsigned int)+0xac>
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
    9a1c:	ldr.w	r3, [r0, #540]	; 0x21c
    9a20:	cmp	r1, r3
    9a22:	beq.n	9a6a <ExFatFile::write(void const*, unsigned int)+0x212>
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    9a24:	ldr.w	r0, [r0, #532]	; 0x214
    9a28:	ldr	r3, [r0, #0]
    9a2a:	mov	r2, sl
    9a2c:	ldr	r3, [r3, #28]
    9a2e:	blx	r3
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeWrite(sector, src)) {
    9a30:	cmp	r0, #0
    9a32:	beq.w	986a <ExFatFile::write(void const*, unsigned int)+0x12>
    9a36:	mov.w	r0, #512	; 0x200
    9a3a:	movs	r1, #0
         DBG_FAIL_MACRO;
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      n = m_vol->bytesPerSector();
    9a3c:	mov.w	r5, #512	; 0x200
    9a40:	b.n	9968 <ExFatFile::write(void const*, unsigned int)+0x110>

        if (isContiguous()) {
          uint32_t lc = m_firstCluster;
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
            m_curCluster++;
    9a42:	adds	r6, r1, #1
    9a44:	str	r6, [r4, #24]
    9a46:	b.n	9904 <ExFatFile::write(void const*, unsigned int)+0xac>
          }
        }
      } else {
        if (m_firstCluster == 0) {
          // allocate first cluster of file
          if (!addCluster()) {
    9a48:	mov	r0, r4
    9a4a:	bl	9148 <ExFatFile::addCluster()>
    9a4e:	cmp	r0, #0
    9a50:	beq.w	986a <ExFatFile::write(void const*, unsigned int)+0x12>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
    9a54:	ldr	r6, [r4, #24]
    9a56:	str	r6, [r4, #28]
    9a58:	ldr	r0, [r4, #32]
    9a5a:	b.n	9904 <ExFatFile::write(void const*, unsigned int)+0xac>
            fg = 1;
          } else {
            fg = 0;
          }
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    9a5c:	ldr	r2, [sp, #4]
    9a5e:	bl	8e90 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
        if (fg == 0) {
    9a62:	cmp	r0, #0
    9a64:	bne.w	9900 <ExFatFile::write(void const*, unsigned int)+0xa8>
    9a68:	b.n	98f6 <ExFatFile::write(void const*, unsigned int)+0x9e>
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    9a6a:	mov.w	r3, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    9a6e:	strb.w	r9, [r0, #528]	; 0x210
    m_sector = 0XFFFFFFFF;
    9a72:	str.w	r3, [r0, #540]	; 0x21c
    9a76:	b.n	9a24 <ExFatFile::write(void const*, unsigned int)+0x1cc>
  }
  uint32_t dataCacheSector() {return m_dataCache.sector();}
  bool dataCacheSync() {return m_dataCache.sync();}
    9a78:	ldr	r0, [r4, #32]
    9a7a:	add.w	r0, r0, #528	; 0x210
    9a7e:	bl	8248 <FsCache::sync()>
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
        // Force write if sector is full - improves large writes.
        if (!m_vol->dataCacheSync()) {
    9a82:	cmp	r0, #0
    9a84:	bne.w	9964 <ExFatFile::write(void const*, unsigned int)+0x10c>
    9a88:	b.n	986a <ExFatFile::write(void const*, unsigned int)+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    if (!seekSet(m_validLength)) {
    9a8a:	ldrd	r2, r3, [r0, #16]
    9a8e:	bl	85e0 <ExFatFile::seekSet(unsigned long long)>
    9a92:	cmp	r0, #0
    9a94:	beq.w	986a <ExFatFile::write(void const*, unsigned int)+0x12>
    9a98:	b.n	9888 <ExFatFile::write(void const*, unsigned int)+0x30>
    }
  }
  if (m_curPosition > m_dataLength) {
    m_dataLength = m_curPosition;
    // update fileSize and insure sync will update dir entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
    9a9a:	ldrb.w	r1, [r4, #51]	; 0x33
    9a9e:	ldr	r0, [sp, #0]
    9aa0:	orn	r1, r1, #127	; 0x7f
      m_flags |= FILE_FLAG_DIR_DIRTY;
      m_validLength = m_curPosition;
    }
  }
  if (m_curPosition > m_dataLength) {
    m_dataLength = m_curPosition;
    9aa4:	strd	r2, r3, [r4, #8]
    // update fileSize and insure sync will update dir entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
    9aa8:	strb.w	r1, [r4, #51]	; 0x33
    9aac:	b.n	987a <ExFatFile::write(void const*, unsigned int)+0x22>
    9aae:	ldr	r0, [sp, #0]
    9ab0:	b.n	987a <ExFatFile::write(void const*, unsigned int)+0x22>
    9ab2:	ldrd	r2, r3, [r4]
    9ab6:	b.n	999c <ExFatFile::write(void const*, unsigned int)+0x144>
    9ab8:	.word	0x1fff6188

00009abc <FatFile::openRoot(FatVolume*) [clone .part.38]>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
    9abc:	push	{r3, r4, r5, lr}
    9abe:	mov	r4, r0
    9ac0:	mov	r5, r1
  // error if file is already open
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(FatFile));
    9ac2:	movs	r2, #36	; 0x24
    9ac4:	movs	r1, #0
    9ac6:	bl	1059c <memset>

  m_vol = vol;
    9aca:	str	r5, [r4, #8]
  switch (vol->fatType()) {
    9acc:	ldrb	r3, [r5, #7]
    9ace:	cmp	r3, #16
    9ad0:	beq.n	9ae4 <FatFile::openRoot(FatVolume*) [clone .part.38]+0x28>
    9ad2:	cmp	r3, #32
    9ad4:	bne.n	9ae0 <FatFile::openRoot(FatVolume*) [clone .part.38]+0x24>
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attributes = FILE_ATTR_ROOT32;
    9ad6:	movs	r3, #64	; 0x40
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    9ad8:	movs	r0, #1
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attributes = FILE_ATTR_ROOT32;
    9ada:	strb	r3, [r4, #0]
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    9adc:	strb	r0, [r4, #2]
    9ade:	pop	{r3, r4, r5, pc}
  return true;

 fail:
  return false;
    9ae0:	movs	r0, #0
}
    9ae2:	pop	{r3, r4, r5, pc}
  switch (vol->fatType()) {
#if FAT12_SUPPORT
  case 12:
#endif  // FAT12_SUPPORT
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    9ae4:	movs	r3, #32
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    9ae6:	movs	r0, #1
  switch (vol->fatType()) {
#if FAT12_SUPPORT
  case 12:
#endif  // FAT12_SUPPORT
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    9ae8:	strb	r3, [r4, #0]
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    9aea:	strb	r0, [r4, #2]
    9aec:	pop	{r3, r4, r5, pc}
    9aee:	nop

00009af0 <FatFile::addCluster()>:
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
    9af0:	mov	r2, r0
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
    9af2:	push	{r3, r4, r5, lr}
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
    9af4:	ldr.w	r5, [r2, #16]!
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
    9af8:	mov	r4, r0
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
  if (!m_vol->allocateCluster(m_curCluster, &m_curCluster)) {
    9afa:	mov	r1, r5
    9afc:	ldr	r0, [r0, #8]
    9afe:	bl	a938 <FatPartition::allocateCluster(unsigned long, unsigned long*)>
    9b02:	cbz	r0, 9b1a <FatFile::addCluster()+0x2a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (cc == 0) {
    9b04:	cbz	r5, 9b1c <FatFile::addCluster()+0x2c>
    m_flags |= FILE_FLAG_CONTIGUOUS;
  } else if (m_curCluster != (cc + 1)) {
    9b06:	ldr	r3, [r4, #16]
    9b08:	adds	r5, #1
    9b0a:	cmp	r3, r5
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    9b0c:	ldrb	r3, [r4, #2]
    9b0e:	it	ne
    9b10:	andne.w	r3, r3, #191	; 0xbf
  }
  m_flags |= FILE_FLAG_DIR_DIRTY;
    9b14:	orn	r3, r3, #127	; 0x7f
    9b18:	strb	r3, [r4, #2]
  return false;
#else  // USE_FAT_FILE_FLAG_CONTIGUOUS
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return m_vol->allocateCluster(m_curCluster, &m_curCluster);
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
}
    9b1a:	pop	{r3, r4, r5, pc}
  if (!m_vol->allocateCluster(m_curCluster, &m_curCluster)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (cc == 0) {
    m_flags |= FILE_FLAG_CONTIGUOUS;
    9b1c:	ldrb	r3, [r4, #2]
    9b1e:	orr.w	r3, r3, #64	; 0x40
    9b22:	b.n	9b14 <FatFile::addCluster()+0x24>

00009b24 <FatFile::addDirCluster()>:
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
}
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// Return with first sector of cluster in the cache.
bool FatFile::addDirCluster() {
    9b24:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  cache_t* pc;

  if (isRootFixed()) {
    9b28:	ldrb	r3, [r0, #0]
    9b2a:	and.w	r3, r3, #32
    9b2e:	cbnz	r3, 9b3c <FatFile::addDirCluster()+0x18>
    9b30:	and.w	r4, r3, #255	; 0xff
    DBG_FAIL_MACRO;
    goto fail;
  }
  // max folder size
  if (m_curPosition >= 512UL*4095) {
    9b34:	ldr	r1, [r0, #20]
    9b36:	ldr	r3, [pc, #128]	; (9bb8 <FatFile::addDirCluster()+0x94>)
    9b38:	cmp	r1, r3
    9b3a:	bls.n	9b44 <FatFile::addDirCluster()+0x20>
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += m_vol->bytesPerCluster();
  return true;

 fail:
  return false;
    9b3c:	movs	r6, #0
}
    9b3e:	mov	r0, r6
    9b40:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    9b44:	mov	r5, r0
  // max folder size
  if (m_curPosition >= 512UL*4095) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
    9b46:	bl	9af0 <FatFile::addCluster()>
    9b4a:	mov	r6, r0
    9b4c:	cmp	r0, #0
    9b4e:	beq.n	9b3c <FatFile::addDirCluster()+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector = m_vol->clusterStartSector(m_curCluster);
    9b50:	ldr	r0, [r5, #8]
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
  }
  uint32_t clusterStartSector(uint32_t cluster) const {
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
    9b52:	ldr	r3, [r5, #16]
    9b54:	ldrb	r7, [r0, #6]
    9b56:	ldr	r2, [r0, #20]
    9b58:	subs	r3, #2
    9b5a:	lsls	r3, r7
    9b5c:	adds	r7, r3, r2
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    9b5e:	adds	r0, #36	; 0x24
    9b60:	mov	r1, r7
    9b62:	movs	r2, #5
    9b64:	bl	81e8 <FsCache::get(unsigned long, unsigned char)>
  pc = m_vol->cacheFetchData(sector, FsCache::CACHE_RESERVE_FOR_WRITE);
  if (!pc) {
    9b68:	mov	r8, r0
    9b6a:	cmp	r0, #0
    9b6c:	beq.n	9b3c <FatFile::addDirCluster()+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(pc, 0, m_vol->bytesPerSector());
    9b6e:	mov.w	r2, #512	; 0x200
    9b72:	mov	r1, r4
    9b74:	bl	1059c <memset>
  // zero rest of clusters
  for (uint8_t i = 1; i < m_vol->sectorsPerCluster(); i++) {
    9b78:	ldr	r3, [r5, #8]
    9b7a:	ldrb	r2, [r3, #4]
    9b7c:	cmp	r2, #1
    9b7e:	bls.n	9ba2 <FatFile::addDirCluster()+0x7e>
    9b80:	movs	r4, #1
    9b82:	b.n	9b8c <FatFile::addDirCluster()+0x68>
    9b84:	ldr	r3, [r5, #8]
    9b86:	ldrb	r2, [r3, #4]
    9b88:	cmp	r2, r4
    9b8a:	bls.n	9ba2 <FatFile::addDirCluster()+0x7e>
    9b8c:	ldr	r0, [r3, #0]
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
  }
  bool writeSector(uint32_t sector, const uint8_t* src) {
    return m_blockDev->writeSector(sector, src);
    9b8e:	ldr	r3, [r0, #0]
    9b90:	adds	r1, r4, r7
    9b92:	ldr	r3, [r3, #28]
    9b94:	mov	r2, r8
    9b96:	blx	r3
    9b98:	adds	r4, #1
    9b9a:	uxtb	r4, r4
    if (!m_vol->writeSector(sector + i, pc->data)) {
    9b9c:	cmp	r0, #0
    9b9e:	bne.n	9b84 <FatFile::addDirCluster()+0x60>
    9ba0:	b.n	9b3c <FatFile::addDirCluster()+0x18>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += m_vol->bytesPerCluster();
    9ba2:	ldrb	r3, [r3, #6]
    9ba4:	ldr	r1, [r5, #20]
    9ba6:	mov.w	r2, #512	; 0x200
    9baa:	lsl.w	r3, r2, r3
    9bae:	uxtah	r3, r1, r3
    9bb2:	str	r3, [r5, #20]
    9bb4:	b.n	9b3e <FatFile::addDirCluster()+0x1a>
    9bb6:	nop
    9bb8:	.word	0x001ffdff

00009bbc <FatFile::cacheDirEntry(unsigned char)>:
  return false;
}
//------------------------------------------------------------------------------
// cache a file's directory entry
// return pointer to cached entry or null for failure
DirFat_t* FatFile::cacheDirEntry(uint8_t action) {
    9bbc:	push	{r4, lr}
    9bbe:	mov	r4, r0
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    9bc0:	ldr	r0, [r0, #8]
    9bc2:	mov	r2, r1
    9bc4:	adds	r0, #36	; 0x24
    9bc6:	ldr	r1, [r4, #24]
    9bc8:	bl	81e8 <FsCache::get(unsigned long, unsigned char)>
  cache_t* pc;
  pc = m_vol->cacheFetchData(m_dirSector, action);
  if (!pc) {
    9bcc:	cbz	r0, 9bd8 <FatFile::cacheDirEntry(unsigned char)+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return pc->dir + (m_dirIndex & 0XF);
    9bce:	ldrh	r3, [r4, #4]
    9bd0:	and.w	r3, r3, #15
    9bd4:	add.w	r0, r0, r3, lsl #5

 fail:
  return nullptr;
}
    9bd8:	pop	{r4, pc}
    9bda:	nop

00009bdc <FatFile::sync() [clone .part.42]>:
 fail:
  m_curCluster = tmp;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
    9bdc:	push	{r4, r5, r6, lr}
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    9bde:	ldrsb.w	r3, [r0, #2]
    9be2:	cmp	r3, #0
 fail:
  m_curCluster = tmp;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
    9be4:	sub	sp, #8
    9be6:	mov	r4, r0
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    9be8:	blt.n	9c1e <FatFile::sync() [clone .part.42]+0x42>
      setLe16(dir->modifyTime, time);
    }
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
  }
  if (m_vol->cacheSync()) {
    9bea:	ldr	r5, [r4, #8]
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    9bec:	add.w	r0, r5, #36	; 0x24
    9bf0:	bl	8248 <FsCache::sync()>
    9bf4:	cbnz	r0, 9c04 <FatFile::sync() [clone .part.42]+0x28>
    return true;
  }
  DBG_FAIL_MACRO;

 fail:
  m_error |= WRITE_ERROR;
    9bf6:	ldrb	r3, [r4, #1]
    9bf8:	orr.w	r3, r3, #1
    9bfc:	strb	r3, [r4, #1]
  return false;
    9bfe:	movs	r0, #0
}
    9c00:	add	sp, #8
    9c02:	pop	{r4, r5, r6, pc}
    9c04:	add.w	r0, r5, #564	; 0x234
    9c08:	bl	8248 <FsCache::sync()>
    9c0c:	cmp	r0, #0
    9c0e:	beq.n	9bf6 <FatFile::sync() [clone .part.42]+0x1a>
    9c10:	ldr	r0, [r5, #0]
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    9c12:	ldr	r3, [r0, #0]
    9c14:	ldr	r3, [r3, #24]
    9c16:	blx	r3
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    9c18:	cmp	r0, #0
    9c1a:	beq.n	9bf6 <FatFile::sync() [clone .part.42]+0x1a>
    9c1c:	b.n	9c00 <FatFile::sync() [clone .part.42]+0x24>
  uint8_t ms10;
  if (!isOpen()) {
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    DirFat_t* dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    9c1e:	movs	r1, #1
    9c20:	bl	9bbc <FatFile::cacheDirEntry(unsigned char)>
    // check for deleted by another open file object
    if (!dir || dir->name[0] == FAT_NAME_DELETED) {
    9c24:	mov	r5, r0
    9c26:	cmp	r0, #0
    9c28:	beq.n	9bf6 <FatFile::sync() [clone .part.42]+0x1a>
    9c2a:	ldrb	r3, [r0, #0]
    9c2c:	cmp	r3, #229	; 0xe5
    9c2e:	beq.n	9bf6 <FatFile::sync() [clone .part.42]+0x1a>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // do not set filesize for dir files
    if (isFile()) {
    9c30:	ldrb	r3, [r4, #0]
    // update first cluster fields
    setLe16(dir->firstClusterLow, m_firstCluster & 0XFFFF);
    setLe16(dir->firstClusterHigh, m_firstCluster >> 16);

    // set modify time if user supplied a callback date/time function
    if (FsDateTime::callback) {
    9c32:	ldr	r2, [pc, #56]	; (9c6c <FatFile::sync() [clone .part.42]+0x90>)
    if (!dir || dir->name[0] == FAT_NAME_DELETED) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // do not set filesize for dir files
    if (isFile()) {
    9c34:	lsls	r3, r3, #28
      setLe32(dir->fileSize, m_fileSize);
    9c36:	itt	mi
    9c38:	ldrmi	r3, [r4, #28]
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    9c3a:	strmi	r3, [r0, #28]
    }

    // update first cluster fields
    setLe16(dir->firstClusterLow, m_firstCluster & 0XFFFF);
    9c3c:	ldr	r3, [r4, #32]
    setLe16(dir->firstClusterHigh, m_firstCluster >> 16);

    // set modify time if user supplied a callback date/time function
    if (FsDateTime::callback) {
    9c3e:	ldr	r6, [r2, #0]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    9c40:	strh	r3, [r0, #26]
    9c42:	lsrs	r3, r3, #16
    9c44:	strh	r3, [r0, #20]
    9c46:	cbz	r6, 9c62 <FatFile::sync() [clone .part.42]+0x86>
      FsDateTime::callback(&date, &time, &ms10);
    9c48:	add.w	r2, sp, #3
    9c4c:	add.w	r1, sp, #6
    9c50:	add	r0, sp, #4
    9c52:	blx	r6
      setLe16(dir->modifyDate, date);
    9c54:	ldrh.w	r3, [sp, #4]
    9c58:	ldrh.w	r2, [sp, #6]
    9c5c:	strh	r3, [r5, #24]
    9c5e:	strh	r3, [r5, #18]
    9c60:	strh	r2, [r5, #22]
      setLe16(dir->accessDate, date);
      setLe16(dir->modifyTime, time);
    }
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    9c62:	ldrb	r3, [r4, #2]
    9c64:	and.w	r3, r3, #127	; 0x7f
    9c68:	strb	r3, [r4, #2]
    9c6a:	b.n	9bea <FatFile::sync() [clone .part.42]+0xe>
    9c6c:	.word	0x1fff6188

00009c70 <FatFile::close()>:

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
    9c70:	push	{r4, lr}
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    9c72:	ldrb	r3, [r0, #0]

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
    9c74:	mov	r4, r0
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    9c76:	cbnz	r3, 9c82 <FatFile::close()+0x12>
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
    9c78:	movs	r3, #0
    9c7a:	strb	r3, [r4, #0]
  m_flags = 0;
    9c7c:	strb	r3, [r4, #2]
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    return true;
    9c7e:	movs	r0, #1
bool FatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return rtn;
}
    9c80:	pop	{r4, pc}
    9c82:	bl	9bdc <FatFile::sync() [clone .part.42]>
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
    9c86:	movs	r3, #0
    9c88:	strb	r3, [r4, #0]
  m_flags = 0;
    9c8a:	strb	r3, [r4, #2]
  return rtn;
}
    9c8c:	pop	{r4, pc}
    9c8e:	nop

00009c90 <FatFile::mkdir(FatFile*, fname_t*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, fname_t* fname) {
    9c90:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  uint32_t sector;
  DirFat_t dot;
  DirFat_t* dir;
  cache_t* pc;

  if (!parent->isDir()) {
    9c94:	ldrb	r4, [r1, #0]
    9c96:	tst.w	r4, #112	; 0x70

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, fname_t* fname) {
    9c9a:	sub	sp, #36	; 0x24
  uint32_t sector;
  DirFat_t dot;
  DirFat_t* dir;
  cache_t* pc;

  if (!parent->isDir()) {
    9c9c:	bne.n	9ca6 <FatFile::mkdir(FatFile*, fname_t*)+0x16>
  // write first sector
  return m_vol->cacheSync();

 fail:
  return false;
}
    9c9e:	movs	r0, #0
    9ca0:	add	sp, #36	; 0x24
    9ca2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (!parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // create a normal file
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    9ca6:	movw	r3, #2562	; 0xa02
    9caa:	mov	r5, r0
    9cac:	mov	r4, r1
    9cae:	bl	b158 <FatFile::open(FatFile*, fname_t*, int)>
    9cb2:	cmp	r0, #0
    9cb4:	beq.n	9c9e <FatFile::mkdir(FatFile*, fname_t*)+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_flags = FILE_FLAG_READ;
    9cb6:	movs	r2, #1
  m_attributes = FILE_ATTR_SUBDIR;
    9cb8:	movs	r3, #16
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_flags = FILE_FLAG_READ;
    9cba:	strb	r2, [r5, #2]
  m_attributes = FILE_ATTR_SUBDIR;
    9cbc:	strb	r3, [r5, #0]

  // allocate and zero first cluster
  if (!addDirCluster()) {
    9cbe:	mov	r0, r5
    9cc0:	bl	9b24 <FatFile::addDirCluster()>
    9cc4:	cmp	r0, #0
    9cc6:	beq.n	9c9e <FatFile::mkdir(FatFile*, fname_t*)+0xe>
bool FatFile::seekSet(uint32_t pos) {
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    9cc8:	ldrb	r3, [r5, #0]
  // allocate and zero first cluster
  if (!addDirCluster()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_firstCluster = m_curCluster;
    9cca:	ldr	r2, [r5, #16]
    9ccc:	str	r2, [r5, #32]
bool FatFile::seekSet(uint32_t pos) {
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    9cce:	cmp	r3, #0
    9cd0:	bne.n	9dbe <FatFile::mkdir(FatFile*, fname_t*)+0x12e>
  if (!sync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // cache entry - should already be in cache due to sync() call
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    9cd2:	movs	r1, #1
    9cd4:	mov	r0, r5
    9cd6:	bl	9bbc <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    9cda:	mov	r6, r0
    9cdc:	cmp	r0, #0
    9cde:	beq.n	9c9e <FatFile::mkdir(FatFile*, fname_t*)+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // change directory entry  attribute
  dir->attributes = FAT_ATTRIB_DIRECTORY;
    9ce0:	movs	r3, #16
    9ce2:	strb	r3, [r0, #11]

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
    9ce4:	ldr	r2, [r0, #8]
    9ce6:	ldr	r1, [r6, #4]
    9ce8:	ldr	r3, [r6, #12]
    9cea:	ldr	r0, [r0, #0]
    9cec:	ldrh.w	r8, [r6, #20]
    9cf0:	ldrh.w	r9, [r6, #26]
    9cf4:	mov	r7, sp
    9cf6:	stmia	r7!, {r0, r1, r2, r3}
    9cf8:	ldr	r1, [r6, #20]
    9cfa:	ldr	r2, [r6, #24]
    9cfc:	ldr	r3, [r6, #28]
    9cfe:	ldr	r0, [r6, #16]
  dot.name[0] = '.';
    9d00:	add	r6, sp, #32
  }
  // change directory entry  attribute
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
    9d02:	stmia	r7!, {r0, r1, r2, r3}
  dot.name[0] = '.';
    9d04:	movs	r3, #46	; 0x2e
    9d06:	strb.w	r3, [r6, #-32]!
    9d0a:	add.w	r1, sp, #10
    9d0e:	mov	r3, r6
  for (uint8_t i = 1; i < 11; i++) {
    dot.name[i] = ' ';
    9d10:	movs	r2, #32
    9d12:	strb.w	r2, [r3, #1]!
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
  dot.name[0] = '.';
  for (uint8_t i = 1; i < 11; i++) {
    9d16:	cmp	r3, r1
    9d18:	bne.n	9d12 <FatFile::mkdir(FatFile*, fname_t*)+0x82>
    dot.name[i] = ' ';
  }

  // cache sector for '.'  and '..'
  sector = m_vol->clusterStartSector(m_firstCluster);
    9d1a:	ldr	r0, [r5, #8]
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    9d1c:	ldr	r3, [r5, #32]
    9d1e:	ldrb	r2, [r0, #6]
    9d20:	ldr	r1, [r0, #20]
    9d22:	subs	r3, #2
    9d24:	lsls	r3, r2
    9d26:	add	r1, r3
    9d28:	adds	r0, #36	; 0x24
    9d2a:	movs	r2, #1
    9d2c:	bl	81e8 <FsCache::get(unsigned long, unsigned char)>
  pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_WRITE);
  if (!pc) {
    9d30:	mov	lr, r0
    9d32:	cmp	r0, #0
    9d34:	beq.n	9c9e <FatFile::mkdir(FatFile*, fname_t*)+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy '.' to sector
  memcpy(&pc->dir[0], &dot, sizeof(dot));
    9d36:	mov	r7, r6
    9d38:	strh.w	r8, [sp, #20]
    9d3c:	strh.w	r9, [sp, #26]
    9d40:	ldmia	r7!, {r0, r1, r2, r3}
    9d42:	str.w	r0, [lr]
    9d46:	str.w	r1, [lr, #4]
    9d4a:	str.w	r2, [lr, #8]
    9d4e:	str.w	r3, [lr, #12]
    9d52:	ldmia	r7!, {r0, r1, r2, r3}
    9d54:	str.w	r0, [lr, #16]
    9d58:	str.w	r1, [lr, #20]
    9d5c:	str.w	r2, [lr, #24]
    9d60:	str.w	r3, [lr, #28]
  // make entry for '..'
  dot.name[1] = '.';
  setLe16(dot.firstClusterLow, parent->m_firstCluster & 0XFFFF);
    9d64:	ldr	r3, [r4, #32]
  setLe16(dot.firstClusterHigh, parent->m_firstCluster >> 16);
  // copy '..' to sector
  memcpy(&pc->dir[1], &dot, sizeof(dot));
    9d66:	strh.w	r3, [sp, #26]
    goto fail;
  }
  // copy '.' to sector
  memcpy(&pc->dir[0], &dot, sizeof(dot));
  // make entry for '..'
  dot.name[1] = '.';
    9d6a:	movs	r2, #46	; 0x2e
  setLe16(dot.firstClusterLow, parent->m_firstCluster & 0XFFFF);
  setLe16(dot.firstClusterHigh, parent->m_firstCluster >> 16);
  // copy '..' to sector
  memcpy(&pc->dir[1], &dot, sizeof(dot));
    9d6c:	lsrs	r3, r3, #16
    9d6e:	mov	r4, r6
    9d70:	strh.w	r3, [sp, #20]
    goto fail;
  }
  // copy '.' to sector
  memcpy(&pc->dir[0], &dot, sizeof(dot));
  // make entry for '..'
  dot.name[1] = '.';
    9d74:	strb.w	r2, [sp, #1]
  setLe16(dot.firstClusterLow, parent->m_firstCluster & 0XFFFF);
  setLe16(dot.firstClusterHigh, parent->m_firstCluster >> 16);
  // copy '..' to sector
  memcpy(&pc->dir[1], &dot, sizeof(dot));
    9d78:	ldmia	r4!, {r0, r1, r2, r3}
    9d7a:	add.w	r6, lr, #32
    9d7e:	str.w	r0, [lr, #32]
    9d82:	str	r1, [r6, #4]
    9d84:	str	r2, [r6, #8]
    9d86:	str	r3, [r6, #12]
    9d88:	ldmia	r4!, {r0, r1, r2, r3}
    9d8a:	str	r0, [r6, #16]
    9d8c:	str	r1, [r6, #20]
    9d8e:	str	r2, [r6, #24]
    9d90:	str	r3, [r6, #28]
  // write first sector
  return m_vol->cacheSync();
    9d92:	ldr	r4, [r5, #8]
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    9d94:	add.w	r0, r4, #36	; 0x24
    9d98:	bl	8248 <FsCache::sync()>
    9d9c:	cmp	r0, #0
    9d9e:	beq.w	9c9e <FatFile::mkdir(FatFile*, fname_t*)+0xe>
    9da2:	add.w	r0, r4, #564	; 0x234
    9da6:	bl	8248 <FsCache::sync()>
    9daa:	cmp	r0, #0
    9dac:	beq.w	9c9e <FatFile::mkdir(FatFile*, fname_t*)+0xe>
    9db0:	ldr	r0, [r4, #0]
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    9db2:	ldr	r3, [r0, #0]
    9db4:	ldr	r3, [r3, #24]

 fail:
  return false;
}
    9db6:	add	sp, #36	; 0x24
    9db8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    9dbc:	bx	r3
  if (!isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    9dbe:	ldr	r3, [r5, #20]
    9dc0:	cbz	r3, 9dd0 <FatFile::mkdir(FatFile*, fname_t*)+0x140>
    }
  }

 done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    9dc2:	ldrb	r3, [r5, #2]
  if (pos == m_curPosition) {
    return true;
  }
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    9dc4:	movs	r2, #0
    }
  }

 done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    9dc6:	bic.w	r3, r3, #32
    9dca:	strb	r3, [r5, #2]
  if (pos == m_curPosition) {
    return true;
  }
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    9dcc:	str	r2, [r5, #16]
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    9dce:	str	r2, [r5, #20]
    9dd0:	mov	r0, r5
    9dd2:	bl	9bdc <FatFile::sync() [clone .part.42]>
  }
  m_firstCluster = m_curCluster;
  // Set to start of dir
  rewind();
  // force entry to device
  if (!sync()) {
    9dd6:	cmp	r0, #0
    9dd8:	beq.w	9c9e <FatFile::mkdir(FatFile*, fname_t*)+0xe>
    9ddc:	b.n	9cd2 <FatFile::mkdir(FatFile*, fname_t*)+0x42>
    9dde:	nop

00009de0 <FatFile::mkdir(FatFile*, char const*, bool)>:
//------------------------------------------------------------------------------
bool FatFile::isBusy() {
  return m_vol->isBusy();
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
    9de0:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9de4:	mov	r6, r0
    9de6:	sub	sp, #72	; 0x48
  fname_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    9de8:	ldrb	r5, [r6, #0]
//------------------------------------------------------------------------------
bool FatFile::isBusy() {
  return m_vol->isBusy();
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
    9dea:	str	r2, [sp, #4]
    9dec:	movs	r0, #0
    9dee:	strb.w	r0, [sp, #36]	; 0x24
    9df2:	strb.w	r0, [sp, #37]	; 0x25
    9df6:	strb.w	r0, [sp, #38]	; 0x26
  fname_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    9dfa:	cbnz	r5, 9e08 <FatFile::mkdir(FatFile*, char const*, bool)+0x28>
    9dfc:	mov	r8, r3
    9dfe:	ldrb	r3, [r1, #0]
    9e00:	tst.w	r3, #112	; 0x70
    9e04:	mov	r4, r1
    9e06:	bne.n	9e10 <FatFile::mkdir(FatFile*, char const*, bool)+0x30>
    close();
  }
  return mkdir(parent, &fname);

 fail:
  return false;
    9e08:	movs	r0, #0
}
    9e0a:	add	sp, #72	; 0x48
    9e0c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    9e10:	ldrb	r3, [r2, #0]
    9e12:	cmp	r3, #47	; 0x2f
    9e14:	mov	r0, r2
    9e16:	beq.n	9e6e <FatFile::mkdir(FatFile*, char const*, bool)+0x8e>
      goto fail;
    }
    if (!*path) {
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    9e18:	movs	r7, #0
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    9e1a:	add	r2, sp, #4
    9e1c:	add	r1, sp, #12
    9e1e:	bl	ad2c <FatFile::parsePathName(char const*, fname_t*, char const**)>
      goto fail;
    }
    if (!*path) {
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    9e22:	add	r2, sp, #12
    9e24:	mov	r1, r4
    9e26:	movs	r3, #0
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    9e28:	cmp	r0, #0
    9e2a:	beq.n	9e08 <FatFile::mkdir(FatFile*, char const*, bool)+0x28>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    9e2c:	ldr	r5, [sp, #4]
    9e2e:	ldrb	r5, [r5, #0]
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    9e30:	mov	r0, r6
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    9e32:	cmp	r5, #0
    9e34:	beq.n	9e92 <FatFile::mkdir(FatFile*, char const*, bool)+0xb2>
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    9e36:	bl	b158 <FatFile::open(FatFile*, fname_t*, int)>
    9e3a:	cbnz	r0, 9e50 <FatFile::mkdir(FatFile*, char const*, bool)+0x70>
      if (!pFlag || !mkdir(parent, &fname)) {
    9e3c:	cmp.w	r8, #0
    9e40:	beq.n	9e08 <FatFile::mkdir(FatFile*, char const*, bool)+0x28>
    9e42:	mov	r1, r4
    9e44:	add	r2, sp, #12
    9e46:	mov	r0, r6
    9e48:	bl	9c90 <FatFile::mkdir(FatFile*, fname_t*)>
    9e4c:	cmp	r0, #0
    9e4e:	beq.n	9e08 <FatFile::mkdir(FatFile*, char const*, bool)+0x28>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    9e50:	mov	r5, r6
    9e52:	ldmia	r5!, {r0, r1, r2, r3}
    9e54:	add	r4, sp, #36	; 0x24
    9e56:	stmia	r4!, {r0, r1, r2, r3}
    9e58:	ldmia	r5!, {r0, r1, r2, r3}
    9e5a:	stmia	r4!, {r0, r1, r2, r3}
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    9e5c:	ldrb	r3, [r6, #0]
      if (!pFlag || !mkdir(parent, &fname)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    9e5e:	ldr	r2, [r5, #0]
    9e60:	str	r2, [r4, #0]
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    9e62:	cbnz	r3, 9e8a <FatFile::mkdir(FatFile*, char const*, bool)+0xaa>
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
    9e64:	strb	r7, [r6, #0]
  m_flags = 0;
    9e66:	strb	r7, [r6, #2]
    9e68:	ldr	r0, [sp, #4]
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    parent = &tmpDir;
    9e6a:	add	r4, sp, #36	; 0x24
    9e6c:	b.n	9e1a <FatFile::mkdir(FatFile*, char const*, bool)+0x3a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    9e6e:	adds	r0, #1
    9e70:	str	r0, [sp, #4]
  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    9e72:	ldrb	r3, [r0, #0]
    9e74:	cmp	r3, #47	; 0x2f
    9e76:	beq.n	9e6e <FatFile::mkdir(FatFile*, char const*, bool)+0x8e>
    9e78:	ldr	r1, [r4, #8]
    9e7a:	add	r0, sp, #36	; 0x24
    9e7c:	bl	9abc <FatFile::openRoot(FatVolume*) [clone .part.38]>
      path++;
    }
    if (!tmpDir.openRoot(parent->m_vol)) {
    9e80:	cmp	r0, #0
    9e82:	beq.n	9e08 <FatFile::mkdir(FatFile*, char const*, bool)+0x28>
    9e84:	ldr	r0, [sp, #4]
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
    9e86:	add	r4, sp, #36	; 0x24
    9e88:	b.n	9e18 <FatFile::mkdir(FatFile*, char const*, bool)+0x38>
    9e8a:	mov	r0, r6
    9e8c:	bl	9bdc <FatFile::sync() [clone .part.42]>
    9e90:	b.n	9e64 <FatFile::mkdir(FatFile*, char const*, bool)+0x84>
    }
    tmpDir = *this;
    parent = &tmpDir;
    close();
  }
  return mkdir(parent, &fname);
    9e92:	add	r2, sp, #12
    9e94:	mov	r1, r4
    9e96:	mov	r0, r6
    9e98:	bl	9c90 <FatFile::mkdir(FatFile*, fname_t*)>

 fail:
  return false;
}
    9e9c:	add	sp, #72	; 0x48
    9e9e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    9ea2:	nop

00009ea4 <FatFile::open(FatFile*, char const*, int)>:
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
    9ea4:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9ea8:	mov	r6, r0
    9eaa:	sub	sp, #72	; 0x48
  FatFile tmpDir;
  fname_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    9eac:	ldrb	r5, [r6, #0]
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
    9eae:	str	r2, [sp, #4]
    9eb0:	movs	r0, #0
    9eb2:	strb.w	r0, [sp, #36]	; 0x24
    9eb6:	strb.w	r0, [sp, #37]	; 0x25
    9eba:	strb.w	r0, [sp, #38]	; 0x26
  FatFile tmpDir;
  fname_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    9ebe:	cbnz	r5, 9ecc <FatFile::open(FatFile*, char const*, int)+0x28>
    9ec0:	mov	r8, r3
    9ec2:	ldrb	r3, [r1, #0]
    9ec4:	tst.w	r3, #112	; 0x70
    9ec8:	mov	r4, r1
    9eca:	bne.n	9ed4 <FatFile::open(FatFile*, char const*, int)+0x30>
    close();
  }
  return open(dirFile, &fname, oflag);

 fail:
  return false;
    9ecc:	movs	r0, #0
}
    9ece:	add	sp, #72	; 0x48
    9ed0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    9ed4:	ldrb	r3, [r2, #0]
    9ed6:	cmp	r3, #47	; 0x2f
    9ed8:	mov	r0, r2
    9eda:	beq.n	9f28 <FatFile::open(FatFile*, char const*, int)+0x84>
      goto fail;
    }
    if (*path == 0) {
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    9edc:	movs	r7, #0
    9ede:	b.n	9ee8 <FatFile::open(FatFile*, char const*, int)+0x44>
    9ee0:	ldr	r0, [sp, #4]
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
    9ee2:	strb	r7, [r6, #0]
  m_flags = 0;
    9ee4:	strb	r7, [r6, #2]
    if (!open(dirFile, &fname, O_RDONLY)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    dirFile = &tmpDir;
    9ee6:	add	r4, sp, #36	; 0x24
      goto fail;
    }
    dirFile = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    9ee8:	add	r2, sp, #4
    9eea:	add	r1, sp, #12
    9eec:	bl	ad2c <FatFile::parsePathName(char const*, fname_t*, char const**)>
      goto fail;
    }
    if (*path == 0) {
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    9ef0:	add	r2, sp, #12
    9ef2:	mov	r1, r4
    9ef4:	movs	r3, #0
      goto fail;
    }
    dirFile = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    9ef6:	cmp	r0, #0
    9ef8:	beq.n	9ecc <FatFile::open(FatFile*, char const*, int)+0x28>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    9efa:	ldr	r5, [sp, #4]
    9efc:	ldrb	r5, [r5, #0]
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    9efe:	mov	r0, r6
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    9f00:	cbz	r5, 9f46 <FatFile::open(FatFile*, char const*, int)+0xa2>
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    9f02:	bl	b158 <FatFile::open(FatFile*, fname_t*, int)>
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    9f06:	mov	r5, r6
    9f08:	add	r4, sp, #36	; 0x24
      goto fail;
    }
    if (*path == 0) {
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    9f0a:	cmp	r0, #0
    9f0c:	beq.n	9ecc <FatFile::open(FatFile*, char const*, int)+0x28>
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    9f0e:	ldmia	r5!, {r0, r1, r2, r3}
    9f10:	stmia	r4!, {r0, r1, r2, r3}
    9f12:	ldmia	r5!, {r0, r1, r2, r3}
    9f14:	stmia	r4!, {r0, r1, r2, r3}
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    9f16:	ldrb	r3, [r6, #0]
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    9f18:	ldr	r2, [r5, #0]
    9f1a:	str	r2, [r4, #0]
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    9f1c:	cmp	r3, #0
    9f1e:	beq.n	9ee0 <FatFile::open(FatFile*, char const*, int)+0x3c>
    9f20:	mov	r0, r6
    9f22:	bl	9bdc <FatFile::sync() [clone .part.42]>
    9f26:	b.n	9ee0 <FatFile::open(FatFile*, char const*, int)+0x3c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    9f28:	adds	r0, #1
    9f2a:	str	r0, [sp, #4]
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    9f2c:	ldrb	r3, [r0, #0]
    9f2e:	cmp	r3, #47	; 0x2f
    9f30:	beq.n	9f28 <FatFile::open(FatFile*, char const*, int)+0x84>
      path++;
    }
    if (*path == 0) {
    9f32:	cbz	r3, 9f58 <FatFile::open(FatFile*, char const*, int)+0xb4>
    9f34:	ldr	r1, [r4, #8]
    9f36:	add	r0, sp, #36	; 0x24
    9f38:	bl	9abc <FatFile::openRoot(FatVolume*) [clone .part.38]>
      return openRoot(dirFile->m_vol);
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
    9f3c:	cmp	r0, #0
    9f3e:	beq.n	9ecc <FatFile::open(FatFile*, char const*, int)+0x28>
    9f40:	ldr	r0, [sp, #4]
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
    9f42:	add	r4, sp, #36	; 0x24
    9f44:	b.n	9edc <FatFile::open(FatFile*, char const*, int)+0x38>
    }
    tmpDir = *this;
    dirFile = &tmpDir;
    close();
  }
  return open(dirFile, &fname, oflag);
    9f46:	mov	r3, r8
    9f48:	add	r2, sp, #12
    9f4a:	mov	r1, r4
    9f4c:	mov	r0, r6
    9f4e:	bl	b158 <FatFile::open(FatFile*, fname_t*, int)>

 fail:
  return false;
}
    9f52:	add	sp, #72	; 0x48
    9f54:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    9f58:	ldr	r1, [r4, #8]
    9f5a:	mov	r0, r6
    9f5c:	bl	9abc <FatFile::openRoot(FatVolume*) [clone .part.38]>
    9f60:	b.n	9ece <FatFile::open(FatFile*, char const*, int)+0x2a>
    9f62:	nop

00009f64 <FatFile::open(FatVolume*, char const*, int)>:
bool FatFile::open(const char* path, oflag_t oflag) {
  return open(FatVolume::cwv(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
    9f64:	cbz	r1, 9f6e <FatFile::open(FatVolume*, char const*, int)+0xa>
    9f66:	addw	r1, r1, #1092	; 0x444
    9f6a:	b.w	9ea4 <FatFile::open(FatFile*, char const*, int)>
}
    9f6e:	mov	r0, r1
    9f70:	bx	lr
    9f72:	nop

00009f74 <FatFile::openRoot(FatVolume*)>:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
  // error if file is already open
  if (isOpen()) {
    9f74:	ldrb	r3, [r0, #0]
    9f76:	cbz	r3, 9f7c <FatFile::openRoot(FatVolume*)+0x8>
  m_flags = FILE_FLAG_READ;
  return true;

 fail:
  return false;
}
    9f78:	movs	r0, #0
    9f7a:	bx	lr
    9f7c:	b.w	9abc <FatFile::openRoot(FatVolume*) [clone .part.38]>

00009f80 <FatFile::read(void*, unsigned int)>:
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
    9f80:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  size_t toRead;
  uint32_t sector;  // raw device sector number
  cache_t* pc;

  // error if not open for read
  if (!isReadable()) {
    9f84:	ldrb	r3, [r0, #2]
    9f86:	lsls	r7, r3, #31
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
    9f88:	sub	sp, #12
    9f8a:	mov	r5, r0
  size_t toRead;
  uint32_t sector;  // raw device sector number
  cache_t* pc;

  // error if not open for read
  if (!isReadable()) {
    9f8c:	bpl.w	a0b4 <FatFile::read(void*, unsigned int)+0x134>
    9f90:	mov	r7, r1
    9f92:	ldrb	r1, [r0, #0]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (isFile()) {
    9f94:	lsls	r6, r1, #28
    9f96:	mov	r9, r2
    9f98:	bmi.w	a0c6 <FatFile::read(void*, unsigned int)+0x146>
    uint32_t tmp32 = m_fileSize - m_curPosition;
    if (nbyte >= tmp32) {
      nbyte = tmp32;
    }
  } else if (isRootFixed()) {
    9f9c:	lsls	r4, r1, #26
    9f9e:	bpl.n	9fb2 <FatFile::read(void*, unsigned int)+0x32>
    uint16_t tmp16 = 32*m_vol->m_rootDirEntryCount - (uint16_t)m_curPosition;
    9fa0:	ldr	r2, [r0, #8]
    if (nbyte > tmp16) {
    9fa2:	ldr	r3, [r0, #20]
    9fa4:	ldrh	r2, [r2, #8]
    9fa6:	rsb	r3, r3, r2, lsl #5
    9faa:	uxth	r3, r3
    9fac:	cmp	r9, r3
    9fae:	it	cs
    9fb0:	movcs	r9, r3
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    9fb2:	cmp.w	r9, #0
    9fb6:	beq.w	a112 <FatFile::read(void*, unsigned int)+0x192>
    9fba:	ldr	r3, [r5, #20]
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    9fbc:	ldr	r2, [r5, #8]
    if (isRootFixed()) {
    9fbe:	lsls	r0, r1, #26
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    9fc0:	mov	r6, r9
    9fc2:	mov.w	r8, #0
        } else if (isFile() && isContiguous()) {
          m_curCluster++;
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    9fc6:	add.w	sl, r5, #16
    }
  }
  toRead = nbyte;
  while (toRead) {
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    9fca:	ubfx	fp, r3, #0, #9
    if (isRootFixed()) {
    9fce:	bpl.n	a052 <FatFile::read(void*, unsigned int)+0xd2>
      sector = m_vol->rootDirStart()
               + (m_curPosition >> m_vol->bytesPerSectorShift());
    9fd0:	ldr	r1, [r2, #32]
    9fd2:	add.w	r1, r1, r3, lsr #9
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
    9fd6:	cmp.w	fp, #0
    9fda:	bne.n	a088 <FatFile::read(void*, unsigned int)+0x108>
          }
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
    9fdc:	cmp.w	r6, #512	; 0x200
    9fe0:	bcc.n	a088 <FatFile::read(void*, unsigned int)+0x108>
    9fe2:	ldr	r3, [r2, #48]	; 0x30
        || sector == m_vol->cacheSectorNumber()) {
    9fe4:	cmp	r1, r3
    9fe6:	beq.n	a088 <FatFile::read(void*, unsigned int)+0x108>
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
    9fe8:	cmp.w	r6, #1024	; 0x400
    9fec:	bcc.n	a0d8 <FatFile::read(void*, unsigned int)+0x158>
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
      if (!isRootFixed()) {
    9fee:	ldrb	r0, [r5, #0]
    9ff0:	lsls	r0, r0, #26
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
    9ff2:	mov.w	fp, r6, lsr #9
      if (!isRootFixed()) {
    9ff6:	bmi.n	a004 <FatFile::read(void*, unsigned int)+0x84>
        uint32_t mb = m_vol->sectorsPerCluster() - sectorOfCluster;
    9ff8:	ldrb	r0, [r2, #4]
    9ffa:	rsb	r0, r8, r0
    9ffe:	cmp	fp, r0
    a000:	it	cs
    a002:	movcs	fp, r0
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    a004:	cmp	r1, r3
        if (mb < ns) {
          ns = mb;
        }
      }
      n = ns << m_vol->bytesPerSectorShift();
    a006:	mov.w	r4, fp, lsl #9
    a00a:	bhi.n	a028 <FatFile::read(void*, unsigned int)+0xa8>
    a00c:	add.w	r0, r1, fp
    a010:	cmp	r3, r0
    a012:	bcs.n	a028 <FatFile::read(void*, unsigned int)+0xa8>
   * \param[in] count Number of sectors to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool cacheSafeRead(uint32_t sector, uint8_t* dst, size_t count) {
    if (isCached(sector, count) && !sync()) {
    a014:	add.w	r0, r2, #36	; 0x24
    a018:	str	r1, [sp, #4]
    a01a:	str	r2, [sp, #0]
    a01c:	bl	8248 <FsCache::sync()>
    a020:	ldr	r2, [sp, #0]
    a022:	ldr	r1, [sp, #4]
    a024:	cmp	r0, #0
    a026:	beq.n	a0b4 <FatFile::read(void*, unsigned int)+0x134>
      return false;
    }
    return m_blockDev->readSectors(sector, dst, count);
    a028:	ldr	r0, [r2, #40]	; 0x28
    a02a:	ldr	r2, [r0, #0]
    a02c:	mov	r3, fp
    a02e:	ldr.w	fp, [r2, #16]
    a032:	mov	r2, r7
    a034:	blx	fp
      if (!m_vol->cacheSafeRead(sector, dst, ns)) {
    a036:	cmp	r0, #0
    a038:	beq.n	a0b4 <FatFile::read(void*, unsigned int)+0x134>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    a03a:	ldr	r3, [r5, #20]
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    a03c:	subs	r6, r6, r4
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    a03e:	add	r3, r4
      if (!m_vol->cacheSafeRead(sector, dst)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    a040:	add	r7, r4
    m_curPosition += n;
    a042:	str	r3, [r5, #20]
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    a044:	beq.n	a112 <FatFile::read(void*, unsigned int)+0x192>
    a046:	ldrb	r1, [r5, #0]
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    a048:	ldr	r2, [r5, #8]
    if (isRootFixed()) {
    a04a:	lsls	r0, r1, #26
    }
  }
  toRead = nbyte;
  while (toRead) {
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    a04c:	ubfx	fp, r3, #0, #9
    if (isRootFixed()) {
    a050:	bmi.n	9fd0 <FatFile::read(void*, unsigned int)+0x50>
  }
  //----------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
    a052:	ldrb.w	r8, [r2, #5]
    a056:	and.w	r8, r8, r3, lsr #9
      sector = m_vol->rootDirStart()
               + (m_curPosition >> m_vol->bytesPerSectorShift());
    } else {
      sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
      if (offset == 0 && sectorOfCluster == 0) {
    a05a:	cmp.w	fp, #0
    a05e:	bne.n	a0d4 <FatFile::read(void*, unsigned int)+0x154>
    a060:	cmp.w	r8, #0
    a064:	bne.n	a0d4 <FatFile::read(void*, unsigned int)+0x154>
        // start of new cluster
        if (m_curPosition == 0) {
    a066:	cmp	r3, #0
    a068:	bne.n	a0ec <FatFile::read(void*, unsigned int)+0x16c>
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    a06a:	lsls	r1, r1, #25
    a06c:	ite	mi
    a06e:	ldrmi	r4, [r2, #32]
    a070:	ldrpl	r4, [r5, #32]
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        } else if (isFile() && isContiguous()) {
          m_curCluster++;
    a072:	str	r4, [r5, #16]
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    a074:	ldrb	r1, [r2, #6]
    a076:	ldr	r0, [r2, #20]
    a078:	subs	r4, #2
    a07a:	lsls	r4, r1
    a07c:	add.w	r1, r8, r0
    a080:	add	r1, r4
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
    a082:	cmp.w	fp, #0
    a086:	beq.n	9fdc <FatFile::read(void*, unsigned int)+0x5c>
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    a088:	add.w	r0, r2, #36	; 0x24
    a08c:	movs	r2, #0
    a08e:	bl	81e8 <FsCache::get(unsigned long, unsigned char)>
      if (n > toRead) {
        n = toRead;
      }
      // read sector to cache and copy data to caller
      pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_READ);
      if (!pc) {
    a092:	cbz	r0, a0b4 <FatFile::read(void*, unsigned int)+0x134>
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
      // amount to be read from current sector
      n = m_vol->bytesPerSector() - offset;
    a094:	rsb	r4, fp, #512	; 0x200
    a098:	cmp	r4, r6
    a09a:	it	cs
    a09c:	movcs	r4, r6
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
    a09e:	add.w	r1, r0, fp
    a0a2:	mov	r2, r4
    a0a4:	mov	r0, r7
    a0a6:	bl	d444 <memcpy>
    a0aa:	b.n	a03a <FatFile::read(void*, unsigned int)+0xba>
          if (fg < 0) {
            DBG_FAIL_MACRO;
            goto fail;
          }
          if (fg == 0) {
            if (isDir()) {
    a0ac:	ldrb	r3, [r5, #0]
    a0ae:	tst.w	r3, #112	; 0x70
    a0b2:	bne.n	a114 <FatFile::read(void*, unsigned int)+0x194>
    toRead -= n;
  }
  return nbyte - toRead;

 fail:
  m_error |= READ_ERROR;
    a0b4:	ldrb	r3, [r5, #1]
  return -1;
    a0b6:	mov.w	r0, #4294967295
    toRead -= n;
  }
  return nbyte - toRead;

 fail:
  m_error |= READ_ERROR;
    a0ba:	orr.w	r3, r3, #2
    a0be:	strb	r3, [r5, #1]
  return -1;
}
    a0c0:	add	sp, #12
    a0c2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (isFile()) {
    uint32_t tmp32 = m_fileSize - m_curPosition;
    a0c6:	ldr	r3, [r0, #28]
    a0c8:	ldr	r2, [r0, #20]
    a0ca:	subs	r3, r3, r2
    a0cc:	cmp	r9, r3
    a0ce:	it	cs
    a0d0:	movcs	r9, r3
    a0d2:	b.n	9fb2 <FatFile::read(void*, unsigned int)+0x32>
    a0d4:	ldr	r4, [r5, #16]
    a0d6:	b.n	a074 <FatFile::read(void*, unsigned int)+0xf4>
  bool cacheSafeRead(uint32_t sector, uint8_t* dst) {
    if (isCached(sector)) {
      memcpy(dst, m_buffer, 512);
      return true;
    }
    return m_blockDev->readSector(sector, dst);
    a0d8:	ldr	r0, [r2, #40]	; 0x28
    a0da:	ldr	r3, [r0, #0]
    a0dc:	mov	r2, r7
    a0de:	ldr	r3, [r3, #12]
    a0e0:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeRead(sector, dst)) {
    a0e2:	cmp	r0, #0
    a0e4:	beq.n	a0b4 <FatFile::read(void*, unsigned int)+0x134>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    a0e6:	mov.w	r4, #512	; 0x200
    a0ea:	b.n	a03a <FatFile::read(void*, unsigned int)+0xba>
        // start of new cluster
        if (m_curPosition == 0) {
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        } else if (isFile() && isContiguous()) {
    a0ec:	lsls	r3, r1, #28
    a0ee:	bpl.n	a0fc <FatFile::read(void*, unsigned int)+0x17c>
    a0f0:	ldrb	r3, [r5, #2]
    a0f2:	lsls	r4, r3, #25
    a0f4:	bpl.n	a0fc <FatFile::read(void*, unsigned int)+0x17c>
          m_curCluster++;
    a0f6:	ldr	r4, [r5, #16]
    a0f8:	adds	r4, #1
    a0fa:	b.n	a072 <FatFile::read(void*, unsigned int)+0xf2>
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    a0fc:	mov	r0, r2
    a0fe:	ldr	r1, [r5, #16]
    a100:	mov	r2, sl
    a102:	bl	a860 <FatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    a106:	cmp	r0, #0
    a108:	blt.n	a0b4 <FatFile::read(void*, unsigned int)+0x134>
            DBG_FAIL_MACRO;
            goto fail;
          }
          if (fg == 0) {
    a10a:	beq.n	a0ac <FatFile::read(void*, unsigned int)+0x12c>
    a10c:	ldr	r2, [r5, #8]
    a10e:	ldr	r4, [r5, #16]
    a110:	b.n	a074 <FatFile::read(void*, unsigned int)+0xf4>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    a112:	movs	r6, #0
    }
    dst += n;
    m_curPosition += n;
    toRead -= n;
  }
  return nbyte - toRead;
    a114:	rsb	r0, r6, r9

 fail:
  m_error |= READ_ERROR;
  return -1;
}
    a118:	add	sp, #12
    a11a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    a11e:	nop

0000a120 <FatFile::peek()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::peek() {
    a120:	push	{r4, r5, r6, lr}
    a122:	sub	sp, #8
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
    a124:	movs	r2, #1
    a126:	add.w	r1, sp, #7
    a12a:	mov	r4, r0
  uint32_t curPosition = m_curPosition;
    a12c:	ldr	r6, [r0, #20]
  uint32_t curCluster = m_curCluster;
    a12e:	ldr	r5, [r0, #16]
    a130:	bl	9f80 <FatFile::read(void*, unsigned int)>
    a134:	cmp	r0, #1
    a136:	it	eq
    a138:	ldrbeq.w	r0, [sp, #7]
  int c = read();
  m_curPosition = curPosition;
    a13c:	str	r6, [r4, #20]
    a13e:	it	ne
    a140:	movne.w	r0, #4294967295
  m_curCluster = curCluster;
    a144:	str	r5, [r4, #16]
  return c;
}
    a146:	add	sp, #8
    a148:	pop	{r4, r5, r6, pc}
    a14a:	nop

0000a14c <FatFile::readDirCache(bool)>:
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache
// Assumes file is correctly positioned
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
    a14c:	push	{r4, r5, lr}
  uint8_t i = (m_curPosition >> 5) & 0XF;
    a14e:	ldr	r3, [r0, #20]
    a150:	ubfx	r5, r3, #5, #4
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache
// Assumes file is correctly positioned
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
    a154:	sub	sp, #12
    a156:	mov	r4, r0
  uint8_t i = (m_curPosition >> 5) & 0XF;

  if (i == 0 || !skipReadOk) {
    a158:	cbz	r5, a15c <FatFile::readDirCache(bool)+0x10>
    a15a:	cbnz	r1, a180 <FatFile::readDirCache(bool)+0x34>
    int8_t n = read(&n, 1);
    a15c:	movs	r2, #1
    a15e:	add.w	r1, sp, #7
    a162:	mov	r0, r4
    a164:	bl	9f80 <FatFile::read(void*, unsigned int)>
    a168:	sxtb	r0, r0
    if  (n != 1) {
    a16a:	cmp	r0, #1
    a16c:	bne.n	a186 <FatFile::readDirCache(bool)+0x3a>
      if (n != 0) {
        DBG_FAIL_MACRO;
      }
      goto fail;
    }
    m_curPosition += 31;
    a16e:	ldr	r3, [r4, #20]
    a170:	adds	r3, #31
    a172:	str	r3, [r4, #20]
  static const uint8_t CACHE_RESERVE_FOR_WRITE =
    CACHE_STATUS_DIRTY | CACHE_OPTION_NO_READ;
  //----------------------------------------------------------------------------
  /** \return Cache buffer address. */
  uint8_t* cacheBuffer() {
    return m_buffer;
    a174:	ldr	r0, [r4, #8]
    a176:	adds	r0, #52	; 0x34
  } else {
    m_curPosition += 32;
  }
  // return pointer to entry
  return reinterpret_cast<DirFat_t*>(m_vol->cacheAddress()) + i;
    a178:	add.w	r0, r0, r5, lsl #5

 fail:
  return nullptr;
}
    a17c:	add	sp, #12
    a17e:	pop	{r4, r5, pc}
      }
      goto fail;
    }
    m_curPosition += 31;
  } else {
    m_curPosition += 32;
    a180:	adds	r3, #32
    a182:	str	r3, [r0, #20]
    a184:	b.n	a174 <FatFile::readDirCache(bool)+0x28>
  }
  // return pointer to entry
  return reinterpret_cast<DirFat_t*>(m_vol->cacheAddress()) + i;

 fail:
  return nullptr;
    a186:	movs	r0, #0
}
    a188:	add	sp, #12
    a18a:	pop	{r4, r5, pc}

0000a18c <FatFile::rename(FatFile*, char const*)>:
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    a18c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    a190:	ldrb	r5, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    a192:	sub	sp, #104	; 0x68
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    a194:	movs	r4, #0
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    a196:	tst.w	r5, #24
    a19a:	strb.w	r4, [sp, #32]
    a19e:	strb.w	r4, [sp, #33]	; 0x21
    a1a2:	strb.w	r4, [sp, #34]	; 0x22
    a1a6:	strb.w	r4, [sp, #68]	; 0x44
    a1aa:	strb.w	r4, [sp, #69]	; 0x45
    a1ae:	strb.w	r4, [sp, #70]	; 0x46
    a1b2:	beq.n	a1be <FatFile::rename(FatFile*, char const*)+0x32>
  if (!USE_LONG_FILE_NAMES && isLFN()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    a1b4:	ldr	r6, [r0, #8]
    a1b6:	ldr	r5, [r1, #8]
    a1b8:	cmp	r6, r5
    a1ba:	mov	r3, r0
    a1bc:	beq.n	a1c6 <FatFile::rename(FatFile*, char const*)+0x3a>
    goto fail;
  }
  return m_vol->cacheSync();

 fail:
  return false;
    a1be:	movs	r0, #0
}
    a1c0:	add	sp, #104	; 0x68
    a1c2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a1c6:	mov	r5, r3
    a1c8:	mov	r8, r2
    a1ca:	mov	r6, r1
    a1cc:	bl	9bdc <FatFile::sync() [clone .part.42]>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // sync() and cache directory entry
  sync();
  oldFile = *this;
    a1d0:	mov	lr, r5
    a1d2:	ldmia.w	lr!, {r0, r1, r2, r3}
    a1d6:	add	r7, sp, #68	; 0x44
    a1d8:	stmia	r7!, {r0, r1, r2, r3}
    a1da:	ldmia.w	lr!, {r0, r1, r2, r3}
    a1de:	stmia	r7!, {r0, r1, r2, r3}
    a1e0:	ldr.w	r3, [lr]
    a1e4:	str	r3, [r7, #0]
  dir = cacheDirEntry(FsCache::CACHE_FOR_READ);
    a1e6:	mov	r1, r4
    a1e8:	mov	r0, r5
    a1ea:	bl	9bbc <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    a1ee:	mov	lr, r0
    a1f0:	cmp	r0, #0
    a1f2:	beq.n	a1be <FatFile::rename(FatFile*, char const*)+0x32>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
    a1f4:	ldr.w	r1, [lr, #4]
    a1f8:	ldr.w	r2, [lr, #8]
    a1fc:	ldr.w	r3, [lr, #12]
    a200:	ldr	r0, [r0, #0]
  // make directory entry for new path
  if (isFile()) {
    a202:	ldrb.w	ip, [r5]
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
    a206:	mov	r7, sp
    a208:	stmia	r7!, {r0, r1, r2, r3}
    a20a:	ldr.w	r1, [lr, #20]
    a20e:	ldr.w	r2, [lr, #24]
    a212:	ldr.w	r3, [lr, #28]
    a216:	ldr.w	r0, [lr, #16]
  // make directory entry for new path
  if (isFile()) {
    a21a:	and.w	lr, ip, #8
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
    a21e:	stmia	r7!, {r0, r1, r2, r3}
  // make directory entry for new path
  if (isFile()) {
    a220:	and.w	r3, lr, #255	; 0xff
    if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    a224:	mov	r2, r8
    a226:	mov	r1, r6
    goto fail;
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
  // make directory entry for new path
  if (isFile()) {
    a228:	cmp.w	lr, #0
    a22c:	beq.w	a350 <FatFile::rename(FatFile*, char const*)+0x1c4>
    if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    a230:	movw	r3, #2561	; 0xa01
    a234:	add	r0, sp, #32
    a236:	bl	9ea4 <FatFile::open(FatFile*, char const*, int)>
    a23a:	cmp	r0, #0
    a23c:	beq.n	a1be <FatFile::rename(FatFile*, char const*)+0x32>
    // save cluster containing new dot dot
    dirCluster = file.m_firstCluster;
  }
  // change to new directory entry

  m_dirSector = file.m_dirSector;
    a23e:	ldr	r0, [sp, #56]	; 0x38
  m_dirIndex = file.m_dirIndex;
    a240:	ldrh.w	r1, [sp, #36]	; 0x24
  m_lfnOrd = file.m_lfnOrd;
    a244:	ldrb.w	r2, [sp, #35]	; 0x23
  m_dirCluster = file.m_dirCluster;
    a248:	ldr	r3, [sp, #44]	; 0x2c
    // save cluster containing new dot dot
    dirCluster = file.m_firstCluster;
  }
  // change to new directory entry

  m_dirSector = file.m_dirSector;
    a24a:	str	r0, [r5, #24]
  m_dirIndex = file.m_dirIndex;
  m_lfnOrd = file.m_lfnOrd;
  m_dirCluster = file.m_dirCluster;
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
    a24c:	movs	r6, #0
    dirCluster = file.m_firstCluster;
  }
  // change to new directory entry

  m_dirSector = file.m_dirSector;
  m_dirIndex = file.m_dirIndex;
    a24e:	strh	r1, [r5, #4]
  m_lfnOrd = file.m_lfnOrd;
    a250:	strb	r2, [r5, #3]
  m_dirCluster = file.m_dirCluster;
    a252:	str	r3, [r5, #12]
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
  file.m_flags = 0;

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    a254:	movs	r1, #1
    a256:	mov	r0, r5
  m_dirSector = file.m_dirSector;
  m_dirIndex = file.m_dirIndex;
  m_lfnOrd = file.m_lfnOrd;
  m_dirCluster = file.m_dirCluster;
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
    a258:	strb.w	r6, [sp, #32]
  file.m_flags = 0;
    a25c:	strb.w	r6, [sp, #34]	; 0x22

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    a260:	bl	9bbc <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    a264:	cmp	r0, #0
    a266:	beq.n	a1be <FatFile::rename(FatFile*, char const*)+0x32>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy all but name and name flags to new directory entry
  memcpy(&dir->createTimeMs, &entry.createTimeMs,
         sizeof(entry) - sizeof(dir->name) - 2);
    a268:	add	r3, sp, #104	; 0x68
  dir->attributes = entry.attributes;
    a26a:	ldrb.w	r2, [sp, #11]
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy all but name and name flags to new directory entry
  memcpy(&dir->createTimeMs, &entry.createTimeMs,
         sizeof(entry) - sizeof(dir->name) - 2);
    a26e:	ldr.w	r7, [r3, #-91]!
    a272:	str.w	r7, [r0, #13]
    a276:	ldr	r7, [r3, #4]
    a278:	str.w	r7, [r0, #17]
    a27c:	ldr	r7, [r3, #8]
    a27e:	str.w	r7, [r0, #21]
    a282:	ldr	r7, [r3, #12]
    a284:	str.w	r7, [r0, #25]
    a288:	ldrh	r7, [r3, #16]
    a28a:	ldrb	r3, [r3, #18]
    a28c:	strh.w	r7, [r0, #29]
    a290:	strb	r3, [r0, #31]
  dir->attributes = entry.attributes;
    a292:	strb	r2, [r0, #11]

  // update dot dot if directory
  if (dirCluster) {
    a294:	cmp	r4, #0
    a296:	beq.n	a30c <FatFile::rename(FatFile*, char const*)+0x180>
    // get new dot dot
    uint32_t sector = m_vol->clusterStartSector(dirCluster);
    a298:	ldr	r0, [r5, #8]
    a29a:	ldrb	r2, [r0, #6]
    a29c:	ldr	r1, [r0, #20]
    a29e:	subs	r3, r4, #2
    a2a0:	lsls	r3, r2
    a2a2:	add	r1, r3
    a2a4:	mov	r2, r6
    a2a6:	adds	r0, #36	; 0x24
    a2a8:	bl	81e8 <FsCache::get(unsigned long, unsigned char)>
    pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    a2ac:	cmp	r0, #0
    a2ae:	beq.n	a1be <FatFile::rename(FatFile*, char const*)+0x32>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memcpy(&entry, &pc->dir[1], sizeof(entry));
    a2b0:	mov	r6, r0
    a2b2:	mov	r7, sp
    a2b4:	ldr.w	r0, [r6, #32]!
    a2b8:	ldr	r1, [r6, #4]
    a2ba:	ldr	r2, [r6, #8]
    a2bc:	ldr	r3, [r6, #12]
    a2be:	stmia	r7!, {r0, r1, r2, r3}
    a2c0:	ldr	r0, [r6, #16]
    a2c2:	ldr	r1, [r6, #20]
    a2c4:	ldr	r2, [r6, #24]
    a2c6:	ldr	r3, [r6, #28]
    a2c8:	stmia	r7!, {r0, r1, r2, r3}

    // free unused cluster
    if (!m_vol->freeChain(dirCluster)) {
    a2ca:	mov	r1, r4
    a2cc:	ldr	r0, [r5, #8]
    a2ce:	bl	a9bc <FatPartition::freeChain(unsigned long)>
    a2d2:	cmp	r0, #0
    a2d4:	beq.w	a1be <FatFile::rename(FatFile*, char const*)+0x32>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // store new dot dot
    sector = m_vol->clusterStartSector(m_firstCluster);
    a2d8:	ldr	r0, [r5, #8]
    a2da:	ldr	r3, [r5, #32]
    a2dc:	ldrb	r2, [r0, #6]
    a2de:	ldr	r1, [r0, #20]
    a2e0:	subs	r3, #2
    a2e2:	lsls	r3, r2
    a2e4:	add	r1, r3
    a2e6:	adds	r0, #36	; 0x24
    a2e8:	movs	r2, #1
    a2ea:	bl	81e8 <FsCache::get(unsigned long, unsigned char)>
    pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    a2ee:	mov	r7, r0
    a2f0:	cmp	r0, #0
    a2f2:	beq.w	a1be <FatFile::rename(FatFile*, char const*)+0x32>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memcpy(&pc->dir[1], &entry, sizeof(entry));
    a2f6:	mov	r4, sp
    a2f8:	ldmia	r4!, {r0, r1, r2, r3}
    a2fa:	str	r0, [r7, #32]
    a2fc:	str	r1, [r7, #36]	; 0x24
    a2fe:	str	r2, [r7, #40]	; 0x28
    a300:	str	r3, [r7, #44]	; 0x2c
    a302:	ldmia	r4!, {r0, r1, r2, r3}
    a304:	str	r0, [r7, #48]	; 0x30
    a306:	str	r1, [r7, #52]	; 0x34
    a308:	str	r2, [r7, #56]	; 0x38
    a30a:	str	r3, [r7, #60]	; 0x3c
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    a30c:	movs	r1, #0
  oldFile.m_flags = FILE_FLAG_WRITE;
    a30e:	movs	r2, #2
  oldFile.m_attributes = FILE_ATTR_FILE;
    a310:	movs	r3, #8
  if (!oldFile.remove()) {
    a312:	add	r0, sp, #68	; 0x44
      goto fail;
    }
    memcpy(&pc->dir[1], &entry, sizeof(entry));
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    a314:	str	r1, [sp, #100]	; 0x64
  oldFile.m_flags = FILE_FLAG_WRITE;
    a316:	strb.w	r2, [sp, #70]	; 0x46
  oldFile.m_attributes = FILE_ATTR_FILE;
    a31a:	strb.w	r3, [sp, #68]	; 0x44
  if (!oldFile.remove()) {
    a31e:	bl	af78 <FatFile::remove()>
    a322:	cmp	r0, #0
    a324:	beq.w	a1be <FatFile::rename(FatFile*, char const*)+0x32>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return m_vol->cacheSync();
    a328:	ldr	r4, [r5, #8]
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    a32a:	add.w	r0, r4, #36	; 0x24
    a32e:	bl	8248 <FsCache::sync()>
    a332:	cmp	r0, #0
    a334:	beq.w	a1be <FatFile::rename(FatFile*, char const*)+0x32>
    a338:	add.w	r0, r4, #564	; 0x234
    a33c:	bl	8248 <FsCache::sync()>
    a340:	cmp	r0, #0
    a342:	beq.w	a1be <FatFile::rename(FatFile*, char const*)+0x32>
    a346:	ldr	r0, [r4, #0]
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    a348:	ldr	r3, [r0, #0]
    a34a:	ldr	r3, [r3, #24]
    a34c:	blx	r3
    a34e:	b.n	a1c0 <FatFile::rename(FatFile*, char const*)+0x34>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else {
    // don't create missing path prefix components
    if (!file.mkdir(dirFile, newPath, false)) {
    a350:	add	r0, sp, #32
    a352:	bl	9de0 <FatFile::mkdir(FatFile*, char const*, bool)>
    a356:	cmp	r0, #0
    a358:	beq.w	a1be <FatFile::rename(FatFile*, char const*)+0x32>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // save cluster containing new dot dot
    dirCluster = file.m_firstCluster;
    a35c:	ldr	r4, [sp, #64]	; 0x40
    a35e:	b.n	a23e <FatFile::rename(FatFile*, char const*)+0xb2>

0000a360 <FatFile::rmdir()>:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::rmdir() {
  // must be open subdirectory
  if (!isSubDir() || (!USE_LONG_FILE_NAMES && isLFN())) {
    a360:	ldrb	r3, [r0, #0]
    a362:	lsls	r2, r3, #27
    a364:	bpl.n	a39c <FatFile::rmdir()+0x3c>
  if (!isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    a366:	ldr	r3, [r0, #20]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::rmdir() {
    a368:	push	{r4, lr}
    a36a:	mov	r4, r0
  if (!isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    a36c:	cbz	r3, a37c <FatFile::rmdir()+0x1c>
    }
  }

 done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    a36e:	ldrb	r3, [r0, #2]
  if (pos == m_curPosition) {
    return true;
  }
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    a370:	movs	r2, #0
    }
  }

 done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    a372:	bic.w	r3, r3, #32
    a376:	strb	r3, [r0, #2]
  if (pos == m_curPosition) {
    return true;
  }
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    a378:	str	r2, [r0, #16]
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    a37a:	str	r2, [r0, #20]
  }
  rewind();

  // make sure directory is empty
  while (1) {
    DirFat_t* dir = readDirCache(true);
    a37c:	movs	r1, #1
    a37e:	mov	r0, r4
    a380:	bl	a14c <FatFile::readDirCache(bool)>
    if (!dir) {
    a384:	cbz	r0, a3a0 <FatFile::rmdir()+0x40>
      }
      DBG_FAIL_MACRO;
      goto fail;
    }
    // done if past last used entry
    if (dir->name[0] == FAT_NAME_FREE) {
    a386:	ldrb	r3, [r0, #0]
    a388:	cbz	r3, a3a6 <FatFile::rmdir()+0x46>
      break;
    }
    // skip empty slot, '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    a38a:	cmp	r3, #229	; 0xe5
    a38c:	beq.n	a37c <FatFile::rmdir()+0x1c>
    a38e:	cmp	r3, #46	; 0x2e
    a390:	beq.n	a37c <FatFile::rmdir()+0x1c>
      continue;
    }
    // error not empty
    if (isFileOrSubdir(dir)) {
    a392:	ldrb	r3, [r0, #11]
    a394:	lsls	r3, r3, #28
    a396:	bmi.n	a37c <FatFile::rmdir()+0x1c>
  m_flags |= FILE_FLAG_WRITE;
  return remove();

 fail:
  return false;
}
    a398:	movs	r0, #0
    a39a:	pop	{r4, pc}
    a39c:	movs	r0, #0
    a39e:	bx	lr
  // make sure directory is empty
  while (1) {
    DirFat_t* dir = readDirCache(true);
    if (!dir) {
      // EOF if no error.
      if (!getError()) {
    a3a0:	ldrb	r3, [r4, #1]
    a3a2:	cmp	r3, #0
    a3a4:	bne.n	a398 <FatFile::rmdir()+0x38>
      goto fail;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
    a3a6:	ldrb	r3, [r4, #2]
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    a3a8:	movs	r2, #8
  m_flags |= FILE_FLAG_WRITE;
    a3aa:	orr.w	r3, r3, #2
    a3ae:	strb	r3, [r4, #2]
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    a3b0:	strb	r2, [r4, #0]
  m_flags |= FILE_FLAG_WRITE;
  return remove();
    a3b2:	mov	r0, r4

 fail:
  return false;
}
    a3b4:	ldmia.w	sp!, {r4, lr}
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();
    a3b8:	b.w	af78 <FatFile::remove()>

0000a3bc <FatFile::seekSet(unsigned long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::seekSet(uint32_t pos) {
    a3bc:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a3c0:	ldrb	r3, [r0, #0]
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
    a3c2:	ldr	r7, [r0, #16]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::seekSet(uint32_t pos) {
    a3c4:	mov	r4, r0
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    a3c6:	cbz	r3, a3f6 <FatFile::seekSet(unsigned long)+0x3a>
    a3c8:	mov	r5, r1
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    a3ca:	ldr	r1, [r0, #20]
    a3cc:	cmp	r1, r5
    a3ce:	beq.n	a428 <FatFile::seekSet(unsigned long)+0x6c>
    return true;
  }
  if (pos == 0) {
    a3d0:	cbnz	r5, a3e4 <FatFile::seekSet(unsigned long)+0x28>
    a3d2:	ldrb	r3, [r0, #2]
    // set position to start of file
    m_curCluster = 0;
    a3d4:	str	r5, [r0, #16]
    }
  }

 done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    a3d6:	bic.w	r3, r3, #32
    a3da:	strb	r3, [r4, #2]
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    a3dc:	str	r5, [r4, #20]
  m_flags &= ~FILE_FLAG_PREALLOCATE;
  return true;
    a3de:	movs	r0, #1
    a3e0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    goto done;
  }
  if (isFile()) {
    a3e4:	lsls	r0, r3, #28
    a3e6:	bmi.n	a3fe <FatFile::seekSet(unsigned long)+0x42>
    if (pos > m_fileSize) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (isRootFixed()) {
    a3e8:	lsls	r2, r3, #26
    a3ea:	bpl.n	a404 <FatFile::seekSet(unsigned long)+0x48>
    a3ec:	ldr	r3, [r4, #8]
    if (pos <= 32*m_vol->rootDirEntryCount()) {
    a3ee:	ldrh	r3, [r3, #8]
    a3f0:	cmp.w	r5, r3, lsl #5
    a3f4:	bls.n	a460 <FatFile::seekSet(unsigned long)+0xa4>
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
  return true;

 fail:
  m_curCluster = tmp;
    a3f6:	str	r7, [r4, #16]
  return false;
    a3f8:	movs	r0, #0
    a3fa:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    // set position to start of file
    m_curCluster = 0;
    goto done;
  }
  if (isFile()) {
    if (pos > m_fileSize) {
    a3fe:	ldr	r2, [r4, #28]
    a400:	cmp	r5, r2
    a402:	bhi.n	a3f6 <FatFile::seekSet(unsigned long)+0x3a>
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    a404:	ldr.w	lr, [r4, #8]
    a408:	ldrb	r2, [r4, #2]
    a40a:	ldrb.w	r0, [lr, #6]
    a40e:	adds	r0, #9
    a410:	uxtb	r0, r0
    a412:	subs	r6, r5, #1
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    a414:	tst.w	r2, #64	; 0x40
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    a418:	lsr.w	r6, r6, r0
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    a41c:	beq.n	a42e <FatFile::seekSet(unsigned long)+0x72>
    m_curCluster = m_firstCluster + nNew;
    a41e:	ldr	r3, [r4, #32]
    a420:	add	r6, r3
    a422:	str	r6, [r4, #16]
    goto done;
    a424:	mov	r3, r2
    a426:	b.n	a3d6 <FatFile::seekSet(unsigned long)+0x1a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    return true;
    a428:	movs	r0, #1
  return true;

 fail:
  m_curCluster = tmp;
  return false;
}
    a42a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    m_curCluster = m_firstCluster + nNew;
    goto done;
  }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> (m_vol->bytesPerClusterShift());
    a42e:	subs	r2, r1, #1
    a430:	lsr.w	r0, r2, r0

  if (nNew < nCur || m_curPosition == 0) {
    a434:	cmp	r6, r0
    a436:	bcs.n	a464 <FatFile::seekSet(unsigned long)+0xa8>
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    a438:	lsls	r3, r3, #25
    a43a:	ite	mi
    a43c:	ldrmi.w	r3, [lr, #32]
    a440:	ldrpl	r3, [r4, #32]
    a442:	str	r3, [r4, #16]
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    a444:	add.w	r8, r4, #16
    a448:	b.n	a45a <FatFile::seekSet(unsigned long)+0x9e>
    a44a:	ldr	r1, [r4, #16]
    a44c:	ldr	r0, [r4, #8]
    a44e:	bl	a860 <FatPartition::fatGet(unsigned long, unsigned long*)>
    a452:	cmp	r0, #0
    a454:	add.w	r6, r6, #4294967295
    a458:	ble.n	a3f6 <FatFile::seekSet(unsigned long)+0x3a>
    a45a:	mov	r2, r8
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    a45c:	cmp	r6, #0
    a45e:	bne.n	a44a <FatFile::seekSet(unsigned long)+0x8e>
    a460:	ldrb	r3, [r4, #2]
    a462:	b.n	a3d6 <FatFile::seekSet(unsigned long)+0x1a>
  }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> (m_vol->bytesPerClusterShift());

  if (nNew < nCur || m_curPosition == 0) {
    a464:	cmp	r1, #0
    a466:	beq.n	a438 <FatFile::seekSet(unsigned long)+0x7c>
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
    a468:	subs	r6, r6, r0
    a46a:	b.n	a444 <FatFile::seekSet(unsigned long)+0x88>

0000a46c <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>:
  return false;
}
//------------------------------------------------------------------------------
// open a cached directory entry.
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
    a46c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a470:	mov	r5, r1
    a472:	mov	r8, r2
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
    a474:	movs	r1, #0
    a476:	movs	r2, #36	; 0x24
  return false;
}
//------------------------------------------------------------------------------
// open a cached directory entry.
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
    a478:	mov	r4, r0
    a47a:	mov	r7, r3
    a47c:	ldrb.w	r6, [sp, #24]
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
    a480:	bl	1059c <memset>
  // location of entry in cache
  m_vol = dirFile->m_vol;
    a484:	ldr	r0, [r5, #8]
  m_dirIndex = dirIndex;
  m_dirCluster = dirFile->m_firstCluster;
    a486:	ldr	r3, [r5, #32]
    a488:	str	r3, [r4, #12]
    a48a:	add.w	r2, r0, #52	; 0x34
  DirFat_t* dir = reinterpret_cast<DirFat_t*>(m_vol->cacheAddress());
  dir += 0XF & dirIndex;
    a48e:	and.w	r3, r8, #15
    a492:	add.w	r2, r2, r3, lsl #5
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
  // location of entry in cache
  m_vol = dirFile->m_vol;
    a496:	str	r0, [r4, #8]
  m_dirIndex = dirIndex;
    a498:	strh.w	r8, [r4, #4]
    a49c:	ldrb	r1, [r2, #11]
  m_dirCluster = dirFile->m_firstCluster;
  DirFat_t* dir = reinterpret_cast<DirFat_t*>(m_vol->cacheAddress());
  dir += 0XF & dirIndex;

  // Must be file or subdirectory.
  if (!isFileOrSubdir(dir)) {
    a49e:	lsls	r5, r1, #28
    a4a0:	bmi.n	a4c8 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x5c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
    a4a2:	and.w	r1, r1, #23
    a4a6:	strb	r1, [r4, #0]
  if (isFileDir(dir)) {
    a4a8:	ldrb	r3, [r2, #11]
    m_attributes |= FILE_ATTR_FILE;
  }
  m_lfnOrd = lfnOrd;
    a4aa:	strb	r6, [r4, #3]
  if (!isFileOrSubdir(dir)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
  if (isFileDir(dir)) {
    a4ac:	tst.w	r3, #24
    m_attributes |= FILE_ATTR_FILE;
    a4b0:	it	eq
    a4b2:	orreq.w	r1, r1, #8
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    a4b6:	and.w	r3, r7, #3
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
  if (isFileDir(dir)) {
    m_attributes |= FILE_ATTR_FILE;
    a4ba:	it	eq
    a4bc:	strbeq	r1, [r4, #0]
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    a4be:	cmp	r3, #1
    a4c0:	beq.n	a4d2 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x66>
    a4c2:	cmp	r3, #2
    a4c4:	beq.n	a51a <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xae>
    a4c6:	cbz	r3, a510 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xa4>
    goto fail;
  }
  return true;

 fail:
  m_attributes = FILE_ATTR_CLOSED;
    a4c8:	movs	r0, #0
    a4ca:	strb	r0, [r4, #0]
  m_flags = 0;
    a4cc:	strb	r0, [r4, #2]
  return false;
    a4ce:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    case O_RDWR:
      m_flags = FILE_FLAG_READ | FILE_FLAG_WRITE;
      break;

    case O_WRONLY:
      m_flags = FILE_FLAG_WRITE;
    a4d2:	movs	r3, #2
    a4d4:	strb	r3, [r4, #2]
      DBG_FAIL_MACRO;
      goto fail;
  }

  if (m_flags & FILE_FLAG_WRITE) {
    if (isSubDir() || isReadOnly()) {
    a4d6:	ldrb	r1, [r4, #0]
    a4d8:	tst.w	r1, #17
    a4dc:	bne.n	a4c8 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x5c>
    a4de:	sxtb	r1, r3
    a4e0:	and.w	r5, r7, #1024	; 0x400
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  m_flags |= (oflag & O_APPEND ? FILE_FLAG_APPEND : 0);
    a4e4:	and.w	r3, r7, #8
    a4e8:	orrs	r3, r1
    a4ea:	uxtb	r3, r3
    a4ec:	strb	r3, [r4, #2]

  m_dirSector = m_vol->cacheSectorNumber();

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);
    a4ee:	ldrh.w	lr, [r2, #20]
    a4f2:	ldrh	r1, [r2, #26]
    a4f4:	ldr	r6, [r0, #48]	; 0x30
      goto fail;
    }
  }
  m_flags |= (oflag & O_APPEND ? FILE_FLAG_APPEND : 0);

  m_dirSector = m_vol->cacheSectorNumber();
    a4f6:	str	r6, [r4, #24]

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);
    a4f8:	orr.w	r1, r1, lr, lsl #16

  if (oflag & O_TRUNC) {
    a4fc:	cbz	r5, a520 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xb4>
    if (firstCluster && !m_vol->freeChain(firstCluster)) {
    a4fe:	cbnz	r1, a536 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xca>
      DBG_FAIL_MACRO;
      goto fail;
    }

    // need to update directory entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
    a500:	orn	r3, r3, #127	; 0x7f
    a504:	strb	r3, [r4, #2]
  } else {
    m_firstCluster = firstCluster;
    m_fileSize = getLe32(dir->fileSize);
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    a506:	lsls	r3, r7, #17
    a508:	bmi.n	a528 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xbc>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return true;
    a50a:	movs	r0, #1
    a50c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    case O_RDONLY:
      if (oflag & O_TRUNC) {
    a510:	ands.w	r5, r7, #1024	; 0x400
    a514:	bne.n	a4c8 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x5c>
    a516:	movs	r1, #1
    a518:	b.n	a4e4 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x78>
      }
      m_flags = FILE_FLAG_READ;
      break;

    case O_RDWR:
      m_flags = FILE_FLAG_READ | FILE_FLAG_WRITE;
    a51a:	movs	r3, #3
    a51c:	strb	r3, [r4, #2]
      break;
    a51e:	b.n	a4d6 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x6a>
    }

    // need to update directory entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else {
    m_firstCluster = firstCluster;
    a520:	str	r1, [r4, #32]
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    a522:	ldr	r3, [r2, #28]
    m_fileSize = getLe32(dir->fileSize);
    a524:	str	r3, [r4, #28]
    a526:	b.n	a506 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x9a>
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    a528:	ldr	r1, [r4, #28]
    a52a:	mov	r0, r4
    a52c:	bl	a3bc <FatFile::seekSet(unsigned long)>
    a530:	cmp	r0, #0
    a532:	bne.n	a50a <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x9e>
    a534:	b.n	a4c8 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x5c>
  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);

  if (oflag & O_TRUNC) {
    if (firstCluster && !m_vol->freeChain(firstCluster)) {
    a536:	bl	a9bc <FatPartition::freeChain(unsigned long)>
    a53a:	cmp	r0, #0
    a53c:	beq.n	a4c8 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x5c>
    a53e:	ldrb	r3, [r4, #2]
    a540:	b.n	a500 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x94>
    a542:	nop

0000a544 <FatFile::openNext(FatFile*, int)>:
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    a544:	ldrb	r3, [r0, #0]
    a546:	cbnz	r3, a550 <FatFile::openNext(FatFile*, int)+0xc>
    a548:	ldrb	r3, [r1, #0]
    a54a:	tst.w	r3, #112	; 0x70
    a54e:	bne.n	a554 <FatFile::openNext(FatFile*, int)+0x10>
      lfnOrd = 0;
    }
  }

 fail:
  return false;
    a550:	movs	r0, #0
}
    a552:	bx	lr
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, oflag_t oflag) {
    a554:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    a558:	ldr	r6, [r1, #20]
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    a55a:	ands.w	r7, r6, #31
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, oflag_t oflag) {
    a55e:	sub	sp, #8
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    a560:	bne.n	a5a6 <FatFile::openNext(FatFile*, int)+0x62>
    a562:	mov	r9, r2
    a564:	mov	r5, r1
    a566:	mov	r8, r0
    a568:	mov	sl, r7
    a56a:	b.n	a570 <FatFile::openNext(FatFile*, int)+0x2c>
      if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
        lfnOrd = ldir->order & 0X1F;
        checksum = ldir->checksum;
      }
    } else {
      lfnOrd = 0;
    a56c:	movs	r7, #0
    a56e:	ldr	r6, [r5, #20]
    goto fail;
  }
  while (1) {
    // read entry into cache
    index = dirFile->curPosition()/32;
    DirFat_t* dir = dirFile->readDirCache();
    a570:	movs	r1, #0
    a572:	mov	r0, r5
    a574:	bl	a14c <FatFile::readDirCache(bool)>
    if (!dir) {
    a578:	cbz	r0, a5a6 <FatFile::openNext(FatFile*, int)+0x62>
        DBG_FAIL_MACRO;
      }
      goto fail;
    }
    // done if last entry
    if (dir->name[0] == FAT_NAME_FREE) {
    a57a:	ldrb	r3, [r0, #0]
    a57c:	cbz	r3, a5a6 <FatFile::openNext(FatFile*, int)+0x62>
      goto fail;
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
    a57e:	cmp	r3, #46	; 0x2e
    a580:	beq.n	a56c <FatFile::openNext(FatFile*, int)+0x28>
    a582:	cmp	r3, #229	; 0xe5
    a584:	beq.n	a56c <FatFile::openNext(FatFile*, int)+0x28>
    a586:	ldrb	r2, [r0, #11]
      lfnOrd = 0;
    } else if (isFileOrSubdir(dir)) {
    a588:	lsls	r1, r2, #28
    a58a:	bpl.n	a5ae <FatFile::openNext(FatFile*, int)+0x6a>
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      return true;
    } else if (isLongName(dir)) {
    a58c:	cmp	r2, #15
    a58e:	bne.n	a56c <FatFile::openNext(FatFile*, int)+0x28>
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
    a590:	lsls	r2, r3, #25
    a592:	bpl.n	a56e <FatFile::openNext(FatFile*, int)+0x2a>
        lfnOrd = ldir->order & 0X1F;
    a594:	and.w	r7, r3, #31
        checksum = ldir->checksum;
    a598:	ldrb.w	sl, [r0, #13]
    a59c:	b.n	a56e <FatFile::openNext(FatFile*, int)+0x2a>
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
      lfnOrd = 0;
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd && checksum != lfnChecksum(dir->name)) {
    a59e:	bl	abec <FatFile::lfnChecksum(unsigned char*)>
    a5a2:	cmp	r0, sl
    a5a4:	beq.n	a5b2 <FatFile::openNext(FatFile*, int)+0x6e>
      lfnOrd = 0;
    }
  }

 fail:
  return false;
    a5a6:	movs	r0, #0
}
    a5a8:	add	sp, #8
    a5aa:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
      lfnOrd = 0;
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd && checksum != lfnChecksum(dir->name)) {
    a5ae:	cmp	r7, #0
    a5b0:	bne.n	a59e <FatFile::openNext(FatFile*, int)+0x5a>
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
    a5b2:	str	r7, [sp, #0]
    a5b4:	mov	r3, r9
    a5b6:	ubfx	r2, r6, #5, #16
    a5ba:	mov	r1, r5
    a5bc:	mov	r0, r8
    a5be:	bl	a46c <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>
    a5c2:	b.n	a5a8 <FatFile::openNext(FatFile*, int)+0x64>

0000a5c4 <FatFile::sync()>:
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    a5c4:	ldrb	r3, [r0, #0]
    a5c6:	cbz	r3, a5cc <FatFile::sync()+0x8>
    a5c8:	b.w	9bdc <FatFile::sync() [clone .part.42]>
  DBG_FAIL_MACRO;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    a5cc:	movs	r0, #1
    a5ce:	bx	lr

0000a5d0 <FatFile::truncate()>:
}
//------------------------------------------------------------------------------
bool FatFile::truncate() {
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    a5d0:	ldrb	r3, [r0, #2]
    a5d2:	lsls	r3, r3, #30
    a5d4:	bpl.n	a60c <FatFile::truncate()+0x3c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
    a5d6:	ldr	r3, [r0, #32]
    a5d8:	cbz	r3, a608 <FatFile::truncate()+0x38>

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::truncate() {
    a5da:	push	{r4, lr}
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
  }
  if (m_curCluster) {
    a5dc:	ldr	r1, [r0, #16]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::truncate() {
    a5de:	sub	sp, #8
    a5e0:	mov	r4, r0
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
  }
  if (m_curCluster) {
    a5e2:	cbnz	r1, a622 <FatFile::truncate()+0x52>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  } else {
    toFree = m_firstCluster;
    a5e4:	str	r3, [sp, #4]
    m_firstCluster = 0;
    a5e6:	str	r1, [r0, #32]
  }
  if (toFree) {
    if (!m_vol->freeChain(toFree)) {
    a5e8:	mov	r1, r3
    a5ea:	ldr	r0, [r4, #8]
    a5ec:	bl	a9bc <FatPartition::freeChain(unsigned long)>
    a5f0:	cbz	r0, a61e <FatFile::truncate()+0x4e>
    }
  }
  m_fileSize = m_curPosition;

  // need to update directory entry
  m_flags |= FILE_FLAG_DIR_DIRTY;
    a5f2:	ldrb	r3, [r4, #2]
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    a5f4:	ldrb	r2, [r4, #0]
    if (!m_vol->freeChain(toFree)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  m_fileSize = m_curPosition;
    a5f6:	ldr	r1, [r4, #20]
    a5f8:	str	r1, [r4, #28]

  // need to update directory entry
  m_flags |= FILE_FLAG_DIR_DIRTY;
    a5fa:	orn	r3, r3, #127	; 0x7f
    a5fe:	strb	r3, [r4, #2]
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    a600:	cbnz	r2, a63e <FatFile::truncate()+0x6e>
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
    a602:	movs	r0, #1
  }
  return true;

 fail:
  return false;
}
    a604:	add	sp, #8
    a606:	pop	{r4, pc}
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
    a608:	movs	r0, #1
  }
  return true;

 fail:
  return false;
}
    a60a:	bx	lr
    goto fail;
  }
  return true;

 fail:
  return false;
    a60c:	movs	r0, #0
}
    a60e:	bx	lr
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
  }
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
    a610:	mvn.w	r2, #4026531840	; 0xf0000000
    a614:	ldr	r1, [r4, #16]
    a616:	ldr	r0, [r4, #8]
    a618:	bl	a8d0 <FatPartition::fatPut(unsigned long, unsigned long)>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg) {
      // current cluster is end of chain
      if (!m_vol->fatPutEOC(m_curCluster)) {
    a61c:	cbnz	r0, a636 <FatFile::truncate()+0x66>
    goto fail;
  }
  return true;

 fail:
  return false;
    a61e:	movs	r0, #0
    a620:	b.n	a604 <FatFile::truncate()+0x34>
  }
  if (m_firstCluster == 0) {
      return true;
  }
  if (m_curCluster) {
    toFree = 0;
    a622:	add	r2, sp, #8
    a624:	movs	r3, #0
    a626:	str.w	r3, [r2, #-4]!
    int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    a62a:	ldr	r0, [r0, #8]
    a62c:	bl	a860 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    a630:	cmp	r0, #0
    a632:	blt.n	a61e <FatFile::truncate()+0x4e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg) {
    a634:	bne.n	a610 <FatFile::truncate()+0x40>
    }
  } else {
    toFree = m_firstCluster;
    m_firstCluster = 0;
  }
  if (toFree) {
    a636:	ldr	r3, [sp, #4]
    a638:	cmp	r3, #0
    a63a:	beq.n	a5f2 <FatFile::truncate()+0x22>
    a63c:	b.n	a5e8 <FatFile::truncate()+0x18>
    a63e:	mov	r0, r4
    a640:	bl	9bdc <FatFile::sync() [clone .part.42]>
    a644:	b.n	a604 <FatFile::truncate()+0x34>
    a646:	nop

0000a648 <FatFile::write(void const*, unsigned int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t FatFile::write(const void* buf, size_t nbyte) {
    a648:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    a64c:	ldrb	r3, [r0, #2]
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isWritable()) {
    a64e:	lsls	r5, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t FatFile::write(const void* buf, size_t nbyte) {
    a650:	mov	r4, r0
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isWritable()) {
    a652:	bmi.n	a664 <FatFile::write(void const*, unsigned int)+0x1c>
  }
  return nbyte;

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
    a654:	ldrb	r3, [r4, #1]
    a656:	orr.w	r3, r3, #1
    a65a:	strb	r3, [r4, #1]
  return -1;
    a65c:	mov.w	r0, #4294967295
    a660:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    a664:	mov	r8, r2
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    a666:	lsls	r2, r3, #28
    a668:	mov	r7, r1
    a66a:	bmi.w	a80a <FatFile::write(void const*, unsigned int)+0x1c2>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    a66e:	ldr	r2, [r4, #20]
    a670:	mvns	r3, r2
    a672:	cmp	r8, r3
    a674:	bhi.n	a654 <FatFile::write(void const*, unsigned int)+0xc>
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    a676:	cmp.w	r8, #0
    a67a:	beq.w	a82c <FatFile::write(void const*, unsigned int)+0x1e4>
    a67e:	mov	r6, r8
    a680:	b.n	a6f8 <FatFile::write(void const*, unsigned int)+0xb0>
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    a682:	cmp.w	r9, #0
    a686:	bne.n	a73a <FatFile::write(void const*, unsigned int)+0xf2>
      // start of new cluster
      if (m_curCluster != 0) {
    a688:	ldr	r1, [r4, #16]
    a68a:	cmp	r1, #0
    a68c:	beq.w	a7b6 <FatFile::write(void const*, unsigned int)+0x16e>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        int8_t fg;
        if (isContiguous() && m_fileSize > m_curPosition) {
    a690:	ldrb	r3, [r4, #2]
    a692:	lsls	r3, r3, #25
    a694:	bpl.w	a7ca <FatFile::write(void const*, unsigned int)+0x182>
    a698:	ldr	r3, [r4, #28]
    a69a:	cmp	r3, r2
    a69c:	bls.w	a7ca <FatFile::write(void const*, unsigned int)+0x182>
          m_curCluster++;
    a6a0:	adds	r3, r1, #1
    a6a2:	str	r3, [r4, #16]
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
  }
  uint32_t clusterStartSector(uint32_t cluster) const {
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
    a6a4:	ldrb	r2, [r0, #6]
    a6a6:	ldr	r3, [r0, #20]
    a6a8:	subs	r1, #1
    a6aa:	lsls	r1, r2
    }
    // sector for data write
    uint32_t sector = m_vol->clusterStartSector(m_curCluster)
                      + sectorOfCluster;

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
    a6ac:	cmp.w	r6, #512	; 0x200
    a6b0:	add	r1, r3
    a6b2:	bcs.n	a756 <FatFile::write(void const*, unsigned int)+0x10e>
    a6b4:	cmp.w	r6, #512	; 0x200
    a6b8:	mov	r5, r6
    a6ba:	it	cs
    a6bc:	movcs.w	r5, #512	; 0x200
      if (n > nToWrite) {
        n = nToWrite;
      }

      if (sectorOffset == 0 &&
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
    a6c0:	ldrb	r3, [r4, #2]
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    a6c2:	tst.w	r3, #32
    a6c6:	ite	eq
    a6c8:	moveq	r2, #1
    a6ca:	movne	r2, #5
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    a6cc:	adds	r0, #36	; 0x24
    a6ce:	bl	81e8 <FsCache::get(unsigned long, unsigned char)>
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
      }
      pc = m_vol->cacheFetchData(sector, cacheOption);
      if (!pc) {
    a6d2:	cmp	r0, #0
    a6d4:	beq.n	a654 <FatFile::write(void const*, unsigned int)+0xc>
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
    a6d6:	add	r0, r9
    a6d8:	mov	r2, r5
    a6da:	mov	r1, r7
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    a6dc:	add	r9, r5
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
    a6de:	bl	d444 <memcpy>
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    a6e2:	cmp.w	r9, #512	; 0x200
    a6e6:	beq.w	a7fa <FatFile::write(void const*, unsigned int)+0x1b2>
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    a6ea:	ldr	r2, [r4, #20]
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    a6ec:	subs	r6, r6, r5
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    a6ee:	add	r2, r5
    src += n;
    a6f0:	add	r7, r5
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    a6f2:	str	r2, [r4, #20]
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    a6f4:	beq.w	a82c <FatFile::write(void const*, unsigned int)+0x1e4>
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    a6f8:	ldr	r0, [r4, #8]
  }
  //----------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
    a6fa:	ldrb	r3, [r0, #5]
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    a6fc:	ands.w	r5, r3, r2, lsr #9
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    a700:	ubfx	r9, r2, #0, #9
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    a704:	beq.n	a682 <FatFile::write(void const*, unsigned int)+0x3a>
        }
      }
    }
    // sector for data write
    uint32_t sector = m_vol->clusterStartSector(m_curCluster)
                      + sectorOfCluster;
    a706:	ldr	r3, [r4, #16]
    a708:	ldrb	r1, [r0, #6]
    a70a:	ldr	r2, [r0, #20]
    a70c:	subs	r3, #2
    a70e:	lsl.w	r1, r3, r1
    a712:	add	r1, r2
    a714:	add	r1, r5

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
    a716:	cmp.w	r9, #0
    a71a:	bne.n	a748 <FatFile::write(void const*, unsigned int)+0x100>
    a71c:	cmp.w	r6, #512	; 0x200
    a720:	bcs.n	a756 <FatFile::write(void const*, unsigned int)+0x10e>
      // lesser of space and amount to write
      if (n > nToWrite) {
        n = nToWrite;
      }

      if (sectorOffset == 0 &&
    a722:	ldr	r2, [r4, #20]
    a724:	ldr	r3, [r4, #28]
    a726:	cmp.w	r6, #512	; 0x200
    a72a:	mov	r5, r6
    a72c:	it	cs
    a72e:	movcs.w	r5, #512	; 0x200
    a732:	cmp	r2, r3
    a734:	bcc.n	a6c0 <FatFile::write(void const*, unsigned int)+0x78>
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    a736:	movs	r2, #5
    a738:	b.n	a6cc <FatFile::write(void const*, unsigned int)+0x84>
  }
  uint32_t clusterStartSector(uint32_t cluster) const {
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
    a73a:	ldr	r3, [r4, #16]
    a73c:	ldrb	r1, [r0, #6]
    a73e:	ldr	r2, [r0, #20]
    a740:	subs	r3, #2
    a742:	lsl.w	r1, r3, r1
    a746:	add	r1, r2
                      + sectorOfCluster;

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
      // partial sector - must use cache
      // max space in sector
      n = m_vol->bytesPerSector() - sectorOffset;
    a748:	rsb	r5, r9, #512	; 0x200
    a74c:	cmp	r5, r6
    a74e:	it	cs
    a750:	movcs	r5, r6
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    a752:	movs	r2, #1
    a754:	b.n	a6cc <FatFile::write(void const*, unsigned int)+0x84>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (nToWrite >= 2*m_vol->bytesPerSector()) {
    a756:	cmp.w	r6, #1024	; 0x400
    a75a:	bcc.n	a79a <FatFile::write(void const*, unsigned int)+0x152>
      // use multiple sector write command
      uint32_t maxSectors = m_vol->sectorsPerCluster() - sectorOfCluster;
    a75c:	ldrb	r3, [r0, #4]
    a75e:	ldr.w	lr, [r0, #48]	; 0x30
    a762:	subs	r3, r3, r5
      uint32_t nSector = nToWrite >> m_vol->bytesPerSectorShift();
    a764:	lsrs	r2, r6, #9
    a766:	cmp	r3, r2
    a768:	it	cs
    a76a:	movcs	r3, r2
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    a76c:	cmp	lr, r1
      if (nSector > maxSectors) {
        nSector = maxSectors;
      }
      n = nSector << m_vol->bytesPerSectorShift();
    a76e:	mov.w	r5, r3, lsl #9
    a772:	bcc.n	a788 <FatFile::write(void const*, unsigned int)+0x140>
    a774:	adds	r2, r3, r1
    a776:	cmp	lr, r2
    a778:	bcs.n	a788 <FatFile::write(void const*, unsigned int)+0x140>
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    a77a:	mov.w	lr, #0
    m_sector = 0XFFFFFFFF;
    a77e:	mov.w	r2, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    a782:	strb.w	lr, [r0, #36]	; 0x24
    m_sector = 0XFFFFFFFF;
    a786:	str	r2, [r0, #48]	; 0x30
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src, size_t count) {
     if (isCached(sector, count)) {
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
    a788:	ldr	r0, [r0, #40]	; 0x28
    a78a:	ldr	r2, [r0, #0]
    a78c:	ldr.w	r9, [r2, #32]
    a790:	mov	r2, r7
    a792:	blx	r9
      if (!m_vol->cacheSafeWrite(sector, src, nSector)) {
    a794:	cmp	r0, #0
    a796:	bne.n	a6ea <FatFile::write(void const*, unsigned int)+0xa2>
    a798:	b.n	a654 <FatFile::write(void const*, unsigned int)+0xc>
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
    a79a:	ldr	r3, [r0, #48]	; 0x30
    a79c:	cmp	r3, r1
    a79e:	beq.n	a7ec <FatFile::write(void const*, unsigned int)+0x1a4>
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    a7a0:	ldr	r0, [r0, #40]	; 0x28
    a7a2:	ldr	r3, [r0, #0]
    a7a4:	mov	r2, r7
    a7a6:	ldr	r3, [r3, #28]
    a7a8:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // use single sector write command
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeWrite(sector, src)) {
    a7aa:	cmp	r0, #0
    a7ac:	beq.w	a654 <FatFile::write(void const*, unsigned int)+0xc>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // use single sector write command
      n = m_vol->bytesPerSector();
    a7b0:	mov.w	r5, #512	; 0x200
    a7b4:	b.n	a6ea <FatFile::write(void const*, unsigned int)+0xa2>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      } else {
        if (m_firstCluster == 0) {
    a7b6:	ldr	r3, [r4, #32]
    a7b8:	cbz	r3, a818 <FatFile::write(void const*, unsigned int)+0x1d0>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
        } else {
          m_curCluster = m_firstCluster;
    a7ba:	str	r3, [r4, #16]
    a7bc:	ldrb	r1, [r0, #6]
    a7be:	ldr	r2, [r0, #20]
    a7c0:	subs	r3, #2
    a7c2:	lsl.w	r1, r3, r1
    a7c6:	add	r1, r2
    a7c8:	b.n	a71c <FatFile::write(void const*, unsigned int)+0xd4>
        int8_t fg;
        if (isContiguous() && m_fileSize > m_curPosition) {
          m_curCluster++;
          fg = 1;
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    a7ca:	add.w	r2, r4, #16
    a7ce:	bl	a860 <FatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    a7d2:	cmp	r0, #0
    a7d4:	blt.w	a654 <FatFile::write(void const*, unsigned int)+0xc>
        if (fg < 0) {
          DBG_FAIL_MACRO;
          goto fail;
        }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        if (fg == 0) {
    a7d8:	bne.n	a7e6 <FatFile::write(void const*, unsigned int)+0x19e>
          // add cluster if at end of chain
          if (!addCluster()) {
    a7da:	mov	r0, r4
    a7dc:	bl	9af0 <FatFile::addCluster()>
    a7e0:	cmp	r0, #0
    a7e2:	beq.w	a654 <FatFile::write(void const*, unsigned int)+0xc>
    a7e6:	ldr	r3, [r4, #16]
    a7e8:	ldr	r0, [r4, #8]
    a7ea:	b.n	a7bc <FatFile::write(void const*, unsigned int)+0x174>
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    a7ec:	movs	r2, #0
    m_sector = 0XFFFFFFFF;
    a7ee:	mov.w	r3, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    a7f2:	strb.w	r2, [r0, #36]	; 0x24
    m_sector = 0XFFFFFFFF;
    a7f6:	str	r3, [r0, #48]	; 0x30
    a7f8:	b.n	a7a0 <FatFile::write(void const*, unsigned int)+0x158>
  }
  void cacheInvalidate() {
    m_cache.invalidate();
  }
  bool cacheSyncData() {
    return m_cache.sync();
    a7fa:	ldr	r0, [r4, #8]
    a7fc:	adds	r0, #36	; 0x24
    a7fe:	bl	8248 <FsCache::sync()>
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
        // Force write if sector is full - improves large writes.
        if (!m_vol->cacheSyncData()) {
    a802:	cmp	r0, #0
    a804:	bne.w	a6ea <FatFile::write(void const*, unsigned int)+0xa2>
    a808:	b.n	a654 <FatFile::write(void const*, unsigned int)+0xc>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    if (!seekSet(m_fileSize)) {
    a80a:	ldr	r1, [r0, #28]
    a80c:	bl	a3bc <FatFile::seekSet(unsigned long)>
    a810:	cmp	r0, #0
    a812:	beq.w	a654 <FatFile::write(void const*, unsigned int)+0xc>
    a816:	b.n	a66e <FatFile::write(void const*, unsigned int)+0x26>
          }
        }
      } else {
        if (m_firstCluster == 0) {
          // allocate first cluster of file
          if (!addCluster()) {
    a818:	mov	r0, r4
    a81a:	bl	9af0 <FatFile::addCluster()>
    a81e:	cmp	r0, #0
    a820:	beq.w	a654 <FatFile::write(void const*, unsigned int)+0xc>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
    a824:	ldr	r3, [r4, #16]
    a826:	str	r3, [r4, #32]
    a828:	ldr	r0, [r4, #8]
    a82a:	b.n	a7bc <FatFile::write(void const*, unsigned int)+0x174>
    }
    m_curPosition += n;
    src += n;
    nToWrite -= n;
  }
  if (m_curPosition > m_fileSize) {
    a82c:	ldr	r3, [r4, #28]
    a82e:	cmp	r3, r2
    a830:	bcc.n	a846 <FatFile::write(void const*, unsigned int)+0x1fe>
    // update fileSize and insure sync will update dir entry
    m_fileSize = m_curPosition;
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    a832:	ldr	r3, [pc, #40]	; (a85c <FatFile::write(void const*, unsigned int)+0x214>)
    a834:	ldr	r3, [r3, #0]
    a836:	cbz	r3, a856 <FatFile::write(void const*, unsigned int)+0x20e>
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
    a838:	ldrb	r3, [r4, #2]
    a83a:	orn	r3, r3, #127	; 0x7f
    a83e:	strb	r3, [r4, #2]
    a840:	mov	r0, r8
    a842:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    nToWrite -= n;
  }
  if (m_curPosition > m_fileSize) {
    // update fileSize and insure sync will update dir entry
    m_fileSize = m_curPosition;
    m_flags |= FILE_FLAG_DIR_DIRTY;
    a846:	ldrb	r3, [r4, #2]
    src += n;
    nToWrite -= n;
  }
  if (m_curPosition > m_fileSize) {
    // update fileSize and insure sync will update dir entry
    m_fileSize = m_curPosition;
    a848:	str	r2, [r4, #28]
    m_flags |= FILE_FLAG_DIR_DIRTY;
    a84a:	orn	r3, r3, #127	; 0x7f
    a84e:	strb	r3, [r4, #2]
    a850:	mov	r0, r8
    a852:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    a856:	mov	r0, r8
    a858:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    a85c:	.word	0x1fff6188

0000a860 <FatPartition::fatGet(unsigned long, unsigned long*)>:
  uint32_t sector;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    a860:	cmp	r1, #1
    a862:	bls.n	a8c8 <FatPartition::fatGet(unsigned long, unsigned long*)+0x68>
    a864:	ldr	r3, [r0, #28]
    a866:	cmp	r1, r3
    a868:	bhi.n	a8c8 <FatPartition::fatGet(unsigned long, unsigned long*)+0x68>
 fail:
  return false;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry - return -1 error, 0 EOC, else 1.
int8_t FatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    a86a:	push	{r4, r5, r6, lr}
    a86c:	ldrb	r3, [r0, #7]
  if (cluster < 2 || cluster > m_lastCluster) {
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (fatType() == 32) {
    a86e:	cmp	r3, #32
    a870:	mov	r6, r2
    a872:	mov	r5, r0
    a874:	mov	r4, r1
    a876:	beq.n	a8aa <FatPartition::fatGet(unsigned long, unsigned long*)+0x4a>
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = getLe32(reinterpret_cast<uint8_t*>
                  (&pc->fat32[cluster & (m_sectorMask >> 2)]));
  } else if (fatType() == 16) {
    a878:	cmp	r3, #16
    a87a:	bne.n	a8a4 <FatPartition::fatGet(unsigned long, unsigned long*)+0x44>
  FsCache m_cache;
#if USE_SEPARATE_FAT_CACHE
  FsCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
    a87c:	ldr	r3, [r0, #24]
    a87e:	ubfx	r1, r1, #8, #8
    a882:	add	r1, r3
    a884:	movs	r2, #2
    a886:	add.w	r0, r0, #564	; 0x234
    a88a:	bl	81e8 <FsCache::get(unsigned long, unsigned char)>
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    a88e:	cbz	r0, a8a4 <FatPartition::fatGet(unsigned long, unsigned long*)+0x44>
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    a890:	uxtb	r1, r4
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = getLe16(reinterpret_cast<uint8_t*>
                  (&pc->fat16[cluster & (m_sectorMask >> 1)]));
    a892:	ldrh.w	r3, [r0, r1, lsl #1]
    next = cluster & 1 ? tmp >> 4 : tmp & 0XFFF;
  } else {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isEOC(next)) {
    a896:	ldr	r2, [r5, #28]
    a898:	cmp	r3, r2
    return 0;
  }
  *value = next;
  return 1;
    a89a:	itte	ls
    a89c:	movls	r0, #1
    goto fail;
  }
  if (isEOC(next)) {
    return 0;
  }
  *value = next;
    a89e:	strls	r3, [r6, #0]
  } else {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isEOC(next)) {
    return 0;
    a8a0:	movhi	r0, #0
  *value = next;
  return 1;

 fail:
  return -1;
}
    a8a2:	pop	{r4, r5, r6, pc}
  }
  *value = next;
  return 1;

 fail:
  return -1;
    a8a4:	mov.w	r0, #4294967295
    a8a8:	pop	{r4, r5, r6, pc}
    a8aa:	ldr	r1, [r0, #24]
    a8ac:	movs	r2, #2
    a8ae:	add.w	r1, r1, r4, lsr #7
    a8b2:	add.w	r0, r0, #564	; 0x234
    a8b6:	bl	81e8 <FsCache::get(unsigned long, unsigned char)>
  }

  if (fatType() == 32) {
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    a8ba:	cmp	r0, #0
    a8bc:	beq.n	a8a4 <FatPartition::fatGet(unsigned long, unsigned long*)+0x44>
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    a8be:	and.w	r1, r4, #127	; 0x7f
    a8c2:	ldr.w	r3, [r0, r1, lsl #2]
    a8c6:	b.n	a896 <FatPartition::fatGet(unsigned long, unsigned long*)+0x36>
  }
  *value = next;
  return 1;

 fail:
  return -1;
    a8c8:	mov.w	r0, #4294967295
}
    a8cc:	bx	lr
    a8ce:	nop

0000a8d0 <FatPartition::fatPut(unsigned long, unsigned long)>:
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    a8d0:	cmp	r1, #1
    a8d2:	bls.n	a910 <FatPartition::fatPut(unsigned long, unsigned long)+0x40>
 fail:
  return -1;
}
//------------------------------------------------------------------------------
// Store a FAT entry
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
    a8d4:	push	{r3, r4, r5, lr}
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    a8d6:	ldr	r3, [r0, #28]
    a8d8:	cmp	r1, r3
    a8da:	bhi.n	a8ea <FatPartition::fatPut(unsigned long, unsigned long)+0x1a>
    a8dc:	ldrb	r3, [r0, #7]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (fatType() == 32) {
    a8de:	cmp	r3, #32
    a8e0:	mov	r5, r2
    a8e2:	mov	r4, r1
    a8e4:	beq.n	a914 <FatPartition::fatPut(unsigned long, unsigned long)+0x44>
    setLe32(reinterpret_cast<uint8_t*>
           (&pc->fat32[cluster & (m_sectorMask >> 2)]), value);
    return true;
  }

  if (fatType() == 16) {
    a8e6:	cmp	r3, #16
    a8e8:	beq.n	a8ee <FatPartition::fatPut(unsigned long, unsigned long)+0x1e>
    DBG_FAIL_MACRO;
    goto fail;
  }

 fail:
  return false;
    a8ea:	movs	r0, #0
    a8ec:	pop	{r3, r4, r5, pc}
    a8ee:	ldr	r3, [r0, #24]
    a8f0:	ubfx	r1, r1, #8, #8
    a8f4:	add	r1, r3
    a8f6:	add.w	r0, r0, #564	; 0x234
    a8fa:	movs	r2, #3
    a8fc:	bl	81e8 <FsCache::get(unsigned long, unsigned char)>

  if (fatType() == 16) {
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    a900:	mov	r3, r0
    a902:	cmp	r0, #0
    a904:	beq.n	a8ea <FatPartition::fatPut(unsigned long, unsigned long)+0x1a>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    a906:	uxtb	r1, r4
      DBG_FAIL_MACRO;
      goto fail;
    }
    setLe16(reinterpret_cast<uint8_t*>
           (&pc->fat16[cluster & (m_sectorMask >> 1)]), value);
    return true;
    a908:	movs	r0, #1
    a90a:	strh.w	r5, [r3, r1, lsl #1]
    goto fail;
  }

 fail:
  return false;
}
    a90e:	pop	{r3, r4, r5, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }

 fail:
  return false;
    a910:	movs	r0, #0
}
    a912:	bx	lr
    a914:	ldr	r1, [r0, #24]
    a916:	movs	r2, #3
    a918:	add.w	r0, r0, #564	; 0x234
    a91c:	add.w	r1, r1, r4, lsr #7
    a920:	bl	81e8 <FsCache::get(unsigned long, unsigned char)>
  }

  if (fatType() == 32) {
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    a924:	mov	r3, r0
    a926:	cmp	r0, #0
    a928:	beq.n	a8ea <FatPartition::fatPut(unsigned long, unsigned long)+0x1a>
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    a92a:	and.w	r1, r4, #127	; 0x7f
      DBG_FAIL_MACRO;
      goto fail;
    }
    setLe32(reinterpret_cast<uint8_t*>
           (&pc->fat32[cluster & (m_sectorMask >> 2)]), value);
    return true;
    a92e:	movs	r0, #1
    a930:	str.w	r5, [r3, r1, lsl #2]
    a934:	pop	{r3, r4, r5, pc}
    a936:	nop

0000a938 <FatPartition::allocateCluster(unsigned long, unsigned long*)>:
#define DBG_FILE "FatPartition.cpp"
#include "../common/DebugMacros.h"
#include "../common/FsStructs.h"
#include "FatPartition.h"
//------------------------------------------------------------------------------
bool FatPartition::allocateCluster(uint32_t current, uint32_t* next) {
    a938:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t find;
  bool setStart;
  if (m_allocSearchStart < current) {
    a93c:	ldr	r4, [r0, #12]
    a93e:	cmp	r4, r1
#define DBG_FILE "FatPartition.cpp"
#include "../common/DebugMacros.h"
#include "../common/FsStructs.h"
#include "FatPartition.h"
//------------------------------------------------------------------------------
bool FatPartition::allocateCluster(uint32_t current, uint32_t* next) {
    a940:	sub	sp, #8
    a942:	mov	r5, r0
    a944:	mov	r7, r1
    a946:	mov	r8, r2
  uint32_t find;
  bool setStart;
  if (m_allocSearchStart < current) {
    a948:	itte	cc
    a94a:	movcc	r4, r1
    // Try to keep file contiguous. Start just after current cluster.
    find = current;
    setStart = false;
    a94c:	movcc	r6, #0
  } else {
    find = m_allocSearchStart;
    setStart = true;
    a94e:	movcs	r6, #1
    a950:	ldr	r3, [r5, #28]
  }
  while (1) {
    find++;
    a952:	adds	r4, #1
    if (find > m_lastCluster) {
    a954:	cmp	r4, r3
      // Can't find space, already searched clusters after current.
      DBG_FAIL_MACRO;
      goto fail;
    }
    uint32_t f;
    int8_t fg = fatGet(find, &f);
    a956:	add	r2, sp, #4
    a958:	mov	r0, r5
    a95a:	mov	r1, r4
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    if (find > m_lastCluster) {
    a95c:	bls.n	a972 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x3a>
      if (setStart) {
    a95e:	cbnz	r6, a9b0 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x78>
        // Can't find space, checked all clusters.
        DBG_FAIL_MACRO;
        goto fail;
      }
      find = m_allocSearchStart;
    a960:	ldr	r4, [r5, #12]
  } else {
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    a962:	adds	r4, #1
    if (find > m_lastCluster) {
    a964:	cmp	r4, r3
        // Can't find space, checked all clusters.
        DBG_FAIL_MACRO;
        goto fail;
      }
      find = m_allocSearchStart;
      setStart = true;
    a966:	mov.w	r6, #1
      // Can't find space, already searched clusters after current.
      DBG_FAIL_MACRO;
      goto fail;
    }
    uint32_t f;
    int8_t fg = fatGet(find, &f);
    a96a:	add	r2, sp, #4
    a96c:	mov	r0, r5
    a96e:	mov	r1, r4
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    if (find > m_lastCluster) {
    a970:	bhi.n	a95e <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x26>
      }
      find = m_allocSearchStart;
      setStart = true;
      continue;
    }
    if (find == current) {
    a972:	cmp	r7, r4
    a974:	beq.n	a9b0 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x78>
      // Can't find space, already searched clusters after current.
      DBG_FAIL_MACRO;
      goto fail;
    }
    uint32_t f;
    int8_t fg = fatGet(find, &f);
    a976:	bl	a860 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    a97a:	cmp	r0, #0
    a97c:	blt.n	a9b0 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x78>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg && f == 0) {
    a97e:	beq.n	a950 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x18>
    a980:	ldr	r3, [sp, #4]
    a982:	cmp	r3, #0
    a984:	bne.n	a950 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x18>
      break;
    }
  }
  if (setStart) {
    a986:	cbz	r6, a98a <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
    m_allocSearchStart = find;
    a988:	str	r4, [r5, #12]
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
  }
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
    a98a:	mvn.w	r2, #4026531840	; 0xf0000000
    a98e:	mov	r1, r4
    a990:	mov	r0, r5
    a992:	bl	a8d0 <FatPartition::fatPut(unsigned long, unsigned long)>
  }
  // Mark end of chain.
  if (!fatPutEOC(find)) {
    a996:	mov	r6, r0
    a998:	cbz	r0, a9b0 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x78>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (current) {
    a99a:	cbnz	r7, a9a2 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x6a>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  updateFreeClusterCount(-1);
  *next = find;
    a99c:	str.w	r4, [r8]
  return true;
    a9a0:	b.n	a9b2 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x7a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (current) {
    // Link clusters.
    if (!fatPut(current, find)) {
    a9a2:	mov	r1, r7
    a9a4:	mov	r0, r5
    a9a6:	mov	r2, r4
    a9a8:	bl	a8d0 <FatPartition::fatPut(unsigned long, unsigned long)>
    a9ac:	cmp	r0, #0
    a9ae:	bne.n	a99c <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x64>
  updateFreeClusterCount(-1);
  *next = find;
  return true;

 fail:
  return false;
    a9b0:	movs	r6, #0
}
    a9b2:	mov	r0, r6
    a9b4:	add	sp, #8
    a9b6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a9ba:	nop

0000a9bc <FatPartition::freeChain(unsigned long)>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
// free a cluster chain
bool FatPartition::freeChain(uint32_t cluster) {
    a9bc:	push	{r4, r5, r6, lr}
    a9be:	mov	r5, r0
    a9c0:	sub	sp, #8
    a9c2:	mov	r4, r1
    a9c4:	b.n	a9dc <FatPartition::freeChain(unsigned long)+0x20>
    if (fg < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // free cluster
    if (!fatPut(cluster, 0)) {
    a9c6:	bl	a8d0 <FatPartition::fatPut(unsigned long, unsigned long)>
    a9ca:	cbz	r0, a9f2 <FatPartition::freeChain(unsigned long)+0x36>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Add one to count of free clusters.
    updateFreeClusterCount(1);
    if (cluster < m_allocSearchStart) {
    a9cc:	ldr	r3, [r5, #12]
    a9ce:	cmp	r4, r3
      m_allocSearchStart = cluster - 1;
    a9d0:	itt	cc
    a9d2:	addcc.w	r4, r4, #4294967295
    a9d6:	strcc	r4, [r5, #12]
    }
    cluster = next;
    a9d8:	ldr	r4, [sp, #4]
//------------------------------------------------------------------------------
// free a cluster chain
bool FatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  int8_t fg;
  do {
    a9da:	cbz	r6, a9f4 <FatPartition::freeChain(unsigned long)+0x38>
    fg = fatGet(cluster, &next);
    a9dc:	add	r2, sp, #4
    a9de:	mov	r1, r4
    a9e0:	mov	r0, r5
    a9e2:	bl	a860 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    a9e6:	subs	r6, r0, #0
      DBG_FAIL_MACRO;
      goto fail;
    }
    // free cluster
    if (!fatPut(cluster, 0)) {
    a9e8:	mov	r1, r4
    a9ea:	mov.w	r2, #0
    a9ee:	mov	r0, r5
bool FatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  int8_t fg;
  do {
    fg = fatGet(cluster, &next);
    if (fg < 0) {
    a9f0:	bge.n	a9c6 <FatPartition::freeChain(unsigned long)+0xa>
  } while (fg);

  return true;

 fail:
  return false;
    a9f2:	movs	r0, #0
}
    a9f4:	add	sp, #8
    a9f6:	pop	{r4, r5, r6, pc}

0000a9f8 <FatPartition::freeClusterCount()>:
//------------------------------------------------------------------------------
int32_t FatPartition::freeClusterCount() {
    a9f8:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a9fc:	ldrb	r3, [r0, #7]
    return m_freeClusterCount;
  }
#endif  // MAINTAIN_FREE_CLUSTER_COUNT
  uint32_t free = 0;
  uint32_t sector;
  uint32_t todo = m_lastCluster + 1;
    a9fe:	ldr	r2, [r0, #28]
      }
      if (fg && c == 0) {
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    aa00:	cmp	r3, #16
    return m_freeClusterCount;
  }
#endif  // MAINTAIN_FREE_CLUSTER_COUNT
  uint32_t free = 0;
  uint32_t sector;
  uint32_t todo = m_lastCluster + 1;
    aa02:	add.w	r8, r2, #1
      }
      if (fg && c == 0) {
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    aa06:	beq.n	aa14 <FatPartition::freeClusterCount()+0x1c>
    aa08:	cmp	r3, #32
    aa0a:	beq.n	aa14 <FatPartition::freeClusterCount()+0x1c>
  }
  setFreeClusterCount(free);
  return free;

 fail:
  return -1;
    aa0c:	mov.w	r0, #4294967295
    aa10:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (fg && c == 0) {
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    sector = m_fatStartSector;
    aa14:	ldr	r5, [r0, #24]
    while (todo) {
    aa16:	cmp.w	r8, #0
    aa1a:	beq.n	aa9a <FatPartition::freeClusterCount()+0xa2>
    aa1c:	mov	r6, r0
    aa1e:	add.w	r7, r0, #564	; 0x234
    aa22:	movs	r4, #0
  FsCache m_cache;
#if USE_SEPARATE_FAT_CACHE
  FsCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
    aa24:	mov	r1, r5
    aa26:	movs	r2, #2
    aa28:	mov	r0, r7
      cache_t* pc = cacheFetchFat(sector++, FsCache::CACHE_FOR_READ);
    aa2a:	adds	r5, #1
    aa2c:	bl	81e8 <FsCache::get(unsigned long, unsigned char)>
      if (!pc) {
    aa30:	cmp	r0, #0
    aa32:	beq.n	aa0c <FatPartition::freeClusterCount()+0x14>
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
    aa34:	ldrb	r3, [r6, #7]
    aa36:	cmp	r3, #16
    aa38:	beq.n	aa68 <FatPartition::freeClusterCount()+0x70>
      if (todo < n) {
    aa3a:	cmp.w	r8, #127	; 0x7f
    aa3e:	bhi.n	aa92 <FatPartition::freeClusterCount()+0x9a>
        n = todo;
    aa40:	uxth.w	r1, r8
    aa44:	mov	lr, r8
    aa46:	subs	r1, #1
    aa48:	uxth	r1, r1
    aa4a:	add.w	r1, r0, r1, lsl #2
    aa4e:	subs	r3, r0, #4
            free++;
          }
        }
      } else {
        for (uint16_t i = 0; i < n; i++) {
          if (pc->fat32[i] == 0) {
    aa50:	ldr.w	r2, [r3, #4]!
    aa54:	cbnz	r2, aa58 <FatPartition::freeClusterCount()+0x60>
            free++;
    aa56:	adds	r4, #1
          if (pc->fat16[i] == 0) {
            free++;
          }
        }
      } else {
        for (uint16_t i = 0; i < n; i++) {
    aa58:	cmp	r3, r1
    aa5a:	bne.n	aa50 <FatPartition::freeClusterCount()+0x58>
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    sector = m_fatStartSector;
    while (todo) {
    aa5c:	subs.w	r8, r8, lr
    aa60:	bne.n	aa24 <FatPartition::freeClusterCount()+0x2c>
    aa62:	mov	r0, r4
    aa64:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
      if (todo < n) {
    aa68:	cmp.w	r8, #255	; 0xff
    aa6c:	bls.n	aaa0 <FatPartition::freeClusterCount()+0xa8>
    aa6e:	mov.w	lr, #256	; 0x100
      cache_t* pc = cacheFetchFat(sector++, FsCache::CACHE_FOR_READ);
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
    aa72:	mov	r3, lr
    aa74:	subs	r1, r3, #1
    aa76:	uxth	r1, r1
    aa78:	add.w	r1, r0, r1, lsl #1
    aa7c:	subs	r3, r0, #2
      if (todo < n) {
        n = todo;
      }
      if (fatType() == 16) {
        for (uint16_t i = 0; i < n; i++) {
          if (pc->fat16[i] == 0) {
    aa7e:	ldrh.w	r2, [r3, #2]!
    aa82:	cbnz	r2, aa86 <FatPartition::freeClusterCount()+0x8e>
            free++;
    aa84:	adds	r4, #1
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
      if (todo < n) {
        n = todo;
      }
      if (fatType() == 16) {
        for (uint16_t i = 0; i < n; i++) {
    aa86:	cmp	r1, r3
    aa88:	bne.n	aa7e <FatPartition::freeClusterCount()+0x86>
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    sector = m_fatStartSector;
    while (todo) {
    aa8a:	subs.w	r8, r8, lr
    aa8e:	bne.n	aa24 <FatPartition::freeClusterCount()+0x2c>
    aa90:	b.n	aa62 <FatPartition::freeClusterCount()+0x6a>
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
      if (todo < n) {
    aa92:	mov.w	lr, #128	; 0x80
      cache_t* pc = cacheFetchFat(sector++, FsCache::CACHE_FOR_READ);
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
    aa96:	mov	r1, lr
    aa98:	b.n	aa46 <FatPartition::freeClusterCount()+0x4e>
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    sector = m_fatStartSector;
    while (todo) {
    aa9a:	mov	r0, r8
    // invalid FAT type
    DBG_FAIL_MACRO;
    goto fail;
  }
  setFreeClusterCount(free);
  return free;
    aa9c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
      if (todo < n) {
        n = todo;
    aaa0:	uxth.w	r3, r8
    aaa4:	mov	lr, r8
    aaa6:	b.n	aa74 <FatPartition::freeClusterCount()+0x7c>

0000aaa8 <FatPartition::init(BlockDeviceInterface*, unsigned char)>:

 fail:
  return -1;
}
//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
    aaa8:	push	{r3, r4, r5, r6, r7, lr}
    aaaa:	mov	r4, r0
  m_blockDev = dev;
  pbs_t* pbs;
  BpbFat32_t* bpb;
  MbrSector_t* mbr;
  uint8_t tmp;
  m_fatType = 0;
    aaac:	movs	r3, #0
  m_allocSearchStart = 1;
    aaae:	movs	r5, #1
    aab0:	mov.w	r0, #4294967295
    aab4:	str	r5, [r4, #12]
//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
  uint32_t clusterCount;
  uint32_t totalSectors;
  uint32_t volumeStartSector = 0;
  m_blockDev = dev;
    aab6:	str	r1, [r4, #0]
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    aab8:	str	r1, [r4, #40]	; 0x28
    aaba:	str.w	r1, [r4, #568]	; 0x238
  pbs_t* pbs;
  BpbFat32_t* bpb;
  MbrSector_t* mbr;
  uint8_t tmp;
  m_fatType = 0;
    aabe:	strb	r3, [r4, #7]
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    aac0:	strb.w	r3, [r4, #36]	; 0x24
    aac4:	strb.w	r3, [r4, #564]	; 0x234
    m_sector = 0XFFFFFFFF;
    aac8:	str	r0, [r4, #48]	; 0x30
    aaca:	str.w	r0, [r4, #576]	; 0x240
#if USE_SEPARATE_FAT_CACHE
  m_fatCache.init(dev);
#endif  // USE_SEPARATE_FAT_CACHE
  // if part == 0 assume super floppy with FAT boot sector in sector zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
    aace:	mov	r5, r2
    aad0:	cbz	r2, ab0a <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x62>
    if (part > 4) {
    aad2:	cmp	r2, #4
    aad4:	bls.n	aada <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x32>
  m_fatCache.setMirrorOffset(m_sectorsPerFat);
#endif  // USE_SEPARATE_FAT_CACHE
  return true;

 fail:
  return false;
    aad6:	movs	r0, #0
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    aad8:	pop	{r3, r4, r5, r6, r7, pc}
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    aada:	add.w	r6, r4, #36	; 0x24
    aade:	mov	r2, r3
    aae0:	mov	r1, r3
    aae2:	mov	r0, r6
    aae4:	bl	81e8 <FsCache::get(unsigned long, unsigned char)>
      DBG_FAIL_MACRO;
      goto fail;
    }
    mbr = reinterpret_cast<MbrSector_t*>
          (cacheFetchData(0, FsCache::CACHE_FOR_READ));
    MbrPart_t* mp = mbr->part + part - 1;
    aae8:	add.w	r5, r5, #268435456	; 0x10000000
    aaec:	subs	r5, #1
    aaee:	lsls	r5, r5, #4
    aaf0:	add.w	r3, r0, #446	; 0x1be
    aaf4:	adds	r2, r3, r5

    if (!mbr || mp->type == 0 || (mp->boot != 0 && mp->boot != 0X80)) {
    aaf6:	cmp	r0, #0
    aaf8:	beq.n	aad6 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x2e>
    aafa:	ldrb	r1, [r2, #4]
    aafc:	cmp	r1, #0
    aafe:	beq.n	aad6 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x2e>
    ab00:	ldrb	r3, [r3, r5]
    ab02:	lsls	r3, r3, #25
    ab04:	bne.n	aad6 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x2e>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    ab06:	ldr	r5, [r2, #8]
    ab08:	b.n	ab0e <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x66>
    ab0a:	add.w	r6, r4, #36	; 0x24
    ab0e:	mov	r0, r6
    ab10:	movs	r2, #0
    ab12:	mov	r1, r5
    ab14:	bl	81e8 <FsCache::get(unsigned long, unsigned char)>
    volumeStartSector = getLe32(mp->relativeSectors);
  }
  pbs = reinterpret_cast<pbs_t*>
        (cacheFetchData(volumeStartSector, FsCache::CACHE_FOR_READ));
  bpb = reinterpret_cast<BpbFat32_t*>(pbs->bpb);
  if (!pbs || bpb->fatCount != 2 || getLe16(bpb->bytesPerSector) != 512) {
    ab18:	cmp	r0, #0
    ab1a:	beq.n	aad6 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x2e>
    ab1c:	ldrb	r3, [r0, #16]
    ab1e:	cmp	r3, #2
    ab20:	bne.n	aad6 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x2e>
    ab22:	ldrh.w	r3, [r0, #11]
    ab26:	cmp.w	r3, #512	; 0x200
    ab2a:	bne.n	aad6 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
    ab2c:	ldrb	r6, [r0, #13]
    ab2e:	strb	r6, [r4, #4]
  m_clusterSectorMask = m_sectorsPerCluster - 1;
    ab30:	subs	r3, r6, #1
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
    ab32:	movs	r2, #0
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    ab34:	cmp	r6, #1
  if (!pbs || bpb->fatCount != 2 || getLe16(bpb->bytesPerSector) != 512) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
  m_clusterSectorMask = m_sectorsPerCluster - 1;
    ab36:	strb	r3, [r4, #5]
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
    ab38:	strb	r2, [r4, #6]
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    ab3a:	beq.n	ab5c <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xb4>
    ab3c:	movs	r2, #1
    ab3e:	mov	r1, r2
    ab40:	b.n	ab44 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x9c>
    ab42:	mov	r2, r3
    ab44:	lsls	r1, r1, #1
    ab46:	uxtb	r1, r1
    ab48:	adds	r3, r2, #1
    ab4a:	cmp	r6, r1
    ab4c:	uxtb	r3, r3
    ab4e:	beq.n	ab5a <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xb2>
    if (tmp == 0) {
    ab50:	cmp	r3, #9
    ab52:	bne.n	ab42 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x9a>
    ab54:	strb	r2, [r4, #6]
  m_fatCache.setMirrorOffset(m_sectorsPerFat);
#endif  // USE_SEPARATE_FAT_CACHE
  return true;

 fail:
  return false;
    ab56:	movs	r0, #0
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    ab58:	pop	{r3, r4, r5, r6, r7, pc}
    ab5a:	strb	r2, [r4, #6]
      DBG_FAIL_MACRO;
      goto fail;
    }
    m_sectorsPerClusterShift++;
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
    ab5c:	ldrh	r6, [r0, #22]
    ab5e:	str	r6, [r4, #16]
  if (m_sectorsPerFat == 0) {
    ab60:	cbnz	r6, ab66 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xbe>
    ab62:	ldr	r6, [r0, #36]	; 0x24
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
    ab64:	str	r6, [r4, #16]
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    ab66:	ldrh	r1, [r0, #14]
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    ab68:	ldrh.w	r3, [r0, #17]

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);
    ab6c:	strh	r3, [r4, #8]
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
  if (m_sectorsPerFat == 0) {
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    ab6e:	add	r1, r5
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    ab70:	lsls	r3, r3, #5

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    ab72:	add.w	r7, r1, r6, lsl #1
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    ab76:	addw	r3, r3, #511	; 0x1ff
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
  if (m_sectorsPerFat == 0) {
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    ab7a:	str	r1, [r4, #24]
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    ((32 * m_rootDirEntryCount + m_bytesPerSector - 1)/m_bytesPerSector);

  // total sectors for FAT16 or FAT32
  totalSectors = getLe16(bpb->totalSectors16);
    ab7c:	ldrh.w	r1, [r0, #19]

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    ab80:	str	r7, [r4, #32]
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    ab82:	add.w	r3, r7, r3, asr #9
    ((32 * m_rootDirEntryCount + m_bytesPerSector - 1)/m_bytesPerSector);
    ab86:	str	r3, [r4, #20]

  // total sectors for FAT16 or FAT32
  totalSectors = getLe16(bpb->totalSectors16);
  if (totalSectors == 0) {
    ab88:	cbnz	r1, ab8c <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xe4>
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    ab8a:	ldr	r1, [r0, #32]
    totalSectors = getLe32(bpb->totalSectors32);
  }
  // total data sectors
  clusterCount = totalSectors - (m_dataStartSector - volumeStartSector);
    ab8c:	subs	r5, r5, r3
    ab8e:	add	r5, r1

  // divide by cluster size to get cluster count
  clusterCount >>= m_sectorsPerClusterShift;
    ab90:	lsr.w	r2, r5, r2
  m_lastCluster = clusterCount + 1;

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    ab94:	movw	r3, #4084	; 0xff4
  // total data sectors
  clusterCount = totalSectors - (m_dataStartSector - volumeStartSector);

  // divide by cluster size to get cluster count
  clusterCount >>= m_sectorsPerClusterShift;
  m_lastCluster = clusterCount + 1;
    ab98:	adds	r1, r2, #1

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    ab9a:	cmp	r2, r3
  // total data sectors
  clusterCount = totalSectors - (m_dataStartSector - volumeStartSector);

  // divide by cluster size to get cluster count
  clusterCount >>= m_sectorsPerClusterShift;
  m_lastCluster = clusterCount + 1;
    ab9c:	str	r1, [r4, #28]

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    ab9e:	bls.n	abbc <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x114>
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (clusterCount < 65525) {
    aba0:	movw	r3, #65524	; 0xfff4
    aba4:	cmp	r2, r3
    aba6:	ittet	hi
    aba8:	ldrhi	r3, [r0, #44]	; 0x2c
    m_fatType = 16;
  } else {
    m_rootDirStart = getLe32(bpb->fat32RootCluster);
    abaa:	strhi	r3, [r4, #32]
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (clusterCount < 65525) {
    m_fatType = 16;
    abac:	movls	r3, #16
  } else {
    m_rootDirStart = getLe32(bpb->fat32RootCluster);
    m_fatType = 32;
    abae:	movhi	r3, #32
    abb0:	strb	r3, [r4, #7]
  }
  /** Set the offset to the second FAT for mirroring.
   * \param[in] offset Sector offset to second FAT.
   */
  void setMirrorOffset(uint32_t offset) {
    m_mirrorOffset = offset;
    abb2:	str	r6, [r4, #44]	; 0x2c
    abb4:	str.w	r6, [r4, #572]	; 0x23c
  }
  m_cache.setMirrorOffset(m_sectorsPerFat);
#if USE_SEPARATE_FAT_CACHE
  m_fatCache.setMirrorOffset(m_sectorsPerFat);
#endif  // USE_SEPARATE_FAT_CACHE
  return true;
    abb8:	movs	r0, #1
    abba:	pop	{r3, r4, r5, r6, r7, pc}

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    m_fatType = 12;
    abbc:	movs	r3, #12
    abbe:	strb	r3, [r4, #7]
    abc0:	b.n	aad6 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x2e>
    abc2:	nop

0000abc4 <lfnGetChar(DirLfn_t*, unsigned char)>:
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \return The 16-bit character.
 */
static uint16_t lfnGetChar(DirLfn_t* ldir, uint8_t i) {
  if (i < 5) {
    abc4:	cmp	r1, #4
    abc6:	bls.n	abe2 <lfnGetChar(DirLfn_t*, unsigned char)+0x1e>
    return getLe16(ldir->unicode1 + 2*i);
  } else if (i < 11) {
    abc8:	cmp	r1, #10
    abca:	bls.n	abda <lfnGetChar(DirLfn_t*, unsigned char)+0x16>
    return getLe16(ldir->unicode2 + 2*i - 10);
  } else if (i < 13) {
    abcc:	cmp	r1, #12
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    abce:	itte	ls
    abd0:	addls.w	r1, r0, r1, lsl #1
    abd4:	ldrhls	r0, [r1, #6]
    return getLe16(ldir->unicode3 + 2*i - 22);
  }
  return 0;
    abd6:	movhi	r0, #0
}
    abd8:	bx	lr
    abda:	add.w	r1, r0, r1, lsl #1
    abde:	ldrh	r0, [r1, #4]
 */
static uint16_t lfnGetChar(DirLfn_t* ldir, uint8_t i) {
  if (i < 5) {
    return getLe16(ldir->unicode1 + 2*i);
  } else if (i < 11) {
    return getLe16(ldir->unicode2 + 2*i - 10);
    abe0:	bx	lr
    abe2:	add.w	r1, r0, r1, lsl #1
    abe6:	ldrh.w	r0, [r1, #1]
 * \param[in] i Index of character.
 * \return The 16-bit character.
 */
static uint16_t lfnGetChar(DirLfn_t* ldir, uint8_t i) {
  if (i < 5) {
    return getLe16(ldir->unicode1 + 2*i);
    abea:	bx	lr

0000abec <FatFile::lfnChecksum(unsigned char*)>:
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
    abec:	push	{r4}
    abee:	subs	r2, r0, #1
    abf0:	add.w	r4, r0, #10
  uint8_t sum = 0;
    abf4:	movs	r0, #0
  for (uint8_t i = 0; i < 11; i++) {
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    abf6:	ldrb.w	r1, [r2, #1]!
    abfa:	lsrs	r3, r0, #1
    abfc:	orr.w	r0, r3, r0, lsl #7
    ac00:	uxtab	r0, r1, r0
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    ac04:	cmp	r4, r2
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    ac06:	uxtb	r0, r0
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    ac08:	bne.n	abf6 <FatFile::lfnChecksum(unsigned char*)+0xa>
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
  }
  return sum;
}
    ac0a:	ldr.w	r4, [sp], #4
    ac0e:	bx	lr

0000ac10 <FatFile::openCluster(FatFile*)>:
 fail:
  name[0] = '\0';
  return 0;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
    ac10:	push	{r3, r4, r5, lr}
  if (file->m_dirCluster == 0) {
    ac12:	ldr	r3, [r1, #12]
    ac14:	cbz	r3, ac34 <FatFile::openCluster(FatFile*)+0x24>
    ac16:	mov	r5, r0
    ac18:	mov	r4, r1
    return openRoot(file->m_vol);
  }
  memset(this, 0, sizeof(FatFile));
    ac1a:	movs	r2, #36	; 0x24
    ac1c:	movs	r1, #0
    ac1e:	bl	1059c <memset>
  m_attributes = FILE_ATTR_SUBDIR;
    ac22:	movs	r3, #16
  m_flags = FILE_FLAG_READ;
    ac24:	movs	r0, #1
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
  }
  memset(this, 0, sizeof(FatFile));
  m_attributes = FILE_ATTR_SUBDIR;
    ac26:	strb	r3, [r5, #0]
  m_flags = FILE_FLAG_READ;
    ac28:	strb	r0, [r5, #2]
  m_vol = file->m_vol;
    ac2a:	ldr	r2, [r4, #8]
  m_firstCluster = file->m_dirCluster;
    ac2c:	ldr	r3, [r4, #12]
    ac2e:	str	r3, [r5, #32]
    return openRoot(file->m_vol);
  }
  memset(this, 0, sizeof(FatFile));
  m_attributes = FILE_ATTR_SUBDIR;
  m_flags = FILE_FLAG_READ;
  m_vol = file->m_vol;
    ac30:	str	r2, [r5, #8]
  m_firstCluster = file->m_dirCluster;
  return true;
}
    ac32:	pop	{r3, r4, r5, pc}
  return 0;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
    ac34:	ldr	r1, [r1, #8]
  m_attributes = FILE_ATTR_SUBDIR;
  m_flags = FILE_FLAG_READ;
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
    ac36:	ldmia.w	sp!, {r3, r4, r5, lr}
  return 0;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
    ac3a:	b.w	9f74 <FatFile::openRoot(FatVolume*)>
    ac3e:	nop

0000ac40 <FatFile::getName(char*, unsigned int)>:
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    lfnPutChar(ldir, i, c);
  }
}
//==============================================================================
size_t FatFile::getName(char* name, size_t size) {
    ac40:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ac44:	sub	sp, #52	; 0x34
  size_t n = 0;
  FatFile dirFile;
  DirLfn_t* ldir;
  if (!isOpen() || size < 13) {
    ac46:	ldrb	r3, [r0, #0]
    ac48:	movs	r4, #0
    ac4a:	strb.w	r4, [sp, #12]
    ac4e:	strb.w	r4, [sp, #13]
    ac52:	strb.w	r4, [sp, #14]
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    lfnPutChar(ldir, i, c);
  }
}
//==============================================================================
size_t FatFile::getName(char* name, size_t size) {
    ac56:	mov	r8, r1
  size_t n = 0;
  FatFile dirFile;
  DirLfn_t* ldir;
  if (!isOpen() || size < 13) {
    ac58:	cbz	r3, ac60 <FatFile::getName(char*, unsigned int)+0x20>
    ac5a:	cmp	r2, #12
    ac5c:	mov	r9, r2
    ac5e:	bhi.n	ac6c <FatFile::getName(char*, unsigned int)+0x2c>
  }
  // Fall into fail.
  DBG_FAIL_MACRO;

 fail:
  name[0] = '\0';
    ac60:	movs	r0, #0
    ac62:	strb.w	r0, [r8]
  return 0;
}
    ac66:	add	sp, #52	; 0x34
    ac68:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  DirLfn_t* ldir;
  if (!isOpen() || size < 13) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!isLFN()) {
    ac6c:	ldrb	r3, [r0, #3]
    ac6e:	mov	r7, r0
    ac70:	cmp	r3, #0
    ac72:	beq.n	ad1a <FatFile::getName(char*, unsigned int)+0xda>
    return getSFN(name);
  }
  if (!dirFile.openCluster(this)) {
    ac74:	add	r0, sp, #12
    ac76:	mov	r1, r7
    ac78:	bl	ac10 <FatFile::openCluster(FatFile*)>
    ac7c:	cmp	r0, #0
    ac7e:	beq.n	ac60 <FatFile::getName(char*, unsigned int)+0x20>
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    ac80:	ldrb	r3, [r7, #3]
    ac82:	cmp	r3, #0
    ac84:	beq.n	ac60 <FatFile::getName(char*, unsigned int)+0x20>
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    ac86:	str	r4, [sp, #4]
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    ac88:	movs	r6, #1
  uint8_t i;
  size_t k = 13*((ldir->order & 0X1F) - 1);
  // https://github.com/greiman/SdFat-beta/issues/67#issuecomment-774508283
  for (i = 0; i < 13; i++) {
    uint16_t c = lfnGetChar(ldir, i);
    if (c == 0 || k >= (n - 1)) {
    ac8a:	add.w	r5, r9, #4294967295
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
    ac8e:	ldrh	r1, [r7, #4]
    ac90:	subs	r1, r1, r6
    ac92:	lsls	r1, r1, #5
    ac94:	add	r0, sp, #12
    ac96:	bl	a3bc <FatFile::seekSet(unsigned long)>
    ac9a:	cmp	r0, #0
    ac9c:	beq.n	ac60 <FatFile::getName(char*, unsigned int)+0x20>
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    ac9e:	movs	r1, #0
    aca0:	add	r0, sp, #12
    aca2:	bl	a14c <FatFile::readDirCache(bool)>
    if (!ldir) {
    aca6:	mov	fp, r0
    aca8:	cmp	r0, #0
    acaa:	beq.n	ac60 <FatFile::getName(char*, unsigned int)+0x20>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME) {
    acac:	ldrb	r3, [r0, #11]
    acae:	cmp	r3, #15
    acb0:	bne.n	ac60 <FatFile::getName(char*, unsigned int)+0x20>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (order != (ldir->order & 0X1F)) {
    acb2:	ldrb	r3, [r0, #0]
    acb4:	and.w	r3, r3, #31
    acb8:	cmp	r6, r3
    acba:	bne.n	ac60 <FatFile::getName(char*, unsigned int)+0x20>
  return 0;
}
//------------------------------------------------------------------------------
static size_t lfnGetName(DirLfn_t* ldir, char* name, size_t n) {
  uint8_t i;
  size_t k = 13*((ldir->order & 0X1F) - 1);
    acbc:	subs	r3, r6, #1
    acbe:	add.w	r4, r3, r3, lsl #1
    acc2:	add.w	r4, r3, r4, lsl #2
    acc6:	mov	r3, r4
    acc8:	add.w	sl, r8, r4
    accc:	add.w	r2, r4, #13
  // https://github.com/greiman/SdFat-beta/issues/67#issuecomment-774508283
  for (i = 0; i < 13; i++) {
    uint16_t c = lfnGetChar(ldir, i);
    acd0:	subs	r1, r3, r4
    acd2:	uxtb	r1, r1
    acd4:	mov	r0, fp
    acd6:	bl	abc4 <lfnGetChar(DirLfn_t*, unsigned char)>
    if (c == 0 || k >= (n - 1)) {
    acda:	cbz	r0, ad24 <FatFile::getName(char*, unsigned int)+0xe4>
    acdc:	cmp	r5, r3
    acde:	bls.n	ad24 <FatFile::getName(char*, unsigned int)+0xe4>
     //       k = n - 1;   <<-------removed
      break;
    }
    name[k++] = c >= 0X7F ? '?' : c;
    ace0:	cmp	r0, #126	; 0x7e
    ace2:	add.w	r3, r3, #1
    ace6:	ite	ls
    ace8:	uxtbls	r0, r0
    acea:	movhi	r0, #63	; 0x3f
//------------------------------------------------------------------------------
static size_t lfnGetName(DirLfn_t* ldir, char* name, size_t n) {
  uint8_t i;
  size_t k = 13*((ldir->order & 0X1F) - 1);
  // https://github.com/greiman/SdFat-beta/issues/67#issuecomment-774508283
  for (i = 0; i < 13; i++) {
    acec:	cmp	r2, r3
    uint16_t c = lfnGetChar(ldir, i);
    if (c == 0 || k >= (n - 1)) {
     //       k = n - 1;   <<-------removed
      break;
    }
    name[k++] = c >= 0X7F ? '?' : c;
    acee:	strb.w	r0, [sl], #1
//------------------------------------------------------------------------------
static size_t lfnGetName(DirLfn_t* ldir, char* name, size_t n) {
  uint8_t i;
  size_t k = 13*((ldir->order & 0X1F) - 1);
  // https://github.com/greiman/SdFat-beta/issues/67#issuecomment-774508283
  for (i = 0; i < 13; i++) {
    acf2:	bne.n	acd0 <FatFile::getName(char*, unsigned int)+0x90>
    }
    name[k++] = c >= 0X7F ? '?' : c;
  }
  // Terminate with zero byte.
  if (k >= n) {  // <<----------added
    k = n - 1;   // <<--------- added
    acf4:	cmp	r9, r2
    acf6:	it	ls
    acf8:	movls	r2, r5
  }             // <<---------added
  name[k] = '\0';
    acfa:	ldrb.w	r3, [sp, #4]
    acfe:	strb.w	r3, [r8, r2]
    if (order != (ldir->order & 0X1F)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    n = lfnGetName(ldir, name, size);
    if (n == 0) {
    ad02:	cmp	r2, #0
    ad04:	beq.n	ac60 <FatFile::getName(char*, unsigned int)+0x20>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
    ad06:	ldrb.w	r3, [fp]
    ad0a:	lsls	r3, r3, #25
    ad0c:	bmi.n	ad28 <FatFile::getName(char*, unsigned int)+0xe8>
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    ad0e:	adds	r6, #1
    ad10:	ldrb	r3, [r7, #3]
    ad12:	uxtb	r6, r6
    ad14:	cmp	r3, r6
    ad16:	bcs.n	ac8e <FatFile::getName(char*, unsigned int)+0x4e>
    ad18:	b.n	ac60 <FatFile::getName(char*, unsigned int)+0x20>
  if (!isOpen() || size < 13) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!isLFN()) {
    return getSFN(name);
    ad1a:	bl	b4e8 <FatFile::getSFN(char*)>
  DBG_FAIL_MACRO;

 fail:
  name[0] = '\0';
  return 0;
}
    ad1e:	add	sp, #52	; 0x34
    ad20:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  uint8_t i;
  size_t k = 13*((ldir->order & 0X1F) - 1);
  // https://github.com/greiman/SdFat-beta/issues/67#issuecomment-774508283
  for (i = 0; i < 13; i++) {
    uint16_t c = lfnGetChar(ldir, i);
    if (c == 0 || k >= (n - 1)) {
    ad24:	mov	r2, r3
    ad26:	b.n	acf4 <FatFile::getName(char*, unsigned int)+0xb4>
    ad28:	mov	r0, r2
    ad2a:	b.n	ac66 <FatFile::getName(char*, unsigned int)+0x26>

0000ad2c <FatFile::parsePathName(char const*, fname_t*, char const**)>:
  m_firstCluster = file->m_dirCluster;
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::parsePathName(const char* path,
                            fname_t* fname, const char** ptr) {
    ad2c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int len = 0;
  int si;
  int dot;

  // Skip leading spaces.
  while (*path == ' ') {
    ad30:	ldrb	r3, [r0, #0]
    ad32:	cmp	r3, #32
    ad34:	bne.n	ad3e <FatFile::parsePathName(char const*, fname_t*, char const**)+0x12>
    ad36:	ldrb.w	r3, [r0, #1]!
    ad3a:	cmp	r3, #32
    ad3c:	beq.n	ad36 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xa>
    path++;
  }
  fname->lfn = path;
    ad3e:	str	r0, [r1, #8]

  for (len = 0; ; len++) {
    c = path[len];
    ad40:	ldrb	r3, [r0, #0]
    if (c == 0 || isDirSeparator(c)) {
    ad42:	cmp	r3, #0
    ad44:	beq.w	af56 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x22a>
    ad48:	cmp	r3, #47	; 0x2f
    ad4a:	beq.n	adac <FatFile::parsePathName(char const*, fname_t*, char const**)+0x80>
  name[k] = '\0';
  return k;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(uint8_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    ad4c:	cmp	r3, #92	; 0x5c
    ad4e:	beq.n	ad96 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
    ad50:	sub.w	r4, r3, #34	; 0x22
    ad54:	uxtb	r4, r4
    ad56:	cmp	r4, #29
    ad58:	bls.n	ad9c <FatFile::parsePathName(char const*, fname_t*, char const**)+0x70>
    ad5a:	ldr.w	lr, [pc, #536]	; af74 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x248>
    ad5e:	adds	r6, r0, #1
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    ad60:	movs	r4, #0
  return k;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(uint8_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
      c == ':' || c == '<' || c == '>' || c == '?' || c == '|') {
    ad62:	cmp	r3, #124	; 0x7c
  for (len = 0; ; len++) {
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
    ad64:	sub.w	r5, r3, #32
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    c = path[len];
    ad68:	mov	r7, r6
  return k;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(uint8_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
      c == ':' || c == '<' || c == '>' || c == '?' || c == '|') {
    ad6a:	beq.n	ad96 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
  for (len = 0; ; len++) {
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
    ad6c:	cmp	r5, #94	; 0x5e
    ad6e:	bhi.n	ad96 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    c = path[len];
    ad70:	ldrb.w	r3, [r6], #1
  name[k] = '\0';
  return k;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(uint8_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    ad74:	sub.w	r5, r3, #34	; 0x22
    ad78:	uxtb	r5, r5
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    ad7a:	adds	r4, #1
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
    ad7c:	cmp	r3, #0
    ad7e:	beq.w	af28 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1fc>
    ad82:	cmp	r3, #47	; 0x2f
    ad84:	beq.n	adae <FatFile::parsePathName(char const*, fname_t*, char const**)+0x82>
  name[k] = '\0';
  return k;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(uint8_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    ad86:	cmp	r3, #92	; 0x5c
    ad88:	lsr.w	r7, lr, r5
    ad8c:	beq.n	ad96 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
    ad8e:	cmp	r5, #29
    ad90:	bhi.n	ad62 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x36>
    ad92:	lsls	r7, r7, #31
    ad94:	bpl.n	ad62 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x36>
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;

 fail:
  return false;
    ad96:	movs	r0, #0
    ad98:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  name[k] = '\0';
  return k;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(uint8_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    ad9c:	ldr	r5, [pc, #468]	; (af74 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x248>)
    ad9e:	lsr.w	r4, r5, r4
    ada2:	lsls	r4, r4, #31
    ada4:	bpl.n	ad5a <FatFile::parsePathName(char const*, fname_t*, char const**)+0x2e>
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;

 fail:
  return false;
    ada6:	movs	r0, #0
    ada8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    adac:	movs	r4, #0
    adae:	adds	r7, r0, r4
    adb0:	mov	r6, r7
    adb2:	mov	r5, r4
    adb4:	movs	r3, #47	; 0x2f
    adb6:	b.n	adbe <FatFile::parsePathName(char const*, fname_t*, char const**)+0x92>
    adb8:	ldrb.w	r3, [r6, #1]!
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
    adbc:	adds	r5, #1
    adbe:	cmp	r3, #32
    adc0:	beq.n	adb8 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x8c>
    adc2:	cmp	r3, #47	; 0x2f
    adc4:	beq.n	adb8 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x8c>
  *ptr = &path[end];
    adc6:	add	r5, r0
    adc8:	str	r5, [r2, #0]

  // Back over spaces and dots.
  while (len) {
    adca:	cbz	r4, ade0 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xb4>
    adcc:	mov	r2, r7
    c = path[len - 1];
    adce:	ldrb.w	r3, [r2, #-1]!
    if (c != '.' && c != ' ') {
    add2:	cmp	r3, #46	; 0x2e
    add4:	beq.n	addc <FatFile::parsePathName(char const*, fname_t*, char const**)+0xb0>
    add6:	cmp	r3, #32
    add8:	bne.w	af2e <FatFile::parsePathName(char const*, fname_t*, char const**)+0x202>
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];

  // Back over spaces and dots.
  while (len) {
    addc:	subs	r4, #1
    adde:	bne.n	adce <FatFile::parsePathName(char const*, fname_t*, char const**)+0xa2>
    ade0:	mov.w	r5, #4294967295
    ade4:	mov	r3, r4
  // Max length of LFN is 255.
  if (len > 255) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  fname->len = len;
    ade6:	str	r3, [r1, #4]
    ade8:	add.w	r6, r1, #23
    adec:	add.w	r3, r1, #12
  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
    fname->sfn[k] = ' ';
    adf0:	movs	r2, #32
    adf2:	strb.w	r2, [r3, #1]!
    DBG_FAIL_MACRO;
    goto fail;
  }
  fname->len = len;
  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
    adf6:	cmp	r3, r6
    adf8:	bne.n	adf2 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xc6>
    adfa:	subs	r6, r0, #1
    adfc:	movs	r2, #0
    adfe:	b.n	ae02 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xd6>
    fname->sfn[k] = ' ';
  }
  // skip leading spaces and dots.
  for (si = 0; path[si] == '.' || path[si] == ' '; si++) {}
    ae00:	adds	r2, #1
    ae02:	ldrb.w	r3, [r6, #1]!
    ae06:	cmp	r3, #46	; 0x2e
    ae08:	beq.n	ae00 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xd4>
    ae0a:	cmp	r3, #32
    ae0c:	beq.n	ae00 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xd4>
  // Not 8.3 if leading dot or space.
  is83 = !si;
    ae0e:	clz	ip, r2

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
    ae12:	adds	r6, r5, #1
    fname->sfn[k] = ' ';
  }
  // skip leading spaces and dots.
  for (si = 0; path[si] == '.' || path[si] == ' '; si++) {}
  // Not 8.3 if leading dot or space.
  is83 = !si;
    ae14:	mov.w	ip, ip, lsr #5

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
    ae18:	beq.n	ae34 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x108>
    ae1a:	ldrb	r7, [r0, r5]
    ae1c:	cmp	r7, #46	; 0x2e
    ae1e:	add.w	r6, r0, r5
    ae22:	bne.n	ae2e <FatFile::parsePathName(char const*, fname_t*, char const**)+0x102>
    ae24:	b.n	ae34 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x108>
    ae26:	ldrb.w	r7, [r6, #-1]!
    ae2a:	cmp	r7, #46	; 0x2e
    ae2c:	beq.n	ae34 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x108>
    ae2e:	adds.w	r5, r5, #4294967295
    ae32:	bcs.n	ae26 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xfa>
  for (; si < len; si++) {
    ae34:	cmp	r2, r4
    ae36:	mov.w	r9, #0
    ae3a:	bge.w	af60 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x234>
    ae3e:	mov	r6, r9
    ae40:	mov	sl, r9
    ae42:	movs	r7, #7
    ae44:	mov.w	r8, #8
    ae48:	b.n	ae96 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x16a>
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
    ae4a:	cmp	r3, #46	; 0x2e
    ae4c:	beq.n	aede <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1b2>
  /** Check for a legal 8.3 character.
   * \param[in] c Character to be checked.
   * \return true for a legal 8.3 character.
   */
  static bool legal83Char(uint8_t c) {
    if (c == '"' || c == '|') {
    ae4e:	cmp	r3, #34	; 0x22
    ae50:	beq.n	ae6a <FatFile::parsePathName(char const*, fname_t*, char const**)+0x13e>
    ae52:	cmp	r3, #124	; 0x7c
    ae54:	beq.n	ae6a <FatFile::parsePathName(char const*, fname_t*, char const**)+0x13e>
      return false;
    }
    // *+,./
    if (0X2A <= c && c <= 0X2F && c != 0X2D) {
    ae56:	sub.w	lr, r3, #42	; 0x2a
    ae5a:	cmp.w	lr, #5
    ae5e:	bls.n	aef2 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1c6>
      return false;
    }
    // :;<=>?
    if (0X3A <= c && c <= 0X3F) {
    ae60:	sub.w	lr, r3, #58	; 0x3a
    ae64:	cmp.w	lr, #5
    ae68:	bhi.n	af1c <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1f0>
      is83 = false;
      continue;
    }
    if (!legal83Char(c) && si != dot) {
    ae6a:	cmp	r5, r2
    ae6c:	beq.n	aee2 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1b6>
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
    ae6e:	cmp	r7, r6
    ae70:	bcc.n	aec6 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x19a>
    if (c == ' ' || (c == '.' && dot != si)) {
      is83 = false;
      continue;
    }
    if (!legal83Char(c) && si != dot) {
      is83 = false;
    ae72:	mov.w	ip, #0
      c = '_';
    ae76:	movs	r3, #95	; 0x5f
        c += 'A' - 'a';
        lc |= bit;
      } else if ('A' <= c && c <= 'Z') {
        uc |= bit;
      }
      fname->sfn[i++] = c;
    ae78:	add.w	lr, r6, #1
    ae7c:	add.w	fp, r1, r6
    ae80:	uxtb.w	r6, lr
      if (i < 7) {
    ae84:	cmp	r6, #6
        c += 'A' - 'a';
        lc |= bit;
      } else if ('A' <= c && c <= 'Z') {
        uc |= bit;
      }
      fname->sfn[i++] = c;
    ae86:	strb.w	r3, [fp, #13]
      if (i < 7) {
    ae8a:	bhi.n	ae8e <FatFile::parsePathName(char const*, fname_t*, char const**)+0x162>
        fname->seqPos = i;
    ae8c:	strb	r6, [r1, #12]
  // Not 8.3 if leading dot or space.
  is83 = !si;

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    ae8e:	adds	r2, #1
    ae90:	cmp	r2, r4
    ae92:	bge.n	aea4 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x178>
    ae94:	ldrb	r3, [r0, r2]
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
    ae96:	cmp	r3, #32
    ae98:	bne.n	ae4a <FatFile::parsePathName(char const*, fname_t*, char const**)+0x11e>
  // Not 8.3 if leading dot or space.
  is83 = !si;

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    ae9a:	adds	r2, #1
    ae9c:	cmp	r2, r4
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
      is83 = false;
    ae9e:	mov.w	ip, #0
  // Not 8.3 if leading dot or space.
  is83 = !si;

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    aea2:	blt.n	ae94 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x168>
      if (i < 7) {
        fname->seqPos = i;
      }
    }
  }
  if (fname->sfn[0] == ' ') {
    aea4:	ldrb	r3, [r1, #13]
    aea6:	cmp	r3, #32
    aea8:	beq.w	ad96 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (is83) {
    aeac:	cmp.w	ip, #0
    aeb0:	beq.n	af42 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x216>
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
    aeb2:	tst.w	sl, r9
    aeb6:	it	ne
    aeb8:	movne.w	r9, #2
    aebc:	strb.w	r9, [r1]
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;
    aec0:	movs	r0, #1
    aec2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (!legal83Char(c) && si != dot) {
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
      if (in == 10) {
    aec6:	cmp	r7, #10
    aec8:	beq.n	af3a <FatFile::parsePathName(char const*, fname_t*, char const**)+0x20e>
      }
      if (si != dot) {
        is83 = false;
      }
      // Break if no dot and base-name is longer than eight characters.
      if (si > dot) {
    aeca:	cmp	r5, r2
    aecc:	blt.n	af3a <FatFile::parsePathName(char const*, fname_t*, char const**)+0x20e>
    aece:	mov	r2, r5
        break;
      }
      si = dot;
      in = 10;  // Max index for full 8.3 name.
    aed0:	movs	r7, #10
      i = 8;    // Place for extension.
    aed2:	movs	r6, #8
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    aed4:	mov.w	r8, #16
        // Done - extension longer than three characters.
        is83 = false;
        break;
      }
      if (si != dot) {
        is83 = false;
    aed8:	mov.w	ip, #0
    aedc:	b.n	ae8e <FatFile::parsePathName(char const*, fname_t*, char const**)+0x162>

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
    aede:	cmp	r5, r2
    aee0:	bne.n	ae9a <FatFile::parsePathName(char const*, fname_t*, char const**)+0x16e>
    if (!legal83Char(c) && si != dot) {
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
      if (in == 10) {
    aee2:	cmp	r7, #10
    aee4:	beq.n	af3a <FatFile::parsePathName(char const*, fname_t*, char const**)+0x20e>
    aee6:	mov	r2, r5
      // Break if no dot and base-name is longer than eight characters.
      if (si > dot) {
        break;
      }
      si = dot;
      in = 10;  // Max index for full 8.3 name.
    aee8:	movs	r7, #10
      i = 8;    // Place for extension.
    aeea:	movs	r6, #8
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    aeec:	mov.w	r8, #16
    aef0:	b.n	ae8e <FatFile::parsePathName(char const*, fname_t*, char const**)+0x162>
  static bool legal83Char(uint8_t c) {
    if (c == '"' || c == '|') {
      return false;
    }
    // *+,./
    if (0X2A <= c && c <= 0X2F && c != 0X2D) {
    aef2:	cmp	r3, #45	; 0x2d
    aef4:	bne.n	ae6a <FatFile::parsePathName(char const*, fname_t*, char const**)+0x13e>
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
      is83 = false;
      continue;
    }
    if (!legal83Char(c) && si != dot) {
    aef6:	sub.w	lr, r3, #33	; 0x21
    aefa:	cmp.w	lr, #93	; 0x5d
    aefe:	bhi.n	ae6a <FatFile::parsePathName(char const*, fname_t*, char const**)+0x13e>
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
    af00:	cmp	r5, r2
    af02:	beq.n	aee2 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1b6>
    af04:	cmp	r7, r6
    af06:	bcc.n	aec6 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x19a>
      si = dot;
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if ('a' <= c && c <= 'z') {
    af08:	sub.w	lr, r3, #97	; 0x61
    af0c:	cmp.w	lr, #25
    af10:	bhi.n	af64 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x238>
        c += 'A' - 'a';
    af12:	subs	r3, #32
    af14:	uxtb	r3, r3
        lc |= bit;
    af16:	orr.w	r9, r8, r9
    af1a:	b.n	ae78 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x14c>
    // :;<=>?
    if (0X3A <= c && c <= 0X3F) {
      return false;
    }
    // [\]
    if (0X5B <= c && c <= 0X5D) {
    af1c:	sub.w	lr, r3, #91	; 0x5b
    af20:	cmp.w	lr, #2
    af24:	bls.n	ae6a <FatFile::parsePathName(char const*, fname_t*, char const**)+0x13e>
    af26:	b.n	aef6 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1ca>
      goto fail;
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];
    af28:	str	r7, [r2, #0]
    af2a:	adds	r7, r0, r4
    af2c:	b.n	adcc <FatFile::parsePathName(char const*, fname_t*, char const**)+0xa0>
      break;
    }
    len--;
  }
  // Max length of LFN is 255.
  if (len > 255) {
    af2e:	cmp	r4, #255	; 0xff
    af30:	bgt.w	ad96 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
    af34:	subs	r5, r4, #1
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];

  // Back over spaces and dots.
  while (len) {
    c = path[len - 1];
    af36:	mov	r3, r4
    af38:	b.n	ade6 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xba>
      if (i < 7) {
        fname->seqPos = i;
      }
    }
  }
  if (fname->sfn[0] == ' ') {
    af3a:	ldrb	r3, [r1, #13]
    af3c:	cmp	r3, #32
    af3e:	beq.w	ad96 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>

  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    af42:	ldrb	r3, [r1, #12]
    af44:	add	r3, r1
  }

  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    af46:	movs	r0, #1
    fname->sfn[fname->seqPos] = '~';
    af48:	movs	r4, #126	; 0x7e
    fname->sfn[fname->seqPos + 1] = '1';
    af4a:	movs	r2, #49	; 0x31
  }

  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    af4c:	strb	r0, [r1, #0]
    fname->sfn[fname->seqPos] = '~';
    af4e:	strb	r4, [r3, #13]
    fname->sfn[fname->seqPos + 1] = '1';
    af50:	strb	r2, [r3, #14]
    af52:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      goto fail;
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];
    af56:	str	r0, [r2, #0]
    af58:	mov	r4, r3
    af5a:	mov.w	r5, #4294967295
    af5e:	b.n	ade6 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xba>
  // Not 8.3 if leading dot or space.
  is83 = !si;

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    af60:	mov	sl, r9
    af62:	b.n	aea4 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x178>
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if ('a' <= c && c <= 'z') {
        c += 'A' - 'a';
        lc |= bit;
      } else if ('A' <= c && c <= 'Z') {
    af64:	sub.w	lr, r3, #65	; 0x41
    af68:	cmp.w	lr, #25
        uc |= bit;
    af6c:	it	ls
    af6e:	orrls.w	sl, r8, sl
    af72:	b.n	ae78 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x14c>
    af74:	.word	0x35000101

0000af78 <FatFile::remove()>:

 fail:
  return 0;
}
//------------------------------------------------------------------------------
bool FatFile::remove() {
    af78:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  FatFile dirFile;
  DirFat_t* dir;
  DirLfn_t* ldir;

  // Cant' remove not open for write.
  if (!isWritable()) {
    af7c:	ldrb	r2, [r0, #2]

 fail:
  return 0;
}
//------------------------------------------------------------------------------
bool FatFile::remove() {
    af7e:	sub	sp, #40	; 0x28
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    af80:	movs	r3, #0
  FatFile dirFile;
  DirFat_t* dir;
  DirLfn_t* ldir;

  // Cant' remove not open for write.
  if (!isWritable()) {
    af82:	lsls	r2, r2, #30
    af84:	strb.w	r3, [sp, #4]
    af88:	strb.w	r3, [sp, #5]
    af8c:	strb.w	r3, [sp, #6]
    af90:	bpl.n	afd8 <FatFile::remove()+0x60>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster && !m_vol->freeChain(m_firstCluster)) {
    af92:	ldr	r1, [r0, #32]
    af94:	mov	r5, r0
    af96:	cbnz	r1, afe2 <FatFile::remove()+0x6a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Cache directory entry.
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    af98:	movs	r1, #1
    af9a:	mov	r0, r5
    af9c:	bl	9bbc <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    afa0:	cbz	r0, afd8 <FatFile::remove()+0x60>
    afa2:	subs	r1, r0, #1
    afa4:	add.w	r7, r0, #10
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
    afa8:	movs	r4, #0
  for (uint8_t i = 0; i < 11; i++) {
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    afaa:	lsrs	r2, r4, #1
    afac:	ldrb.w	r6, [r1, #1]!
    afb0:	orr.w	r3, r2, r4, lsl #7
    afb4:	uxtab	r3, r6, r3
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    afb8:	cmp	r7, r1
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    afba:	uxtb	r4, r3
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    afbc:	bne.n	afaa <FatFile::remove()+0x32>
    goto fail;
  }
  checksum = lfnChecksum(dir->name);

  // Mark entry deleted.
  dir->name[0] = FAT_NAME_DELETED;
    afbe:	mov.w	r8, #229	; 0xe5
    afc2:	strb.w	r8, [r0]
  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;

  // Write entry to device.
  if (!m_vol->cacheSync()) {
    afc6:	ldr	r6, [r5, #8]

  // Mark entry deleted.
  dir->name[0] = FAT_NAME_DELETED;

  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    afc8:	movs	r3, #0
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    afca:	add.w	r0, r6, #36	; 0x24
    afce:	strb	r3, [r5, #0]
  m_flags = 0;
    afd0:	strb	r3, [r5, #2]
    afd2:	bl	8248 <FsCache::sync()>
    afd6:	cbnz	r0, afee <FatFile::remove()+0x76>
  }
  // Fall into fail.
  DBG_FAIL_MACRO;

 fail:
  return false;
    afd8:	movs	r6, #0
}
    afda:	mov	r0, r6
    afdc:	add	sp, #40	; 0x28
    afde:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster && !m_vol->freeChain(m_firstCluster)) {
    afe2:	ldr	r0, [r0, #8]
    afe4:	bl	a9bc <FatPartition::freeChain(unsigned long)>
    afe8:	cmp	r0, #0
    afea:	bne.n	af98 <FatFile::remove()+0x20>
    afec:	b.n	afd8 <FatFile::remove()+0x60>
    afee:	add.w	r0, r6, #564	; 0x234
    aff2:	bl	8248 <FsCache::sync()>
    aff6:	cmp	r0, #0
    aff8:	beq.n	afd8 <FatFile::remove()+0x60>
    affa:	ldr	r0, [r6, #0]
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    affc:	ldr	r3, [r0, #0]
    affe:	ldr	r3, [r3, #24]
    b000:	blx	r3
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    b002:	mov	r6, r0
    b004:	cmp	r0, #0
    b006:	beq.n	afd8 <FatFile::remove()+0x60>
  // Write entry to device.
  if (!m_vol->cacheSync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!isLFN()) {
    b008:	ldrb	r3, [r5, #3]
    b00a:	cmp	r3, #0
    b00c:	beq.n	afda <FatFile::remove()+0x62>
    // Done, no LFN entries.
    return true;
  }
  if (!dirFile.openCluster(this)) {
    b00e:	add	r0, sp, #4
    b010:	mov	r1, r5
    b012:	bl	ac10 <FatFile::openCluster(FatFile*)>
    b016:	cmp	r0, #0
    b018:	beq.n	afd8 <FatFile::remove()+0x60>
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    b01a:	ldrb	r3, [r5, #3]
    b01c:	cmp	r3, #0
    b01e:	beq.n	afd8 <FatFile::remove()+0x60>
    b020:	movs	r7, #1
    b022:	b.n	b064 <FatFile::remove()+0xec>
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    b024:	add	r0, sp, #4
    b026:	bl	a14c <FatFile::readDirCache(bool)>
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    b02a:	adds	r3, r7, #1
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    if (!ldir) {
    b02c:	cmp	r0, #0
    b02e:	beq.n	afd8 <FatFile::remove()+0x60>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    b030:	ldrb	r2, [r0, #11]
    b032:	cmp	r2, #15
    b034:	bne.n	afd8 <FatFile::remove()+0x60>
        order != (ldir->order & 0X1F) ||
    b036:	ldrb	r2, [r0, #0]
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    b038:	and.w	r1, r2, #31
    b03c:	cmp	r7, r1
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    b03e:	uxtb	r7, r3
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    b040:	bne.n	afd8 <FatFile::remove()+0x60>
        order != (ldir->order & 0X1F) ||
    b042:	ldrb	r3, [r0, #13]
    b044:	cmp	r3, r4
    b046:	bne.n	afd8 <FatFile::remove()+0x60>
        checksum != ldir->checksum) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    last = ldir->order & FAT_ORDER_LAST_LONG_ENTRY;
    ldir->order = FAT_NAME_DELETED;
    b048:	strb.w	r8, [r0]
    m_vol->cacheDirty();
    b04c:	ldr	r1, [r5, #8]
    invalidate();
    return m_buffer;
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    b04e:	ldrb.w	r3, [r1, #36]	; 0x24
    b052:	orr.w	r3, r3, #1
    b056:	strb.w	r3, [r1, #36]	; 0x24
    if (last) {
    b05a:	lsls	r3, r2, #25
    b05c:	bmi.n	b078 <FatFile::remove()+0x100>
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    b05e:	ldrb	r3, [r5, #3]
    b060:	cmp	r3, r7
    b062:	bcc.n	afd8 <FatFile::remove()+0x60>
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
    b064:	ldrh	r1, [r5, #4]
    b066:	subs	r1, r1, r7
    b068:	lsls	r1, r1, #5
    b06a:	add	r0, sp, #4
    b06c:	bl	a3bc <FatFile::seekSet(unsigned long)>
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    b070:	movs	r1, #0
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
    b072:	cmp	r0, #0
    b074:	bne.n	b024 <FatFile::remove()+0xac>
    b076:	b.n	afd8 <FatFile::remove()+0x60>
    }
    last = ldir->order & FAT_ORDER_LAST_LONG_ENTRY;
    ldir->order = FAT_NAME_DELETED;
    m_vol->cacheDirty();
    if (last) {
      if (!m_vol->cacheSync()) {
    b078:	ldr	r4, [r5, #8]
    b07a:	add.w	r0, r4, #36	; 0x24
    b07e:	bl	8248 <FsCache::sync()>
    b082:	cmp	r0, #0
    b084:	beq.n	afd8 <FatFile::remove()+0x60>
    b086:	add.w	r0, r4, #564	; 0x234
    b08a:	bl	8248 <FsCache::sync()>
    b08e:	cmp	r0, #0
    b090:	beq.n	afd8 <FatFile::remove()+0x60>
    b092:	ldr	r0, [r4, #0]
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    b094:	ldr	r3, [r0, #0]
    b096:	ldr	r3, [r3, #24]
    b098:	blx	r3
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    b09a:	cmp	r0, #0
    b09c:	beq.n	afd8 <FatFile::remove()+0x60>
    b09e:	b.n	afda <FatFile::remove()+0x62>

0000b0a0 <FatFile::lfnUniqueSfn(fname_t*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::lfnUniqueSfn(fname_t* fname) {
    b0a0:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;;
    b0a4:	ldrb	r7, [r1, #12]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::lfnUniqueSfn(fname_t* fname) {
    b0a6:	mov	r6, r1
    b0a8:	mov	r4, r0
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    b0aa:	add.w	r5, r1, #13
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::lfnUniqueSfn(fname_t* fname) {
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;;
    b0ae:	mov.w	r8, #2
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
        hex >>= 4;
      }
    }
    fname->sfn[pos] = '~';
    b0b2:	mov.w	r9, #126	; 0x7e
  for (uint8_t seq = 2; seq < 100; seq++) {
    if (seq < FIRST_HASH_SEQ) {
      fname->sfn[pos + 1] = '0' + seq;
    } else {
      DBG_PRINT_IF(seq > FIRST_HASH_SEQ);
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
    b0b6:	ldr	r0, [r6, #4]
    b0b8:	ldr	r1, [r6, #8]
    b0ba:	add.w	r3, r8, r0
    b0be:	uxth	r3, r3
}
//------------------------------------------------------------------------------
// Daniel Bernstein University of Illinois at Chicago.
// Original had + instead of ^
static uint16_t Bernstein(uint16_t hash, const char *str, size_t len) {
  for (size_t i = 0; i < len; i++) {
    b0c0:	cbz	r0, b0d4 <FatFile::lfnUniqueSfn(fname_t*)+0x34>
    b0c2:	add	r0, r1
    // hash = hash * 33 ^ str[i];
    hash = ((hash << 5) + hash) ^ str[i];
    b0c4:	ldrb.w	r2, [r1], #1
    b0c8:	add.w	r3, r3, r3, lsl #5
    b0cc:	eors	r3, r2
}
//------------------------------------------------------------------------------
// Daniel Bernstein University of Illinois at Chicago.
// Original had + instead of ^
static uint16_t Bernstein(uint16_t hash, const char *str, size_t len) {
  for (size_t i = 0; i < len; i++) {
    b0ce:	cmp	r0, r1
    // hash = hash * 33 ^ str[i];
    hash = ((hash << 5) + hash) ^ str[i];
    b0d0:	uxth	r3, r3
}
//------------------------------------------------------------------------------
// Daniel Bernstein University of Illinois at Chicago.
// Original had + instead of ^
static uint16_t Bernstein(uint16_t hash, const char *str, size_t len) {
  for (size_t i = 0; i < len; i++) {
    b0d2:	bne.n	b0c4 <FatFile::lfnUniqueSfn(fname_t*)+0x24>
    b0d4:	cmp	r7, #3
    b0d6:	it	cs
    b0d8:	movcs	r7, #3
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    b0da:	adds	r2, r7, #4
    b0dc:	uxtb	r2, r2
        uint8_t h = hex & 0XF;
    b0de:	and.w	r1, r3, #15
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    b0e2:	adds	r0, r6, r2
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    b0e4:	subs	r2, #1
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    b0e6:	cmp	r1, #9
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    b0e8:	uxtb	r2, r2
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    b0ea:	ite	ls
    b0ec:	addls	r1, #48	; 0x30
    b0ee:	addhi	r1, #55	; 0x37
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    b0f0:	cmp	r7, r2
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
        hex >>= 4;
    b0f2:	mov.w	r3, r3, lsr #4
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    b0f6:	strb	r1, [r0, #13]
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    b0f8:	bcc.n	b0de <FatFile::lfnUniqueSfn(fname_t*)+0x3e>
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
        hex >>= 4;
      }
    }
    fname->sfn[pos] = '~';
    b0fa:	adds	r3, r6, r7
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    b0fc:	movs	r1, #0
    b0fe:	strb.w	r9, [r3, #13]
    b102:	mov	r0, r4
    b104:	bl	a3bc <FatFile::seekSet(unsigned long)>
    rewind();
    while (1) {
      dir = readDirCache(true);
    b108:	movs	r1, #1
    b10a:	mov	r0, r4
    b10c:	bl	a14c <FatFile::readDirCache(bool)>
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    b110:	movs	r2, #11
    }
    fname->sfn[pos] = '~';
    rewind();
    while (1) {
      dir = readDirCache(true);
      if (!dir) {
    b112:	mov	r3, r0
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    b114:	mov	r1, r0
    }
    fname->sfn[pos] = '~';
    rewind();
    while (1) {
      dir = readDirCache(true);
      if (!dir) {
    b116:	cbz	r0, b144 <FatFile::lfnUniqueSfn(fname_t*)+0xa4>
          goto done;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    b118:	ldrb.w	lr, [r3]
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    b11c:	mov	r0, r5
          goto done;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    b11e:	cmp.w	lr, #0
    b122:	beq.n	b150 <FatFile::lfnUniqueSfn(fname_t*)+0xb0>
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    b124:	ldrb	r3, [r3, #11]
    b126:	lsls	r3, r3, #28
    b128:	bmi.n	b108 <FatFile::lfnUniqueSfn(fname_t*)+0x68>
    b12a:	bl	10470 <memcmp>
    b12e:	cmp	r0, #0
    b130:	bne.n	b108 <FatFile::lfnUniqueSfn(fname_t*)+0x68>
    b132:	add.w	r8, r8, #1
    b136:	uxth.w	r8, r8
  uint16_t hex;

  DBG_HALT_IF(!(fname->flags & FNAME_FLAG_LOST_CHARS));
  DBG_HALT_IF(fname->sfn[pos] != '~' && fname->sfn[pos + 1] != '1');

  for (uint8_t seq = 2; seq < 100; seq++) {
    b13a:	cmp.w	r8, #100	; 0x64
    b13e:	bne.n	b0b6 <FatFile::lfnUniqueSfn(fname_t*)+0x16>
 fail:
  return false;

 done:
  return true;
}
    b140:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    fname->sfn[pos] = '~';
    rewind();
    while (1) {
      dir = readDirCache(true);
      if (!dir) {
        if (!getError()) {
    b144:	ldrb	r0, [r4, #1]
    b146:	clz	r0, r0
    b14a:	lsrs	r0, r0, #5
    b14c:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

 fail:
  return false;

 done:
  return true;
    b150:	movs	r0, #1
    b152:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    b156:	nop

0000b158 <FatFile::open(FatFile*, fname_t*, int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
    b158:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;
  size_t len = fname->len;

  if (!dirFile->isDir() || isOpen()) {
    b15c:	ldrb	r4, [r1, #0]
    b15e:	tst.w	r4, #112	; 0x70

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
    b162:	sub	sp, #52	; 0x34
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;
  size_t len = fname->len;

  if (!dirFile->isDir() || isOpen()) {
    b164:	beq.n	b16a <FatFile::open(FatFile*, fname_t*, int)+0x12>
    b166:	ldrb	r4, [r0, #0]
    b168:	cbz	r4, b172 <FatFile::open(FatFile*, fname_t*, int)+0x1a>
    goto fail;
  }
  return true;

 fail:
  return false;
    b16a:	movs	r0, #0
}
    b16c:	add	sp, #52	; 0x34
    b16e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (!dirFile->isDir() || isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;
    b172:	ldrb	r4, [r2, #0]
  uint16_t curIndex;
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;
  size_t len = fname->len;
    b174:	ldr.w	sl, [r2, #4]
  if (!dirFile->isDir() || isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;
    b178:	lsls	r4, r4, #30
    b17a:	bne.n	b202 <FatFile::open(FatFile*, fname_t*, int)+0xaa>
    b17c:	mov.w	r8, #1
    b180:	mov	r6, r1
    b182:	mov	fp, r2
    b184:	str	r0, [sp, #36]	; 0x24
    b186:	movs	r1, #0
    b188:	mov	r0, r6
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
  uint8_t checksum = 0;
  uint8_t ms10;
  uint16_t freeIndex = 0;
    b18a:	mov	r7, r1
    b18c:	str	r3, [sp, #28]
    b18e:	bl	a3bc <FatFile::seekSet(unsigned long)>
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    b192:	add.w	r3, fp, #13
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
  uint8_t checksum = 0;
    b196:	str	r7, [sp, #24]
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
    b198:	str	r7, [sp, #12]
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
    b19a:	mov	r4, r7
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
    b19c:	mov	r9, r7
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
  bool fnameFound = false;
    b19e:	str	r7, [sp, #20]
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    b1a0:	str	r3, [sp, #16]
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;

  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    dir = dirFile->readDirCache(true);
    b1a2:	movs	r1, #1
    b1a4:	mov	r0, r6
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;

  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    b1a6:	ldr	r5, [r6, #20]
    dir = dirFile->readDirCache(true);
    b1a8:	bl	a14c <FatFile::readDirCache(bool)>
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;

  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    b1ac:	ubfx	r5, r5, #5, #16
    dir = dirFile->readDirCache(true);
    if (!dir) {
    b1b0:	mov	r3, r0
    b1b2:	cmp	r0, #0
    b1b4:	beq.w	b2d0 <FatFile::open(FatFile*, fname_t*, int)+0x178>
        goto fail;
      }
      // At EOF
      goto create;
    }
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == FAT_NAME_FREE) {
    b1b8:	ldrb	r2, [r0, #0]
    b1ba:	cmp	r2, #229	; 0xe5
    b1bc:	beq.n	b234 <FatFile::open(FatFile*, fname_t*, int)+0xdc>
    b1be:	cmp	r2, #0
    b1c0:	beq.n	b234 <FatFile::open(FatFile*, fname_t*, int)+0xdc>
      if (dir->name[0] == FAT_NAME_FREE) {
        goto create;
      }
    } else {
      if (freeFound < freeNeed) {
        freeFound = 0;
    b1c2:	cmp	r4, r8
    b1c4:	it	cc
    b1c6:	movcc	r4, #0
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    b1c8:	cmp	r2, #46	; 0x2e
    b1ca:	beq.n	b22e <FatFile::open(FatFile*, fname_t*, int)+0xd6>
    b1cc:	ldrb	r1, [r3, #11]
      lfnOrd = 0;
    } else if (isLongName(dir)) {
    b1ce:	cmp	r1, #15
    b1d0:	beq.n	b250 <FatFile::open(FatFile*, fname_t*, int)+0xf8>
          // Not found.
          lfnOrd = 0;
          break;
        }
      }
    } else if (isFileOrSubdir(dir)) {
    b1d2:	and.w	r1, r1, #8
    b1d6:	and.w	r2, r1, #255	; 0xff
    b1da:	cbnz	r1, b22e <FatFile::open(FatFile*, fname_t*, int)+0xd6>
      if (lfnOrd) {
    b1dc:	cmp.w	r9, #0
    b1e0:	bne.w	b4a4 <FatFile::open(FatFile*, fname_t*, int)+0x34c>
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    b1e4:	mov	r0, r3
    b1e6:	movs	r2, #11
    b1e8:	ldr	r1, [sp, #16]
    b1ea:	bl	10470 <memcmp>
    b1ee:	cmp	r0, #0
    b1f0:	bne.n	b1a2 <FatFile::open(FatFile*, fname_t*, int)+0x4a>
        if (!(fname->flags & FNAME_FLAG_LOST_CHARS)) {
    b1f2:	ldrb.w	r3, [fp]
    b1f6:	lsls	r0, r3, #31
    b1f8:	bpl.w	b4cc <FatFile::open(FatFile*, fname_t*, int)+0x374>
          goto found;
        }
        fnameFound = true;
    b1fc:	movs	r3, #1
    b1fe:	str	r3, [sp, #20]
    b200:	b.n	b1a2 <FatFile::open(FatFile*, fname_t*, int)+0x4a>
  if (!dirFile->isDir() || isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;
    b202:	ldr	r5, [pc, #732]	; (b4e0 <FatFile::open(FatFile*, fname_t*, int)+0x388>)
    b204:	add.w	r4, sl, #12
    b208:	umull	r4, r8, r5, r4
    b20c:	mov.w	r8, r8, lsr #2
    b210:	add.w	r8, r8, #1
    b214:	uxtb.w	r8, r8
    b218:	b.n	b180 <FatFile::open(FatFile*, fname_t*, int)+0x28>
        if ((ldir->order & FAT_ORDER_LAST_LONG_ENTRY) == 0) {
          continue;
        }
        lfnOrd = order = ldir->order & 0X1F;
        checksum = ldir->checksum;
      } else if (ldir->order != --order || checksum != ldir->checksum) {
    b21a:	ldr	r1, [sp, #12]
    b21c:	subs	r1, #1
    b21e:	uxtb	r1, r1
    b220:	cmp	r2, r1
    b222:	str	r1, [sp, #12]
    b224:	bne.n	b22e <FatFile::open(FatFile*, fname_t*, int)+0xd6>
    b226:	ldrb	r2, [r3, #13]
    b228:	ldr	r1, [sp, #24]
    b22a:	cmp	r1, r2
    b22c:	beq.n	b266 <FatFile::open(FatFile*, fname_t*, int)+0x10e>
          goto found;
        }
        fnameFound = true;
      }
    } else {
      lfnOrd = 0;
    b22e:	mov.w	r9, #0
    b232:	b.n	b1a2 <FatFile::open(FatFile*, fname_t*, int)+0x4a>
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;

  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    b234:	cmp	r4, #0
    b236:	it	eq
    b238:	moveq	r7, r5
    }
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == FAT_NAME_FREE) {
      if (freeFound == 0) {
        freeIndex = curIndex;
      }
      if (freeFound < freeNeed) {
    b23a:	cmp	r4, r8
        freeFound++;
    b23c:	itt	cc
    b23e:	addcc	r4, #1
    b240:	uxtbcc	r4, r4
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    b242:	cmp	r2, #0
    b244:	beq.n	b2d8 <FatFile::open(FatFile*, fname_t*, int)+0x180>
      if (freeFound < freeNeed) {
        freeFound = 0;
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    b246:	cmp	r2, #229	; 0xe5
    b248:	bne.n	b1c8 <FatFile::open(FatFile*, fname_t*, int)+0x70>
          goto found;
        }
        fnameFound = true;
      }
    } else {
      lfnOrd = 0;
    b24a:	mov.w	r9, #0
    b24e:	b.n	b1a2 <FatFile::open(FatFile*, fname_t*, int)+0x4a>
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
      lfnOrd = 0;
    } else if (isLongName(dir)) {
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (!lfnOrd) {
    b250:	cmp.w	r9, #0
    b254:	bne.n	b21a <FatFile::open(FatFile*, fname_t*, int)+0xc2>
        if ((ldir->order & FAT_ORDER_LAST_LONG_ENTRY) == 0) {
    b256:	lsls	r5, r2, #25
    b258:	bpl.n	b1a2 <FatFile::open(FatFile*, fname_t*, int)+0x4a>
          continue;
        }
        lfnOrd = order = ldir->order & 0X1F;
    b25a:	and.w	r9, r2, #31
        checksum = ldir->checksum;
    b25e:	ldrb	r2, [r3, #13]
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (!lfnOrd) {
        if ((ldir->order & FAT_ORDER_LAST_LONG_ENTRY) == 0) {
          continue;
        }
        lfnOrd = order = ldir->order & 0X1F;
    b260:	str.w	r9, [sp, #12]
        checksum = ldir->checksum;
    b264:	str	r2, [sp, #24]
      } else if (ldir->order != --order || checksum != ldir->checksum) {
        lfnOrd = 0;
        continue;
      }
      size_t k = 13*(order - 1);
    b266:	ldr	r2, [sp, #12]
    b268:	subs	r2, #1
    b26a:	add.w	r5, r2, r2, lsl #1
    b26e:	add.w	r5, r2, r5, lsl #2
      if (k >= len) {
    b272:	cmp	sl, r5
        checksum = ldir->checksum;
      } else if (ldir->order != --order || checksum != ldir->checksum) {
        lfnOrd = 0;
        continue;
      }
      size_t k = 13*(order - 1);
    b274:	mov	r2, r5
      if (k >= len) {
    b276:	bls.n	b22e <FatFile::open(FatFile*, fname_t*, int)+0xd6>
    b278:	add.w	r1, r5, #13
    b27c:	str.w	r9, [sp, #32]
    b280:	mov	r9, r1
    b282:	b.n	b2ac <FatFile::open(FatFile*, fname_t*, int)+0x154>
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    b284:	ldr.w	r0, [fp, #8]
    b288:	ldrb	r2, [r0, r2]
}
#if USE_LONG_FILE_NAMES
//------------------------------------------------------------------------------
// Saves about 90 bytes of flash on 328 over tolower().
inline char lfnToLower(char c) {
  return 'A' <= c && c <= 'Z' ? c + 'a' - 'A' : c;
    b28a:	cmp.w	ip, #25
    b28e:	it	ls
    b290:	addls	r1, #32
    b292:	sub.w	r0, r2, #65	; 0x41
    b296:	it	ls
    b298:	uxtbls	r1, r1
    b29a:	cmp	r0, #25
    b29c:	itt	ls
    b29e:	addls	r2, #32
    b2a0:	uxtbls	r2, r2
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    b2a2:	cmp	r1, r2
    b2a4:	bne.n	b22e <FatFile::open(FatFile*, fname_t*, int)+0xd6>
      if (k >= len) {
        // Not found.
        lfnOrd = 0;
        continue;
      }
      for (uint8_t i = 0; i < 13; i++) {
    b2a6:	cmp	lr, r9
    b2a8:	beq.n	b330 <FatFile::open(FatFile*, fname_t*, int)+0x1d8>
    b2aa:	mov	r2, lr
        uint16_t u = lfnGetChar(ldir, i);
    b2ac:	subs	r1, r2, r5
    b2ae:	uxtb	r1, r1
    b2b0:	mov	r0, r3
    b2b2:	bl	abc4 <lfnGetChar(DirLfn_t*, unsigned char)>
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    b2b6:	uxtb	r1, r0
        lfnOrd = 0;
        continue;
      }
      for (uint8_t i = 0; i < 13; i++) {
        uint16_t u = lfnGetChar(ldir, i);
        if (k == len) {
    b2b8:	cmp	sl, r2
}
#if USE_LONG_FILE_NAMES
//------------------------------------------------------------------------------
// Saves about 90 bytes of flash on 328 over tolower().
inline char lfnToLower(char c) {
  return 'A' <= c && c <= 'Z' ? c + 'a' - 'A' : c;
    b2ba:	sub.w	ip, r1, #65	; 0x41
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    b2be:	add.w	lr, r2, #1
        lfnOrd = 0;
        continue;
      }
      for (uint8_t i = 0; i < 13; i++) {
        uint16_t u = lfnGetChar(ldir, i);
        if (k == len) {
    b2c2:	beq.w	b496 <FatFile::open(FatFile*, fname_t*, int)+0x33e>
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    b2c6:	cmp	r0, #255	; 0xff
    b2c8:	bls.n	b284 <FatFile::open(FatFile*, fname_t*, int)+0x12c>
          goto found;
        }
        fnameFound = true;
      }
    } else {
      lfnOrd = 0;
    b2ca:	mov.w	r9, #0
    b2ce:	b.n	b1a2 <FatFile::open(FatFile*, fname_t*, int)+0x4a>
  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    dir = dirFile->readDirCache(true);
    if (!dir) {
      if (dirFile->getError()) {
    b2d0:	ldrb	r3, [r6, #1]
    b2d2:	cmp	r3, #0
    b2d4:	bne.w	b16a <FatFile::open(FatFile*, fname_t*, int)+0x12>
  }
  goto open;

 create:
  // don't create unless O_CREAT and write mode
  if (!(oflag & O_CREAT) || !isWriteMode(oflag)) {
    b2d8:	ldr	r2, [sp, #28]
    b2da:	mov	r3, r2
    b2dc:	lsls	r2, r3, #22
    b2de:	bpl.w	b16a <FatFile::open(FatFile*, fname_t*, int)+0x12>
    b2e2:	and.w	r3, r3, #3
    b2e6:	subs	r3, #1
    b2e8:	cmp	r3, #1
    b2ea:	bhi.w	b16a <FatFile::open(FatFile*, fname_t*, int)+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // If at EOF start in next cluster.
  if (freeFound == 0) {
    b2ee:	cmp	r4, #0
    b2f0:	it	eq
    b2f2:	moveq	r7, r5
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    b2f4:	cmp	r4, r8
    b2f6:	bcc.n	b300 <FatFile::open(FatFile*, fname_t*, int)+0x1a8>
    b2f8:	b.n	b336 <FatFile::open(FatFile*, fname_t*, int)+0x1de>
        goto fail;
      }
      // EOF if no error.
      break;
    }
    freeFound++;
    b2fa:	uxtb	r4, r3
  // If at EOF start in next cluster.
  if (freeFound == 0) {
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    b2fc:	cmp	r8, r4
    b2fe:	bls.n	b336 <FatFile::open(FatFile*, fname_t*, int)+0x1de>
    dir = dirFile->readDirCache();
    b300:	movs	r1, #0
    b302:	mov	r0, r6
    b304:	bl	a14c <FatFile::readDirCache(bool)>
        goto fail;
      }
      // EOF if no error.
      break;
    }
    freeFound++;
    b308:	adds	r3, r4, #1
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    dir = dirFile->readDirCache();
    if (!dir) {
    b30a:	cmp	r0, #0
    b30c:	bne.n	b2fa <FatFile::open(FatFile*, fname_t*, int)+0x1a2>
      if (dirFile->getError()) {
    b30e:	ldrb	r3, [r6, #1]
    b310:	cbz	r3, b31c <FatFile::open(FatFile*, fname_t*, int)+0x1c4>
    b312:	b.n	b16a <FatFile::open(FatFile*, fname_t*, int)+0x12>
    b314:	ldr	r3, [r6, #8]
    if (!dirFile->addDirCluster()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Done if more than one sector per cluster.  Max freeNeed is 21.
    if (dirFile->m_vol->sectorsPerCluster() > 1) {
    b316:	ldrb	r3, [r3, #4]
    b318:	cmp	r3, #1
    b31a:	bhi.n	b336 <FatFile::open(FatFile*, fname_t*, int)+0x1de>
      // EOF if no error.
      break;
    }
    freeFound++;
  }
  while (freeFound < freeNeed) {
    b31c:	cmp	r8, r4
    b31e:	bls.n	b336 <FatFile::open(FatFile*, fname_t*, int)+0x1de>
    // Will fail if FAT16 root.
    if (!dirFile->addDirCluster()) {
    b320:	mov	r0, r6
    b322:	bl	9b24 <FatFile::addDirCluster()>
    }
    // Done if more than one sector per cluster.  Max freeNeed is 21.
    if (dirFile->m_vol->sectorsPerCluster() > 1) {
      break;
    }
    freeFound += 16;
    b326:	adds	r4, #16
    b328:	uxtb	r4, r4
    }
    freeFound++;
  }
  while (freeFound < freeNeed) {
    // Will fail if FAT16 root.
    if (!dirFile->addDirCluster()) {
    b32a:	cmp	r0, #0
    b32c:	bne.n	b314 <FatFile::open(FatFile*, fname_t*, int)+0x1bc>
    b32e:	b.n	b16a <FatFile::open(FatFile*, fname_t*, int)+0x12>
    b330:	ldr.w	r9, [sp, #32]
    b334:	b.n	b1a2 <FatFile::open(FatFile*, fname_t*, int)+0x4a>
    if (dirFile->m_vol->sectorsPerCluster() > 1) {
      break;
    }
    freeFound += 16;
  }
  if (fnameFound) {
    b336:	ldr	r3, [sp, #20]
    b338:	cbz	r3, b348 <FatFile::open(FatFile*, fname_t*, int)+0x1f0>
    if (!dirFile->lfnUniqueSfn(fname)) {
    b33a:	mov	r1, fp
    b33c:	mov	r0, r6
    b33e:	bl	b0a0 <FatFile::lfnUniqueSfn(fname_t*)>
    b342:	cmp	r0, #0
    b344:	beq.w	b16a <FatFile::open(FatFile*, fname_t*, int)+0x12>
      goto fail;
    }
  }
  if (!dirFile->seekSet(32UL*freeIndex)) {
    b348:	lsls	r1, r7, #5
    b34a:	mov	r0, r6
    b34c:	bl	a3bc <FatFile::seekSet(unsigned long)>
    b350:	cmp	r0, #0
    b352:	beq.w	b16a <FatFile::open(FatFile*, fname_t*, int)+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  lfnOrd = freeNeed - 1;
    b356:	add.w	r8, r8, #4294967295
  for (order = lfnOrd ; order ; order--) {
    b35a:	ands.w	r9, r8, #255	; 0xff
    b35e:	beq.n	b414 <FatFile::open(FatFile*, fname_t*, int)+0x2bc>
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile->m_vol->cacheDirty();
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    b360:	orr.w	r4, r9, #64	; 0x40
    b364:	uxtb	r4, r4
  if (!dirFile->seekSet(32UL*freeIndex)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  lfnOrd = freeNeed - 1;
  for (order = lfnOrd ; order ; order--) {
    b366:	mov	r5, r9
    ldir = reinterpret_cast<DirLfn_t*>(dirFile->readDirCache());
    b368:	movs	r7, #0
    b36a:	movs	r1, #0
    b36c:	mov	r0, r6
    b36e:	bl	a14c <FatFile::readDirCache(bool)>
    if (!ldir) {
    b372:	cmp	r0, #0
    b374:	beq.w	b16a <FatFile::open(FatFile*, fname_t*, int)+0x12>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile->m_vol->cacheDirty();
    b378:	ldr	r2, [r6, #8]
    b37a:	ldrb.w	r3, [r2, #36]	; 0x24
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    b37e:	cmp	r9, r5
    b380:	orr.w	r3, r3, #1
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    b384:	mov.w	ip, #15
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile->m_vol->cacheDirty();
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    b388:	ite	ne
    b38a:	movne	r1, r5
    b38c:	moveq	r1, r4
    b38e:	strb.w	r3, [r2, #36]	; 0x24
    b392:	add.w	lr, fp, #12
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    b396:	strb.w	ip, [r0, #11]
    ldir->mustBeZero1 = 0;
    b39a:	strb	r7, [r0, #12]
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile->m_vol->cacheDirty();
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    b39c:	strb	r1, [r0, #0]
    b39e:	add.w	ip, fp, #23
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
    b3a2:	movs	r3, #0
  for (uint8_t i = 0; i < 11; i++) {
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    b3a4:	ldrb.w	r8, [lr, #1]!
    b3a8:	lsrs	r2, r3, #1
    b3aa:	orr.w	r3, r2, r3, lsl #7
    b3ae:	uxtab	r3, r8, r3
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    b3b2:	cmp	lr, ip
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    b3b4:	uxtb	r3, r3
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    b3b6:	bne.n	b3a4 <FatFile::open(FatFile*, fname_t*, int)+0x24c>
    setLe16(ldir->unicode3 + 2*i - 22, c);
  }
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t* ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
    b3b8:	and.w	r1, r1, #31
    b3bc:	subs	r1, #1
    }
    dirFile->m_vol->cacheDirty();
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    ldir->mustBeZero1 = 0;
    ldir->checksum = lfnChecksum(fname->sfn);
    b3be:	strb	r3, [r0, #13]
    setLe16(ldir->unicode3 + 2*i - 22, c);
  }
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t* ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
    b3c0:	add.w	r2, r1, r1, lsl #1
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    ldir->mustBeZero1 = 0;
    ldir->checksum = lfnChecksum(fname->sfn);
    setLe16(ldir->mustBeZero2, 0);
    lfnPutName(ldir, fname->lfn, len);
    b3c4:	ldr.w	lr, [fp, #8]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    b3c8:	strh	r7, [r0, #26]
    setLe16(ldir->unicode3 + 2*i - 22, c);
  }
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t* ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
    b3ca:	add.w	r2, r1, r2, lsl #2
    b3ce:	adds	r0, #4
  for (uint8_t i = 0; i < 13; i++, k++) {
    b3d0:	movs	r3, #0
    b3d2:	b.n	b3f4 <FatFile::open(FatFile*, fname_t*, int)+0x29c>
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c  The 16-bit character.
 */
static void lfnPutChar(DirLfn_t* ldir, uint8_t i, uint16_t c) {
  if (i < 5) {
    b3d4:	cmp	r3, #4
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t* ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
  for (uint8_t i = 0; i < 13; i++, k++) {
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    b3d6:	ldrb.w	r1, [lr, r2]
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c  The 16-bit character.
 */
static void lfnPutChar(DirLfn_t* ldir, uint8_t i, uint16_t c) {
  if (i < 5) {
    b3da:	bls.n	b406 <FatFile::open(FatFile*, fname_t*, int)+0x2ae>
    setLe16(ldir->unicode1 + 2*i, c);
  } else if (i < 11) {
    b3dc:	cmp	r3, #10
    b3de:	ite	ls
    b3e0:	strhls	r1, [r0, #0]
    b3e2:	strhhi	r1, [r0, #2]
  }
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t* ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
  for (uint8_t i = 0; i < 13; i++, k++) {
    b3e4:	adds	r3, #1
    b3e6:	uxtb	r3, r3
    b3e8:	cmp	r3, #13
    b3ea:	add.w	r2, r2, #1
    b3ee:	add.w	r0, r0, #2
    b3f2:	beq.n	b40c <FatFile::open(FatFile*, fname_t*, int)+0x2b4>
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    b3f4:	cmp	sl, r2
    b3f6:	bhi.n	b3d4 <FatFile::open(FatFile*, fname_t*, int)+0x27c>
    b3f8:	ite	ne
    b3fa:	movne.w	r1, #4294967295
    b3fe:	moveq	r1, #0
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c  The 16-bit character.
 */
static void lfnPutChar(DirLfn_t* ldir, uint8_t i, uint16_t c) {
  if (i < 5) {
    b400:	cmp	r3, #4
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t* ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
  for (uint8_t i = 0; i < 13; i++, k++) {
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    b402:	uxth	r1, r1
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c  The 16-bit character.
 */
static void lfnPutChar(DirLfn_t* ldir, uint8_t i, uint16_t c) {
  if (i < 5) {
    b404:	bhi.n	b3dc <FatFile::open(FatFile*, fname_t*, int)+0x284>
    b406:	strh.w	r1, [r0, #-3]
    b40a:	b.n	b3e4 <FatFile::open(FatFile*, fname_t*, int)+0x28c>
  if (!dirFile->seekSet(32UL*freeIndex)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  lfnOrd = freeNeed - 1;
  for (order = lfnOrd ; order ; order--) {
    b40c:	subs	r5, #1
    b40e:	ands.w	r5, r5, #255	; 0xff
    b412:	bne.n	b36a <FatFile::open(FatFile*, fname_t*, int)+0x212>
    ldir->checksum = lfnChecksum(fname->sfn);
    setLe16(ldir->mustBeZero2, 0);
    lfnPutName(ldir, fname->lfn, len);
  }
  curIndex = dirFile->m_curPosition/32;
  dir = dirFile->readDirCache();
    b414:	movs	r1, #0
    b416:	mov	r0, r6
    ldir->mustBeZero1 = 0;
    ldir->checksum = lfnChecksum(fname->sfn);
    setLe16(ldir->mustBeZero2, 0);
    lfnPutName(ldir, fname->lfn, len);
  }
  curIndex = dirFile->m_curPosition/32;
    b418:	ldr	r5, [r6, #20]
  dir = dirFile->readDirCache();
    b41a:	bl	a14c <FatFile::readDirCache(bool)>
    ldir->mustBeZero1 = 0;
    ldir->checksum = lfnChecksum(fname->sfn);
    setLe16(ldir->mustBeZero2, 0);
    lfnPutName(ldir, fname->lfn, len);
  }
  curIndex = dirFile->m_curPosition/32;
    b41e:	ubfx	r5, r5, #5, #16
  dir = dirFile->readDirCache();
  if (!dir) {
    b422:	mov	r4, r0
    b424:	cmp	r0, #0
    b426:	beq.w	b16a <FatFile::open(FatFile*, fname_t*, int)+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // initialize as empty file
  memset(dir, 0, sizeof(DirFat_t));
    b42a:	movs	r2, #32
    b42c:	movs	r1, #0
    b42e:	bl	1059c <memset>
  memcpy(dir->name, fname->sfn, 11);
    b432:	mov	r3, fp

  // Set base-name and extension lower case bits.
  dir->caseFlags =  (FAT_CASE_LC_BASE | FAT_CASE_LC_EXT) & fname->flags;

  // Set timestamps.
  if (FsDateTime::callback) {
    b434:	ldr	r2, [pc, #172]	; (b4e4 <FatFile::open(FatFile*, fname_t*, int)+0x38c>)
    DBG_FAIL_MACRO;
    goto fail;
  }
  // initialize as empty file
  memset(dir, 0, sizeof(DirFat_t));
  memcpy(dir->name, fname->sfn, 11);
    b436:	ldr.w	r1, [r3, #13]!
    b43a:	ldr	r0, [r3, #4]
    b43c:	str	r0, [r4, #4]
    b43e:	str	r1, [r4, #0]
    b440:	ldrh	r1, [r3, #8]
    b442:	ldrb	r3, [r3, #10]
    b444:	strb	r3, [r4, #10]
    b446:	strh	r1, [r4, #8]

  // Set base-name and extension lower case bits.
  dir->caseFlags =  (FAT_CASE_LC_BASE | FAT_CASE_LC_EXT) & fname->flags;
    b448:	ldrb.w	r3, [fp]

  // Set timestamps.
  if (FsDateTime::callback) {
    b44c:	ldr	r7, [r2, #0]
  // initialize as empty file
  memset(dir, 0, sizeof(DirFat_t));
  memcpy(dir->name, fname->sfn, 11);

  // Set base-name and extension lower case bits.
  dir->caseFlags =  (FAT_CASE_LC_BASE | FAT_CASE_LC_EXT) & fname->flags;
    b44e:	and.w	r3, r3, #24
    b452:	strb	r3, [r4, #12]

  // Set timestamps.
  if (FsDateTime::callback) {
    b454:	cmp	r7, #0
    b456:	beq.n	b4d4 <FatFile::open(FatFile*, fname_t*, int)+0x37c>
    // call user date/time function
    FsDateTime::callback(&date, &time, &ms10);
    b458:	add.w	r2, sp, #43	; 0x2b
    b45c:	add.w	r1, sp, #46	; 0x2e
    b460:	add	r0, sp, #44	; 0x2c
    b462:	blx	r7
    b464:	ldrh.w	r1, [sp, #44]	; 0x2c
    b468:	ldrh.w	r2, [sp, #46]	; 0x2e
    setLe16(dir->createDate, date);
    setLe16(dir->createTime, time);
    dir->createTimeMs = ms10;
    b46c:	ldrb.w	r3, [sp, #43]	; 0x2b
    b470:	strh	r1, [r4, #16]
    b472:	strh	r2, [r4, #14]
    b474:	strb	r3, [r4, #13]
      setLe16(dir->createTime, FS_DEFAULT_TIME);
      setLe16(dir->modifyTime, FS_DEFAULT_TIME);
    }
  }
  // Force write of entry to device.
  dirFile->m_vol->cacheDirty();
    b476:	ldr	r2, [r6, #8]
    b478:	ldrb.w	r3, [r2, #36]	; 0x24
    b47c:	orr.w	r3, r3, #1
    b480:	strb.w	r3, [r2, #36]	; 0x24

 open:
  // open entry in cache.
  if (!openCachedEntry(dirFile, curIndex, oflag, lfnOrd)) {
    b484:	str.w	r9, [sp]
    b488:	ldr	r3, [sp, #28]
    b48a:	ldr	r0, [sp, #36]	; 0x24
    b48c:	mov	r2, r5
    b48e:	mov	r1, r6
    b490:	bl	a46c <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>
    b494:	b.n	b16c <FatFile::open(FatFile*, fname_t*, int)+0x14>
      for (uint8_t i = 0; i < 13; i++) {
        uint16_t u = lfnGetChar(ldir, i);
        if (k == len) {
          if (u != 0) {
            // Not found.
            lfnOrd = 0;
    b496:	cmp	r0, #0
    b498:	ldr.w	r9, [sp, #32]
    b49c:	it	ne
    b49e:	movne.w	r9, #0
    b4a2:	b.n	b1a2 <FatFile::open(FatFile*, fname_t*, int)+0x4a>
          break;
        }
      }
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd) {
        if (1 == order && lfnChecksum(dir->name) == checksum) {
    b4a4:	ldr	r1, [sp, #12]
    b4a6:	cmp	r1, #1
    b4a8:	bne.w	b16a <FatFile::open(FatFile*, fname_t*, int)+0x12>
    b4ac:	subs	r4, r3, #1
    b4ae:	adds	r3, #10
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    b4b0:	ldrb.w	r0, [r4, #1]!
    b4b4:	lsrs	r1, r2, #1
    b4b6:	orr.w	r2, r1, r2, lsl #7
    b4ba:	uxtab	r2, r0, r2
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    b4be:	cmp	r4, r3
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    b4c0:	uxtb	r2, r2
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    b4c2:	bne.n	b4b0 <FatFile::open(FatFile*, fname_t*, int)+0x358>
          break;
        }
      }
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd) {
        if (1 == order && lfnChecksum(dir->name) == checksum) {
    b4c4:	ldr	r3, [sp, #24]
    b4c6:	cmp	r3, r2
    b4c8:	bne.w	b16a <FatFile::open(FatFile*, fname_t*, int)+0x12>
    }
  }

 found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
    b4cc:	ldr	r3, [sp, #28]
    b4ce:	lsls	r1, r3, #20
    b4d0:	bpl.n	b484 <FatFile::open(FatFile*, fname_t*, int)+0x32c>
    b4d2:	b.n	b16a <FatFile::open(FatFile*, fname_t*, int)+0x12>
    b4d4:	movw	r3, #21025	; 0x5221
    b4d8:	strh	r3, [r4, #16]
    b4da:	strh	r3, [r4, #24]
    b4dc:	strh	r3, [r4, #18]
    b4de:	b.n	b476 <FatFile::open(FatFile*, fname_t*, int)+0x31e>
    b4e0:	.word	0x4ec4ec4f
    b4e4:	.word	0x1fff6188

0000b4e8 <FatFile::getSFN(char*)>:
#include "../common/DebugMacros.h"
#include "../common/FsStructs.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
size_t FatFile::getSFN(char* name) {
    b4e8:	push	{r3, r4, r5, r6, r7, lr}
    b4ea:	ldrb	r3, [r0, #0]
    b4ec:	mov	r5, r1
  uint8_t j = 0;
  uint8_t lcBit = FAT_CASE_LC_BASE;
  DirFat_t* dir;

  if (!isOpen()) {
    b4ee:	cbz	r3, b502 <FatFile::getSFN(char*)+0x1a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isRoot()) {
    b4f0:	ands.w	r4, r3, #96	; 0x60
    b4f4:	beq.n	b508 <FatFile::getSFN(char*)+0x20>
    name[0] = '/';
    b4f6:	movs	r2, #47	; 0x2f
    name[1] = '\0';
    b4f8:	movs	r3, #0
  if (!isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isRoot()) {
    name[0] = '/';
    b4fa:	strb	r2, [r1, #0]
    name[1] = '\0';
    b4fc:	strb	r3, [r1, #1]
    return 1;
    b4fe:	movs	r0, #1
    b500:	pop	{r3, r4, r5, r6, r7, pc}
  }
  name[j] = '\0';
  return j;

 fail:
  name[0] = '\0';
    b502:	movs	r0, #0
    b504:	strb	r0, [r5, #0]
  return 0;
}
    b506:	pop	{r3, r4, r5, r6, r7, pc}
    name[0] = '/';
    name[1] = '\0';
    return 1;
  }
  // cache entry
  dir = reinterpret_cast<DirFat_t*>(cacheDirEntry(FsCache::CACHE_FOR_READ));
    b508:	mov	r1, r4
    b50a:	bl	9bbc <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    b50e:	cmp	r0, #0
    b510:	beq.n	b502 <FatFile::getSFN(char*)+0x1a>
    b512:	mov	r1, r4
    b514:	mov	r3, r4
    b516:	movs	r7, #8
    b518:	subs	r4, r0, #1
      continue;
    }
    if (i == 8) {
      // Position bit for extension.
      lcBit = FAT_CASE_LC_EXT;
      name[j++] = '.';
    b51a:	mov.w	lr, #46	; 0x2e
    DBG_FAIL_MACRO;
    goto fail;
  }
  // format name
  for (uint8_t i = 0; i < 11; i++) {
    if (dir->name[i] == ' ') {
    b51e:	ldrb.w	r2, [r4, #1]!
    b522:	cmp	r2, #32
    b524:	beq.n	b542 <FatFile::getSFN(char*)+0x5a>
      continue;
    }
    if (i == 8) {
    b526:	cmp	r1, #8
    b528:	beq.n	b550 <FatFile::getSFN(char*)+0x68>
      // Position bit for extension.
      lcBit = FAT_CASE_LC_EXT;
      name[j++] = '.';
    }
    char c = dir->name[i];
    if ('A' <= c && c <= 'Z' && (lcBit & dir->caseFlags)) {
    b52a:	sub.w	r6, r2, #65	; 0x41
    b52e:	cmp	r6, #25
    b530:	bhi.n	b53c <FatFile::getSFN(char*)+0x54>
    b532:	ldrb	r6, [r0, #12]
    b534:	tst	r7, r6
      c += 'a' - 'A';
    b536:	itt	ne
    b538:	addne	r2, #32
    b53a:	uxtbne	r2, r2
    }
    name[j++] = c;
    b53c:	strb	r2, [r5, r3]
    b53e:	adds	r3, #1
    b540:	uxtb	r3, r3
    b542:	adds	r1, #1
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // format name
  for (uint8_t i = 0; i < 11; i++) {
    b544:	cmp	r1, #11
    b546:	bne.n	b51e <FatFile::getSFN(char*)+0x36>
    if ('A' <= c && c <= 'Z' && (lcBit & dir->caseFlags)) {
      c += 'a' - 'A';
    }
    name[j++] = c;
  }
  name[j] = '\0';
    b548:	movs	r2, #0
    b54a:	strb	r2, [r5, r3]
  return j;
    b54c:	mov	r0, r3
    b54e:	pop	{r3, r4, r5, r6, r7, pc}
      continue;
    }
    if (i == 8) {
      // Position bit for extension.
      lcBit = FAT_CASE_LC_EXT;
      name[j++] = '.';
    b550:	strb.w	lr, [r5, r3]
    b554:	adds	r3, #1
    b556:	uxtb	r3, r3
    b558:	ldrb	r2, [r4, #0]
    if (dir->name[i] == ' ') {
      continue;
    }
    if (i == 8) {
      // Position bit for extension.
      lcBit = FAT_CASE_LC_EXT;
    b55a:	movs	r7, #16
    b55c:	b.n	b52a <FatFile::getSFN(char*)+0x42>
    b55e:	nop

0000b560 <FsBaseFile::FsBaseFile(FsBaseFile const&)>:
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
//------------------------------------------------------------------------------
FsBaseFile::FsBaseFile(const FsBaseFile& from) {
    b560:	push	{r3, r4, r5, r6, r7, lr}
    b562:	movs	r5, #0
    b564:	str	r5, [r0, #56]	; 0x38
  m_fFile = nullptr;
  m_xFile = nullptr;
  if (from.m_fFile) {
    b566:	ldr	r4, [r1, #56]	; 0x38
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
//------------------------------------------------------------------------------
FsBaseFile::FsBaseFile(const FsBaseFile& from) {
    b568:	str	r5, [r0, #60]	; 0x3c
    b56a:	mov	r6, r0
    b56c:	mov	r7, r1
  m_fFile = nullptr;
  m_xFile = nullptr;
  if (from.m_fFile) {
    b56e:	cbz	r4, b594 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x34>
    m_fFile = new (m_fileMem) FatFile;
    b570:	mov	r1, r0
    b572:	movs	r0, #36	; 0x24
    b574:	bl	b7d0 <operator new(unsigned int, unsigned long*)>
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    b578:	strb	r5, [r0, #0]
    b57a:	strb	r5, [r0, #1]
    b57c:	strb	r5, [r0, #2]
    b57e:	str	r0, [r6, #56]	; 0x38
    *m_fFile = *from.m_fFile;
    b580:	ldr	r5, [r7, #56]	; 0x38
    b582:	mov	r4, r0
    b584:	ldmia	r5!, {r0, r1, r2, r3}
    b586:	stmia	r4!, {r0, r1, r2, r3}
    b588:	ldmia	r5!, {r0, r1, r2, r3}
    b58a:	stmia	r4!, {r0, r1, r2, r3}
    b58c:	ldr	r3, [r5, #0]
    b58e:	str	r3, [r4, #0]
  } else if (from.m_xFile) {
    m_xFile = new (m_fileMem) ExFatFile;
    *m_xFile = *from.m_xFile;
  }
}
    b590:	mov	r0, r6
    b592:	pop	{r3, r4, r5, r6, r7, pc}
  m_fFile = nullptr;
  m_xFile = nullptr;
  if (from.m_fFile) {
    m_fFile = new (m_fileMem) FatFile;
    *m_fFile = *from.m_fFile;
  } else if (from.m_xFile) {
    b594:	ldr	r3, [r1, #60]	; 0x3c
    b596:	cmp	r3, #0
    b598:	beq.n	b590 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x30>
    m_xFile = new (m_fileMem) ExFatFile;
    b59a:	mov	r1, r0
    b59c:	movs	r0, #56	; 0x38
    b59e:	bl	b7d0 <operator new(unsigned int, unsigned long*)>
    b5a2:	strb.w	r4, [r0, #49]	; 0x31
    b5a6:	strb.w	r4, [r0, #50]	; 0x32
    b5aa:	strb.w	r4, [r0, #51]	; 0x33
    b5ae:	str	r0, [r6, #60]	; 0x3c
    *m_xFile = *from.m_xFile;
    b5b0:	ldr	r3, [r7, #60]	; 0x3c
    b5b2:	mov	r2, r0
    b5b4:	add.w	r1, r3, #48	; 0x30
    b5b8:	ldr	r5, [r3, #0]
    b5ba:	ldr	r4, [r3, #4]
    b5bc:	ldr	r0, [r3, #8]
    b5be:	ldr	r7, [r3, #12]
    b5c0:	str	r7, [r2, #12]
    b5c2:	adds	r3, #16
    b5c4:	cmp	r3, r1
    b5c6:	str	r5, [r2, #0]
    b5c8:	str	r4, [r2, #4]
    b5ca:	str	r0, [r2, #8]
    b5cc:	add.w	r2, r2, #16
    b5d0:	bne.n	b5b8 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x58>
    b5d2:	ldr	r3, [r3, #0]
    b5d4:	str	r3, [r2, #0]
    b5d6:	b.n	b590 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x30>

0000b5d8 <FsBaseFile::close()>:
    *m_xFile = *from.m_xFile;
  }
  return *this;
}
//------------------------------------------------------------------------------
bool FsBaseFile::close() {
    b5d8:	push	{r4, lr}
    b5da:	mov	r4, r0
  if (m_fFile && m_fFile->close()) {
    b5dc:	ldr	r0, [r0, #56]	; 0x38
    b5de:	cbz	r0, b5ec <FsBaseFile::close()+0x14>
    b5e0:	bl	9c70 <FatFile::close()>
    b5e4:	cbz	r0, b5ec <FsBaseFile::close()+0x14>
    m_fFile = nullptr;
    b5e6:	movs	r3, #0
    b5e8:	str	r3, [r4, #56]	; 0x38
    return true;
    b5ea:	pop	{r4, pc}
  }
  if (m_xFile && m_xFile->close()) {
    b5ec:	ldr	r0, [r4, #60]	; 0x3c
    b5ee:	cbz	r0, b5fc <FsBaseFile::close()+0x24>
    b5f0:	bl	8258 <ExFatFile::close()>
    b5f4:	cbz	r0, b5fc <FsBaseFile::close()+0x24>
    m_xFile = nullptr;
    b5f6:	movs	r3, #0
    b5f8:	str	r3, [r4, #60]	; 0x3c
    b5fa:	pop	{r4, pc}
    return true;
  }
  return false;
    b5fc:	movs	r0, #0
}
    b5fe:	pop	{r4, pc}

0000b600 <FsBaseFile::open(FsVolume*, char const*, int)>:
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::open(FsVolume* vol, const char* path, oflag_t oflag) {
  if (!vol) {
    b600:	cbz	r1, b676 <FsBaseFile::open(FsVolume*, char const*, int)+0x76>
    m_xFile = nullptr;
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::open(FsVolume* vol, const char* path, oflag_t oflag) {
    b602:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b606:	mov	r4, r1
    b608:	mov	r5, r0
    b60a:	mov	r8, r3
    b60c:	mov	r7, r2
  if (!vol) {
    return false;
  }
  close();
    b60e:	bl	b5d8 <FsBaseFile::close()>
  if (vol->m_fVol) {
    b612:	ldr.w	r6, [r4, #1152]	; 0x480
    b616:	cbz	r6, b644 <FsBaseFile::open(FsVolume*, char const*, int)+0x44>
    m_fFile = new (m_fileMem) FatFile;
    b618:	mov	r1, r5
    b61a:	movs	r0, #36	; 0x24
    b61c:	bl	b7d0 <operator new(unsigned int, unsigned long*)>
    b620:	movs	r1, #0
    b622:	strb	r1, [r0, #0]
    b624:	strb	r1, [r0, #1]
    b626:	strb	r1, [r0, #2]
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
    b628:	ldr.w	r1, [r4, #1152]	; 0x480
  if (!vol) {
    return false;
  }
  close();
  if (vol->m_fVol) {
    m_fFile = new (m_fileMem) FatFile;
    b62c:	str	r0, [r5, #56]	; 0x38
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
    b62e:	mov	r3, r8
    b630:	mov	r2, r7
    b632:	bl	9f64 <FatFile::open(FatVolume*, char const*, int)>
    b636:	cbz	r0, b63e <FsBaseFile::open(FsVolume*, char const*, int)+0x3e>
      return true;
    b638:	movs	r0, #1
    b63a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
    m_fFile = nullptr;
    b63e:	str	r0, [r5, #56]	; 0x38
    b640:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  } else if (vol->m_xVol) {
    b644:	ldr.w	r3, [r4, #1156]	; 0x484
    b648:	cbz	r3, b67a <FsBaseFile::open(FsVolume*, char const*, int)+0x7a>
    m_xFile = new (m_fileMem) ExFatFile;
    b64a:	mov	r1, r5
    b64c:	movs	r0, #56	; 0x38
    b64e:	bl	b7d0 <operator new(unsigned int, unsigned long*)>
    b652:	strb.w	r6, [r0, #49]	; 0x31
    b656:	strb.w	r6, [r0, #50]	; 0x32
    b65a:	strb.w	r6, [r0, #51]	; 0x33
    if (m_xFile && m_xFile->open(vol->m_xVol, path, oflag)) {
    b65e:	ldr.w	r1, [r4, #1156]	; 0x484
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
      return true;
    }
    m_fFile = nullptr;
  } else if (vol->m_xVol) {
    m_xFile = new (m_fileMem) ExFatFile;
    b662:	str	r0, [r5, #60]	; 0x3c
    if (m_xFile && m_xFile->open(vol->m_xVol, path, oflag)) {
    b664:	mov	r3, r8
    b666:	mov	r2, r7
    b668:	bl	8bbc <ExFatFile::open(ExFatVolume*, char const*, int)>
    b66c:	cmp	r0, #0
    b66e:	bne.n	b638 <FsBaseFile::open(FsVolume*, char const*, int)+0x38>
      return true;
    }
    m_xFile = nullptr;
    b670:	str	r0, [r5, #60]	; 0x3c
  }
  return false;
}
    b672:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::open(FsVolume* vol, const char* path, oflag_t oflag) {
  if (!vol) {
    return false;
    b676:	movs	r0, #0
      return true;
    }
    m_xFile = nullptr;
  }
  return false;
}
    b678:	bx	lr
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::open(FsVolume* vol, const char* path, oflag_t oflag) {
  if (!vol) {
    return false;
    b67a:	movs	r0, #0
    b67c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000b680 <FsBaseFile::openNext(FsBaseFile*, int)>:
    m_xFile = nullptr;
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::openNext(FsBaseFile* dir, oflag_t oflag) {
    b680:	push	{r3, r4, r5, r6, r7, lr}
    b682:	mov	r5, r1
    b684:	mov	r7, r2
    b686:	mov	r4, r0
  close();
    b688:	bl	b5d8 <FsBaseFile::close()>
  if (dir->m_fFile) {
    b68c:	ldr	r6, [r5, #56]	; 0x38
    b68e:	cbz	r6, b6b4 <FsBaseFile::openNext(FsBaseFile*, int)+0x34>
    m_fFile = new (m_fileMem) FatFile;
    b690:	mov	r1, r4
    b692:	movs	r0, #36	; 0x24
    b694:	bl	b7d0 <operator new(unsigned int, unsigned long*)>
    b698:	movs	r2, #0
    b69a:	strb	r2, [r0, #0]
    b69c:	strb	r2, [r0, #1]
    b69e:	strb	r2, [r0, #2]
    b6a0:	str	r0, [r4, #56]	; 0x38
    if (m_fFile->openNext(dir->m_fFile, oflag)) {
    b6a2:	mov	r2, r7
    b6a4:	ldr	r1, [r5, #56]	; 0x38
    b6a6:	bl	a544 <FatFile::openNext(FatFile*, int)>
    b6aa:	cbz	r0, b6b0 <FsBaseFile::openNext(FsBaseFile*, int)+0x30>
      return true;
    b6ac:	movs	r0, #1
    b6ae:	pop	{r3, r4, r5, r6, r7, pc}
    }
    m_fFile = nullptr;
    b6b0:	str	r0, [r4, #56]	; 0x38
    b6b2:	pop	{r3, r4, r5, r6, r7, pc}
  } else if (dir->m_xFile) {
    b6b4:	ldr	r0, [r5, #60]	; 0x3c
    b6b6:	cbz	r0, b6dc <FsBaseFile::openNext(FsBaseFile*, int)+0x5c>
    m_xFile = new (m_fileMem) ExFatFile;
    b6b8:	mov	r1, r4
    b6ba:	movs	r0, #56	; 0x38
    b6bc:	bl	b7d0 <operator new(unsigned int, unsigned long*)>
    b6c0:	strb.w	r6, [r0, #49]	; 0x31
    b6c4:	strb.w	r6, [r0, #50]	; 0x32
    b6c8:	strb.w	r6, [r0, #51]	; 0x33
    b6cc:	str	r0, [r4, #60]	; 0x3c
    if (m_xFile->openNext(dir->m_xFile, oflag)) {
    b6ce:	mov	r2, r7
    b6d0:	ldr	r1, [r5, #60]	; 0x3c
    b6d2:	bl	8bcc <ExFatFile::openNext(ExFatFile*, int)>
    b6d6:	cmp	r0, #0
    b6d8:	bne.n	b6ac <FsBaseFile::openNext(FsBaseFile*, int)+0x2c>
      return true;
    }
    m_xFile = nullptr;
    b6da:	str	r0, [r4, #60]	; 0x3c
  }
  return false;
}
    b6dc:	pop	{r3, r4, r5, r6, r7, pc}
    b6de:	nop

0000b6e0 <FsVolume::begin(BlockDeviceInterface*)>:
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
FsVolume* FsVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FsVolume::begin(BlockDevice* blockDev) {
    b6e0:	push	{r4, r5, r6, lr}
  m_blockDev = blockDev;
  m_fVol = nullptr;
    b6e2:	movs	r6, #0
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
FsVolume* FsVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FsVolume::begin(BlockDevice* blockDev) {
    b6e4:	mov	r4, r0
  m_blockDev = blockDev;
    b6e6:	str.w	r1, [r0, #1160]	; 0x488
  m_fVol = nullptr;
    b6ea:	str.w	r6, [r0, #1152]	; 0x480
  m_xVol = new (m_volMem) ExFatVolume;
    b6ee:	mov	r1, r0
    b6f0:	mov.w	r0, #1152	; 0x480
    b6f4:	bl	b7d0 <operator new(unsigned int, unsigned long*)>
 * \class ExFatPartition
 * \brief Access exFat partitions on raw file devices.
 */
class ExFatPartition {
 public:
  ExFatPartition() {}
    b6f8:	strb.w	r6, [r0, #1092]	; 0x444
    b6fc:	strb.w	r6, [r0, #1145]	; 0x479
    b700:	strb.w	r6, [r0, #1146]	; 0x47a
    b704:	strb.w	r6, [r0, #1147]	; 0x47b
   * \param[in] setCwv Set current working volume if true.
   * \param[in] part partition to initialize.
   * \return true for success or false for failure.
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
    b708:	movs	r2, #1
    b70a:	ldr.w	r1, [r4, #1160]	; 0x488
    b70e:	str.w	r0, [r4, #1156]	; 0x484
    b712:	mov	r5, r0
    b714:	bl	8fbc <ExFatPartition::init(BlockDeviceInterface*, unsigned char)>
    b718:	cbnz	r0, b756 <FsVolume::begin(BlockDeviceInterface*)+0x76>
  if (m_xVol && m_xVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_xVol = nullptr;
    b71a:	movs	r6, #0
  m_fVol = new (m_volMem) FatVolume;
    b71c:	mov	r1, r4
  m_fVol = nullptr;
  m_xVol = new (m_volMem) ExFatVolume;
  if (m_xVol && m_xVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_xVol = nullptr;
    b71e:	str.w	r6, [r4, #1156]	; 0x484
  m_fVol = new (m_volMem) FatVolume;
    b722:	mov.w	r0, #1128	; 0x468
    b726:	bl	b7d0 <operator new(unsigned int, unsigned long*)>
 */
class FatPartition {
 public:
  /** Create an instance of FatPartition
   */
  FatPartition() {}
    b72a:	strb	r6, [r0, #7]
    b72c:	strb.w	r6, [r0, #1092]	; 0x444
    b730:	strb.w	r6, [r0, #1093]	; 0x445
    b734:	strb.w	r6, [r0, #1094]	; 0x446
   * \param[in] setCwv Set current working volume if true.
   * \param[in] part partition to initialize.
   * \return true for success or false for failure.
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
    b738:	movs	r2, #1
    b73a:	ldr.w	r1, [r4, #1160]	; 0x488
    b73e:	str.w	r0, [r4, #1152]	; 0x480
    b742:	mov	r5, r0
    b744:	bl	aaa8 <FatPartition::init(BlockDeviceInterface*, unsigned char)>
    b748:	cbnz	r0, b77a <FsVolume::begin(BlockDeviceInterface*)+0x9a>
  if (m_fVol && m_fVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_cwv = nullptr;
    b74a:	ldr	r3, [pc, #80]	; (b79c <FsVolume::begin(BlockDeviceInterface*)+0xbc>)
    b74c:	movs	r0, #0
    b74e:	str	r0, [r3, #0]
  m_fVol = nullptr;
    b750:	str.w	r0, [r4, #1152]	; 0x480
  return false;

 done:
  m_cwv = this;
  return true;
}
    b754:	pop	{r4, r5, r6, pc}
  /**
   * Set volume working directory to root.
   * \return true for success or false for failure.
   */
  bool chdir() {
    m_vwd.close();
    b756:	add.w	r6, r5, #1096	; 0x448
    b75a:	mov	r0, r6
    b75c:	bl	8258 <ExFatFile::close()>
    return m_vwd.openRoot(this);
    b760:	mov	r1, r5
    b762:	mov	r0, r6
    b764:	bl	831c <ExFatFile::openRoot(ExFatVolume*)>
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
      return false;
    }
    if (!chdir()) {
    b768:	cmp	r0, #0
    b76a:	beq.n	b71a <FsVolume::begin(BlockDeviceInterface*)+0x3a>
      return false;
    }
    if (setCwv || !m_cwv) {
    b76c:	ldr	r3, [pc, #48]	; (b7a0 <FsVolume::begin(BlockDeviceInterface*)+0xc0>)
    b76e:	ldr	r2, [r3, #0]
    b770:	cbz	r2, b798 <FsVolume::begin(BlockDeviceInterface*)+0xb8>
  m_cwv = nullptr;
  m_fVol = nullptr;
  return false;

 done:
  m_cwv = this;
    b772:	ldr	r3, [pc, #40]	; (b79c <FsVolume::begin(BlockDeviceInterface*)+0xbc>)
  return true;
    b774:	movs	r0, #1
  m_cwv = nullptr;
  m_fVol = nullptr;
  return false;

 done:
  m_cwv = this;
    b776:	str	r4, [r3, #0]
  return true;
    b778:	pop	{r4, r5, r6, pc}
  /**
   * Set volume working directory to root.
   * \return true for success or false for failure.
   */
  bool chdir() {
    m_vwd.close();
    b77a:	addw	r6, r5, #1092	; 0x444
    b77e:	mov	r0, r6
    b780:	bl	9c70 <FatFile::close()>
    return m_vwd.openRoot(this);
    b784:	mov	r1, r5
    b786:	mov	r0, r6
    b788:	bl	9f74 <FatFile::openRoot(FatVolume*)>
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
      return false;
    }
    if (!chdir()) {
    b78c:	cmp	r0, #0
    b78e:	beq.n	b74a <FsVolume::begin(BlockDeviceInterface*)+0x6a>
      return false;
    }
    if (setCwv || !m_cwv) {
    b790:	ldr	r3, [pc, #16]	; (b7a4 <FsVolume::begin(BlockDeviceInterface*)+0xc4>)
    b792:	ldr	r2, [r3, #0]
    b794:	cmp	r2, #0
    b796:	bne.n	b772 <FsVolume::begin(BlockDeviceInterface*)+0x92>
      m_cwv = this;
    b798:	str	r5, [r3, #0]
    b79a:	b.n	b772 <FsVolume::begin(BlockDeviceInterface*)+0x92>
    b79c:	.word	0x1fff6194
    b7a0:	.word	0x1fff618c
    b7a4:	.word	0x1fff6190

0000b7a8 <FsVolume::open(char const*, int)>:
bool FsVolume::ls(print_t* pr, const char* path, uint8_t flags) {
  FsBaseFile dir;
  return dir.open(this, path, O_RDONLY) && dir.ls(pr, flags);
}
//------------------------------------------------------------------------------
FsFile FsVolume::open(const char *path, oflag_t oflag) {
    b7a8:	push	{r3, r4, r5, r6, r7, lr}
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
    b7aa:	movs	r5, #0
    b7ac:	mov.w	r7, #1000	; 0x3e8
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    b7b0:	ldr	r6, [pc, #24]	; (b7cc <FsVolume::open(char const*, int)+0x24>)
    b7b2:	str	r7, [r0, #8]
    b7b4:	mov	r4, r0
    b7b6:	strb	r5, [r0, #4]
    b7b8:	strb	r5, [r0, #12]
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  /** Create an instance. */
  FsBaseFile() {}
    b7ba:	str	r5, [r0, #72]	; 0x48
    b7bc:	str	r5, [r0, #76]	; 0x4c
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    b7be:	str.w	r6, [r0], #16
  FsFile tmpFile;
  tmpFile.open(this, path, oflag);
    b7c2:	bl	b600 <FsBaseFile::open(FsVolume*, char const*, int)>
  return tmpFile;
}
    b7c6:	mov	r0, r4
    b7c8:	pop	{r3, r4, r5, r6, r7, pc}
    b7ca:	nop
    b7cc:	.word	0x000140b8

0000b7d0 <operator new(unsigned int, unsigned long*)>:
 */
#include "FsNew.h"
void* operator new(size_t size, newalign_t* ptr) {
  (void)size;
  return ptr;
}
    b7d0:	mov	r0, r1
    b7d2:	bx	lr

0000b7d4 <SdSpiCard::errorCode() const>:
  /**
   * \return code for the last error. See SdCardInfo.h for a list of error codes.
   */
  uint8_t errorCode() const {
    return m_errorCode;
  }
    b7d4:	ldrb	r0, [r0, #19]
    b7d6:	bx	lr

0000b7d8 <SdSpiCard::errorData() const>:
  /** \return error data for last error. */
  uint32_t errorData() const {
    return m_status;
  }
    b7d8:	ldrb	r0, [r0, #21]
    b7da:	bx	lr

0000b7dc <SdSpiCard::readSector(unsigned long, unsigned char*)>:
   *
   * \param[in] sector Logical sector to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
    b7dc:	push	{r4}
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    b7de:	ldr	r4, [r0, #0]
    b7e0:	ldr	r4, [r4, #16]
    b7e2:	movs	r3, #1
    b7e4:	mov	ip, r4
#else  // ENABLE_DEDICATED_SPI
    return readSingle(sector, dst);
#endif  // ENABLE_DEDICATED_SPI
  }
    b7e6:	ldr.w	r4, [sp], #4
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    b7ea:	bx	ip

0000b7ec <SdSpiCard::type() const>:
  /** Return the card type: SD V1, SD V2 or SDHC/SDXC
   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC/SDXC.
   */
  uint8_t type() const {
    return m_type;
  }
    b7ec:	ldrb	r0, [r0, #22]
    b7ee:	bx	lr

0000b7f0 <SdSpiCard::~SdSpiCard()>:
/**
 * \class SdSpiCard
 * \brief Raw access to SD and SDHC flash memory cards via SPI protocol.
 */
#if HAS_SDIO_CLASS
class SdSpiCard : public SdCardInterface {
    b7f0:	bx	lr
    b7f2:	nop

0000b7f4 <SdSpiCard::~SdSpiCard()>:
    b7f4:	push	{r4, lr}
    b7f6:	movs	r1, #24
    b7f8:	mov	r4, r0
    b7fa:	bl	effc <operator delete(void*, unsigned int)>
    b7fe:	mov	r0, r4
    b800:	pop	{r4, pc}
    b802:	nop

0000b804 <SdSpiCard::spiStart() [clone .part.6] [clone .constprop.26]>:
uint32_t SdSpiCard::sectorCount() {
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStart() {
    b804:	push	{r4, lr}
    b806:	mov	r4, r0
  bool waitNotBusy(SdMillis_t timeoutMS);
  bool writeData(uint8_t token, const uint8_t* src);

#if SPI_DRIVER_SELECT < 2
  void spiActivate() {
    m_spiDriver.activate();
    b808:	adds	r0, #4
    b80a:	bl	d228 <SdSpiArduinoDriver::activate()>
  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
  bool isTimedOut(SdMillis_t startMS, SdMillis_t timeoutMS);
  bool readData(uint8_t* dst, size_t count);
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
    b80e:	ldrb	r0, [r4, #18]
    b810:	movs	r1, #0
    b812:	bl	d3d8 <sdCsWrite(unsigned char, bool)>
  if (!m_spiActive) {
    spiActivate();
    spiSelect();
    m_spiActive = true;
    b816:	movs	r3, #1
    b818:	strb	r3, [r4, #20]
    b81a:	pop	{r4, pc}

0000b81c <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>:
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
    b81c:	push	{r3, r4, r5, lr}
    b81e:	mov	r4, r0
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    b820:	movs	r1, #1
    b822:	ldrb	r0, [r0, #18]
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriver.send(data);
    b824:	adds	r5, r4, #4
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    b826:	bl	d3d8 <sdCsWrite(unsigned char, bool)>
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriver.send(data);
    b82a:	mov	r0, r5
    b82c:	movs	r1, #255	; 0xff
    b82e:	bl	d364 <SdSpiArduinoDriver::send(unsigned char)>
  }
  void spiBegin(SdSpiConfig spiConfig) {
    m_spiDriver.begin(spiConfig);
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
    b832:	mov	r0, r5
    b834:	bl	d2f0 <SdSpiArduinoDriver::deactivate()>
  if (m_spiActive) {
    spiUnselect();
    spiSend(0XFF);
    spiDeactivate();
    m_spiActive = false;
    b838:	movs	r3, #0
    b83a:	strb	r3, [r4, #20]
    b83c:	pop	{r3, r4, r5, pc}
    b83e:	nop

0000b840 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    b840:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b844:	mov	r6, r1
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    b846:	ldrb	r1, [r0, #16]
    b848:	cmp	r1, #2
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    b84a:	mov	r5, r0
    b84c:	mov	r4, r2
    b84e:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    b850:	beq.n	b896 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x56>
    if (!writeStart(sector)) {
    b852:	ldr	r3, [r5, #0]
    b854:	mov	r1, r6
    b856:	ldr	r3, [r3, #72]	; 0x48
    b858:	mov	r0, r5
    b85a:	blx	r3
    b85c:	cbz	r0, b882 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x42>
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
    b85e:	movs	r3, #2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    if (!writeStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    b860:	str	r6, [r5, #12]
    m_curState = WRITE_STATE;
    b862:	strb	r3, [r5, #16]
  }
  for (size_t i = 0; i < ns; i++, src += 512) {
    b864:	movs	r6, #0
    b866:	cbnz	r7, b86e <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2e>
    b868:	b.n	b89e <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x5e>
    b86a:	cmp	r7, r6
    b86c:	beq.n	b89e <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x5e>
    if (!writeData(src)) {
    b86e:	ldr	r3, [r5, #0]
    b870:	mov	r1, r4
    b872:	ldr	r3, [r3, #68]	; 0x44
    b874:	mov	r0, r5
    b876:	blx	r3
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
  }
  for (size_t i = 0; i < ns; i++, src += 512) {
    b878:	adds	r6, #1
    b87a:	add.w	r4, r4, #512	; 0x200
    if (!writeData(src)) {
    b87e:	cmp	r0, #0
    b880:	bne.n	b86a <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2a>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    b882:	ldrb	r0, [r5, #20]
    b884:	cbnz	r0, b88a <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x4a>
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    b886:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    b88a:	mov	r0, r5
    b88c:	bl	b81c <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
  return writeStop();
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
    b890:	movs	r0, #0
}
    b892:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    b896:	ldr	r3, [r0, #12]
    b898:	cmp	r3, r6
    b89a:	bne.n	b852 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x12>
    b89c:	b.n	b864 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x24>
  for (size_t i = 0; i < ns; i++, src += 512) {
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
    b89e:	ldr	r3, [r5, #12]
  return m_sharedSpi ? syncDevice() : true;
    b8a0:	ldrb	r2, [r5, #17]
  for (size_t i = 0; i < ns; i++, src += 512) {
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
    b8a2:	add	r7, r3
    b8a4:	str	r7, [r5, #12]
  return m_sharedSpi ? syncDevice() : true;
    b8a6:	cbnz	r2, b8ae <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x6e>
    b8a8:	movs	r0, #1
    b8aa:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    b8ae:	ldr	r3, [r5, #0]
    b8b0:	mov	r0, r5
    b8b2:	ldr	r3, [r3, #24]
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    b8b4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    b8b8:	bx	r3
    b8ba:	nop

0000b8bc <SdSpiCard::isBusy()>:
bool SdSpiCard::eraseSingleSectorEnable() {
  csd_t csd;
  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
    b8bc:	push	{r3, r4, r5, r6, r7, lr}
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    b8be:	ldrb	r3, [r0, #16]
    b8c0:	cmp	r3, #1
    b8c2:	beq.n	b906 <SdSpiCard::isBusy()+0x4a>
    return false;
  }
#endif  // ENABLE_DEDICATED_SPI
  bool rtn = true;
  bool spiActive = m_spiActive;
    b8c4:	ldrb	r7, [r0, #20]
    b8c6:	mov	r5, r0
  if (!spiActive) {
    b8c8:	cbz	r7, b8f6 <SdSpiCard::isBusy()+0x3a>
    b8ca:	adds	r6, r5, #4
bool SdSpiCard::eraseSingleSectorEnable() {
  csd_t csd;
  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
    b8cc:	movs	r4, #8
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    b8ce:	mov	r0, r6
    b8d0:	bl	d328 <SdSpiArduinoDriver::receive()>
  bool spiActive = m_spiActive;
  if (!spiActive) {
    spiStart();
  }
  for (uint8_t i = 0; i < 8; i++) {
    if (0XFF == spiReceive()) {
    b8d4:	cmp	r0, #255	; 0xff
    b8d6:	add.w	r3, r4, #4294967295
    b8da:	beq.n	b8ee <SdSpiCard::isBusy()+0x32>
  bool rtn = true;
  bool spiActive = m_spiActive;
  if (!spiActive) {
    spiStart();
  }
  for (uint8_t i = 0; i < 8; i++) {
    b8dc:	ands.w	r4, r3, #255	; 0xff
    b8e0:	bne.n	b8ce <SdSpiCard::isBusy()+0x12>
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    return false;
  }
#endif  // ENABLE_DEDICATED_SPI
  bool rtn = true;
    b8e2:	movs	r4, #1
    if (0XFF == spiReceive()) {
      rtn = false;
      break;
    }
  }
  if (!spiActive) {
    b8e4:	cbnz	r7, b8ea <SdSpiCard::isBusy()+0x2e>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    b8e6:	ldrb	r3, [r5, #20]
    b8e8:	cbnz	r3, b8fc <SdSpiCard::isBusy()+0x40>
    }
  }
  if (!spiActive) {
    spiStop();
  }
  return rtn;
    b8ea:	mov	r0, r4
}
    b8ec:	pop	{r3, r4, r5, r6, r7, pc}
  if (!spiActive) {
    spiStart();
  }
  for (uint8_t i = 0; i < 8; i++) {
    if (0XFF == spiReceive()) {
      rtn = false;
    b8ee:	movs	r4, #0
      break;
    }
  }
  if (!spiActive) {
    b8f0:	cmp	r7, #0
    b8f2:	beq.n	b8e6 <SdSpiCard::isBusy()+0x2a>
    b8f4:	b.n	b8ea <SdSpiCard::isBusy()+0x2e>
    b8f6:	bl	b804 <SdSpiCard::spiStart() [clone .part.6] [clone .constprop.26]>
    b8fa:	b.n	b8ca <SdSpiCard::isBusy()+0xe>
    b8fc:	mov	r0, r5
    b8fe:	bl	b81c <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    spiStop();
  }
  return rtn;
    b902:	mov	r0, r4
    b904:	pop	{r3, r4, r5, r6, r7, pc}
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    return false;
    b906:	movs	r0, #0
    b908:	pop	{r3, r4, r5, r6, r7, pc}
    b90a:	nop

0000b90c <SdSpiCard::readData(unsigned char*, unsigned int)>:
//------------------------------------------------------------------------------
bool SdSpiCard::readData(uint8_t* dst) {
  return readData(dst, 512);
}
//------------------------------------------------------------------------------
bool SdSpiCard::readData(uint8_t* dst, size_t count) {
    b90c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    b910:	ldr	r6, [pc, #116]	; (b988 <SdSpiCard::readData(unsigned char*, unsigned int)+0x7c>)
    b912:	sub	sp, #12
    b914:	ldr	r3, [r6, #0]
    b916:	str	r3, [sp, #0]
	return ret;
    b918:	ldr	r5, [sp, #0]
    b91a:	mov	r4, r0
    b91c:	mov	r8, r1
    b91e:	mov	r9, r2

  DBG_BEGIN_TIME(DBG_WAIT_READ);
  // wait for start sector token
  SdMillis_t t0 = SysCall::curTimeMS();
  while ((m_status = spiReceive()) == 0XFF) {
    if (isTimedOut(t0, SD_READ_TIMEOUT)) {
    b920:	uxth	r5, r5
    b922:	adds	r7, r0, #4
    b924:	b.n	b936 <SdSpiCard::readData(unsigned char*, unsigned int)+0x2a>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    b926:	ldr	r3, [r6, #0]
    b928:	str	r3, [sp, #4]
	return ret;
    b92a:	ldr	r3, [sp, #4]
    b92c:	uxth	r3, r3
    b92e:	subs	r3, r3, r5
    b930:	cmp.w	r3, #300	; 0x12c
    b934:	bgt.n	b95c <SdSpiCard::readData(unsigned char*, unsigned int)+0x50>
    b936:	mov	r0, r7
    b938:	bl	d328 <SdSpiArduinoDriver::receive()>
#endif  // USE_SD_CRC

  DBG_BEGIN_TIME(DBG_WAIT_READ);
  // wait for start sector token
  SdMillis_t t0 = SysCall::curTimeMS();
  while ((m_status = spiReceive()) == 0XFF) {
    b93c:	cmp	r0, #255	; 0xff
    b93e:	strb	r0, [r4, #21]
    b940:	beq.n	b926 <SdSpiCard::readData(unsigned char*, unsigned int)+0x1a>
      error(SD_CARD_ERROR_READ_TIMEOUT);
      goto fail;
    }
  }
  DBG_END_TIME(DBG_WAIT_READ);
  if (m_status != DATA_START_SECTOR) {
    b942:	cmp	r0, #254	; 0xfe
    b944:	beq.n	b962 <SdSpiCard::readData(unsigned char*, unsigned int)+0x56>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    b946:	movs	r3, #24
    b948:	strb	r3, [r4, #19]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    b94a:	ldrb	r0, [r4, #20]
    b94c:	cbz	r0, b956 <SdSpiCard::readData(unsigned char*, unsigned int)+0x4a>
    b94e:	mov	r0, r4
    b950:	bl	b81c <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
#endif  // USE_SD_CRC
  return true;

 fail:
  spiStop();
  return false;
    b954:	movs	r0, #0
}
    b956:	add	sp, #12
    b958:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    b95c:	movs	r3, #29
    b95e:	strb	r3, [r4, #19]
    b960:	b.n	b94a <SdSpiCard::readData(unsigned char*, unsigned int)+0x3e>
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
    b962:	mov	r2, r9
    b964:	mov	r1, r8
    b966:	mov	r0, r7
    b968:	bl	d344 <SdSpiArduinoDriver::receive(unsigned char*, unsigned int)>
  if (m_status != DATA_START_SECTOR) {
    error(SD_CARD_ERROR_READ_TOKEN);
    goto fail;
  }
  // transfer data
  if ((m_status = spiReceive(dst, count))) {
    b96c:	strb	r0, [r4, #21]
    b96e:	cbz	r0, b976 <SdSpiCard::readData(unsigned char*, unsigned int)+0x6a>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    b970:	movs	r3, #37	; 0x25
    b972:	strb	r3, [r4, #19]
    b974:	b.n	b94a <SdSpiCard::readData(unsigned char*, unsigned int)+0x3e>
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    b976:	mov	r0, r7
    b978:	bl	d328 <SdSpiArduinoDriver::receive()>
    b97c:	mov	r0, r7
    b97e:	bl	d328 <SdSpiArduinoDriver::receive()>
#else  // USE_SD_CRC
  // discard crc
  spiReceive();
  spiReceive();
#endif  // USE_SD_CRC
  return true;
    b982:	movs	r0, #1
    b984:	b.n	b956 <SdSpiCard::readData(unsigned char*, unsigned int)+0x4a>
    b986:	nop
    b988:	.word	0x1fff66b0

0000b98c <SdSpiCard::waitNotBusy(unsigned short)>:
#endif  // ENABLE_DEDICATED_SPI
  return true;
}
//------------------------------------------------------------------------------
// wait for card to go not busy
bool SdSpiCard::waitNotBusy(SdMillis_t timeoutMS) {
    b98c:	push	{r4, r5, r6, r7, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    b98e:	ldr	r5, [pc, #52]	; (b9c4 <SdSpiCard::waitNotBusy(unsigned short)+0x38>)
    b990:	sub	sp, #12
    b992:	ldr	r3, [r5, #0]
    b994:	str	r3, [sp, #0]
	return ret;
    b996:	ldr	r4, [sp, #0]
    b998:	mov	r7, r1
    b99a:	adds	r6, r0, #4
  }
  return false;
#else  // WDT_YIELD_TIME_MILLIS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    if (isTimedOut(t0, timeoutMS)) {
    b99c:	uxth	r4, r4
    b99e:	b.n	b9ae <SdSpiCard::waitNotBusy(unsigned short)+0x22>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    b9a0:	ldr	r3, [r5, #0]
    b9a2:	str	r3, [sp, #4]
	return ret;
    b9a4:	ldr	r3, [sp, #4]
    b9a6:	uxth	r3, r3
    b9a8:	subs	r3, r3, r4
    b9aa:	cmp	r3, r7
    b9ac:	bgt.n	b9be <SdSpiCard::waitNotBusy(unsigned short)+0x32>
    b9ae:	mov	r0, r6
    b9b0:	bl	d328 <SdSpiArduinoDriver::receive()>
    }
  }
  return false;
#else  // WDT_YIELD_TIME_MILLIS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    b9b4:	cmp	r0, #255	; 0xff
    b9b6:	bne.n	b9a0 <SdSpiCard::waitNotBusy(unsigned short)+0x14>
    if (isTimedOut(t0, timeoutMS)) {
      return false;
    }
  }
  return true;
    b9b8:	movs	r0, #1
#endif  // WDT_YIELD_TIME_MILLIS
}
    b9ba:	add	sp, #12
    b9bc:	pop	{r4, r5, r6, r7, pc}
  return false;
#else  // WDT_YIELD_TIME_MILLIS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    if (isTimedOut(t0, timeoutMS)) {
      return false;
    b9be:	movs	r0, #0
    }
  }
  return true;
#endif  // WDT_YIELD_TIME_MILLIS
}
    b9c0:	add	sp, #12
    b9c2:	pop	{r4, r5, r6, r7, pc}
    b9c4:	.word	0x1fff66b0

0000b9c8 <SdSpiCard::cardCommand(unsigned char, unsigned long)>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
    b9c8:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b9cc:	sub	sp, #8
#if ENABLE_DEDICATED_SPI
  if (m_curState != IDLE_STATE && !syncDevice()) {
    b9ce:	ldrb	r3, [r0, #16]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
    b9d0:	str	r2, [sp, #4]
    b9d2:	mov	r4, r0
    b9d4:	mov	r7, r1
#if ENABLE_DEDICATED_SPI
  if (m_curState != IDLE_STATE && !syncDevice()) {
    b9d6:	cbnz	r3, ba38 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x70>
    return 0XFF;
  }
#endif  // ENABLE_DEDICATED_SPI
  // select card
  if (!m_spiActive) {
    b9d8:	ldrb	r3, [r4, #20]
    b9da:	cmp	r3, #0
    b9dc:	beq.n	ba56 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x8e>
    spiStart();
  }
  // wait if busy unless CMD0
  if (cmd != CMD0) {
    b9de:	cmp	r7, #0
    b9e0:	bne.n	ba4a <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x82>
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriver.send(data);
    b9e2:	adds	r5, r4, #4
    b9e4:	mov	r0, r5
    b9e6:	orr.w	r1, r7, #64	; 0x40
    b9ea:	bl	d364 <SdSpiArduinoDriver::send(unsigned char)>
    b9ee:	add.w	r8, sp, #4
    b9f2:	add	r6, sp, #8
    b9f4:	ldrb.w	r1, [r6, #-1]!
    b9f8:	mov	r0, r5
    b9fa:	bl	d364 <SdSpiArduinoDriver::send(unsigned char)>
  // send command
  spiSend(cmd | 0x40);

  // send argument
  uint8_t* pa = reinterpret_cast<uint8_t*>(&arg);
  for (int8_t i = 3; i >= 0; i--) {
    b9fe:	cmp	r8, r6
    ba00:	bne.n	b9f4 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x2c>
    spiSend(pa[i]);
  }

  // send CRC - correct for CMD0 with arg zero or CMD8 with arg 0X1AA
  spiSend(cmd == CMD0 ? 0X95 : 0X87);
    ba02:	cmp	r7, #0
    ba04:	ite	eq
    ba06:	moveq	r1, #149	; 0x95
    ba08:	movne	r1, #135	; 0x87
    ba0a:	mov	r0, r5
    ba0c:	bl	d364 <SdSpiArduinoDriver::send(unsigned char)>
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    ba10:	mov	r0, r5
    ba12:	bl	d328 <SdSpiArduinoDriver::receive()>
    ba16:	movs	r6, #11
    ba18:	mov	r0, r5
    ba1a:	bl	d328 <SdSpiArduinoDriver::receive()>

  // discard first fill byte to avoid MISO pull-up problem.
  spiReceive();

  // there are 1-8 fill bytes before response.  fill bytes should be 0XFF.
  for (uint8_t i = 0; ((m_status = spiReceive()) & 0X80) && i < 10; i++) {
    ba1e:	lsls	r3, r0, #24
    ba20:	strb	r0, [r4, #21]
    ba22:	bmi.n	ba2a <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x62>
  }
  return m_status;
}
    ba24:	add	sp, #8
    ba26:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ba2a:	subs	r3, r6, #1

  // discard first fill byte to avoid MISO pull-up problem.
  spiReceive();

  // there are 1-8 fill bytes before response.  fill bytes should be 0XFF.
  for (uint8_t i = 0; ((m_status = spiReceive()) & 0X80) && i < 10; i++) {
    ba2c:	ands.w	r6, r3, #255	; 0xff
    ba30:	bne.n	ba18 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x50>
  }
  return m_status;
}
    ba32:	add	sp, #8
    ba34:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
#if ENABLE_DEDICATED_SPI
  if (m_curState != IDLE_STATE && !syncDevice()) {
    ba38:	ldr	r3, [r0, #0]
    ba3a:	ldr	r3, [r3, #24]
    ba3c:	blx	r3
    ba3e:	cmp	r0, #0
    ba40:	bne.n	b9d8 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x10>
    return 0XFF;
    ba42:	movs	r0, #255	; 0xff

  // there are 1-8 fill bytes before response.  fill bytes should be 0XFF.
  for (uint8_t i = 0; ((m_status = spiReceive()) & 0X80) && i < 10; i++) {
  }
  return m_status;
}
    ba44:	add	sp, #8
    ba46:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    spiStart();
  }
  // wait if busy unless CMD0
  if (cmd != CMD0) {
    DBG_BEGIN_TIME(DBG_CMD_BUSY);
    waitNotBusy(SD_CMD_TIMEOUT);
    ba4a:	mov.w	r1, #300	; 0x12c
    ba4e:	mov	r0, r4
    ba50:	bl	b98c <SdSpiCard::waitNotBusy(unsigned short)>
    ba54:	b.n	b9e2 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x1a>
    ba56:	mov	r0, r4
    ba58:	bl	b804 <SdSpiCard::spiStart() [clone .part.6] [clone .constprop.26]>
    ba5c:	b.n	b9de <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x16>
    ba5e:	nop

0000ba60 <SdSpiCard::begin(SdSpiConfig)>:
#endif  // CRC_CCITT
#endif  // USE_SD_CRC
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(SdSpiConfig spiConfig) {
    ba60:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    ba64:	sub	sp, #40	; 0x28
    ba66:	add	r5, sp, #4
    ba68:	stmia.w	r5, {r1, r2, r3}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    ba6c:	ldr	r7, [pc, #492]	; (bc5c <SdSpiCard::begin(SdSpiConfig)+0x1fc>)
    ba6e:	ldrb.w	r3, [sp, #4]
    ba72:	ldr	r2, [r7, #0]
  SdMillis_t t0 = SysCall::curTimeMS();
  m_spiActive = false;
  m_errorCode = SD_CARD_ERROR_NONE;
  m_type = 0;
  m_csPin = spiConfig.csPin;
    ba74:	strb	r3, [r0, #18]
#endif  // CRC_CCITT
#endif  // USE_SD_CRC
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(SdSpiConfig spiConfig) {
    ba76:	mov	r6, r0
  SdMillis_t t0 = SysCall::curTimeMS();
  m_spiActive = false;
    ba78:	mov.w	sl, #0
    ba7c:	str	r2, [sp, #20]
  if (!m_spiDriverPtr) {
    error(SD_CARD_ERROR_INVALID_CARD_CONFIG);
    goto fail;
  }
#endif  // SPI_DRIVER_SELECT
  sdCsInit(m_csPin);
    ba7e:	mov	r0, r3
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(SdSpiConfig spiConfig) {
  SdMillis_t t0 = SysCall::curTimeMS();
  m_spiActive = false;
    ba80:	strb.w	sl, [r6, #20]
  m_errorCode = SD_CARD_ERROR_NONE;
    ba84:	strb.w	sl, [r6, #19]
  m_type = 0;
    ba88:	strb.w	sl, [r6, #22]
    ba8c:	ldrb.w	r4, [sp, #5]
	return ret;
    ba90:	ldr.w	r8, [sp, #20]
    ba94:	ldr.w	r9, [sp, #8]
  if (!m_spiDriverPtr) {
    error(SD_CARD_ERROR_INVALID_CARD_CONFIG);
    goto fail;
  }
#endif  // SPI_DRIVER_SELECT
  sdCsInit(m_csPin);
    ba98:	bl	d3d0 <sdCsInit(unsigned char)>
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    ba9c:	ldrb	r0, [r6, #18]
    ba9e:	movs	r1, #1
    baa0:	bl	d3d8 <sdCsWrite(unsigned char, bool)>
    baa4:	ldmia.w	r5, {r0, r1, r2}
    baa8:	add	r3, sp, #28
    baaa:	stmia.w	r3, {r0, r1, r2}
#if SPI_DRIVER_SELECT < 2
  void spiActivate() {
    m_spiDriver.activate();
  }
  void spiBegin(SdSpiConfig spiConfig) {
    m_spiDriver.begin(spiConfig);
    baae:	adds	r5, r6, #4
  /** Save high speed SPISettings after SD initialization.
   *
   * \param[in] maxSck Maximum SCK frequency.
   */
  void setSckSpeed(uint32_t maxSck) {
    m_spiSettings = SPISettings(maxSck, MSBFIRST, SPI_MODE0);
    bab0:	ldr	r2, [pc, #428]	; (bc60 <SdSpiCard::begin(SdSpiConfig)+0x200>)
    bab2:	str	r2, [r6, #8]
    bab4:	mov	r0, r5
    bab6:	ldmia	r3, {r1, r2, r3}
    bab8:	bl	d2a0 <SdSpiArduinoDriver::begin(SdSpiConfig)>
  spiSetSckSpeed(1000UL*SD_MAX_INIT_RATE_KHZ);
  spiBegin(spiConfig);
  uint32_t arg;
#if ENABLE_DEDICATED_SPI
  m_curState = IDLE_STATE;
  m_sharedSpi = spiOptionShared(spiConfig.options);
    babc:	and.w	r3, r4, #1
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStart() {
  if (!m_spiActive) {
    bac0:	ldrb	r2, [r6, #20]
  spiUnselect();
  spiSetSckSpeed(1000UL*SD_MAX_INIT_RATE_KHZ);
  spiBegin(spiConfig);
  uint32_t arg;
#if ENABLE_DEDICATED_SPI
  m_curState = IDLE_STATE;
    bac2:	strb.w	sl, [r6, #16]
  m_sharedSpi = spiOptionShared(spiConfig.options);
    bac6:	eor.w	r3, r3, #1
    baca:	strb	r3, [r6, #17]
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStart() {
  if (!m_spiActive) {
    bacc:	cmp	r2, #0
    bace:	beq.w	bbe8 <SdSpiCard::begin(SdSpiConfig)+0x188>
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    bad2:	movs	r1, #1
    bad4:	ldrb	r0, [r6, #18]
    bad6:	bl	d3d8 <sdCsWrite(unsigned char, bool)>
    bada:	movs	r4, #10
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriver.send(data);
    badc:	movs	r1, #255	; 0xff
    bade:	mov	r0, r5
    bae0:	bl	d364 <SdSpiArduinoDriver::send(unsigned char)>
    bae4:	subs	r3, r4, #1
#endif  // ENABLE_DEDICATED_SPI
  spiStart();

  // must supply min of 74 clock cycles with CS high.
  spiUnselect();
  for (uint8_t i = 0; i < 10; i++) {
    bae6:	ands.w	r4, r3, #255	; 0xff
    baea:	bne.n	badc <SdSpiCard::begin(SdSpiConfig)+0x7c>
  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
  bool isTimedOut(SdMillis_t startMS, SdMillis_t timeoutMS);
  bool readData(uint8_t* dst, size_t count);
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
    baec:	mov	r1, r4
    baee:	ldrb	r0, [r6, #18]
    baf0:	bl	d3d8 <sdCsWrite(unsigned char, bool)>
    baf4:	mov.w	sl, #10
  spiSelect();
  DBG_BEGIN_TIME(DBG_CMD0_TIME);
  // command to go idle in SPI mode
  for (uint8_t i = 1;; i++) {
    DBG_EVENT_COUNT(DBG_CMD0_COUNT);
    if (cardCommand(CMD0, 0) == R1_IDLE_STATE) {
    baf8:	movs	r2, #0
    bafa:	mov	r1, r2
    bafc:	mov	r0, r6
    bafe:	bl	b9c8 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    bb02:	cmp	r0, #1
    bb04:	mov	r4, r0
    bb06:	beq.n	bb46 <SdSpiCard::begin(SdSpiConfig)+0xe6>
    bb08:	add.w	r3, sl, #4294967295
      break;
    }
    if (i == SD_CMD0_RETRY) {
    bb0c:	ands.w	sl, r3, #255	; 0xff
    bb10:	beq.n	bb2a <SdSpiCard::begin(SdSpiConfig)+0xca>
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriver.send(data);
    bb12:	movs	r1, #253	; 0xfd
    bb14:	mov	r0, r5
    bb16:	bl	d364 <SdSpiArduinoDriver::send(unsigned char)>
    bb1a:	mov.w	r4, #520	; 0x208
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    bb1e:	mov	r0, r5
    bb20:	bl	d328 <SdSpiArduinoDriver::receive()>
      goto fail;
    }
    // stop multi-block write
    spiSend(STOP_TRAN_TOKEN);
    // finish block transfer
    for (int i = 0; i < 520; i++) {
    bb24:	subs	r4, #1
    bb26:	bne.n	bb1e <SdSpiCard::begin(SdSpiConfig)+0xbe>
    bb28:	b.n	baf8 <SdSpiCard::begin(SdSpiConfig)+0x98>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    bb2a:	movs	r3, #1
    bb2c:	strb	r3, [r6, #19]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    bb2e:	ldrb	r0, [r6, #20]
    bb30:	cbnz	r0, bb38 <SdSpiCard::begin(SdSpiConfig)+0xd8>
  return true;

 fail:
  spiStop();
  return false;
}
    bb32:	add	sp, #40	; 0x28
    bb34:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    bb38:	mov	r0, r6
    bb3a:	bl	b81c <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
  spiSetSckSpeed(spiConfig.maxSck);
  return true;

 fail:
  spiStop();
  return false;
    bb3e:	movs	r0, #0
}
    bb40:	add	sp, #40	; 0x28
    bb42:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    goto fail;
  }
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    bb46:	mov.w	r2, #426	; 0x1aa
    bb4a:	movs	r1, #8
    bb4c:	mov	r0, r6
    bb4e:	bl	b9c8 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    bb52:	lsls	r3, r0, #29
    bb54:	bpl.n	bbf0 <SdSpiCard::begin(SdSpiConfig)+0x190>
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    bb56:	strb	r4, [r6, #22]
    }
  } else {
    type(SD_CARD_TYPE_SD1);
  }
  // initialize card and send host supports SDHC if SD2
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
    bb58:	ldr	r3, [r6, #0]
    bb5a:	ldr.w	sl, [pc, #276]	; bc70 <SdSpiCard::begin(SdSpiConfig)+0x210>
    bb5e:	ldr	r3, [r3, #64]	; 0x40
    bb60:	cmp	r3, sl
    bb62:	bne.n	bc16 <SdSpiCard::begin(SdSpiConfig)+0x1b6>
  bool syncDevice();
  /** Return the card type: SD V1, SD V2 or SDHC/SDXC
   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC/SDXC.
   */
  uint8_t type() const {
    return m_type;
    bb64:	ldrb	r0, [r6, #22]
    bb66:	cmp	r0, #2
    bb68:	ite	eq
    bb6a:	moveq.w	r4, #1073741824	; 0x40000000
    bb6e:	movne	r4, #0
    bb70:	b.n	bb82 <SdSpiCard::begin(SdSpiConfig)+0x122>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    bb72:	ldr	r3, [r7, #0]
    bb74:	str	r3, [sp, #24]
	return ret;
    bb76:	ldr	r3, [sp, #24]
  DBG_BEGIN_TIME(DBG_ACMD41_TIME);
  while (cardAcmd(ACMD41, arg) != R1_READY_STATE) {
    DBG_EVENT_COUNT(DBG_ACMD41_COUNT);
    // check for timeout
    if (isTimedOut(t0, SD_INIT_TIMEOUT)) {
    bb78:	uxth	r3, r3
    bb7a:	subs	r3, r3, r2
    bb7c:	cmp.w	r3, #2000	; 0x7d0
    bb80:	bgt.n	bc10 <SdSpiCard::begin(SdSpiConfig)+0x1b0>
  void spiStop();

 private:
  // private functions
  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
    cardCommand(CMD55, 0);
    bb82:	movs	r2, #0
    bb84:	movs	r1, #55	; 0x37
    bb86:	mov	r0, r6
    bb88:	bl	b9c8 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    return cardCommand(cmd, arg);
    bb8c:	mov	r2, r4
    bb8e:	movs	r1, #41	; 0x29
    bb90:	mov	r0, r6
    bb92:	bl	b9c8 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    bb96:	uxth.w	r2, r8
    type(SD_CARD_TYPE_SD1);
  }
  // initialize card and send host supports SDHC if SD2
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
  DBG_BEGIN_TIME(DBG_ACMD41_TIME);
  while (cardAcmd(ACMD41, arg) != R1_READY_STATE) {
    bb9a:	cmp	r0, #0
    bb9c:	bne.n	bb72 <SdSpiCard::begin(SdSpiConfig)+0x112>
    }
  }
  DBG_END_TIME(DBG_ACMD41_TIME);

  // if SD2 read OCR register to check for SDHC card
  if (type() == SD_CARD_TYPE_SD2) {
    bb9e:	ldr	r3, [r6, #0]
    bba0:	ldr	r3, [r3, #64]	; 0x40
    bba2:	cmp	r3, sl
    bba4:	bne.n	bc1c <SdSpiCard::begin(SdSpiConfig)+0x1bc>
  bool syncDevice();
  /** Return the card type: SD V1, SD V2 or SDHC/SDXC
   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC/SDXC.
   */
  uint8_t type() const {
    return m_type;
    bba6:	ldrb	r0, [r6, #22]
    bba8:	cmp	r0, #2
    bbaa:	beq.n	bc22 <SdSpiCard::begin(SdSpiConfig)+0x1c2>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    bbac:	ldrb	r3, [r6, #20]
    bbae:	cbz	r3, bbb6 <SdSpiCard::begin(SdSpiConfig)+0x156>
    bbb0:	mov	r0, r6
    bbb2:	bl	b81c <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    bbb6:	ldr	r1, [pc, #172]	; (bc64 <SdSpiCard::begin(SdSpiConfig)+0x204>)
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
				t = ctar_clock_table[i];
				if (clock >= F_BUS / ctar_div_table[i]) break;
    bbb8:	ldr	r4, [pc, #172]	; (bc68 <SdSpiCard::begin(SdSpiConfig)+0x208>)
    }
  } else {
    type(SD_CARD_TYPE_SD1);
  }
  // initialize card and send host supports SDHC if SD2
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
    bbba:	movs	r3, #0
    bbbc:	b.n	bbc4 <SdSpiCard::begin(SdSpiConfig)+0x164>
				t = SPI_CTAR_PBR(2) | SPI_CTAR_BR(7) | SPI_CTAR_CSSCK(6);
			} else {	 /* F_BUS / 768 */
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
    bbbe:	cmp	r0, #23
    bbc0:	beq.n	bbd4 <SdSpiCard::begin(SdSpiConfig)+0x174>
    bbc2:	mov	r3, r0
				t = ctar_clock_table[i];
				if (clock >= F_BUS / ctar_div_table[i]) break;
    bbc4:	ldrh.w	r2, [r1, #2]!
    bbc8:	sdiv	r2, r4, r2
    bbcc:	cmp	r9, r2
				t = SPI_CTAR_PBR(2) | SPI_CTAR_BR(7) | SPI_CTAR_CSSCK(6);
			} else {	 /* F_BUS / 768 */
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
    bbce:	add.w	r0, r3, #1
				t = ctar_clock_table[i];
				if (clock >= F_BUS / ctar_div_table[i]) break;
    bbd2:	bcc.n	bbbe <SdSpiCard::begin(SdSpiConfig)+0x15e>
			} else {	 /* F_BUS / 768 */
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
				t = ctar_clock_table[i];
    bbd4:	ldr	r2, [pc, #148]	; (bc6c <SdSpiCard::begin(SdSpiConfig)+0x20c>)
    bbd6:	ldr.w	r3, [r2, r3, lsl #2]
      spiReceive();
    }
  }
  spiStop();
  spiSetSckSpeed(spiConfig.maxSck);
  return true;
    bbda:	movs	r0, #1
    bbdc:	orr.w	r3, r3, #939524096	; 0x38000000
    bbe0:	str	r3, [r6, #8]

 fail:
  spiStop();
  return false;
}
    bbe2:	add	sp, #40	; 0x28
    bbe4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    bbe8:	mov	r0, r6
    bbea:	bl	b804 <SdSpiCard::spiStart() [clone .part.6] [clone .constprop.26]>
    bbee:	b.n	bad2 <SdSpiCard::begin(SdSpiConfig)+0x72>
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    bbf0:	movs	r3, #2
    bbf2:	strb	r3, [r6, #22]
    bbf4:	movs	r4, #4
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    bbf6:	mov	r0, r5
    bbf8:	bl	d328 <SdSpiArduinoDriver::receive()>
    bbfc:	subs	r4, #1
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    type(SD_CARD_TYPE_SD2);
    for (uint8_t i = 0; i < 4; i++) {
    bbfe:	ands.w	r4, r4, #255	; 0xff
      m_status = spiReceive();
    bc02:	strb	r0, [r6, #21]
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    type(SD_CARD_TYPE_SD2);
    for (uint8_t i = 0; i < 4; i++) {
    bc04:	bne.n	bbf6 <SdSpiCard::begin(SdSpiConfig)+0x196>
      m_status = spiReceive();
    }
    if (m_status != 0XAA) {
    bc06:	cmp	r0, #170	; 0xaa
    bc08:	beq.n	bb58 <SdSpiCard::begin(SdSpiConfig)+0xf8>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    bc0a:	movs	r3, #6
    bc0c:	strb	r3, [r6, #19]
    bc0e:	b.n	bb2e <SdSpiCard::begin(SdSpiConfig)+0xce>
    bc10:	movs	r3, #23
    bc12:	strb	r3, [r6, #19]
    bc14:	b.n	bb2e <SdSpiCard::begin(SdSpiConfig)+0xce>
    }
  } else {
    type(SD_CARD_TYPE_SD1);
  }
  // initialize card and send host supports SDHC if SD2
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
    bc16:	mov	r0, r6
    bc18:	blx	r3
    bc1a:	b.n	bb66 <SdSpiCard::begin(SdSpiConfig)+0x106>
    }
  }
  DBG_END_TIME(DBG_ACMD41_TIME);

  // if SD2 read OCR register to check for SDHC card
  if (type() == SD_CARD_TYPE_SD2) {
    bc1c:	mov	r0, r6
    bc1e:	blx	r3
    bc20:	b.n	bba8 <SdSpiCard::begin(SdSpiConfig)+0x148>
    if (cardCommand(CMD58, 0)) {
    bc22:	movs	r2, #0
    bc24:	movs	r1, #58	; 0x3a
    bc26:	mov	r0, r6
    bc28:	bl	b9c8 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    bc2c:	cbz	r0, bc34 <SdSpiCard::begin(SdSpiConfig)+0x1d4>
    bc2e:	movs	r3, #18
    bc30:	strb	r3, [r6, #19]
    bc32:	b.n	bb2e <SdSpiCard::begin(SdSpiConfig)+0xce>
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    bc34:	mov	r0, r5
    bc36:	bl	d328 <SdSpiArduinoDriver::receive()>
      error(SD_CARD_ERROR_CMD58);
      goto fail;
    }
    if ((spiReceive() & 0XC0) == 0XC0) {
    bc3a:	and.w	r0, r0, #192	; 0xc0
    bc3e:	cmp	r0, #192	; 0xc0
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    bc40:	itt	eq
    bc42:	moveq	r3, #3
    bc44:	strbeq	r3, [r6, #22]
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    bc46:	mov	r0, r5
    bc48:	bl	d328 <SdSpiArduinoDriver::receive()>
    bc4c:	mov	r0, r5
    bc4e:	bl	d328 <SdSpiArduinoDriver::receive()>
    bc52:	mov	r0, r5
    bc54:	bl	d328 <SdSpiArduinoDriver::receive()>
    bc58:	b.n	bbac <SdSpiCard::begin(SdSpiConfig)+0x14c>
    bc5a:	nop
    bc5c:	.word	0x1fff66b0
    bc60:	.word	0x38005006
    bc64:	.word	0x00014546
    bc68:	.word	0x02dc6c00
    bc6c:	.word	0x0001460c
    bc70:	.word	0x0000b7ed

0000bc74 <SdSpiCard::readOCR(unsigned long*)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    bc74:	push	{r3, r4, r5, r6, r7, lr}
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    bc76:	movs	r2, #0
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    bc78:	mov	r5, r1
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    bc7a:	movs	r1, #58	; 0x3a
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    bc7c:	mov	r6, r0
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    bc7e:	bl	b9c8 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    bc82:	cbnz	r0, bca0 <SdSpiCard::readOCR(unsigned long*)+0x2c>
    bc84:	adds	r7, r6, #4
    bc86:	adds	r4, r5, #4
    bc88:	mov	r0, r7
    bc8a:	bl	d328 <SdSpiArduinoDriver::receive()>
    error(SD_CARD_ERROR_CMD58);
    goto fail;
  }
  for (uint8_t i = 0; i < 4; i++) {
    p[3 - i] = spiReceive();
    bc8e:	strb.w	r0, [r4, #-1]!
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    error(SD_CARD_ERROR_CMD58);
    goto fail;
  }
  for (uint8_t i = 0; i < 4; i++) {
    bc92:	cmp	r5, r4
    bc94:	bne.n	bc88 <SdSpiCard::readOCR(unsigned long*)+0x14>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    bc96:	ldrb	r4, [r6, #20]
    bc98:	cbnz	r4, bcb6 <SdSpiCard::readOCR(unsigned long*)+0x42>
    bc9a:	movs	r4, #1
  return true;

 fail:
  spiStop();
  return false;
}
    bc9c:	mov	r0, r4
    bc9e:	pop	{r3, r4, r5, r6, r7, pc}
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    bca0:	ldrb	r4, [r6, #20]
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    bca2:	movs	r3, #18
    bca4:	strb	r3, [r6, #19]
    bca6:	cmp	r4, #0
    bca8:	beq.n	bc9c <SdSpiCard::readOCR(unsigned long*)+0x28>
    bcaa:	mov	r0, r6
  spiStop();
  return true;

 fail:
  spiStop();
  return false;
    bcac:	movs	r4, #0
    bcae:	bl	b81c <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
}
    bcb2:	mov	r0, r4
    bcb4:	pop	{r3, r4, r5, r6, r7, pc}
    bcb6:	mov	r0, r6
    bcb8:	bl	b81c <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    bcbc:	mov	r0, r4
    bcbe:	pop	{r3, r4, r5, r6, r7, pc}

0000bcc0 <SdSpiCard::readRegister(unsigned char, void*)>:
//------------------------------------------------------------------------------
/** read CID or CSR register */
bool SdSpiCard::readRegister(uint8_t cmd, void* buf) {
    bcc0:	push	{r3, r4, r5, lr}
    bcc2:	mov	r5, r2
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
  if (cardCommand(cmd, 0)) {
    bcc4:	movs	r2, #0
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
/** read CID or CSR register */
bool SdSpiCard::readRegister(uint8_t cmd, void* buf) {
    bcc6:	mov	r4, r0
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
  if (cardCommand(cmd, 0)) {
    bcc8:	bl	b9c8 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    bccc:	cbz	r0, bce0 <SdSpiCard::readRegister(unsigned char, void*)+0x20>
    bcce:	movs	r3, #27
    bcd0:	strb	r3, [r4, #19]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    bcd2:	ldrb	r0, [r4, #20]
    bcd4:	cbz	r0, bcde <SdSpiCard::readRegister(unsigned char, void*)+0x1e>
    bcd6:	mov	r0, r4
    bcd8:	bl	b81c <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
  spiStop();
  return true;

 fail:
  spiStop();
  return false;
    bcdc:	movs	r0, #0
}
    bcde:	pop	{r3, r4, r5, pc}
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
  if (cardCommand(cmd, 0)) {
    error(SD_CARD_ERROR_READ_REG);
    goto fail;
  }
  if (!readData(dst, 16)) {
    bce0:	mov	r1, r5
    bce2:	movs	r2, #16
    bce4:	mov	r0, r4
    bce6:	bl	b90c <SdSpiCard::readData(unsigned char*, unsigned int)>
    bcea:	cmp	r0, #0
    bcec:	beq.n	bcd2 <SdSpiCard::readRegister(unsigned char, void*)+0x12>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    bcee:	ldrb	r5, [r4, #20]
    bcf0:	cmp	r5, #0
    bcf2:	beq.n	bcde <SdSpiCard::readRegister(unsigned char, void*)+0x1e>
    bcf4:	mov	r0, r4
    bcf6:	bl	b81c <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    bcfa:	mov	r0, r5
    bcfc:	pop	{r3, r4, r5, pc}
    bcfe:	nop

0000bd00 <SdSpiCard::readCSD(csd_t*)>:
   * \param[out] csd pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCSD(csd_t* csd) {
    return readRegister(CMD9, csd);
    bd00:	mov	r2, r1
    bd02:	movs	r1, #9
    bd04:	b.w	bcc0 <SdSpiCard::readRegister(unsigned char, void*)>

0000bd08 <SdSpiCard::readCID(CID*)>:
   * \param[out] cid pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCID(cid_t* cid) {
    return readRegister(CMD10, cid);
    bd08:	mov	r2, r1
    bd0a:	movs	r1, #10
    bd0c:	b.w	bcc0 <SdSpiCard::readRegister(unsigned char, void*)>

0000bd10 <SdSpiCard::sectorCount()>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
uint32_t SdSpiCard::sectorCount() {
    bd10:	push	{r4, r5, lr}
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
    bd12:	ldr	r3, [r0, #0]
    bd14:	ldr	r2, [pc, #140]	; (bda4 <SdSpiCard::sectorCount()+0x94>)
    bd16:	ldr	r3, [r3, #52]	; 0x34
    bd18:	cmp	r3, r2
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
uint32_t SdSpiCard::sectorCount() {
    bd1a:	sub	sp, #20
    bd1c:	bne.n	bd7e <SdSpiCard::sectorCount()+0x6e>
   * \param[out] csd pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCSD(csd_t* csd) {
    return readRegister(CMD9, csd);
    bd1e:	mov	r2, sp
    bd20:	movs	r1, #9
    bd22:	bl	bcc0 <SdSpiCard::readRegister(unsigned char, void*)>
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
    bd26:	cbz	r0, bd38 <SdSpiCard::sectorCount()+0x28>
  csd1_t v1;
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    bd28:	ldrb.w	r3, [sp]
    bd2c:	ands.w	r3, r3, #192	; 0xc0
    bd30:	beq.n	bd3c <SdSpiCard::sectorCount()+0x2c>
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    bd32:	cmp	r3, #64	; 0x40
    bd34:	beq.n	bd84 <SdSpiCard::sectorCount()+0x74>
    bd36:	movs	r0, #0
}
    bd38:	add	sp, #20
    bd3a:	pop	{r4, r5, pc}
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
    bd3c:	ldrb.w	r4, [sp, #9]
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
    bd40:	ldrb.w	r3, [sp, #6]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    bd44:	ldrb.w	r2, [sp, #7]
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    bd48:	ldrb.w	r0, [sp, #10]
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    bd4c:	ldrb.w	r1, [sp, #5]
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    bd50:	ldrb.w	r5, [sp, #8]
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    bd54:	and.w	r4, r4, #3
    bd58:	lsls	r4, r4, #1
    bd5a:	lsls	r2, r2, #2
    bd5c:	and.w	r3, r3, #3
    bd60:	orr.w	r0, r4, r0, lsr #7
    bd64:	and.w	r1, r1, #15
    bd68:	orr.w	r3, r2, r3, lsl #10
    bd6c:	add	r0, r1
    bd6e:	orr.w	r3, r3, r5, lsr #6
    bd72:	adds	r3, #1
    bd74:	subs	r0, #7
    bd76:	lsl.w	r0, r3, r0
    bd7a:	add	sp, #20
    bd7c:	pop	{r4, r5, pc}
  return false;
}
//------------------------------------------------------------------------------
uint32_t SdSpiCard::sectorCount() {
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
    bd7e:	mov	r1, sp
    bd80:	blx	r3
    bd82:	b.n	bd26 <SdSpiCard::sectorCount()+0x16>
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    bd84:	ldrb.w	r3, [sp, #9]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
    bd88:	ldrb.w	r1, [sp, #7]
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    bd8c:	ldrb.w	r0, [sp, #8]
    bd90:	adds	r2, r3, #1
    bd92:	and.w	r3, r1, #63	; 0x3f
    bd96:	add.w	r3, r2, r3, lsl #16
    bd9a:	add.w	r0, r3, r0, lsl #8
    bd9e:	lsls	r0, r0, #10
}
    bda0:	add	sp, #20
    bda2:	pop	{r4, r5, pc}
    bda4:	.word	0x0000bd01

0000bda8 <SdSpiCard::readStart(unsigned long)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
    bda8:	push	{r4, r5, lr}
  if (type() != SD_CARD_TYPE_SDHC) {
    bdaa:	ldr	r3, [r0, #0]
    bdac:	ldr	r5, [pc, #68]	; (bdf4 <SdSpiCard::readStart(unsigned long)+0x4c>)
    bdae:	ldr	r3, [r3, #64]	; 0x40
    bdb0:	cmp	r3, r5
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
    bdb2:	sub	sp, #12
    bdb4:	mov	r4, r0
    bdb6:	mov	r2, r1
    bdb8:	bne.n	bdea <SdSpiCard::readStart(unsigned long)+0x42>
  bool syncDevice();
  /** Return the card type: SD V1, SD V2 or SDHC/SDXC
   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC/SDXC.
   */
  uint8_t type() const {
    return m_type;
    bdba:	ldrb	r0, [r0, #22]
  if (type() != SD_CARD_TYPE_SDHC) {
    bdbc:	cmp	r0, #3
    sector <<= 9;
    bdbe:	it	ne
    bdc0:	lslne	r2, r2, #9
  }
  if (cardCommand(CMD18, sector)) {
    bdc2:	movs	r1, #18
    bdc4:	mov	r0, r4
    bdc6:	bl	b9c8 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    bdca:	cbz	r0, bde4 <SdSpiCard::readStart(unsigned long)+0x3c>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    bdcc:	ldrb	r0, [r4, #20]
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    bdce:	movs	r3, #12
    bdd0:	strb	r3, [r4, #19]
    bdd2:	cbnz	r0, bdd8 <SdSpiCard::readStart(unsigned long)+0x30>
  return true;

 fail:
  spiStop();
  return false;
}
    bdd4:	add	sp, #12
    bdd6:	pop	{r4, r5, pc}
    bdd8:	mov	r0, r4
    bdda:	bl	b81c <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    bdde:	movs	r0, #0
    bde0:	add	sp, #12
    bde2:	pop	{r4, r5, pc}
  if (cardCommand(CMD18, sector)) {
    error(SD_CARD_ERROR_CMD18);
    goto fail;
  }
//  spiStop();
  return true;
    bde4:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    bde6:	add	sp, #12
    bde8:	pop	{r4, r5, pc}
    bdea:	str	r1, [sp, #4]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
  if (type() != SD_CARD_TYPE_SDHC) {
    bdec:	blx	r3
    bdee:	ldr	r2, [sp, #4]
    bdf0:	b.n	bdbc <SdSpiCard::readStart(unsigned long)+0x14>
    bdf2:	nop
    bdf4:	.word	0x0000b7ed

0000bdf8 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    bdf8:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    bdfc:	mov	r5, r1
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    bdfe:	ldrb	r1, [r0, #16]
    be00:	cmp	r1, #1
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    be02:	mov	r6, r0
    be04:	mov	r4, r2
    be06:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    be08:	beq.n	be40 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x48>
    if (!readStart(sector)) {
    be0a:	mov	r1, r5
    be0c:	mov	r0, r6
    be0e:	bl	bda8 <SdSpiCard::readStart(unsigned long)>
    be12:	cbz	r0, be3a <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x42>
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
    be14:	movs	r3, #1
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    be16:	str	r5, [r6, #12]
    m_curState = READ_STATE;
    be18:	strb	r3, [r6, #16]
  }
  for (size_t i = 0; i < ns; i++, dst += 512) {
    be1a:	movs	r5, #0
    be1c:	cbnz	r7, be24 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x2c>
    be1e:	b.n	be48 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x50>
    be20:	cmp	r7, r5
    be22:	beq.n	be48 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x50>
    if (!readData(dst, 512)) {
    be24:	mov	r1, r4
    be26:	mov.w	r2, #512	; 0x200
    be2a:	mov	r0, r6
    be2c:	bl	b90c <SdSpiCard::readData(unsigned char*, unsigned int)>
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++, dst += 512) {
    be30:	adds	r5, #1
    be32:	add.w	r4, r4, #512	; 0x200
    if (!readData(dst, 512)) {
    be36:	cmp	r0, #0
    be38:	bne.n	be20 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x28>
    }
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
    be3a:	movs	r0, #0
    be3c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    be40:	ldr	r3, [r0, #12]
    be42:	cmp	r3, r5
    be44:	bne.n	be0a <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x12>
    be46:	b.n	be1a <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x22>
  for (size_t i = 0; i < ns; i++, dst += 512) {
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
    be48:	ldr	r3, [r6, #12]
  return m_sharedSpi ? syncDevice() : true;
    be4a:	ldrb	r2, [r6, #17]
  for (size_t i = 0; i < ns; i++, dst += 512) {
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
    be4c:	add	r7, r3
    be4e:	str	r7, [r6, #12]
  return m_sharedSpi ? syncDevice() : true;
    be50:	cbnz	r2, be58 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x60>
    be52:	movs	r0, #1
    be54:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    be58:	ldr	r3, [r6, #0]
    be5a:	mov	r0, r6
    be5c:	ldr	r3, [r3, #24]
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    be5e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    be62:	bx	r3

0000be64 <SdSpiCard::readStop()>:
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
    be64:	push	{r3, r4, r5, lr}
  if (cardCommand(CMD12, 0)) {
    be66:	movs	r2, #0
    be68:	movs	r1, #12
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
    be6a:	mov	r5, r0
  if (cardCommand(CMD12, 0)) {
    be6c:	bl	b9c8 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    be70:	ldrb	r4, [r5, #20]
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
  if (cardCommand(CMD12, 0)) {
    be72:	cbz	r0, be7e <SdSpiCard::readStop()+0x1a>
    be74:	movs	r3, #9
    be76:	strb	r3, [r5, #19]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    be78:	cbnz	r4, be90 <SdSpiCard::readStop()+0x2c>
  return true;

 fail:
  spiStop();
  return false;
}
    be7a:	mov	r0, r4
    be7c:	pop	{r3, r4, r5, pc}
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    be7e:	cbnz	r4, be86 <SdSpiCard::readStop()+0x22>
  if (cardCommand(CMD12, 0)) {
    error(SD_CARD_ERROR_CMD12);
    goto fail;
  }
  spiStop();
  return true;
    be80:	movs	r4, #1

 fail:
  spiStop();
  return false;
}
    be82:	mov	r0, r4
    be84:	pop	{r3, r4, r5, pc}
    be86:	mov	r0, r5
    be88:	bl	b81c <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    be8c:	mov	r0, r4
    be8e:	pop	{r3, r4, r5, pc}
    be90:	mov	r0, r5
    be92:	movs	r4, #0
    be94:	bl	b81c <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    be98:	mov	r0, r4
    be9a:	pop	{r3, r4, r5, pc}

0000be9c <SdSpiCard::syncDevice()>:
}
//------------------------------------------------------------------------------
bool SdSpiCard::syncDevice() {
#if ENABLE_DEDICATED_SPI
  // Insure no recursive loop with cardCommand().
  uint8_t state = m_curState;
    be9c:	ldrb	r2, [r0, #16]
  m_curState = IDLE_STATE;
    be9e:	movs	r1, #0
  if (state == WRITE_STATE) {
    bea0:	cmp	r2, #2
//------------------------------------------------------------------------------
bool SdSpiCard::syncDevice() {
#if ENABLE_DEDICATED_SPI
  // Insure no recursive loop with cardCommand().
  uint8_t state = m_curState;
  m_curState = IDLE_STATE;
    bea2:	strb	r1, [r0, #16]
  if (state == WRITE_STATE) {
    bea4:	beq.n	beb2 <SdSpiCard::syncDevice()+0x16>
    return writeStop();
  }
  if (state == READ_STATE) {
    bea6:	cmp	r2, #1
    bea8:	beq.n	beae <SdSpiCard::syncDevice()+0x12>
    return readStop();
  }
#endif  // ENABLE_DEDICATED_SPI
  return true;
}
    beaa:	movs	r0, #1
    beac:	bx	lr
  m_curState = IDLE_STATE;
  if (state == WRITE_STATE) {
    return writeStop();
  }
  if (state == READ_STATE) {
    return readStop();
    beae:	b.w	be64 <SdSpiCard::readStop()>
#if ENABLE_DEDICATED_SPI
  // Insure no recursive loop with cardCommand().
  uint8_t state = m_curState;
  m_curState = IDLE_STATE;
  if (state == WRITE_STATE) {
    return writeStop();
    beb2:	ldr	r3, [r0, #0]
    beb4:	ldr	r3, [r3, #76]	; 0x4c
    beb6:	bx	r3

0000beb8 <SdSpiCard::writeStart(unsigned long)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
    beb8:	push	{r4, r5, lr}
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    beba:	ldr	r3, [r0, #0]
    bebc:	ldr	r5, [pc, #68]	; (bf04 <SdSpiCard::writeStart(unsigned long)+0x4c>)
    bebe:	ldr	r3, [r3, #64]	; 0x40
    bec0:	cmp	r3, r5
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
    bec2:	sub	sp, #12
    bec4:	mov	r4, r0
    bec6:	mov	r2, r1
    bec8:	bne.n	befa <SdSpiCard::writeStart(unsigned long)+0x42>
  bool syncDevice();
  /** Return the card type: SD V1, SD V2 or SDHC/SDXC
   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC/SDXC.
   */
  uint8_t type() const {
    return m_type;
    beca:	ldrb	r0, [r0, #22]
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    becc:	cmp	r0, #3
    sector <<= 9;
    bece:	it	ne
    bed0:	lslne	r2, r2, #9
  }
  if (cardCommand(CMD25, sector)) {
    bed2:	movs	r1, #25
    bed4:	mov	r0, r4
    bed6:	bl	b9c8 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    beda:	cbz	r0, bef4 <SdSpiCard::writeStart(unsigned long)+0x3c>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    bedc:	ldrb	r0, [r4, #20]
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    bede:	movs	r3, #14
    bee0:	strb	r3, [r4, #19]
    bee2:	cbnz	r0, bee8 <SdSpiCard::writeStart(unsigned long)+0x30>
  return true;

 fail:
  spiStop();
  return false;
}
    bee4:	add	sp, #12
    bee6:	pop	{r4, r5, pc}
    bee8:	mov	r0, r4
    beea:	bl	b81c <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    beee:	movs	r0, #0
    bef0:	add	sp, #12
    bef2:	pop	{r4, r5, pc}
  }
  if (cardCommand(CMD25, sector)) {
    error(SD_CARD_ERROR_CMD25);
    goto fail;
  }
  return true;
    bef4:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    bef6:	add	sp, #12
    bef8:	pop	{r4, r5, pc}
    befa:	str	r1, [sp, #4]
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    befc:	blx	r3
    befe:	ldr	r2, [sp, #4]
    bf00:	b.n	becc <SdSpiCard::writeStart(unsigned long)+0x14>
    bf02:	nop
    bf04:	.word	0x0000b7ed

0000bf08 <SdSpiCard::erase(unsigned long, unsigned long)>:
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    bf08:	push	{r4, r5, r6, r7, lr}
  csd_t csd;
  if (!readCSD(&csd)) {
    bf0a:	ldr	r3, [r0, #0]
    bf0c:	ldr	r7, [pc, #172]	; (bfbc <SdSpiCard::erase(unsigned long, unsigned long)+0xb4>)
    bf0e:	ldr	r3, [r3, #52]	; 0x34
    bf10:	cmp	r3, r7
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    bf12:	sub	sp, #20
    bf14:	mov	r4, r0
    bf16:	mov	r5, r1
    bf18:	mov	r6, r2
    bf1a:	bne.n	bf78 <SdSpiCard::erase(unsigned long, unsigned long)+0x70>
   * \param[out] csd pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCSD(csd_t* csd) {
    return readRegister(CMD9, csd);
    bf1c:	mov	r2, sp
    bf1e:	movs	r1, #9
    bf20:	bl	bcc0 <SdSpiCard::readRegister(unsigned char, void*)>
  csd_t csd;
  if (!readCSD(&csd)) {
    bf24:	cbz	r0, bf4c <SdSpiCard::erase(unsigned long, unsigned long)+0x44>
    goto fail;
  }
  // check for single sector erase
  if (!csd.v1.erase_blk_en) {
    bf26:	ldrb.w	r3, [sp, #10]
    bf2a:	lsls	r2, r3, #25
    bf2c:	bpl.n	bf5c <SdSpiCard::erase(unsigned long, unsigned long)+0x54>
      // error card can't erase specified area
      error(SD_CARD_ERROR_ERASE_SINGLE_SECTOR);
      goto fail;
    }
  }
  if (m_type != SD_CARD_TYPE_SDHC) {
    bf2e:	ldrb	r3, [r4, #22]
    bf30:	cmp	r3, #3
    firstSector <<= 9;
    bf32:	it	ne
    bf34:	lslne	r5, r5, #9
    lastSector <<= 9;
  }
  if (cardCommand(CMD32, firstSector)
    bf36:	mov	r2, r5
    bf38:	mov.w	r1, #32
    bf3c:	mov	r0, r4
      goto fail;
    }
  }
  if (m_type != SD_CARD_TYPE_SDHC) {
    firstSector <<= 9;
    lastSector <<= 9;
    bf3e:	it	ne
    bf40:	lslne	r6, r6, #9
  }
  if (cardCommand(CMD32, firstSector)
    bf42:	bl	b9c8 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
      || cardCommand(CMD33, lastSector)
      || cardCommand(CMD38, 0)) {
    bf46:	cbz	r0, bf7e <SdSpiCard::erase(unsigned long, unsigned long)+0x76>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    bf48:	movs	r3, #38	; 0x26
    bf4a:	strb	r3, [r4, #19]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    bf4c:	ldrb	r0, [r4, #20]
    bf4e:	cbz	r0, bf58 <SdSpiCard::erase(unsigned long, unsigned long)+0x50>
    bf50:	mov	r0, r4
    bf52:	bl	b81c <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
  spiStop();
  return true;

 fail:
  spiStop();
  return false;
    bf56:	movs	r0, #0
}
    bf58:	add	sp, #20
    bf5a:	pop	{r4, r5, r6, r7, pc}
  }
  // check for single sector erase
  if (!csd.v1.erase_blk_en) {
    // erase size mask
    uint8_t m = (csd.v1.sector_size_high << 1) | csd.v1.sector_size_low;
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
    bf5c:	and.w	r3, r3, #63	; 0x3f
    goto fail;
  }
  // check for single sector erase
  if (!csd.v1.erase_blk_en) {
    // erase size mask
    uint8_t m = (csd.v1.sector_size_high << 1) | csd.v1.sector_size_low;
    bf60:	ldrb.w	r1, [sp, #11]
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
    bf64:	lsls	r3, r3, #1
    bf66:	adds	r2, r6, #1
    bf68:	orr.w	r3, r3, r1, lsr #7
    bf6c:	orrs	r2, r5
    bf6e:	tst	r3, r2
    bf70:	beq.n	bf2e <SdSpiCard::erase(unsigned long, unsigned long)+0x26>
    bf72:	movs	r3, #39	; 0x27
    bf74:	strb	r3, [r4, #19]
    bf76:	b.n	bf4c <SdSpiCard::erase(unsigned long, unsigned long)+0x44>
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
  csd_t csd;
  if (!readCSD(&csd)) {
    bf78:	mov	r1, sp
    bf7a:	blx	r3
    bf7c:	b.n	bf24 <SdSpiCard::erase(unsigned long, unsigned long)+0x1c>
  if (m_type != SD_CARD_TYPE_SDHC) {
    firstSector <<= 9;
    lastSector <<= 9;
  }
  if (cardCommand(CMD32, firstSector)
      || cardCommand(CMD33, lastSector)
    bf7e:	mov	r2, r6
    bf80:	movs	r1, #33	; 0x21
    bf82:	mov	r0, r4
    bf84:	bl	b9c8 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    bf88:	cmp	r0, #0
    bf8a:	bne.n	bf48 <SdSpiCard::erase(unsigned long, unsigned long)+0x40>
      || cardCommand(CMD38, 0)) {
    bf8c:	mov	r2, r0
    bf8e:	movs	r1, #38	; 0x26
    bf90:	mov	r0, r4
    bf92:	bl	b9c8 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    bf96:	cmp	r0, #0
    bf98:	bne.n	bf48 <SdSpiCard::erase(unsigned long, unsigned long)+0x40>
    error(SD_CARD_ERROR_ERASE);
    goto fail;
  }
  DBG_BEGIN_TIME(DBG_ERASE_BUSY);
  if (!waitNotBusy(SD_ERASE_TIMEOUT)) {
    bf9a:	movw	r1, #10000	; 0x2710
    bf9e:	mov	r0, r4
    bfa0:	bl	b98c <SdSpiCard::waitNotBusy(unsigned short)>
    bfa4:	cbnz	r0, bfac <SdSpiCard::erase(unsigned long, unsigned long)+0xa4>
    bfa6:	movs	r3, #40	; 0x28
    bfa8:	strb	r3, [r4, #19]
    bfaa:	b.n	bf4c <SdSpiCard::erase(unsigned long, unsigned long)+0x44>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    bfac:	ldrb	r5, [r4, #20]
    bfae:	cmp	r5, #0
    bfb0:	beq.n	bf58 <SdSpiCard::erase(unsigned long, unsigned long)+0x50>
    bfb2:	mov	r0, r4
    bfb4:	bl	b81c <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    error(SD_CARD_ERROR_ERASE_TIMEOUT);
    goto fail;
  }
  DBG_END_TIME(DBG_ERASE_BUSY);
  spiStop();
  return true;
    bfb8:	mov	r0, r5
    bfba:	b.n	bf58 <SdSpiCard::erase(unsigned long, unsigned long)+0x50>
    bfbc:	.word	0x0000bd01

0000bfc0 <SdSpiCard::writeStop()>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
    bfc0:	push	{r4, r5, r6, lr}
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    bfc2:	mov.w	r1, #600	; 0x258
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
    bfc6:	mov	r5, r0
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    bfc8:	bl	b98c <SdSpiCard::waitNotBusy(unsigned short)>
    bfcc:	mov	r6, r0
    bfce:	cbnz	r0, bfe8 <SdSpiCard::writeStop()+0x28>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    bfd0:	ldrb	r4, [r5, #20]
    bfd2:	movs	r3, #30
    bfd4:	strb	r3, [r5, #19]
    bfd6:	cbnz	r4, bfdc <SdSpiCard::writeStop()+0x1c>

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  spiStop();
  return false;
}
    bfd8:	mov	r0, r4
    bfda:	pop	{r4, r5, r6, pc}
    bfdc:	mov	r0, r5
  return true;

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  spiStop();
  return false;
    bfde:	mov	r4, r6
    bfe0:	bl	b81c <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
}
    bfe4:	mov	r0, r4
    bfe6:	pop	{r4, r5, r6, pc}
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriver.send(data);
    bfe8:	movs	r1, #253	; 0xfd
    bfea:	adds	r0, r5, #4
    bfec:	bl	d364 <SdSpiArduinoDriver::send(unsigned char)>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    bff0:	ldrb	r4, [r5, #20]
    bff2:	cbnz	r4, bffa <SdSpiCard::writeStop()+0x3a>
    bff4:	mov	r4, r6

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  spiStop();
  return false;
}
    bff6:	mov	r0, r4
    bff8:	pop	{r4, r5, r6, pc}
    bffa:	mov	r0, r5
    bffc:	bl	b81c <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    c000:	b.n	bfd8 <SdSpiCard::writeStop()+0x18>
    c002:	nop

0000c004 <SdSpiCard::writeData(unsigned char, unsigned char const*)>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send one sector of data for write sector or write multiple sectors
bool SdSpiCard::writeData(uint8_t token, const uint8_t* src) {
    c004:	push	{r4, r5, r6, lr}
    c006:	adds	r4, r0, #4
    c008:	mov	r6, r2
    c00a:	mov	r5, r0
    c00c:	mov	r0, r4
    c00e:	bl	d364 <SdSpiArduinoDriver::send(unsigned char)>
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriver.send(buf, n);
    c012:	mov.w	r2, #512	; 0x200
    c016:	mov	r1, r6
    c018:	mov	r0, r4
    c01a:	bl	d37c <SdSpiArduinoDriver::send(unsigned char const*, unsigned int)>
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver.receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriver.send(data);
    c01e:	mov	r0, r4
    c020:	movs	r1, #255	; 0xff
    c022:	bl	d364 <SdSpiArduinoDriver::send(unsigned char)>
    c026:	mov	r0, r4
    c028:	movs	r1, #255	; 0xff
    c02a:	bl	d364 <SdSpiArduinoDriver::send(unsigned char)>
  }
  void spiDeactivate() {
    m_spiDriver.deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriver.receive();
    c02e:	mov	r0, r4
    c030:	bl	d328 <SdSpiArduinoDriver::receive()>
  spiSend(src, 512);
  spiSend(crc >> 8);
  spiSend(crc & 0XFF);

  m_status = spiReceive();
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    c034:	and.w	r3, r0, #31
    c038:	cmp	r3, #5
  spiSend(token);
  spiSend(src, 512);
  spiSend(crc >> 8);
  spiSend(crc & 0XFF);

  m_status = spiReceive();
    c03a:	strb	r0, [r5, #21]
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    c03c:	beq.n	c052 <SdSpiCard::writeData(unsigned char, unsigned char const*)+0x4e>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    c03e:	ldrb	r0, [r5, #20]
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    c040:	movs	r3, #32
    c042:	strb	r3, [r5, #19]
    c044:	cbnz	r0, c048 <SdSpiCard::writeData(unsigned char, unsigned char const*)+0x44>
  return true;

 fail:
  spiStop();
  return false;
}
    c046:	pop	{r4, r5, r6, pc}
    c048:	mov	r0, r5
    c04a:	bl	b81c <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
  }
  return true;

 fail:
  spiStop();
  return false;
    c04e:	movs	r0, #0
    c050:	pop	{r4, r5, r6, pc}
  m_status = spiReceive();
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    error(SD_CARD_ERROR_WRITE_DATA);
    goto fail;
  }
  return true;
    c052:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    c054:	pop	{r4, r5, r6, pc}
    c056:	nop

0000c058 <SdSpiCard::writeData(unsigned char const*)>:
  }
  return true;
#endif  // WDT_YIELD_TIME_MILLIS
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
    c058:	push	{r3, r4, r5, lr}
    c05a:	mov	r5, r1
  // wait for previous write to finish
  DBG_BEGIN_TIME(DBG_WRITE_BUSY);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    c05c:	mov.w	r1, #600	; 0x258
  }
  return true;
#endif  // WDT_YIELD_TIME_MILLIS
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
    c060:	mov	r4, r0
  // wait for previous write to finish
  DBG_BEGIN_TIME(DBG_WRITE_BUSY);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    c062:	bl	b98c <SdSpiCard::waitNotBusy(unsigned short)>
    c066:	cbnz	r0, c07a <SdSpiCard::writeData(unsigned char const*)+0x22>
    c068:	movs	r3, #36	; 0x24
    c06a:	strb	r3, [r4, #19]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    c06c:	ldrb	r0, [r4, #20]
    c06e:	cbz	r0, c078 <SdSpiCard::writeData(unsigned char const*)+0x20>
    c070:	mov	r0, r4
    c072:	bl	b81c <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
  }
  return true;

 fail:
  spiStop();
  return false;
    c076:	movs	r0, #0
}
    c078:	pop	{r3, r4, r5, pc}
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    error(SD_CARD_ERROR_WRITE_TIMEOUT);
    goto fail;
  }
  DBG_END_TIME(DBG_WRITE_BUSY);
  if (!writeData(WRITE_MULTIPLE_TOKEN, src)) {
    c07a:	mov	r2, r5
    c07c:	movs	r1, #252	; 0xfc
    c07e:	mov	r0, r4
    c080:	bl	c004 <SdSpiCard::writeData(unsigned char, unsigned char const*)>
    c084:	cmp	r0, #0
    c086:	beq.n	c06c <SdSpiCard::writeData(unsigned char const*)+0x14>
  return true;

 fail:
  spiStop();
  return false;
}
    c088:	pop	{r3, r4, r5, pc}
    c08a:	nop

0000c08c <SdSpiCard::writeSingle(unsigned long, unsigned char const*)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
    c08c:	push	{r4, r5, r6, lr}
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    c08e:	ldr	r3, [r0, #0]
    c090:	ldr	r5, [pc, #88]	; (c0ec <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x60>)
    c092:	ldr	r3, [r3, #64]	; 0x40
    c094:	cmp	r3, r5
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
    c096:	sub	sp, #8
    c098:	mov	r4, r0
    c09a:	mov	r6, r2
    c09c:	bne.n	c0e4 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x58>
  bool syncDevice();
  /** Return the card type: SD V1, SD V2 or SDHC/SDXC
   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC/SDXC.
   */
  uint8_t type() const {
    return m_type;
    c09e:	ldrb	r0, [r0, #22]
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    c0a0:	cmp	r0, #3
    sector <<= 9;
    c0a2:	it	ne
    c0a4:	lslne	r1, r1, #9
  }
  if (cardCommand(CMD24, sector)) {
    c0a6:	mov	r2, r1
    c0a8:	mov	r0, r4
    c0aa:	movs	r1, #24
    c0ac:	bl	b9c8 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    c0b0:	cbz	r0, c0c6 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x3a>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    c0b2:	movs	r3, #13
    c0b4:	strb	r3, [r4, #19]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    c0b6:	ldrb	r0, [r4, #20]
    c0b8:	cbz	r0, c0c2 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x36>
    c0ba:	mov	r0, r4
    c0bc:	bl	b81c <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
  spiStop();
  return true;

 fail:
  spiStop();
  return false;
    c0c0:	movs	r0, #0
}
    c0c2:	add	sp, #8
    c0c4:	pop	{r4, r5, r6, pc}
  }
  if (cardCommand(CMD24, sector)) {
    error(SD_CARD_ERROR_CMD24);
    goto fail;
  }
  if (!writeData(DATA_START_SECTOR, src)) {
    c0c6:	mov	r2, r6
    c0c8:	movs	r1, #254	; 0xfe
    c0ca:	mov	r0, r4
    c0cc:	bl	c004 <SdSpiCard::writeData(unsigned char, unsigned char const*)>
    c0d0:	cmp	r0, #0
    c0d2:	beq.n	c0b6 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x2a>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    c0d4:	ldrb	r5, [r4, #20]
    c0d6:	cmp	r5, #0
    c0d8:	beq.n	c0c2 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x36>
    c0da:	mov	r0, r4
    c0dc:	bl	b81c <SdSpiCard::spiStop() [clone .part.7] [clone .constprop.28]>
    c0e0:	mov	r0, r5
    c0e2:	b.n	c0c2 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x36>
    c0e4:	str	r1, [sp, #4]
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    c0e6:	blx	r3
    c0e8:	ldr	r1, [sp, #4]
    c0ea:	b.n	c0a0 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x14>
    c0ec:	.word	0x0000b7ed

0000c0f0 <SdSpiCard::writeSector(unsigned long, unsigned char const*)>:
   *
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    c0f0:	push	{r4}
    if (m_sharedSpi) {
    c0f2:	ldrb	r4, [r0, #17]
    c0f4:	cbnz	r4, c104 <SdSpiCard::writeSector(unsigned long, unsigned char const*)+0x14>
      return writeSingle(sector, src);
    } else {
      return writeSectors(sector, src, 1);
    c0f6:	ldr	r4, [r0, #0]
    c0f8:	ldr	r4, [r4, #32]
    c0fa:	movs	r3, #1
    c0fc:	mov	ip, r4
    }
  }
    c0fe:	ldr.w	r4, [sp], #4
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
      return writeSingle(sector, src);
    } else {
      return writeSectors(sector, src, 1);
    c102:	bx	ip
    }
  }
    c104:	ldr.w	r4, [sp], #4
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
      return writeSingle(sector, src);
    c108:	b.w	c08c <SdSpiCard::writeSingle(unsigned long, unsigned char const*)>

0000c10c <sdIrs()>:
#endif  // USE_DEBUG_MODE
  return false;
}
//==============================================================================
// ISR
static void sdIrs() {
    c10c:	push	{r4}
  SDHC_IRQSIGEN = 0;
    c10e:	ldr	r4, [pc, #28]	; (c12c <sdIrs()+0x20>)
  m_irqstat = SDHC_IRQSTAT;
    c110:	ldr	r2, [pc, #28]	; (c130 <sdIrs()+0x24>)
    c112:	ldr	r1, [pc, #32]	; (c134 <sdIrs()+0x28>)
  SDHC_IRQSTAT = m_irqstat;
#if defined(__IMXRT1062__)
  SDHC_MIX_CTRL &= ~(SDHC_MIX_CTRL_AC23EN | SDHC_MIX_CTRL_DMAEN);
#endif
  m_dmaBusy = false;
    c114:	ldr	r0, [pc, #32]	; (c138 <sdIrs()+0x2c>)
  return false;
}
//==============================================================================
// ISR
static void sdIrs() {
  SDHC_IRQSIGEN = 0;
    c116:	movs	r3, #0
    c118:	str	r3, [r4, #0]
  m_irqstat = SDHC_IRQSTAT;
    c11a:	ldr	r4, [r2, #0]
    c11c:	str	r4, [r1, #0]
  SDHC_IRQSTAT = m_irqstat;
    c11e:	ldr	r1, [r1, #0]
    c120:	str	r1, [r2, #0]
#if defined(__IMXRT1062__)
  SDHC_MIX_CTRL &= ~(SDHC_MIX_CTRL_AC23EN | SDHC_MIX_CTRL_DMAEN);
#endif
  m_dmaBusy = false;
}
    c122:	ldr.w	r4, [sp], #4
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
#if defined(__IMXRT1062__)
  SDHC_MIX_CTRL &= ~(SDHC_MIX_CTRL_AC23EN | SDHC_MIX_CTRL_DMAEN);
#endif
  m_dmaBusy = false;
    c126:	strb	r3, [r0, #0]
}
    c128:	bx	lr
    c12a:	nop
    c12c:	.word	0x400b1038
    c130:	.word	0x400b1030
    c134:	.word	0x1fff61c0
    c138:	.word	0x1fff61d8

0000c13c <isBusyCommandComplete()>:
static bool isBusyCMD13() {
  return !(statusCMD13() & CARD_STATUS_READY_FOR_DATA);
}
//------------------------------------------------------------------------------
static bool isBusyCommandComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_CC | SDHC_IRQSTAT_CMD_ERROR));
    c13c:	ldr	r3, [pc, #12]	; (c14c <isBusyCommandComplete()+0x10>)
    c13e:	ldr	r0, [pc, #16]	; (c150 <isBusyCommandComplete()+0x14>)
    c140:	ldr	r3, [r3, #0]
    c142:	ands	r0, r3
}
    c144:	clz	r0, r0
    c148:	lsrs	r0, r0, #5
    c14a:	bx	lr
    c14c:	.word	0x400b1030
    c150:	.word	0x000f0001

0000c154 <isBusyCommandInhibit()>:
//------------------------------------------------------------------------------
static bool isBusyCommandInhibit() {
  return SDHC_PRSSTAT & SDHC_PRSSTAT_CIHB;
    c154:	ldr	r3, [pc, #8]	; (c160 <isBusyCommandInhibit()+0xc>)
    c156:	ldr	r0, [r3, #0]
}
    c158:	and.w	r0, r0, #1
    c15c:	bx	lr
    c15e:	nop
    c160:	.word	0x400b1024

0000c164 <isBusyDat()>:
//------------------------------------------------------------------------------
static bool isBusyDat() {
  return SDHC_PRSSTAT & (1 << 24) ? false : true;
    c164:	ldr	r3, [pc, #12]	; (c174 <isBusyDat()+0x10>)
    c166:	ldr	r0, [r3, #0]
    c168:	eor.w	r0, r0, #16777216	; 0x1000000
}
    c16c:	ubfx	r0, r0, #24, #1
    c170:	bx	lr
    c172:	nop
    c174:	.word	0x400b1024

0000c178 <isBusyDMA()>:
//------------------------------------------------------------------------------
static bool isBusyDMA() {
  return m_dmaBusy;
    c178:	ldr	r3, [pc, #4]	; (c180 <isBusyDMA()+0x8>)
    c17a:	ldrb	r0, [r3, #0]
}
    c17c:	bx	lr
    c17e:	nop
    c180:	.word	0x1fff61d8

0000c184 <isBusyFifoRead()>:
//------------------------------------------------------------------------------
static bool isBusyFifoRead() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BREN);
    c184:	ldr	r3, [pc, #12]	; (c194 <isBusyFifoRead()+0x10>)
    c186:	ldr	r0, [r3, #0]
    c188:	eor.w	r0, r0, #2048	; 0x800
}
    c18c:	ubfx	r0, r0, #11, #1
    c190:	bx	lr
    c192:	nop
    c194:	.word	0x400b1024

0000c198 <isBusyFifoWrite()>:
//------------------------------------------------------------------------------
static bool isBusyFifoWrite() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN);
    c198:	ldr	r3, [pc, #12]	; (c1a8 <isBusyFifoWrite()+0x10>)
    c19a:	ldr	r0, [r3, #0]
    c19c:	eor.w	r0, r0, #1024	; 0x400
}
    c1a0:	ubfx	r0, r0, #10, #1
    c1a4:	bx	lr
    c1a6:	nop
    c1a8:	.word	0x400b1024

0000c1ac <isBusyTransferComplete()>:
//------------------------------------------------------------------------------
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
    c1ac:	ldr	r3, [pc, #12]	; (c1bc <isBusyTransferComplete()+0x10>)
    c1ae:	ldr	r0, [pc, #16]	; (c1c0 <isBusyTransferComplete()+0x14>)
    c1b0:	ldr	r3, [r3, #0]
    c1b2:	ands	r0, r3
}
    c1b4:	clz	r0, r0
    c1b8:	lsrs	r0, r0, #5
    c1ba:	bx	lr
    c1bc:	.word	0x400b1030
    c1c0:	.word	0x117f0002

0000c1c4 <setSdclk(unsigned long)>:
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
    c1c4:	mov.w	r2, #1000	; 0x3e8
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    c1c8:	ldr	r3, [pc, #176]	; (c27c <setSdclk(unsigned long)+0xb8>)
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
    c1ca:	mul.w	r0, r2, r0
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    c1ce:	cmp	r0, r3
  }
  d[15] = 0;
  return true;
}
//------------------------------------------------------------------------------
static void setSdclk(uint32_t kHzMax) {
    c1d0:	push	{r4, r5, r6, r7}
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    c1d2:	bhi.n	c26c <setSdclk(unsigned long)+0xa8>
    c1d4:	ldr	r5, [pc, #168]	; (c280 <setSdclk(unsigned long)+0xbc>)
    c1d6:	movs	r2, #8
    c1d8:	movs	r1, #1
    sdclkfs <<= 1;
    c1da:	lsls	r1, r1, #1
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    c1dc:	lsls	r3, r1, #4
    c1de:	udiv	r3, r5, r3
    c1e2:	cmp	r0, r3
    c1e4:	ldr	r4, [pc, #152]	; (c280 <setSdclk(unsigned long)+0xbc>)
    c1e6:	bcs.n	c264 <setSdclk(unsigned long)+0xa0>
    c1e8:	subs	r2, #1
    c1ea:	bne.n	c1da <setSdclk(unsigned long)+0x16>
    c1ec:	udiv	r4, r4, r1
    c1f0:	lsrs	r3, r1, #1
    c1f2:	lsls	r7, r3, #8
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    c1f4:	cmp	r0, r4
    c1f6:	bcs.n	c274 <setSdclk(unsigned long)+0xb0>
    c1f8:	ldr	r6, [pc, #132]	; (c280 <setSdclk(unsigned long)+0xbc>)
    c1fa:	lsls	r3, r1, #1
    c1fc:	movs	r2, #1
    c1fe:	b.n	c202 <setSdclk(unsigned long)+0x3e>
    c200:	mov	r3, r4
    c202:	udiv	r4, r6, r3
    c206:	cmp	r0, r4
    dvs++;
    c208:	add.w	r5, r2, #1
    c20c:	add.w	r4, r3, r1
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    c210:	bcs.n	c260 <setSdclk(unsigned long)+0x9c>
    c212:	cmp	r5, #16
    c214:	mov	r2, r5
    c216:	bne.n	c200 <setSdclk(unsigned long)+0x3c>
    c218:	movs	r2, #240	; 0xf0
    dvs++;
  }
  m_sdClkKhz = base/(1000*sdclkfs*dvs);
    c21a:	ldr	r6, [pc, #104]	; (c284 <setSdclk(unsigned long)+0xc0>)
  sdclkfs >>= 1;
  dvs--;
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Disable SDHC clock.
  SDHC_SYSCTL &= ~SDHC_SYSCTL_SDCLKEN;
    c21c:	ldr	r4, [pc, #104]	; (c288 <setSdclk(unsigned long)+0xc4>)
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    dvs++;
  }
  m_sdClkKhz = base/(1000*sdclkfs*dvs);
    c21e:	ldr	r0, [pc, #96]	; (c280 <setSdclk(unsigned long)+0xbc>)

  SDHC_SYSCTL = sysctl | SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_DVS(dvs)
                | SDHC_SYSCTL_SDCLKFS(sdclkfs);

  // Wait until the SDHC clock is stable.
  while (!(SDHC_PRSSTAT & SDHC_PRSSTAT_SDSTB)) {
    c220:	ldr	r1, [pc, #104]	; (c28c <setSdclk(unsigned long)+0xc8>)
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    dvs++;
  }
  m_sdClkKhz = base/(1000*sdclkfs*dvs);
    c222:	mov.w	r5, #1000	; 0x3e8
    c226:	mul.w	r3, r5, r3
    c22a:	udiv	r3, r0, r3
    c22e:	str	r3, [r6, #0]
  sdclkfs >>= 1;
  dvs--;
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Disable SDHC clock.
  SDHC_SYSCTL &= ~SDHC_SYSCTL_SDCLKEN;
    c230:	ldr	r3, [r4, #0]
    c232:	bic.w	r3, r3, #8
    c236:	str	r3, [r4, #0]
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)

  // Change dividers.
  uint32_t sysctl = SDHC_SYSCTL & ~(SDHC_SYSCTL_DTOCV_MASK
    c238:	ldr	r0, [r4, #0]
                    | SDHC_SYSCTL_DVS_MASK | SDHC_SYSCTL_SDCLKFS_MASK);

  SDHC_SYSCTL = sysctl | SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_DVS(dvs)
                | SDHC_SYSCTL_SDCLKFS(sdclkfs);
    c23a:	bic.w	r3, r0, #1044480	; 0xff000
    c23e:	bic.w	r3, r3, #4080	; 0xff0
    c242:	orr.w	r3, r3, #917504	; 0xe0000
    c246:	orrs	r3, r7
    c248:	orrs	r2, r3
    c24a:	str	r2, [r4, #0]

  // Wait until the SDHC clock is stable.
  while (!(SDHC_PRSSTAT & SDHC_PRSSTAT_SDSTB)) {
    c24c:	ldr	r3, [r1, #0]
    c24e:	lsls	r3, r3, #28
    c250:	bpl.n	c24c <setSdclk(unsigned long)+0x88>
  }

#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Enable the SDHC clock.
  SDHC_SYSCTL |= SDHC_SYSCTL_SDCLKEN;
    c252:	ldr	r2, [pc, #52]	; (c288 <setSdclk(unsigned long)+0xc4>)
    c254:	ldr	r3, [r2, #0]
    c256:	orr.w	r3, r3, #8
    c25a:	str	r3, [r2, #0]
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
}
    c25c:	pop	{r4, r5, r6, r7}
    c25e:	bx	lr
    c260:	lsls	r2, r2, #4
    c262:	b.n	c21a <setSdclk(unsigned long)+0x56>
    c264:	udiv	r4, r4, r1
    c268:	lsls	r7, r1, #7
    c26a:	b.n	c1f4 <setSdclk(unsigned long)+0x30>
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    c26c:	ldr	r4, [pc, #16]	; (c280 <setSdclk(unsigned long)+0xbc>)
    c26e:	movs	r7, #0
//------------------------------------------------------------------------------
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
    c270:	movs	r1, #1
    c272:	b.n	c1f4 <setSdclk(unsigned long)+0x30>
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    c274:	mov	r3, r1
    c276:	movs	r2, #0
    c278:	b.n	c21a <setSdclk(unsigned long)+0x56>
    c27a:	nop
    c27c:	.word	0x005b8d7f
    c280:	.word	0x05b8d800
    c284:	.word	0x1fff61dc
    c288:	.word	0x400b102c
    c28c:	.word	0x400b1024

0000c290 <SdioCard::errorCode() const>:
  }
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdioCard::errorCode() const {
  return m_errorCode;
    c290:	ldr	r3, [pc, #4]	; (c298 <SdioCard::errorCode() const+0x8>)
}
    c292:	ldrb	r0, [r3, #0]
    c294:	bx	lr
    c296:	nop
    c298:	.word	0x1fff09d4

0000c29c <SdioCard::errorData() const>:
//------------------------------------------------------------------------------
uint32_t SdioCard::errorData() const {
  return m_irqstat;
    c29c:	ldr	r3, [pc, #4]	; (c2a4 <SdioCard::errorData() const+0x8>)
    c29e:	ldr	r0, [r3, #0]
}
    c2a0:	bx	lr
    c2a2:	nop
    c2a4:	.word	0x1fff61c0

0000c2a8 <SdioCard::readCID(CID*)>:
//------------------------------------------------------------------------------
uint32_t SdioCard::kHzSdClk() {
  return m_sdClkKhz;
}
//------------------------------------------------------------------------------
bool SdioCard::readCID(cid_t* cid) {
    c2a8:	push	{r4, r5}
  memcpy(cid, &m_cid, 16);
    c2aa:	ldr	r4, [pc, #20]	; (c2c0 <SdioCard::readCID(CID*)+0x18>)
//------------------------------------------------------------------------------
uint32_t SdioCard::kHzSdClk() {
  return m_sdClkKhz;
}
//------------------------------------------------------------------------------
bool SdioCard::readCID(cid_t* cid) {
    c2ac:	mov	r5, r1
  memcpy(cid, &m_cid, 16);
    c2ae:	ldmia	r4!, {r0, r1, r2, r3}
    c2b0:	str	r0, [r5, #0]
    c2b2:	str	r1, [r5, #4]
    c2b4:	str	r2, [r5, #8]
    c2b6:	str	r3, [r5, #12]
  return true;
}
    c2b8:	movs	r0, #1
    c2ba:	pop	{r4, r5}
    c2bc:	bx	lr
    c2be:	nop
    c2c0:	.word	0x1fff619c

0000c2c4 <SdioCard::readCSD(csd_t*)>:
//------------------------------------------------------------------------------
bool SdioCard::readCSD(csd_t* csd) {
    c2c4:	push	{r4, r5}
  memcpy(csd, &m_csd, 16);
    c2c6:	ldr	r4, [pc, #20]	; (c2dc <SdioCard::readCSD(csd_t*)+0x18>)
bool SdioCard::readCID(cid_t* cid) {
  memcpy(cid, &m_cid, 16);
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readCSD(csd_t* csd) {
    c2c8:	mov	r5, r1
  memcpy(csd, &m_csd, 16);
    c2ca:	ldmia	r4!, {r0, r1, r2, r3}
    c2cc:	str	r0, [r5, #0]
    c2ce:	str	r1, [r5, #4]
    c2d0:	str	r2, [r5, #8]
    c2d2:	str	r3, [r5, #12]
  return true;
}
    c2d4:	movs	r0, #1
    c2d6:	pop	{r4, r5}
    c2d8:	bx	lr
    c2da:	nop
    c2dc:	.word	0x1fff61c8

0000c2e0 <SdioCard::readOCR(unsigned long*)>:
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
    c2e0:	ldr	r3, [pc, #8]	; (c2ec <SdioCard::readOCR(unsigned long*)+0xc>)
    c2e2:	ldr	r3, [r3, #0]
    c2e4:	str	r3, [r1, #0]
  return true;
}
    c2e6:	movs	r0, #1
    c2e8:	bx	lr
    c2ea:	nop
    c2ec:	.word	0x1fff61b4

0000c2f0 <SdioCard::~SdioCard()>:
    c2f0:	bx	lr
    c2f2:	nop

0000c2f4 <waitTimeout(bool (*)())>:
  }
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool waitTimeout(bool (*fcn)()) {
    c2f4:	push	{r3, r4, r5, r6, r7, lr}
    c2f6:	mov	r5, r0
  uint32_t m = micros();
    c2f8:	bl	de88 <micros>
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    c2fc:	ldr	r7, [pc, #24]	; (c318 <waitTimeout(bool (*)())+0x24>)
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool waitTimeout(bool (*fcn)()) {
  uint32_t m = micros();
    c2fe:	mov	r6, r0
    c300:	b.n	c30c <waitTimeout(bool (*)())+0x18>
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    c302:	bl	de88 <micros>
    c306:	subs	r0, r0, r6
    c308:	cmp	r0, r7
    c30a:	bhi.n	c314 <waitTimeout(bool (*)())+0x20>
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool waitTimeout(bool (*fcn)()) {
  uint32_t m = micros();
  while (fcn()) {
    c30c:	blx	r5
    c30e:	mov	r4, r0
    c310:	cmp	r0, #0
    c312:	bne.n	c302 <waitTimeout(bool (*)())+0xe>
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
      return true;
    }
  }
  return false;  // Caller will set errorCode.
}
    c314:	mov	r0, r4
    c316:	pop	{r3, r4, r5, r6, r7, pc}
    c318:	.word	0x000f4240

0000c31c <yieldTimeout(bool (*)())>:
  }
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
    c31c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  m_busyFcn = fcn;
    c320:	ldr.w	r8, [pc, #64]	; c364 <yieldTimeout(bool (*)())+0x48>
  uint32_t m = micros();
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    c324:	ldr	r7, [pc, #56]	; (c360 <yieldTimeout(bool (*)())+0x44>)
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
  m_busyFcn = fcn;
    c326:	str.w	r0, [r8]
  }
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
    c32a:	mov	r5, r0
  m_busyFcn = fcn;
  uint32_t m = micros();
    c32c:	bl	de88 <micros>
    c330:	mov	r6, r0
    c332:	b.n	c342 <yieldTimeout(bool (*)())+0x26>
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    c334:	bl	de88 <micros>
    c338:	subs	r0, r0, r6
    c33a:	cmp	r0, r7
    c33c:	bhi.n	c354 <yieldTimeout(bool (*)())+0x38>
  }
}
#elif defined(ARDUINO)
inline void SysCall::yield() {
  // Use the external Arduino yield() function.
  ::yield();
    c33e:	bl	ebc4 <yield>
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
  m_busyFcn = fcn;
  uint32_t m = micros();
  while (fcn()) {
    c342:	blx	r5
    c344:	mov	r4, r0
    c346:	cmp	r0, #0
    c348:	bne.n	c334 <yieldTimeout(bool (*)())+0x18>
      m_busyFcn = 0;
      return true;
    }
    SysCall::yield();
  }
  m_busyFcn = 0;
    c34a:	str.w	r0, [r8]
  return false;  // Caller will set errorCode.
}
    c34e:	mov	r0, r4
    c350:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
static bool yieldTimeout(bool (*fcn)()) {
  m_busyFcn = fcn;
  uint32_t m = micros();
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
      m_busyFcn = 0;
    c354:	movs	r3, #0
    c356:	str.w	r3, [r8]
    }
    SysCall::yield();
  }
  m_busyFcn = 0;
  return false;  // Caller will set errorCode.
}
    c35a:	mov	r0, r4
    c35c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    c360:	.word	0x000f4240
    c364:	.word	0x1fff61ac

0000c368 <SdioCard::~SdioCard()>:
    c368:	push	{r4, lr}
    c36a:	movs	r1, #12
    c36c:	mov	r4, r0
    c36e:	bl	effc <operator delete(void*, unsigned int)>
    c372:	mov	r0, r4
    c374:	pop	{r4, pc}
    c376:	nop

0000c378 <SdioCard::type() const>:
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdioCard::type() const {
  return  m_version2 ? m_highCapacity ?
          SD_CARD_TYPE_SDHC : SD_CARD_TYPE_SD2 : SD_CARD_TYPE_SD1;
    c378:	ldr	r3, [pc, #20]	; (c390 <SdioCard::type() const+0x18>)
    c37a:	ldrb	r3, [r3, #0]
    c37c:	cbz	r3, c38c <SdioCard::type() const+0x14>
    c37e:	ldr	r3, [pc, #20]	; (c394 <SdioCard::type() const+0x1c>)
    c380:	ldrb	r3, [r3, #0]
    c382:	cmp	r3, #0
    c384:	ite	ne
    c386:	movne	r0, #3
    c388:	moveq	r0, #2
    c38a:	bx	lr
    c38c:	movs	r0, #1
}
    c38e:	bx	lr
    c390:	.word	0x1fff6198
    c394:	.word	0x1fff61b0

0000c398 <cardCommand(unsigned long, unsigned long)>:
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
}
//------------------------------------------------------------------------------
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
    c398:	push	{r3, r4, r5, lr}
    c39a:	mov	r4, r0
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    c39c:	ldr	r0, [pc, #60]	; (c3dc <cardCommand(unsigned long, unsigned long)+0x44>)
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
}
//------------------------------------------------------------------------------
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
    c39e:	mov	r5, r1
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    c3a0:	bl	c2f4 <waitTimeout(bool (*)())>
    c3a4:	cbz	r0, c3aa <cardCommand(unsigned long, unsigned long)+0x12>
    return false;  // Caller will set errorCode.
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
    c3a6:	movs	r0, #0
    c3a8:	pop	{r3, r4, r5, pc}
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    return false;  // Caller will set errorCode.
  }
  SDHC_CMDARG = arg;
    c3aa:	ldr	r2, [pc, #52]	; (c3e0 <cardCommand(unsigned long, unsigned long)+0x48>)
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_MASK;
    SDHC_MIX_CTRL |= xfertyp & SDHC_MIX_CTRL_MASK;
  }
  xfertyp &= ~SDHC_MIX_CTRL_MASK;
#endif  // defined(__IMXRT1062__)
  SDHC_XFERTYP = xfertyp;
    c3ac:	ldr	r3, [pc, #52]	; (c3e4 <cardCommand(unsigned long, unsigned long)+0x4c>)
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    return false;  // Caller will set errorCode.
  }
  SDHC_CMDARG = arg;
    c3ae:	str	r5, [r2, #0]
    SDHC_MIX_CTRL |= xfertyp & SDHC_MIX_CTRL_MASK;
  }
  xfertyp &= ~SDHC_MIX_CTRL_MASK;
#endif  // defined(__IMXRT1062__)
  SDHC_XFERTYP = xfertyp;
  if (waitTimeout(isBusyCommandComplete)) {
    c3b0:	ldr	r0, [pc, #52]	; (c3e8 <cardCommand(unsigned long, unsigned long)+0x50>)
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_MASK;
    SDHC_MIX_CTRL |= xfertyp & SDHC_MIX_CTRL_MASK;
  }
  xfertyp &= ~SDHC_MIX_CTRL_MASK;
#endif  // defined(__IMXRT1062__)
  SDHC_XFERTYP = xfertyp;
    c3b2:	str	r4, [r3, #0]
  if (waitTimeout(isBusyCommandComplete)) {
    c3b4:	bl	c2f4 <waitTimeout(bool (*)())>
    c3b8:	cmp	r0, #0
    c3ba:	bne.n	c3a6 <cardCommand(unsigned long, unsigned long)+0xe>
    return false;  // Caller will set errorCode.
  }
  m_irqstat = SDHC_IRQSTAT;
    c3bc:	ldr	r2, [pc, #44]	; (c3ec <cardCommand(unsigned long, unsigned long)+0x54>)
    c3be:	ldr	r3, [pc, #48]	; (c3f0 <cardCommand(unsigned long, unsigned long)+0x58>)
    c3c0:	ldr	r1, [r2, #0]
    c3c2:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    c3c4:	ldr	r1, [r3, #0]
    c3c6:	str	r1, [r2, #0]

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
    c3c8:	ldr	r2, [r3, #0]
    c3ca:	lsls	r2, r2, #31
    c3cc:	bpl.n	c3a6 <cardCommand(unsigned long, unsigned long)+0xe>
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
    c3ce:	ldr	r3, [r3, #0]
    return false;  // Caller will set errorCode.
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
    c3d0:	tst.w	r3, #983040	; 0xf0000
    c3d4:	bne.n	c3a6 <cardCommand(unsigned long, unsigned long)+0xe>
    c3d6:	movs	r0, #1
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
    c3d8:	pop	{r3, r4, r5, pc}
    c3da:	nop
    c3dc:	.word	0x0000c155
    c3e0:	.word	0x400b1008
    c3e4:	.word	0x400b100c
    c3e8:	.word	0x0000c13d
    c3ec:	.word	0x400b1030
    c3f0:	.word	0x1fff61c0

0000c3f4 <isBusyCMD13()>:
//------------------------------------------------------------------------------
static uint32_t statusCMD13() {
  return cardCommand(CMD13_XFERTYP, m_rca) ? SDHC_CMDRSP0 : 0;
}
//------------------------------------------------------------------------------
static bool isBusyCMD13() {
    c3f4:	push	{r3, lr}
  while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) {
  }
}
//------------------------------------------------------------------------------
static uint32_t statusCMD13() {
  return cardCommand(CMD13_XFERTYP, m_rca) ? SDHC_CMDRSP0 : 0;
    c3f6:	ldr	r3, [pc, #28]	; (c414 <isBusyCMD13()+0x20>)
    c3f8:	ldr	r0, [pc, #28]	; (c418 <isBusyCMD13()+0x24>)
    c3fa:	ldr	r1, [r3, #0]
    c3fc:	bl	c398 <cardCommand(unsigned long, unsigned long)>
    c400:	cbz	r0, c410 <isBusyCMD13()+0x1c>
    c402:	ldr	r3, [pc, #24]	; (c41c <isBusyCMD13()+0x28>)
    c404:	ldr	r0, [r3, #0]
    c406:	eor.w	r0, r0, #256	; 0x100
    c40a:	ubfx	r0, r0, #8, #1
    c40e:	pop	{r3, pc}
    c410:	movs	r0, #1
}
//------------------------------------------------------------------------------
static bool isBusyCMD13() {
  return !(statusCMD13() & CARD_STATUS_READY_FOR_DATA);
}
    c412:	pop	{r3, pc}
    c414:	.word	0x1fff61b8
    c418:	.word	0x0d1a0000
    c41c:	.word	0x400b1010

0000c420 <SdioCard::status()>:
//------------------------------------------------------------------------------
uint32_t SdioCard::sectorCount() {
  return sdCardCapacity(&m_csd);
}
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
    c420:	push	{r3, lr}
  while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) {
  }
}
//------------------------------------------------------------------------------
static uint32_t statusCMD13() {
  return cardCommand(CMD13_XFERTYP, m_rca) ? SDHC_CMDRSP0 : 0;
    c422:	ldr	r3, [pc, #16]	; (c434 <SdioCard::status()+0x14>)
    c424:	ldr	r0, [pc, #16]	; (c438 <SdioCard::status()+0x18>)
    c426:	ldr	r1, [r3, #0]
    c428:	bl	c398 <cardCommand(unsigned long, unsigned long)>
    c42c:	cbz	r0, c432 <SdioCard::status()+0x12>
    c42e:	ldr	r3, [pc, #12]	; (c43c <SdioCard::status()+0x1c>)
    c430:	ldr	r0, [r3, #0]
  return sdCardCapacity(&m_csd);
}
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
}
    c432:	pop	{r3, pc}
    c434:	.word	0x1fff61b8
    c438:	.word	0x0d1a0000
    c43c:	.word	0x400b1010

0000c440 <readReg16(unsigned long, void*)>:
  }
  return waitDmaStatus();
}
//------------------------------------------------------------------------------
// Read 16 byte CID or CSD register.
static bool readReg16(uint32_t xfertyp, void* data) {
    c440:	push	{r4, r5, lr}
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    c442:	ldr	r3, [pc, #84]	; (c498 <readReg16(unsigned long, void*)+0x58>)
  }
  return waitDmaStatus();
}
//------------------------------------------------------------------------------
// Read 16 byte CID or CSD register.
static bool readReg16(uint32_t xfertyp, void* data) {
    c444:	sub	sp, #20
    c446:	mov	r5, r1
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    c448:	ldr	r1, [r3, #0]
    c44a:	bl	c398 <cardCommand(unsigned long, unsigned long)>
    c44e:	cbz	r0, c492 <readReg16(unsigned long, void*)+0x52>
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
    c450:	ldr	r2, [pc, #72]	; (c49c <readReg16(unsigned long, void*)+0x5c>)
    c452:	ldr	r3, [pc, #76]	; (c4a0 <readReg16(unsigned long, void*)+0x60>)
    c454:	ldr	r2, [r2, #0]
    c456:	str	r2, [sp, #0]
    c458:	ldr	r1, [r3, #0]
    c45a:	str	r1, [sp, #4]
    c45c:	ldr	r1, [r3, #4]
    c45e:	str	r1, [sp, #8]
    c460:	adds	r3, #8
    c462:	add.w	r4, r5, #15
    c466:	ldr	r3, [r3, #0]
    c468:	str	r3, [sp, #12]
  for (int i = 0; i < 15; i++) {
    c46a:	movs	r3, #0
    c46c:	b.n	c472 <readReg16(unsigned long, void*)+0x32>
    c46e:	ldr.w	r2, [r1, #-16]
    d[14 - i] = sr[i/4] >> 8*(i%4);
    c472:	and.w	r1, r3, #3
    c476:	lsls	r1, r1, #3
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    c478:	adds	r3, #1
    d[14 - i] = sr[i/4] >> 8*(i%4);
    c47a:	lsrs	r2, r1
    c47c:	add.w	lr, sp, #16
    c480:	bic.w	r1, r3, #3
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    c484:	cmp	r3, #15
    c486:	add	r1, lr
    d[14 - i] = sr[i/4] >> 8*(i%4);
    c488:	strb.w	r2, [r4, #-1]!
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    c48c:	bne.n	c46e <readReg16(unsigned long, void*)+0x2e>
    d[14 - i] = sr[i/4] >> 8*(i%4);
  }
  d[15] = 0;
    c48e:	movs	r3, #0
    c490:	strb	r3, [r5, #15]
  return true;
}
    c492:	add	sp, #20
    c494:	pop	{r4, r5, pc}
    c496:	nop
    c498:	.word	0x1fff61b8
    c49c:	.word	0x400b1010
    c4a0:	.word	0x400b1014

0000c4a4 <waitDmaStatus() [clone .part.4]>:
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    return false;  // Caller will set errorCode.
  }
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
    c4a4:	ldr	r3, [pc, #20]	; (c4bc <waitDmaStatus() [clone .part.4]+0x18>)
    c4a6:	ldr	r0, [r3, #0]
    c4a8:	ands.w	r0, r0, #2
    c4ac:	beq.n	c4ba <waitDmaStatus() [clone .part.4]+0x16>
    c4ae:	ldr	r3, [r3, #0]
    c4b0:	ldr	r0, [pc, #12]	; (c4c0 <waitDmaStatus() [clone .part.4]+0x1c>)
    c4b2:	ands	r0, r3
    c4b4:	clz	r0, r0
    c4b8:	lsrs	r0, r0, #5
}
    c4ba:	bx	lr
    c4bc:	.word	0x1fff61c0
    c4c0:	.word	0x117f0000

0000c4c4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>:
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
}
//------------------------------------------------------------------------------
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
    c4c4:	push	{r3, r4, r5, r6, r7, lr}
  if ((3 & (uint32_t)buf) || n == 0) {
    c4c6:	lsls	r4, r2, #30
    c4c8:	bne.n	c4cc <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x8>
    c4ca:	cbnz	r3, c4de <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x1a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c4cc:	ldr	r1, [pc, #124]	; (c54c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x88>)
  m_errorLine = line;
    c4ce:	ldr	r3, [pc, #128]	; (c550 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x8c>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c4d0:	movs	r0, #37	; 0x25
  m_errorLine = line;
    c4d2:	movw	r2, #503	; 0x1f7
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c4d6:	strb	r0, [r1, #0]
  m_errorLine = line;
    c4d8:	str	r2, [r3, #0]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    return false;
  }
  return waitDmaStatus();
}
    c4da:	movs	r0, #0
    c4dc:	pop	{r3, r4, r5, r6, r7, pc}
    c4de:	mov	r6, r0
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
  if ((3 & (uint32_t)buf) || n == 0) {
    return sdError(SD_CARD_ERROR_DMA);
  }
  if (yieldTimeout(isBusyCMD13)) {
    c4e0:	ldr	r0, [pc, #112]	; (c554 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x90>)
    c4e2:	mov	r4, r3
    c4e4:	mov	r7, r1
    c4e6:	mov	r5, r2
    c4e8:	bl	c31c <yieldTimeout(bool (*)())>
    c4ec:	cbnz	r0, c536 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x72>
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    c4ee:	ldr	r1, [pc, #104]	; (c558 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x94>)
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
    c4f0:	ldr	r2, [pc, #104]	; (c55c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x98>)
  }
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
    c4f2:	ldr.w	lr, [pc, #128]	; c574 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0xb0>
    c4f6:	mov.w	ip, #1
    c4fa:	strb.w	ip, [lr]
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    c4fe:	lsls	r3, r4, #16
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    c500:	str	r0, [r1, #0]
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    c502:	ldr	r4, [pc, #92]	; (c560 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x9c>)
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
    c504:	str	r5, [r2, #0]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    c506:	ldr	r2, [pc, #92]	; (c564 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0xa0>)
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    c508:	ldr	r1, [pc, #92]	; (c568 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0xa4>)
    c50a:	ldr	r0, [pc, #96]	; (c56c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0xa8>)
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    c50c:	orr.w	r3, r3, #512	; 0x200
    c510:	str	r3, [r4, #0]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    c512:	ldrb	r3, [r2, #0]
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    c514:	str	r0, [r1, #0]
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    c516:	cbnz	r3, c546 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x82>
    c518:	lsls	r1, r7, #9
    c51a:	mov	r0, r6
    c51c:	bl	c398 <cardCommand(unsigned long, unsigned long)>
    c520:	cmp	r0, #0
    c522:	beq.n	c4da <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x16>
  m_busyFcn = 0;
  return false;  // Caller will set errorCode.
}
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    c524:	ldr	r0, [pc, #72]	; (c570 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0xac>)
    c526:	bl	c31c <yieldTimeout(bool (*)())>
    c52a:	cmp	r0, #0
    c52c:	bne.n	c4da <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x16>
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    return false;
  }
  return waitDmaStatus();
}
    c52e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    c532:	b.w	c4a4 <waitDmaStatus() [clone .part.4]>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c536:	ldr	r1, [pc, #20]	; (c54c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x88>)
  m_errorLine = line;
    c538:	ldr	r3, [pc, #20]	; (c550 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x8c>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c53a:	movs	r0, #10
  m_errorLine = line;
    c53c:	mov.w	r2, #506	; 0x1fa
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c540:	strb	r0, [r1, #0]
  m_errorLine = line;
    c542:	str	r2, [r3, #0]
                       uint32_t sector, uint8_t* buf, size_t n) {
  if ((3 & (uint32_t)buf) || n == 0) {
    return sdError(SD_CARD_ERROR_DMA);
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    c544:	b.n	c4da <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x16>
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    c546:	mov	r1, r7
    c548:	b.n	c51a <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x56>
    c54a:	nop
    c54c:	.word	0x1fff09d4
    c550:	.word	0x1fff61e0
    c554:	.word	0x0000c3f5
    c558:	.word	0x1fff61c0
    c55c:	.word	0x400b1000
    c560:	.word	0x400b1004
    c564:	.word	0x1fff61b0
    c568:	.word	0x400b1038
    c56c:	.word	0x117f0002
    c570:	.word	0x0000c179
    c574:	.word	0x1fff61d8

0000c578 <SdioCard::sectorCount()>:
//------------------------------------------------------------------------------
bool SdioCard::readStop() {
  return transferStop();
}
//------------------------------------------------------------------------------
uint32_t SdioCard::sectorCount() {
    c578:	push	{r4, r5, r6}
  csd1_t v1;
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    c57a:	ldr	r1, [pc, #100]	; (c5e0 <SdioCard::sectorCount()+0x68>)
    c57c:	ldrb	r3, [r1, #0]
    c57e:	ands.w	r3, r3, #192	; 0xc0
    c582:	beq.n	c5a8 <SdioCard::sectorCount()+0x30>
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    c584:	cmp	r3, #64	; 0x40
    c586:	beq.n	c58e <SdioCard::sectorCount()+0x16>
    return (((uint32_t)csd->v2.c_size_high << 16) +
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
  } else {
    return 0;
    c588:	movs	r0, #0
  return sdCardCapacity(&m_csd);
}
    c58a:	pop	{r4, r5, r6}
    c58c:	bx	lr
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    c58e:	ldrb	r3, [r1, #9]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
    c590:	ldrb	r4, [r1, #7]
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    c592:	ldrb	r0, [r1, #8]
    c594:	adds	r2, r3, #1
    c596:	and.w	r3, r4, #63	; 0x3f
    c59a:	add.w	r3, r2, r3, lsl #16
    c59e:	add.w	r0, r3, r0, lsl #8
    c5a2:	lsls	r0, r0, #10
    c5a4:	pop	{r4, r5, r6}
    c5a6:	bx	lr
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
    c5a8:	ldrb	r5, [r1, #9]
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
    c5aa:	ldrb	r3, [r1, #6]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    c5ac:	ldrb	r2, [r1, #7]
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    c5ae:	ldrb	r4, [r1, #5]
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    c5b0:	ldrb	r6, [r1, #8]
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    c5b2:	ldrb	r0, [r1, #10]
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    c5b4:	and.w	r1, r5, #3
    c5b8:	lsls	r1, r1, #1
    c5ba:	and.w	r3, r3, #3
    c5be:	lsls	r2, r2, #2
    c5c0:	orr.w	r0, r1, r0, lsr #7
    c5c4:	orr.w	r3, r2, r3, lsl #10
    c5c8:	and.w	r1, r4, #15
    c5cc:	orr.w	r3, r3, r6, lsr #6
    c5d0:	add	r0, r1
    c5d2:	subs	r0, #7
    c5d4:	adds	r3, #1
    c5d6:	lsl.w	r0, r3, r0
    c5da:	pop	{r4, r5, r6}
    c5dc:	bx	lr
    c5de:	nop
    c5e0:	.word	0x1fff61c8

0000c5e4 <SdioCard::erase(unsigned long, unsigned long)>:
  enableGPIO(true);
  m_initDone = true;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::erase(uint32_t firstSector, uint32_t lastSector) {
    c5e4:	push	{r4, r5, r6, lr}
    c5e6:	mov	r5, r1
#if ENABLE_TEENSY_SDIO_MOD
  if (m_curState != IDLE_STATE && !syncDevice()) {
    c5e8:	ldrb	r1, [r0, #9]
  enableGPIO(true);
  m_initDone = true;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::erase(uint32_t firstSector, uint32_t lastSector) {
    c5ea:	mov	r6, r2
#if ENABLE_TEENSY_SDIO_MOD
  if (m_curState != IDLE_STATE && !syncDevice()) {
    c5ec:	cbnz	r1, c64a <SdioCard::erase(unsigned long, unsigned long)+0x66>
    return false;
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  // check for single sector erase
  if (!m_csd.v1.erase_blk_en) {
    c5ee:	ldr	r2, [pc, #192]	; (c6b0 <SdioCard::erase(unsigned long, unsigned long)+0xcc>)
    c5f0:	ldrb	r3, [r2, #10]
    c5f2:	and.w	r0, r3, #64	; 0x40
    c5f6:	and.w	r4, r0, #255	; 0xff
    c5fa:	cbz	r0, c624 <SdioCard::erase(unsigned long, unsigned long)+0x40>
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
      // error card can't erase specified area
      return sdError(SD_CARD_ERROR_ERASE_SINGLE_SECTOR);
    }
  }
  if (!m_highCapacity) {
    c5fc:	ldr	r3, [pc, #180]	; (c6b4 <SdioCard::erase(unsigned long, unsigned long)+0xd0>)
    c5fe:	ldrb	r3, [r3, #0]
    c600:	cbnz	r3, c606 <SdioCard::erase(unsigned long, unsigned long)+0x22>
    firstSector <<= 9;
    c602:	lsls	r5, r5, #9
    lastSector <<= 9;
    c604:	lsls	r6, r6, #9
  }
  if (!cardCommand(CMD32_XFERTYP, firstSector)) {
    c606:	mov	r1, r5
    c608:	ldr	r0, [pc, #172]	; (c6b8 <SdioCard::erase(unsigned long, unsigned long)+0xd4>)
    c60a:	bl	c398 <cardCommand(unsigned long, unsigned long)>
    c60e:	mov	r4, r0
    c610:	cbnz	r0, c65a <SdioCard::erase(unsigned long, unsigned long)+0x76>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c612:	ldr	r1, [pc, #168]	; (c6bc <SdioCard::erase(unsigned long, unsigned long)+0xd8>)
  m_errorLine = line;
    c614:	ldr	r3, [pc, #168]	; (c6c0 <SdioCard::erase(unsigned long, unsigned long)+0xdc>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c616:	movs	r0, #15
  m_errorLine = line;
    c618:	mov.w	r2, #752	; 0x2f0
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c61c:	strb	r0, [r1, #0]
  m_errorLine = line;
    c61e:	str	r2, [r3, #0]
  }
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_ERASE_TIMEOUT);
  }
  return true;
}
    c620:	mov	r0, r4
    c622:	pop	{r4, r5, r6, pc}
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  // check for single sector erase
  if (!m_csd.v1.erase_blk_en) {
    // erase size mask
    uint8_t m = (m_csd.v1.sector_size_high << 1) | m_csd.v1.sector_size_low;
    c624:	ldrb	r1, [r2, #11]
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
    c626:	and.w	r3, r3, #63	; 0x3f
    c62a:	lsls	r3, r3, #1
    c62c:	adds	r2, r6, #1
    c62e:	orr.w	r3, r3, r1, lsr #7
    c632:	orrs	r2, r5
    c634:	tst	r3, r2
    c636:	beq.n	c5fc <SdioCard::erase(unsigned long, unsigned long)+0x18>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c638:	ldr	r1, [pc, #128]	; (c6bc <SdioCard::erase(unsigned long, unsigned long)+0xd8>)
  m_errorLine = line;
    c63a:	ldr	r3, [pc, #132]	; (c6c0 <SdioCard::erase(unsigned long, unsigned long)+0xdc>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c63c:	movs	r0, #39	; 0x27
  m_errorLine = line;
    c63e:	mov.w	r2, #744	; 0x2e8
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c642:	strb	r0, [r1, #0]
  m_errorLine = line;
    c644:	str	r2, [r3, #0]
  }
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_ERASE_TIMEOUT);
  }
  return true;
}
    c646:	mov	r0, r4
    c648:	pop	{r4, r5, r6, pc}
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::erase(uint32_t firstSector, uint32_t lastSector) {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_curState != IDLE_STATE && !syncDevice()) {
    c64a:	ldr	r3, [r0, #0]
    c64c:	ldr	r3, [r3, #24]
    c64e:	blx	r3
    c650:	mov	r4, r0
    c652:	cmp	r0, #0
    c654:	bne.n	c5ee <SdioCard::erase(unsigned long, unsigned long)+0xa>
  }
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_ERASE_TIMEOUT);
  }
  return true;
}
    c656:	mov	r0, r4
    c658:	pop	{r4, r5, r6, pc}
    lastSector <<= 9;
  }
  if (!cardCommand(CMD32_XFERTYP, firstSector)) {
    return sdError(SD_CARD_ERROR_CMD32);
  }
  if (!cardCommand(CMD33_XFERTYP, lastSector)) {
    c65a:	mov	r1, r6
    c65c:	ldr	r0, [pc, #100]	; (c6c4 <SdioCard::erase(unsigned long, unsigned long)+0xe0>)
    c65e:	bl	c398 <cardCommand(unsigned long, unsigned long)>
    c662:	mov	r4, r0
    c664:	cbnz	r0, c676 <SdioCard::erase(unsigned long, unsigned long)+0x92>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c666:	ldr	r1, [pc, #84]	; (c6bc <SdioCard::erase(unsigned long, unsigned long)+0xd8>)
  m_errorLine = line;
    c668:	ldr	r3, [pc, #84]	; (c6c0 <SdioCard::erase(unsigned long, unsigned long)+0xdc>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c66a:	movs	r0, #16
  m_errorLine = line;
    c66c:	movw	r2, #755	; 0x2f3
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c670:	strb	r0, [r1, #0]
  m_errorLine = line;
    c672:	str	r2, [r3, #0]
    c674:	b.n	c620 <SdioCard::erase(unsigned long, unsigned long)+0x3c>
    return sdError(SD_CARD_ERROR_CMD32);
  }
  if (!cardCommand(CMD33_XFERTYP, lastSector)) {
     return sdError(SD_CARD_ERROR_CMD33);
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    c676:	movs	r1, #0
    c678:	ldr	r0, [pc, #76]	; (c6c8 <SdioCard::erase(unsigned long, unsigned long)+0xe4>)
    c67a:	bl	c398 <cardCommand(unsigned long, unsigned long)>
    c67e:	mov	r4, r0
    c680:	cbnz	r0, c692 <SdioCard::erase(unsigned long, unsigned long)+0xae>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c682:	ldr	r1, [pc, #56]	; (c6bc <SdioCard::erase(unsigned long, unsigned long)+0xd8>)
  m_errorLine = line;
    c684:	ldr	r3, [pc, #56]	; (c6c0 <SdioCard::erase(unsigned long, unsigned long)+0xdc>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c686:	movs	r0, #17
  m_errorLine = line;
    c688:	movw	r2, #758	; 0x2f6
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c68c:	strb	r0, [r1, #0]
  m_errorLine = line;
    c68e:	str	r2, [r3, #0]
    c690:	b.n	c620 <SdioCard::erase(unsigned long, unsigned long)+0x3c>
     return sdError(SD_CARD_ERROR_CMD33);
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD38);
  }
  if (waitTimeout(isBusyCMD13)) {
    c692:	ldr	r0, [pc, #56]	; (c6cc <SdioCard::erase(unsigned long, unsigned long)+0xe8>)
    c694:	bl	c2f4 <waitTimeout(bool (*)())>
    c698:	cmp	r0, #0
    c69a:	beq.n	c620 <SdioCard::erase(unsigned long, unsigned long)+0x3c>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c69c:	ldr	r1, [pc, #28]	; (c6bc <SdioCard::erase(unsigned long, unsigned long)+0xd8>)
  m_errorLine = line;
    c69e:	ldr	r3, [pc, #32]	; (c6c0 <SdioCard::erase(unsigned long, unsigned long)+0xdc>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c6a0:	movs	r0, #40	; 0x28
  m_errorLine = line;
    c6a2:	movw	r2, #761	; 0x2f9
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c6a6:	strb	r0, [r1, #0]
  m_errorLine = line;
    c6a8:	str	r2, [r3, #0]
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD38);
  }
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_ERASE_TIMEOUT);
    c6aa:	movs	r4, #0
    c6ac:	b.n	c620 <SdioCard::erase(unsigned long, unsigned long)+0x3c>
    c6ae:	nop
    c6b0:	.word	0x1fff61c8
    c6b4:	.word	0x1fff61b0
    c6b8:	.word	0x201a0000
    c6bc:	.word	0x1fff09d4
    c6c0:	.word	0x1fff61e0
    c6c4:	.word	0x211a0000
    c6c8:	.word	0x261b0000
    c6cc:	.word	0x0000c3f5

0000c6d0 <waitTransferComplete() [clone .part.8]>:
  }
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
    c6d0:	push	{r4, lr}
  if (!m_transferActive) {
    return true;
  }
  bool timeOut = waitTimeout(isBusyTransferComplete);
    c6d2:	ldr	r0, [pc, #56]	; (c70c <waitTransferComplete() [clone .part.8]+0x3c>)
    c6d4:	bl	c2f4 <waitTimeout(bool (*)())>
  m_transferActive = false;
    c6d8:	ldr	r1, [pc, #52]	; (c710 <waitTransferComplete() [clone .part.8]+0x40>)
  m_irqstat = SDHC_IRQSTAT;
    c6da:	ldr	r2, [pc, #56]	; (c714 <waitTransferComplete() [clone .part.8]+0x44>)
    c6dc:	ldr	r3, [pc, #56]	; (c718 <waitTransferComplete() [clone .part.8]+0x48>)
static bool waitTransferComplete() {
  if (!m_transferActive) {
    return true;
  }
  bool timeOut = waitTimeout(isBusyTransferComplete);
  m_transferActive = false;
    c6de:	movs	r4, #0
    c6e0:	strb	r4, [r1, #0]
  m_irqstat = SDHC_IRQSTAT;
    c6e2:	ldr	r1, [r2, #0]
    c6e4:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    c6e6:	ldr	r1, [r3, #0]
    c6e8:	str	r1, [r2, #0]
  if (timeOut || (m_irqstat & SDHC_IRQSTAT_ERROR)) {
    c6ea:	cbnz	r0, c6f4 <waitTransferComplete() [clone .part.8]+0x24>
    c6ec:	ldr	r2, [r3, #0]
    c6ee:	ldr	r3, [pc, #44]	; (c71c <waitTransferComplete() [clone .part.8]+0x4c>)
    c6f0:	ands	r3, r2
    c6f2:	cbz	r3, c706 <waitTransferComplete() [clone .part.8]+0x36>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c6f4:	ldr	r1, [pc, #40]	; (c720 <waitTransferComplete() [clone .part.8]+0x50>)
  m_errorLine = line;
    c6f6:	ldr	r3, [pc, #44]	; (c724 <waitTransferComplete() [clone .part.8]+0x54>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c6f8:	movs	r0, #31
  m_errorLine = line;
    c6fa:	movw	r2, #638	; 0x27e
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c6fe:	strb	r0, [r1, #0]
  m_errorLine = line;
    c700:	str	r2, [r3, #0]
  bool timeOut = waitTimeout(isBusyTransferComplete);
  m_transferActive = false;
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  if (timeOut || (m_irqstat & SDHC_IRQSTAT_ERROR)) {
    return sdError(SD_CARD_ERROR_TRANSFER_COMPLETE);
    c702:	movs	r0, #0
  }
  return true;
}
    c704:	pop	{r4, pc}
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  if (timeOut || (m_irqstat & SDHC_IRQSTAT_ERROR)) {
    return sdError(SD_CARD_ERROR_TRANSFER_COMPLETE);
  }
  return true;
    c706:	movs	r0, #1
    c708:	pop	{r4, pc}
    c70a:	nop
    c70c:	.word	0x0000c1ad
    c710:	.word	0x1fff61bc
    c714:	.word	0x400b1030
    c718:	.word	0x1fff61c0
    c71c:	.word	0x117f0000
    c720:	.word	0x1fff09d4
    c724:	.word	0x1fff61e0

0000c728 <SdioCard::readStop()>:
    return sdError(SD_CARD_ERROR_CMD25);
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
    c728:	push	{r4, r5, r6, lr}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
}
//------------------------------------------------------------------------------
static bool transferStop() {
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    c72a:	ldr	r4, [pc, #104]	; (c794 <SdioCard::readStop()+0x6c>)
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    c72c:	ldr	r0, [pc, #104]	; (c798 <SdioCard::readStop()+0x70>)
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
}
//------------------------------------------------------------------------------
static bool transferStop() {
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    c72e:	ldr	r3, [r4, #0]
    c730:	bic.w	r3, r3, #65536	; 0x10000
    c734:	str	r3, [r4, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    c736:	movs	r1, #0
    c738:	bl	c398 <cardCommand(unsigned long, unsigned long)>
    c73c:	mov	r5, r0
    c73e:	cbnz	r0, c752 <SdioCard::readStop()+0x2a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c740:	ldr	r1, [pc, #88]	; (c79c <SdioCard::readStop()+0x74>)
  m_errorLine = line;
    c742:	ldr	r3, [pc, #92]	; (c7a0 <SdioCard::readStop()+0x78>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c744:	movs	r0, #9
  m_errorLine = line;
    c746:	movw	r2, #575	; 0x23f
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c74a:	strb	r0, [r1, #0]
  m_errorLine = line;
    c74c:	str	r2, [r3, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
  return transferStop();
}
    c74e:	mov	r0, r5
    c750:	pop	{r4, r5, r6, pc}
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
//  if (yieldTimeout(isBusyCMD13)) {
  if (yieldTimeout(isBusyDat)) {
    c752:	ldr	r0, [pc, #80]	; (c7a4 <SdioCard::readStop()+0x7c>)
    c754:	bl	c31c <yieldTimeout(bool (*)())>
    c758:	cbnz	r0, c77e <SdioCard::readStop()+0x56>
    return sdError(SD_CARD_ERROR_CMD13);
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    c75a:	ldr	r3, [pc, #76]	; (c7a8 <SdioCard::readStop()+0x80>)
    c75c:	ldr	r3, [r3, #0]
    c75e:	lsls	r3, r3, #30
    c760:	bpl.n	c74e <SdioCard::readStop()+0x26>
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    c762:	ldr	r1, [pc, #72]	; (c7ac <SdioCard::readStop()+0x84>)
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    c764:	ldr	r0, [pc, #72]	; (c7b0 <SdioCard::readStop()+0x88>)
    return sdError(SD_CARD_ERROR_CMD13);
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    c766:	ldr	r6, [r1, #0]
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    c768:	ldr	r3, [r4, #0]
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    c76a:	ldr	r2, [r0, #0]
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    c76c:	bic.w	r3, r3, #65536	; 0x10000
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    c770:	orr.w	r2, r2, #67108864	; 0x4000000
    c774:	str	r2, [r0, #0]
    // Restore registers.
    SDHC_IRQSTATEN = irqsststen;
    c776:	str	r6, [r1, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
  return transferStop();
}
    c778:	mov	r0, r5
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    // Restore registers.
    SDHC_IRQSTATEN = irqsststen;
    SDHC_PROCTL = proctl;
    c77a:	str	r3, [r4, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
  return transferStop();
}
    c77c:	pop	{r4, r5, r6, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c77e:	ldr	r1, [pc, #28]	; (c79c <SdioCard::readStop()+0x74>)
  m_errorLine = line;
    c780:	ldr	r3, [pc, #28]	; (c7a0 <SdioCard::readStop()+0x78>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c782:	movs	r0, #10
  m_errorLine = line;
    c784:	movw	r2, #579	; 0x243
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c788:	strb	r0, [r1, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
//  if (yieldTimeout(isBusyCMD13)) {
  if (yieldTimeout(isBusyDat)) {
    return sdError(SD_CARD_ERROR_CMD13);
    c78a:	movs	r5, #0
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    c78c:	str	r2, [r3, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
  return transferStop();
}
    c78e:	mov	r0, r5
    c790:	pop	{r4, r5, r6, pc}
    c792:	nop
    c794:	.word	0x400b1028
    c798:	.word	0x0cdb0000
    c79c:	.word	0x1fff09d4
    c7a0:	.word	0x1fff61e0
    c7a4:	.word	0x0000c165
    c7a8:	.word	0x400b1024
    c7ac:	.word	0x400b1034
    c7b0:	.word	0x400b102c

0000c7b4 <SdioCard::writeData(unsigned char const*)>:
uint8_t SdioCard::type() const {
  return  m_version2 ? m_highCapacity ?
          SD_CARD_TYPE_SDHC : SD_CARD_TYPE_SD2 : SD_CARD_TYPE_SD1;
}
//------------------------------------------------------------------------------
bool SdioCard::writeData(const uint8_t* src) {
    c7b4:	push	{r4, r5, r6, lr}
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
  if (!m_transferActive) {
    c7b6:	ldr	r6, [pc, #124]	; (c834 <SdioCard::writeData(unsigned char const*)+0x80>)
    c7b8:	ldrb	r3, [r6, #0]
uint8_t SdioCard::type() const {
  return  m_version2 ? m_highCapacity ?
          SD_CARD_TYPE_SDHC : SD_CARD_TYPE_SD2 : SD_CARD_TYPE_SD1;
}
//------------------------------------------------------------------------------
bool SdioCard::writeData(const uint8_t* src) {
    c7ba:	mov	r5, r1
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
  if (!m_transferActive) {
    c7bc:	cmp	r3, #0
    c7be:	bne.n	c828 <SdioCard::writeData(unsigned char const*)+0x74>
  if (!waitTransferComplete()) {
    return false;
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  const uint32_t* p32 = reinterpret_cast<const uint32_t*>(src);
  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_WTA)) {
    c7c0:	ldr	r3, [pc, #116]	; (c838 <SdioCard::writeData(unsigned char const*)+0x84>)
    c7c2:	ldr	r3, [r3, #0]
    c7c4:	lsls	r1, r3, #23
    c7c6:	bmi.n	c7da <SdioCard::writeData(unsigned char const*)+0x26>
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    c7c8:	ldr	r3, [pc, #112]	; (c83c <SdioCard::writeData(unsigned char const*)+0x88>)
    c7ca:	ldr	r2, [r3, #0]
    c7cc:	bic.w	r2, r2, #65536	; 0x10000
    c7d0:	str	r2, [r3, #0]
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    c7d2:	ldr	r2, [r3, #0]
    c7d4:	orr.w	r2, r2, #131072	; 0x20000
    c7d8:	str	r2, [r3, #0]
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    c7da:	ldr	r2, [pc, #96]	; (c83c <SdioCard::writeData(unsigned char const*)+0x88>)
  if (waitTimeout(isBusyFifoWrite)) {
    c7dc:	ldr	r0, [pc, #96]	; (c840 <SdioCard::writeData(unsigned char const*)+0x8c>)
  const uint32_t* p32 = reinterpret_cast<const uint32_t*>(src);
  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_WTA)) {
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    c7de:	ldr	r3, [r2, #0]
    c7e0:	orr.w	r3, r3, #65536	; 0x10000
    c7e4:	str	r3, [r2, #0]
  if (waitTimeout(isBusyFifoWrite)) {
    c7e6:	bl	c2f4 <waitTimeout(bool (*)())>
    c7ea:	cbnz	r0, c816 <SdioCard::writeData(unsigned char const*)+0x62>
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    c7ec:	ldr	r4, [pc, #72]	; (c838 <SdioCard::writeData(unsigned char const*)+0x84>)
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      SDHC_DATPORT = p32[i];
    c7ee:	ldr	r0, [pc, #84]	; (c844 <SdioCard::writeData(unsigned char const*)+0x90>)
    c7f0:	subs	r3, r5, #4
    c7f2:	add.w	r5, r5, #508	; 0x1fc
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    c7f6:	ldr	r2, [r4, #0]
    c7f8:	lsls	r2, r2, #21
    c7fa:	bpl.n	c7f6 <SdioCard::writeData(unsigned char const*)+0x42>
    c7fc:	add.w	r1, r3, #64	; 0x40
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      SDHC_DATPORT = p32[i];
    c800:	ldr.w	r2, [r3, #4]!
    c804:	str	r2, [r0, #0]
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
    c806:	cmp	r1, r3
    c808:	bne.n	c800 <SdioCard::writeData(unsigned char const*)+0x4c>
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    c80a:	cmp	r5, r1
    c80c:	mov	r3, r1
    c80e:	bne.n	c7f6 <SdioCard::writeData(unsigned char const*)+0x42>
      SDHC_DATPORT = p32[i];
    }
    p32 += FIFO_WML;
  }
#if ENABLE_TEENSY_SDIO_MOD
  m_transferActive = true;
    c810:	movs	r0, #1
    c812:	strb	r0, [r6, #0]
    c814:	pop	{r4, r5, r6, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c816:	ldr	r1, [pc, #48]	; (c848 <SdioCard::writeData(unsigned char const*)+0x94>)
  m_errorLine = line;
    c818:	ldr	r3, [pc, #48]	; (c84c <SdioCard::writeData(unsigned char const*)+0x98>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c81a:	movs	r0, #33	; 0x21
  m_errorLine = line;
    c81c:	mov.w	r2, #1012	; 0x3f4
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c820:	strb	r0, [r1, #0]
  m_errorLine = line;
    c822:	str	r2, [r3, #0]
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
    c824:	movs	r0, #0
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    c826:	pop	{r4, r5, r6, pc}
    c828:	bl	c6d0 <waitTransferComplete() [clone .part.8]>
}
//------------------------------------------------------------------------------
bool SdioCard::writeData(const uint8_t* src) {
  DBG_IRQSTAT();
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    c82c:	cmp	r0, #0
    c82e:	bne.n	c7c0 <SdioCard::writeData(unsigned char const*)+0xc>
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    c830:	pop	{r4, r5, r6, pc}
    c832:	nop
    c834:	.word	0x1fff61bc
    c838:	.word	0x400b1024
    c83c:	.word	0x400b1028
    c840:	.word	0x0000c199
    c844:	.word	0x400b1020
    c848:	.word	0x1fff09d4
    c84c:	.word	0x1fff61e0

0000c850 <SdioCard::writeStart(unsigned long)>:
    }
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
    c850:	push	{r3, r4, r5, lr}
  if (yieldTimeout(isBusyCMD13)) {
    c852:	ldr	r0, [pc, #80]	; (c8a4 <SdioCard::writeStart(unsigned long)+0x54>)
    }
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
    c854:	mov	r4, r1
  if (yieldTimeout(isBusyCMD13)) {
    c856:	bl	c31c <yieldTimeout(bool (*)())>
    c85a:	cbnz	r0, c890 <SdioCard::writeStart(unsigned long)+0x40>
    return sdError(SD_CARD_ERROR_CMD13);
  }
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    c85c:	ldr	r2, [pc, #72]	; (c8a8 <SdioCard::writeStart(unsigned long)+0x58>)
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    c85e:	ldr	r1, [pc, #76]	; (c8ac <SdioCard::writeStart(unsigned long)+0x5c>)
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    c860:	ldr	r3, [r2, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
    c862:	ldr	r0, [pc, #76]	; (c8b0 <SdioCard::writeStart(unsigned long)+0x60>)
    c864:	ldr	r5, [pc, #76]	; (c8b4 <SdioCard::writeStart(unsigned long)+0x64>)
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    c866:	bic.w	r3, r3, #65536	; 0x10000
    c86a:	str	r3, [r2, #0]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    c86c:	ldrb	r3, [r1, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
    c86e:	str	r5, [r0, #0]
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    c870:	cbnz	r3, c88c <SdioCard::writeStart(unsigned long)+0x3c>
    c872:	lsls	r1, r4, #9
    c874:	ldr	r0, [pc, #64]	; (c8b8 <SdioCard::writeStart(unsigned long)+0x68>)
    c876:	bl	c398 <cardCommand(unsigned long, unsigned long)>
    c87a:	cbnz	r0, c88a <SdioCard::writeStart(unsigned long)+0x3a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c87c:	ldr	r1, [pc, #60]	; (c8bc <SdioCard::writeStart(unsigned long)+0x6c>)
  m_errorLine = line;
    c87e:	ldr	r3, [pc, #64]	; (c8c0 <SdioCard::writeStart(unsigned long)+0x70>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c880:	movs	r4, #14
  m_errorLine = line;
    c882:	mov.w	r2, #1128	; 0x468
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c886:	strb	r4, [r1, #0]
  m_errorLine = line;
    c888:	str	r2, [r3, #0]
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    return sdError(SD_CARD_ERROR_CMD25);
  }
  return true;
}
    c88a:	pop	{r3, r4, r5, pc}
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    c88c:	mov	r1, r4
    c88e:	b.n	c874 <SdioCard::writeStart(unsigned long)+0x24>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c890:	ldr	r1, [pc, #40]	; (c8bc <SdioCard::writeStart(unsigned long)+0x6c>)
  m_errorLine = line;
    c892:	ldr	r3, [pc, #44]	; (c8c0 <SdioCard::writeStart(unsigned long)+0x70>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c894:	movs	r0, #10
  m_errorLine = line;
    c896:	movw	r2, #1116	; 0x45c
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c89a:	strb	r0, [r1, #0]
  m_errorLine = line;
    c89c:	str	r2, [r3, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    c89e:	movs	r0, #0
    c8a0:	pop	{r3, r4, r5, pc}
    c8a2:	nop
    c8a4:	.word	0x0000c3f5
    c8a8:	.word	0x400b1028
    c8ac:	.word	0x1fff61b0
    c8b0:	.word	0x400b1004
    c8b4:	.word	0xffff0200
    c8b8:	.word	0x193a0022
    c8bc:	.word	0x1fff09d4
    c8c0:	.word	0x1fff61e0

0000c8c4 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>:
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
    c8c4:	push	{r3, r4, r5, r6, r7, lr}
    c8c6:	mov	r6, r0
  if (m_sdioConfig.useDma()) {
    c8c8:	ldrb	r0, [r0, #8]
    c8ca:	lsls	r0, r0, #31
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
    c8cc:	mov	r4, r1
    c8ce:	mov	r5, r2
    c8d0:	mov	r7, r3
  if (m_sdioConfig.useDma()) {
    c8d2:	bmi.n	c8fc <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x38>
    }
    if (!rdWrSectors(CMD25_DMA_XFERTYP, sector, ptr, n)) {
      return sdError(SD_CARD_ERROR_CMD25);
    }
  } else {
    for (size_t i = 0; i < n; i++) {
    c8d4:	cbz	r3, c8f8 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x34>
    c8d6:	add	r7, r1
    c8d8:	b.n	c8de <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x1a>
    c8da:	cmp	r4, r7
    c8dc:	beq.n	c8f8 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x34>
      if (!writeSector(sector + i, src + i*512UL)) {
    c8de:	ldr	r3, [r6, #0]
    c8e0:	mov	r2, r5
    c8e2:	mov	r1, r4
    c8e4:	ldr	r3, [r3, #28]
    c8e6:	mov	r0, r6
    c8e8:	blx	r3
    c8ea:	adds	r4, #1
    c8ec:	add.w	r5, r5, #512	; 0x200
    c8f0:	cmp	r0, #0
    c8f2:	bne.n	c8da <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x16>
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr = const_cast<uint8_t*>(src);
    if (3 & (uint32_t)ptr) {
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
        if (!writeSector(sector, ptr)) {
          return false;  // writeSector will set errorCode.
    c8f4:	movs	r0, #0
    c8f6:	pop	{r3, r4, r5, r6, r7, pc}
      if (!writeSector(sector + i, src + i*512UL)) {
        return false;
      }
    }
  }
  return true;
    c8f8:	movs	r0, #1
    c8fa:	pop	{r3, r4, r5, r6, r7, pc}
}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr = const_cast<uint8_t*>(src);
    if (3 & (uint32_t)ptr) {
    c8fc:	lsls	r0, r2, #30
    c8fe:	beq.n	c926 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x62>
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
    c900:	cmp	r3, #0
    c902:	beq.n	c8f8 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x34>
    c904:	add	r7, r1
    c906:	b.n	c90c <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x48>
    c908:	cmp	r7, r4
    c90a:	beq.n	c8f8 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x34>
        if (!writeSector(sector, ptr)) {
    c90c:	ldr	r3, [r6, #0]
    c90e:	mov	r2, r5
    c910:	mov	r1, r4
    c912:	ldr	r3, [r3, #28]
    c914:	mov	r0, r6
    c916:	blx	r3
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr = const_cast<uint8_t*>(src);
    if (3 & (uint32_t)ptr) {
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
    c918:	adds	r4, #1
    c91a:	add.w	r5, r5, #512	; 0x200
        if (!writeSector(sector, ptr)) {
    c91e:	cmp	r0, #0
    c920:	bne.n	c908 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x44>
          return false;  // writeSector will set errorCode.
    c922:	movs	r0, #0
    c924:	pop	{r3, r4, r5, r6, r7, pc}
        }
      }
      return true;
    }
    if (!rdWrSectors(CMD25_DMA_XFERTYP, sector, ptr, n)) {
    c926:	ldr	r0, [pc, #24]	; (c940 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x7c>)
    c928:	bl	c4c4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    c92c:	cmp	r0, #0
    c92e:	bne.n	c8f8 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x34>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c930:	ldr	r1, [pc, #16]	; (c944 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x80>)
  m_errorLine = line;
    c932:	ldr	r3, [pc, #20]	; (c948 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x84>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c934:	movs	r4, #14
  m_errorLine = line;
    c936:	movw	r2, #1102	; 0x44e
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c93a:	strb	r4, [r1, #0]
  m_errorLine = line;
    c93c:	str	r2, [r3, #0]
    c93e:	pop	{r3, r4, r5, r6, r7, pc}
    c940:	.word	0x193a0027
    c944:	.word	0x1fff09d4
    c948:	.word	0x1fff61e0

0000c94c <SdioCard::writeSector(unsigned long, unsigned char const*)>:
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    c94c:	push	{r4, r5, r6, lr}
  if (m_sdioConfig.useDma()) {
    c94e:	ldrb	r3, [r0, #8]
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    c950:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    c952:	lsls	r2, r3, #31
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    c954:	sub.w	sp, sp, #512	; 0x200
    c958:	mov	r6, r1
  if (m_sdioConfig.useDma()) {
    c95a:	bpl.n	c990 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x44>
    uint8_t* ptr;
    uint8_t aligned[512];
    if (3 & (uint32_t)src) {
    c95c:	lsls	r3, r5, #30
    c95e:	beq.n	c96e <SdioCard::writeSector(unsigned long, unsigned char const*)+0x22>
      ptr = aligned;
      memcpy(aligned, src, 512);
    c960:	mov	r1, r5
    c962:	mov	r0, sp
    c964:	mov.w	r2, #512	; 0x200
    c968:	bl	d444 <memcpy>
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr;
    uint8_t aligned[512];
    if (3 & (uint32_t)src) {
      ptr = aligned;
    c96c:	mov	r5, sp
      memcpy(aligned, src, 512);
    } else {
      ptr = const_cast<uint8_t*>(src);
    }
    if (!rdWrSectors(CMD24_DMA_XFERTYP, sector, ptr, 1)) {
    c96e:	mov	r2, r5
    c970:	mov	r1, r6
    c972:	movs	r3, #1
    c974:	ldr	r0, [pc, #144]	; (ca08 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xbc>)
    c976:	bl	c4c4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    c97a:	cbnz	r0, c98a <SdioCard::writeSector(unsigned long, unsigned char const*)+0x3e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c97c:	ldr	r1, [pc, #140]	; (ca0c <SdioCard::writeSector(unsigned long, unsigned char const*)+0xc0>)
  m_errorLine = line;
    c97e:	ldr	r3, [pc, #144]	; (ca10 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xc4>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c980:	movs	r4, #13
  m_errorLine = line;
    c982:	movw	r2, #1046	; 0x416
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    c986:	strb	r4, [r1, #0]
  m_errorLine = line;
    c988:	str	r2, [r3, #0]
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
    c98a:	add.w	sp, sp, #512	; 0x200
    c98e:	pop	{r4, r5, r6, pc}
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
  if (!m_transferActive) {
    c990:	ldr	r3, [pc, #128]	; (ca14 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xc8>)
    c992:	ldrb	r3, [r3, #0]
    c994:	mov	r4, r0
    c996:	cbnz	r3, c9ba <SdioCard::writeSector(unsigned long, unsigned char const*)+0x6e>
    if (!waitTransferComplete()) {
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    // End transfer with CMD12 if required.
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
    c998:	ldr	r3, [pc, #124]	; (ca18 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xcc>)
    c99a:	ldr	r3, [r3, #0]
    c99c:	lsrs	r3, r3, #16
    c99e:	lsls	r3, r3, #16
    c9a0:	cbz	r3, c9f8 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xac>
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != WRITE_STATE || m_curSector != sector) {
    c9a2:	ldrb	r3, [r4, #9]
    c9a4:	cmp	r3, #2
    c9a6:	beq.n	c9c6 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x7a>
      if (!syncDevice()) {
    c9a8:	ldr	r3, [r4, #0]
    c9aa:	mov	r0, r4
    c9ac:	ldr	r3, [r3, #24]
    c9ae:	blx	r3
    c9b0:	cbnz	r0, c9ce <SdioCard::writeSector(unsigned long, unsigned char const*)+0x82>
      return sdError(SD_CARD_ERROR_CMD24);
    }
  } else {
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
      return false;
    c9b2:	movs	r0, #0
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
    c9b4:	add.w	sp, sp, #512	; 0x200
    c9b8:	pop	{r4, r5, r6, pc}
    c9ba:	bl	c6d0 <waitTransferComplete() [clone .part.8]>
    if (!rdWrSectors(CMD24_DMA_XFERTYP, sector, ptr, 1)) {
      return sdError(SD_CARD_ERROR_CMD24);
    }
  } else {
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
    c9be:	cmp	r0, #0
    c9c0:	bne.n	c998 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4c>
      return false;
    c9c2:	movs	r0, #0
    c9c4:	b.n	c9b4 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x68>
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != WRITE_STATE || m_curSector != sector) {
    c9c6:	ldr	r3, [r4, #4]
    c9c8:	cmp	r6, r3
    c9ca:	bne.n	c9a8 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x5c>
    c9cc:	b.n	c9e2 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x96>
      if (!syncDevice()) {
        return false;
      }
      if (!writeStart(sector )) {
    c9ce:	ldr	r3, [r4, #0]
    c9d0:	mov	r1, r6
    c9d2:	ldr	r3, [r3, #72]	; 0x48
    c9d4:	mov	r0, r4
    c9d6:	blx	r3
    c9d8:	cmp	r0, #0
    c9da:	beq.n	c9b2 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x66>
        return false;
      }
      m_curSector = sector;
      m_curState = WRITE_STATE;
    c9dc:	movs	r3, #2
        return false;
      }
      if (!writeStart(sector )) {
        return false;
      }
      m_curSector = sector;
    c9de:	str	r6, [r4, #4]
      m_curState = WRITE_STATE;
    c9e0:	strb	r3, [r4, #9]
    }
    if (!writeData(src)) {
    c9e2:	ldr	r3, [r4, #0]
    c9e4:	mov	r1, r5
    c9e6:	ldr	r3, [r3, #68]	; 0x44
    c9e8:	mov	r0, r4
    c9ea:	blx	r3
    c9ec:	cmp	r0, #0
    c9ee:	beq.n	c9b2 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x66>
      return false;
    }
    m_curSector++;
    c9f0:	ldr	r3, [r4, #4]
    c9f2:	adds	r3, #1
    c9f4:	str	r3, [r4, #4]
    c9f6:	b.n	c98a <SdioCard::writeSector(unsigned long, unsigned char const*)+0x3e>
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    // End transfer with CMD12 if required.
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
      if (!syncDevice()) {
    c9f8:	ldr	r3, [r4, #0]
    c9fa:	mov	r0, r4
    c9fc:	ldr	r3, [r3, #24]
    c9fe:	blx	r3
    ca00:	cmp	r0, #0
    ca02:	bne.n	c9a2 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x56>
    ca04:	b.n	c9b2 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x66>
    ca06:	nop
    ca08:	.word	0x183a0001
    ca0c:	.word	0x1fff09d4
    ca10:	.word	0x1fff61e0
    ca14:	.word	0x1fff61bc
    ca18:	.word	0x400b1004

0000ca1c <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)>:
    m_curSector++;
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
    ca1c:	push	{r3, r4, r5, r6, r7, lr}
    ca1e:	mov	r6, r0
  if (m_sdioConfig.useDma()) {
    ca20:	ldrb	r0, [r0, #8]
    ca22:	lsls	r0, r0, #31
    m_curSector++;
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
    ca24:	mov	r4, r1
    ca26:	mov	r5, r2
    ca28:	mov	r7, r3
  if (m_sdioConfig.useDma()) {
    ca2a:	bmi.n	ca54 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x38>
    }
    if (!rdWrSectors(CMD18_DMA_XFERTYP, sector, dst, n)) {
      return sdError(SD_CARD_ERROR_CMD18);
    }
  } else {
    for (size_t i = 0; i < n; i++) {
    ca2c:	cbz	r3, ca50 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x34>
    ca2e:	add	r7, r1
    ca30:	b.n	ca36 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x1a>
    ca32:	cmp	r4, r7
    ca34:	beq.n	ca50 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x34>
      if (!readSector(sector + i, dst + i*512UL)) {
    ca36:	ldr	r3, [r6, #0]
    ca38:	mov	r2, r5
    ca3a:	mov	r1, r4
    ca3c:	ldr	r3, [r3, #12]
    ca3e:	mov	r0, r6
    ca40:	blx	r3
    ca42:	adds	r4, #1
    ca44:	add.w	r5, r5, #512	; 0x200
    ca48:	cmp	r0, #0
    ca4a:	bne.n	ca32 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x16>
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
  if (m_sdioConfig.useDma()) {
    if ((uint32_t)dst & 3) {
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
        if (!readSector(sector, dst)) {
          return false;  // readSector will set errorCode.
    ca4c:	movs	r0, #0
    ca4e:	pop	{r3, r4, r5, r6, r7, pc}
      if (!readSector(sector + i, dst + i*512UL)) {
        return false;
      }
    }
  }
  return true;
    ca50:	movs	r0, #1
    ca52:	pop	{r3, r4, r5, r6, r7, pc}
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
  if (m_sdioConfig.useDma()) {
    if ((uint32_t)dst & 3) {
    ca54:	lsls	r0, r2, #30
    ca56:	beq.n	ca7e <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x62>
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
    ca58:	cmp	r3, #0
    ca5a:	beq.n	ca50 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x34>
    ca5c:	add	r7, r1
    ca5e:	b.n	ca64 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x48>
    ca60:	cmp	r7, r4
    ca62:	beq.n	ca50 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x34>
        if (!readSector(sector, dst)) {
    ca64:	ldr	r3, [r6, #0]
    ca66:	mov	r2, r5
    ca68:	mov	r1, r4
    ca6a:	ldr	r3, [r3, #12]
    ca6c:	mov	r0, r6
    ca6e:	blx	r3
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
  if (m_sdioConfig.useDma()) {
    if ((uint32_t)dst & 3) {
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
    ca70:	adds	r4, #1
    ca72:	add.w	r5, r5, #512	; 0x200
        if (!readSector(sector, dst)) {
    ca76:	cmp	r0, #0
    ca78:	bne.n	ca60 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x44>
          return false;  // readSector will set errorCode.
    ca7a:	movs	r0, #0
    ca7c:	pop	{r3, r4, r5, r6, r7, pc}
        }
      }
      return true;
    }
    if (!rdWrSectors(CMD18_DMA_XFERTYP, sector, dst, n)) {
    ca7e:	ldr	r0, [pc, #24]	; (ca98 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x7c>)
    ca80:	bl	c4c4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    ca84:	cmp	r0, #0
    ca86:	bne.n	ca50 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x34>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    ca88:	ldr	r1, [pc, #16]	; (ca9c <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x80>)
  m_errorLine = line;
    ca8a:	ldr	r3, [pc, #20]	; (caa0 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x84>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    ca8c:	movs	r4, #12
  m_errorLine = line;
    ca8e:	movw	r2, #909	; 0x38d
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    ca92:	strb	r4, [r1, #0]
  m_errorLine = line;
    ca94:	str	r2, [r3, #0]
    ca96:	pop	{r3, r4, r5, r6, r7, pc}
    ca98:	.word	0x123a0037
    ca9c:	.word	0x1fff09d4
    caa0:	.word	0x1fff61e0

0000caa4 <cardCMD6(unsigned long, unsigned char*)>:

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
//------------------------------------------------------------------------------
static bool cardCMD6(uint32_t arg, uint8_t* status) {
    caa4:	push	{r3, r4, r5, r6, r7, lr}
    caa6:	mov	r5, r0
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    caa8:	ldr	r0, [pc, #116]	; (cb20 <cardCMD6(unsigned long, unsigned char*)+0x7c>)

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
//------------------------------------------------------------------------------
static bool cardCMD6(uint32_t arg, uint8_t* status) {
    caaa:	mov	r4, r1
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    caac:	bl	c2f4 <waitTimeout(bool (*)())>
    cab0:	cbz	r0, cac4 <cardCMD6(unsigned long, unsigned char*)+0x20>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cab2:	ldr	r1, [pc, #112]	; (cb24 <cardCMD6(unsigned long, unsigned char*)+0x80>)
  m_errorLine = line;
    cab4:	ldr	r3, [pc, #112]	; (cb28 <cardCMD6(unsigned long, unsigned char*)+0x84>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cab6:	movs	r0, #10
  m_errorLine = line;
    cab8:	mov.w	r2, #410	; 0x19a
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cabc:	strb	r0, [r1, #0]
  m_errorLine = line;
    cabe:	str	r2, [r3, #0]
}
//------------------------------------------------------------------------------
static bool cardCMD6(uint32_t arg, uint8_t* status) {
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    cac0:	movs	r0, #0
    cac2:	pop	{r3, r4, r5, r6, r7, pc}
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    cac4:	ldr	r2, [pc, #100]	; (cb2c <cardCMD6(unsigned long, unsigned char*)+0x88>)
  }
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
    cac6:	ldr.w	lr, [pc, #132]	; cb4c <cardCMD6(unsigned long, unsigned char*)+0xa8>
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
    caca:	ldr	r7, [pc, #100]	; (cb30 <cardCMD6(unsigned long, unsigned char*)+0x8c>)
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
    cacc:	ldr	r6, [pc, #100]	; (cb34 <cardCMD6(unsigned long, unsigned char*)+0x90>)
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    cace:	ldr	r3, [pc, #104]	; (cb38 <cardCMD6(unsigned long, unsigned char*)+0x94>)
  }
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
    cad0:	mov.w	ip, #1
    cad4:	strb.w	ip, [lr]
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    cad8:	mov	r1, r5
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    cada:	str	r0, [r2, #0]
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
    cadc:	ldr	r5, [pc, #92]	; (cb3c <cardCMD6(unsigned long, unsigned char*)+0x98>)
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    cade:	ldr	r2, [pc, #96]	; (cb40 <cardCMD6(unsigned long, unsigned char*)+0x9c>)
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
    cae0:	str	r4, [r7, #0]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    cae2:	ldr	r0, [pc, #96]	; (cb44 <cardCMD6(unsigned long, unsigned char*)+0xa0>)
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
    cae4:	str	r5, [r6, #0]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    cae6:	str	r2, [r3, #0]
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    cae8:	bl	c398 <cardCommand(unsigned long, unsigned long)>
    caec:	cbnz	r0, cafe <cardCMD6(unsigned long, unsigned char*)+0x5a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    caee:	ldr	r1, [pc, #52]	; (cb24 <cardCMD6(unsigned long, unsigned char*)+0x80>)
  m_errorLine = line;
    caf0:	ldr	r3, [pc, #52]	; (cb28 <cardCMD6(unsigned long, unsigned char*)+0x84>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    caf2:	movs	r4, #4
  m_errorLine = line;
    caf4:	movw	r2, #417	; 0x1a1
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    caf8:	strb	r4, [r1, #0]
  m_errorLine = line;
    cafa:	str	r2, [r3, #0]
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
    cafc:	pop	{r3, r4, r5, r6, r7, pc}
  m_busyFcn = 0;
  return false;  // Caller will set errorCode.
}
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    cafe:	ldr	r0, [pc, #72]	; (cb48 <cardCMD6(unsigned long, unsigned char*)+0xa4>)
    cb00:	bl	c31c <yieldTimeout(bool (*)())>
    cb04:	cbnz	r0, cb0e <cardCMD6(unsigned long, unsigned char*)+0x6a>
    cb06:	bl	c4a4 <waitDmaStatus() [clone .part.4]>
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
  }
  if (!waitDmaStatus()) {
    cb0a:	cbz	r0, cb0e <cardCMD6(unsigned long, unsigned char*)+0x6a>
    return sdError(SD_CARD_ERROR_DMA);
  }
  return true;
}
    cb0c:	pop	{r3, r4, r5, r6, r7, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cb0e:	ldr	r1, [pc, #20]	; (cb24 <cardCMD6(unsigned long, unsigned char*)+0x80>)
  m_errorLine = line;
    cb10:	ldr	r3, [pc, #20]	; (cb28 <cardCMD6(unsigned long, unsigned char*)+0x84>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cb12:	movs	r0, #37	; 0x25
  m_errorLine = line;
    cb14:	mov.w	r2, #420	; 0x1a4
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cb18:	strb	r0, [r1, #0]
  m_errorLine = line;
    cb1a:	str	r2, [r3, #0]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
  }
  if (!waitDmaStatus()) {
    return sdError(SD_CARD_ERROR_DMA);
    cb1c:	movs	r0, #0
    cb1e:	pop	{r3, r4, r5, r6, r7, pc}
    cb20:	.word	0x0000c3f5
    cb24:	.word	0x1fff09d4
    cb28:	.word	0x1fff61e0
    cb2c:	.word	0x1fff61c0
    cb30:	.word	0x400b1000
    cb34:	.word	0x400b1004
    cb38:	.word	0x400b1038
    cb3c:	.word	0x00010040
    cb40:	.word	0x117f0002
    cb44:	.word	0x063a0011
    cb48:	.word	0x0000c179
    cb4c:	.word	0x1fff61d8

0000cb50 <SdioCard::begin(SdioConfig)>:
}
#endif  // ENABLE_TEENSY_SDIO_MOD
//==============================================================================
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
    cb50:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
  m_errorCode = SD_CARD_ERROR_NONE;
    cb54:	ldr	r5, [pc, #568]	; (cd90 <SdioCard::begin(SdioConfig)+0x240>)
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    cb56:	ldr	r4, [pc, #572]	; (cd94 <SdioCard::begin(SdioConfig)+0x244>)
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
    cb58:	ldr.w	r8, [pc, #684]	; ce08 <SdioCard::begin(SdioConfig)+0x2b8>
  m_errorCode = SD_CARD_ERROR_NONE;
  m_highCapacity = false;
    cb5c:	ldr	r7, [pc, #568]	; (cd98 <SdioCard::begin(SdioConfig)+0x248>)
  m_version2 = false;
    cb5e:	ldr	r6, [pc, #572]	; (cd9c <SdioCard::begin(SdioConfig)+0x24c>)
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
    cb60:	strb	r1, [r0, #8]
  m_curState = IDLE_STATE;
    cb62:	movs	r3, #0
  m_initDone = false;
  m_errorCode = SD_CARD_ERROR_NONE;
    cb64:	strb	r3, [r5, #0]
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
    cb66:	strb	r3, [r0, #9]
  m_initDone = false;
    cb68:	strb.w	r3, [r8]
  m_errorCode = SD_CARD_ERROR_NONE;
  m_highCapacity = false;
    cb6c:	strb	r3, [r7, #0]
  m_version2 = false;
    cb6e:	strb	r3, [r6, #0]
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    cb70:	ldr	r3, [r4, #0]
#endif  // HAS_KINETIS_MPU
  // Enable SDHC clock.
  SIM_SCGC3 |= SIM_SCGC3_SDHC;
    cb72:	ldr	r2, [pc, #556]	; (cda0 <SdioCard::begin(SdioConfig)+0x250>)
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    cb74:	ldr	r0, [pc, #556]	; (cda4 <SdioCard::begin(SdioConfig)+0x254>)
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    cb76:	ldr	r1, [pc, #560]	; (cda8 <SdioCard::begin(SdioConfig)+0x258>)
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    cb78:	ldr.w	lr, [pc, #656]	; ce0c <SdioCard::begin(SdioConfig)+0x2bc>
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    cb7c:	orr.w	r3, r3, #201326592	; 0xc000000
    cb80:	str	r3, [r4, #0]
#endif  // HAS_KINETIS_MPU
  // Enable SDHC clock.
  SIM_SCGC3 |= SIM_SCGC3_SDHC;
    cb82:	ldr	r3, [r2, #0]
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    cb84:	add.w	r4, r4, #260096	; 0x3f800
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
#endif  // HAS_KINETIS_MPU
  // Enable SDHC clock.
  SIM_SCGC3 |= SIM_SCGC3_SDHC;
    cb88:	orr.w	r3, r3, #131072	; 0x20000
    cb8c:	str	r3, [r2, #0]
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    cb8e:	adds	r4, #12
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    cb90:	add.w	r2, r2, #428032	; 0x68800
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    cb94:	movw	r3, #259	; 0x103
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    cb98:	addw	r2, r2, #2044	; 0x7fc
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    cb9c:	str	r3, [r0, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    cb9e:	str.w	r3, [lr]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    cba2:	str	r3, [r1, #0]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    cba4:	str	r3, [r4, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    cba6:	str	r3, [r0, #16]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    cba8:	str	r3, [r1, #12]
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    cbaa:	ldr	r3, [r2, #0]
    cbac:	orr.w	r3, r3, #16777216	; 0x1000000
    cbb0:	orr.w	r3, r3, #32768	; 0x8000
}
#endif  // ENABLE_TEENSY_SDIO_MOD
//==============================================================================
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
    cbb4:	sub	sp, #68	; 0x44
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    cbb6:	str	r3, [r2, #0]

  while (SDHC_SYSCTL & SDHC_SYSCTL_RSTA) {
    cbb8:	ldr	r3, [r2, #0]
    cbba:	ldr	r4, [pc, #496]	; (cdac <SdioCard::begin(SdioConfig)+0x25c>)
    cbbc:	lsls	r1, r3, #7
    cbbe:	bmi.n	cbb8 <SdioCard::begin(SdioConfig)+0x68>
  }

  // Set initial SCK rate.
  setSdclk(SD_MAX_INIT_RATE_KHZ);
    cbc0:	mov.w	r0, #400	; 0x190
    cbc4:	bl	c1c4 <setSdclk(unsigned long)>
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    cbc8:	ldr.w	ip, [pc, #472]	; cda4 <SdioCard::begin(SdioConfig)+0x254>
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    cbcc:	ldr.w	lr, [pc, #572]	; ce0c <SdioCard::begin(SdioConfig)+0x2bc>
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    cbd0:	ldr	r1, [pc, #468]	; (cda8 <SdioCard::begin(SdioConfig)+0x258>)
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    cbd2:	ldr	r2, [pc, #476]	; (cdb0 <SdioCard::begin(SdioConfig)+0x260>)
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    cbd4:	ldr	r0, [pc, #476]	; (cdb4 <SdioCard::begin(SdioConfig)+0x264>)
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    cbd6:	movw	r3, #1091	; 0x443
    cbda:	str.w	r3, [ip]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    cbde:	str.w	r3, [lr]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    cbe2:	mov.w	lr, #1088	; 0x440
    cbe6:	str.w	lr, [r1]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    cbea:	str	r3, [r2, #0]
  setSdclk(SD_MAX_INIT_RATE_KHZ);

  enableGPIO(true);

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;
    cbec:	add.w	r2, r2, #409600	; 0x64000
    cbf0:	adds	r2, #40	; 0x28

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    cbf2:	str	r3, [r0, #0]
  setSdclk(SD_MAX_INIT_RATE_KHZ);

  enableGPIO(true);

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;
    cbf4:	ldr	r0, [pc, #448]	; (cdb8 <SdioCard::begin(SdioConfig)+0x268>)
  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    cbf6:	str	r3, [r1, #12]
  setSdclk(SD_MAX_INIT_RATE_KHZ);

  enableGPIO(true);

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;
    cbf8:	str	r0, [r2, #0]

  attachInterruptVector(IRQ_SDHC, sdIrs);
    cbfa:	ldr	r1, [pc, #448]	; (cdbc <SdioCard::begin(SdioConfig)+0x26c>)
    cbfc:	movs	r0, #81	; 0x51
    cbfe:	bl	de30 <attachInterruptVector>
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    cc02:	ldr	r3, [pc, #444]	; (cdc0 <SdioCard::begin(SdioConfig)+0x270>)

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;

  attachInterruptVector(IRQ_SDHC, sdIrs);
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
    cc04:	ldr	r1, [pc, #444]	; (cdc4 <SdioCard::begin(SdioConfig)+0x274>)
    cc06:	movs	r0, #96	; 0x60
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    cc08:	mov.w	r2, #131072	; 0x20000

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;

  attachInterruptVector(IRQ_SDHC, sdIrs);
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
    cc0c:	strb	r0, [r1, #0]
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    cc0e:	str	r2, [r3, #0]

  // Send 80 clocks to card.
  SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
    cc10:	ldr	r3, [r4, #0]
    cc12:	orr.w	r3, r3, #134217728	; 0x8000000
    cc16:	str	r3, [r4, #0]
  while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) {
    cc18:	ldr	r1, [r4, #0]
    cc1a:	ands.w	r1, r1, #134217728	; 0x8000000
    cc1e:	bne.n	cc18 <SdioCard::begin(SdioConfig)+0xc8>
  m_highCapacity = false;
  m_version2 = false;

  // initialize controller.
  initSDHC();
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    cc20:	mov	r0, r1
    cc22:	bl	c398 <cardCommand(unsigned long, unsigned long)>
    cc26:	mov	r4, r0
    cc28:	cmp	r0, #0
    cc2a:	beq.n	ccca <SdioCard::begin(SdioConfig)+0x17a>
    cc2c:	movs	r4, #3
    return sdError(SD_CARD_ERROR_CMD0);
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    if (cardCommand(CMD8_XFERTYP, 0X1AA)) {
    cc2e:	mov.w	r1, #426	; 0x1aa
    cc32:	ldr	r0, [pc, #404]	; (cdc8 <SdioCard::begin(SdioConfig)+0x278>)
    cc34:	bl	c398 <cardCommand(unsigned long, unsigned long)>
    cc38:	cmp	r0, #0
    cc3a:	bne.n	ccf8 <SdioCard::begin(SdioConfig)+0x1a8>
  initSDHC();
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD0);
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    cc3c:	subs	r4, #1
    cc3e:	bne.n	cc2e <SdioCard::begin(SdioConfig)+0xde>
      }
      m_version2 = true;
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
    cc40:	ldrb	r3, [r6, #0]
    cc42:	ldr	r6, [pc, #392]	; (cdcc <SdioCard::begin(SdioConfig)+0x27c>)
    cc44:	cmp	r3, #0
    cc46:	it	eq
    cc48:	moveq.w	r6, #3145728	; 0x300000
  int m = micros();
    cc4c:	bl	de88 <micros>
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
    cc50:	ldr	r4, [pc, #380]	; (cdd0 <SdioCard::begin(SdioConfig)+0x280>)
      m_version2 = true;
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
    cc52:	mov	r9, r0
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    cc54:	movs	r1, #0
    cc56:	ldr	r0, [pc, #380]	; (cdd4 <SdioCard::begin(SdioConfig)+0x284>)
    cc58:	bl	c398 <cardCommand(unsigned long, unsigned long)>
    cc5c:	cbnz	r0, cc74 <SdioCard::begin(SdioConfig)+0x124>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    cc5e:	ldr	r2, [pc, #376]	; (cdd8 <SdioCard::begin(SdioConfig)+0x288>)
    cc60:	mov.w	r1, #676	; 0x2a4
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cc64:	movs	r3, #23
  m_errorLine = line;
    cc66:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cc68:	strb	r3, [r5, #0]
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    cc6a:	movs	r4, #0

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
  return true;
}
    cc6c:	mov	r0, r4
    cc6e:	add	sp, #68	; 0x44
    cc70:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    cc74:	mov	r1, r6
    cc76:	ldr	r0, [pc, #356]	; (cddc <SdioCard::begin(SdioConfig)+0x28c>)
    cc78:	bl	c398 <cardCommand(unsigned long, unsigned long)>
    cc7c:	cmp	r0, #0
    cc7e:	beq.n	cc5e <SdioCard::begin(SdioConfig)+0x10e>
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
    cc80:	bl	de88 <micros>
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
    cc84:	ldr	r3, [pc, #344]	; (cde0 <SdioCard::begin(SdioConfig)+0x290>)
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
    cc86:	ldr	r2, [pc, #328]	; (cdd0 <SdioCard::begin(SdioConfig)+0x280>)
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
    cc88:	rsb	r0, r9, r0
    cc8c:	cmp	r0, r3
    cc8e:	bhi.n	cc5e <SdioCard::begin(SdioConfig)+0x10e>
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
    cc90:	ldr	r3, [r4, #0]
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    cc92:	cmp	r3, #0
    cc94:	bge.n	cc54 <SdioCard::begin(SdioConfig)+0x104>
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
    cc96:	ldr	r3, [pc, #332]	; (cde4 <SdioCard::begin(SdioConfig)+0x294>)
    cc98:	ldr	r1, [r2, #0]
    cc9a:	str	r1, [r3, #0]
  if (SDHC_CMDRSP0 & 0x40000000) {
    cc9c:	ldr	r3, [r2, #0]
    // Is high capacity.
    m_highCapacity = true;
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    cc9e:	ldr	r0, [pc, #328]	; (cde8 <SdioCard::begin(SdioConfig)+0x298>)
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
  if (SDHC_CMDRSP0 & 0x40000000) {
    cca0:	lsls	r2, r3, #1
    // Is high capacity.
    m_highCapacity = true;
    cca2:	it	mi
    cca4:	movmi	r3, #1
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    cca6:	mov.w	r1, #0
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
  if (SDHC_CMDRSP0 & 0x40000000) {
    // Is high capacity.
    m_highCapacity = true;
    ccaa:	it	mi
    ccac:	strbmi	r3, [r7, #0]
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    ccae:	bl	c398 <cardCommand(unsigned long, unsigned long)>
    ccb2:	mov	r4, r0
    ccb4:	cbnz	r0, ccde <SdioCard::begin(SdioConfig)+0x18e>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    ccb6:	ldr	r2, [pc, #288]	; (cdd8 <SdioCard::begin(SdioConfig)+0x288>)
    ccb8:	movw	r1, #685	; 0x2ad
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    ccbc:	movs	r3, #2

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
  return true;
}
    ccbe:	mov	r0, r4
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    ccc0:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    ccc2:	strb	r3, [r5, #0]

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
  return true;
}
    ccc4:	add	sp, #68	; 0x44
    ccc6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    ccca:	ldr	r2, [pc, #268]	; (cdd8 <SdioCard::begin(SdioConfig)+0x288>)
    cccc:	movw	r1, #659	; 0x293
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    ccd0:	movs	r3, #1

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
  return true;
}
    ccd2:	mov	r0, r4
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    ccd4:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    ccd6:	strb	r3, [r5, #0]

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
  return true;
}
    ccd8:	add	sp, #68	; 0x44
    ccda:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    m_highCapacity = true;
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    ccde:	movs	r1, #0
    cce0:	ldr	r0, [pc, #264]	; (cdec <SdioCard::begin(SdioConfig)+0x29c>)
    cce2:	bl	c398 <cardCommand(unsigned long, unsigned long)>
    cce6:	mov	r4, r0
    cce8:	cbnz	r0, cd1a <SdioCard::begin(SdioConfig)+0x1ca>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    ccea:	ldr	r2, [pc, #236]	; (cdd8 <SdioCard::begin(SdioConfig)+0x288>)
    ccec:	mov.w	r1, #688	; 0x2b0
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    ccf0:	movs	r3, #3
  m_errorLine = line;
    ccf2:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    ccf4:	strb	r3, [r5, #0]
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD3);
    ccf6:	b.n	cc6c <SdioCard::begin(SdioConfig)+0x11c>
    return sdError(SD_CARD_ERROR_CMD0);
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    if (cardCommand(CMD8_XFERTYP, 0X1AA)) {
      if (SDHC_CMDRSP0 != 0X1AA) {
    ccf8:	ldr	r3, [pc, #212]	; (cdd0 <SdioCard::begin(SdioConfig)+0x280>)
    ccfa:	ldr	r3, [r3, #0]
    ccfc:	cmp.w	r3, #426	; 0x1aa
    cd00:	beq.n	cd12 <SdioCard::begin(SdioConfig)+0x1c2>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    cd02:	ldr	r2, [pc, #212]	; (cdd8 <SdioCard::begin(SdioConfig)+0x288>)
    cd04:	movw	r1, #665	; 0x299
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cd08:	movs	r3, #6
  m_errorLine = line;
    cd0a:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cd0c:	strb	r3, [r5, #0]
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    if (cardCommand(CMD8_XFERTYP, 0X1AA)) {
      if (SDHC_CMDRSP0 != 0X1AA) {
        return sdError(SD_CARD_ERROR_CMD8);
    cd0e:	movs	r4, #0
    cd10:	b.n	cc6c <SdioCard::begin(SdioConfig)+0x11c>
      }
      m_version2 = true;
    cd12:	movs	r3, #1
    cd14:	strb	r3, [r6, #0]
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
    cd16:	ldr	r6, [pc, #180]	; (cdcc <SdioCard::begin(SdioConfig)+0x27c>)
    cd18:	b.n	cc4c <SdioCard::begin(SdioConfig)+0xfc>
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD3);
  }
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;
    cd1a:	ldr	r3, [pc, #180]	; (cdd0 <SdioCard::begin(SdioConfig)+0x280>)
    cd1c:	ldr	r6, [pc, #208]	; (cdf0 <SdioCard::begin(SdioConfig)+0x2a0>)
    cd1e:	ldr	r3, [r3, #0]

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    cd20:	ldr	r1, [pc, #208]	; (cdf4 <SdioCard::begin(SdioConfig)+0x2a4>)
    cd22:	ldr	r0, [pc, #212]	; (cdf8 <SdioCard::begin(SdioConfig)+0x2a8>)
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD3);
  }
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;
    cd24:	lsrs	r3, r3, #16
    cd26:	lsls	r3, r3, #16
    cd28:	str	r3, [r6, #0]

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    cd2a:	bl	c440 <readReg16(unsigned long, void*)>
    cd2e:	mov	r4, r0
    cd30:	cbnz	r0, cd40 <SdioCard::begin(SdioConfig)+0x1f0>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    cd32:	ldr	r2, [pc, #164]	; (cdd8 <SdioCard::begin(SdioConfig)+0x288>)
    cd34:	movw	r1, #693	; 0x2b5
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cd38:	movs	r3, #7
  m_errorLine = line;
    cd3a:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cd3c:	strb	r3, [r5, #0]
    return sdError(SD_CARD_ERROR_CMD3);
  }
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    return sdError(SD_CARD_ERROR_CMD9);
    cd3e:	b.n	cc6c <SdioCard::begin(SdioConfig)+0x11c>
  }
  if (!readReg16(CMD10_XFERTYP, &m_cid)) {
    cd40:	ldr	r1, [pc, #184]	; (cdfc <SdioCard::begin(SdioConfig)+0x2ac>)
    cd42:	ldr	r0, [pc, #188]	; (ce00 <SdioCard::begin(SdioConfig)+0x2b0>)
    cd44:	bl	c440 <readReg16(unsigned long, void*)>
    cd48:	mov	r4, r0
    cd4a:	cbnz	r0, cd5a <SdioCard::begin(SdioConfig)+0x20a>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    cd4c:	ldr	r2, [pc, #136]	; (cdd8 <SdioCard::begin(SdioConfig)+0x288>)
    cd4e:	mov.w	r1, #696	; 0x2b8
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cd52:	movs	r3, #8
  m_errorLine = line;
    cd54:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cd56:	strb	r3, [r5, #0]

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    return sdError(SD_CARD_ERROR_CMD9);
  }
  if (!readReg16(CMD10_XFERTYP, &m_cid)) {
    return sdError(SD_CARD_ERROR_CMD10);
    cd58:	b.n	cc6c <SdioCard::begin(SdioConfig)+0x11c>
  }
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    cd5a:	ldr	r1, [r6, #0]
    cd5c:	ldr	r0, [pc, #164]	; (ce04 <SdioCard::begin(SdioConfig)+0x2b4>)
    cd5e:	bl	c398 <cardCommand(unsigned long, unsigned long)>
    cd62:	mov	r4, r0
    cd64:	cbnz	r0, cd74 <SdioCard::begin(SdioConfig)+0x224>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    cd66:	ldr	r2, [pc, #112]	; (cdd8 <SdioCard::begin(SdioConfig)+0x288>)
    cd68:	movw	r1, #699	; 0x2bb
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cd6c:	movs	r3, #5
  m_errorLine = line;
    cd6e:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cd70:	strb	r3, [r5, #0]
  }
  if (!readReg16(CMD10_XFERTYP, &m_cid)) {
    return sdError(SD_CARD_ERROR_CMD10);
  }
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    return sdError(SD_CARD_ERROR_CMD7);
    cd72:	b.n	cc6c <SdioCard::begin(SdioConfig)+0x11c>
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    cd74:	ldr	r1, [r6, #0]
    cd76:	ldr	r0, [pc, #92]	; (cdd4 <SdioCard::begin(SdioConfig)+0x284>)
    cd78:	bl	c398 <cardCommand(unsigned long, unsigned long)>
    cd7c:	cmp	r0, #0
    cd7e:	bne.n	ce10 <SdioCard::begin(SdioConfig)+0x2c0>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    cd80:	ldr	r2, [pc, #84]	; (cdd8 <SdioCard::begin(SdioConfig)+0x288>)
    cd82:	movw	r1, #703	; 0x2bf
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cd86:	movs	r3, #20
  m_errorLine = line;
    cd88:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cd8a:	strb	r3, [r5, #0]
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    return sdError(SD_CARD_ERROR_CMD7);
  }
  // Set card to bus width four.
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
    cd8c:	movs	r4, #0
    cd8e:	b.n	cc6c <SdioCard::begin(SdioConfig)+0x11c>
    cd90:	.word	0x1fff09d4
    cd94:	.word	0x4000d800
    cd98:	.word	0x1fff61b0
    cd9c:	.word	0x1fff6198
    cda0:	.word	0x40048030
    cda4:	.word	0x4004d000
    cda8:	.word	0x4004d008
    cdac:	.word	0x400b102c
    cdb0:	.word	0x4004d00c
    cdb4:	.word	0x4004d010
    cdb8:	.word	0x117f000b
    cdbc:	.word	0x0000c10d
    cdc0:	.word	0xe000e108
    cdc4:	.word	0xe000e451
    cdc8:	.word	0x081a0000
    cdcc:	.word	0x40300000
    cdd0:	.word	0x400b1010
    cdd4:	.word	0x371a0000
    cdd8:	.word	0x1fff61e0
    cddc:	.word	0x29020000
    cde0:	.word	0x000f4240
    cde4:	.word	0x1fff61b4
    cde8:	.word	0x02090000
    cdec:	.word	0x031a0000
    cdf0:	.word	0x1fff61b8
    cdf4:	.word	0x1fff61c8
    cdf8:	.word	0x09090000
    cdfc:	.word	0x1fff619c
    ce00:	.word	0x0a090000
    ce04:	.word	0x071b0000
    ce08:	.word	0x1fff61c4
    ce0c:	.word	0x4004d004
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    ce10:	movs	r1, #2
    ce12:	ldr	r0, [pc, #168]	; (cebc <SdioCard::begin(SdioConfig)+0x36c>)
    ce14:	bl	c398 <cardCommand(unsigned long, unsigned long)>
    ce18:	mov	r4, r0
    ce1a:	cmp	r0, #0
    ce1c:	beq.n	cd80 <SdioCard::begin(SdioConfig)+0x230>
  // Set card to bus width four.
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
  }
  // Set SDHC to bus width four.
  SDHC_PROCTL &= ~SDHC_PROCTL_DTW_MASK;
    ce1e:	ldr	r3, [pc, #160]	; (cec0 <SdioCard::begin(SdioConfig)+0x370>)
  SDHC_PROCTL |= SDHC_PROCTL_DTW(SDHC_PROCTL_DTW_4BIT);

  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);
    ce20:	ldr	r0, [pc, #160]	; (cec4 <SdioCard::begin(SdioConfig)+0x374>)
  // Set card to bus width four.
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
  }
  // Set SDHC to bus width four.
  SDHC_PROCTL &= ~SDHC_PROCTL_DTW_MASK;
    ce22:	ldr	r2, [r3, #0]
    ce24:	bic.w	r2, r2, #6
    ce28:	str	r2, [r3, #0]
  SDHC_PROCTL |= SDHC_PROCTL_DTW(SDHC_PROCTL_DTW_4BIT);
    ce2a:	ldr	r2, [r3, #0]

  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);
    ce2c:	mov.w	r5, #1048592	; 0x100010
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
  }
  // Set SDHC to bus width four.
  SDHC_PROCTL &= ~SDHC_PROCTL_DTW_MASK;
  SDHC_PROCTL |= SDHC_PROCTL_DTW(SDHC_PROCTL_DTW_4BIT);
    ce30:	orr.w	r2, r2, #2
    ce34:	str	r2, [r3, #0]
  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    ce36:	mov	r1, sp
  }
  // Set SDHC to bus width four.
  SDHC_PROCTL &= ~SDHC_PROCTL_DTW_MASK;
  SDHC_PROCTL |= SDHC_PROCTL_DTW(SDHC_PROCTL_DTW_4BIT);

  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);
    ce38:	str	r5, [r0, #0]

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    ce3a:	mvn.w	r0, #4278190080	; 0xff000000
    ce3e:	bl	caa4 <cardCMD6(unsigned long, unsigned char*)>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    ce42:	cbz	r0, ce4c <SdioCard::begin(SdioConfig)+0x2fc>
  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    ce44:	ldrb.w	r3, [sp, #13]
    ce48:	lsls	r3, r3, #30
    ce4a:	bmi.n	ce9e <SdioCard::begin(SdioConfig)+0x34e>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    kHzSdClk = 50000;
  } else {
    kHzSdClk = 25000;
    ce4c:	movw	r0, #25000	; 0x61a8
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    ce50:	ldr.w	fp, [pc, #132]	; ced8 <SdioCard::begin(SdioConfig)+0x388>
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    ce54:	ldr.w	sl, [pc, #132]	; cedc <SdioCard::begin(SdioConfig)+0x38c>
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    ce58:	ldr.w	r9, [pc, #132]	; cee0 <SdioCard::begin(SdioConfig)+0x390>
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    ce5c:	ldr	r7, [pc, #104]	; (cec8 <SdioCard::begin(SdioConfig)+0x378>)
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    ce5e:	ldr	r6, [pc, #108]	; (cecc <SdioCard::begin(SdioConfig)+0x37c>)
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    ce60:	ldr	r5, [pc, #108]	; (ced0 <SdioCard::begin(SdioConfig)+0x380>)
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    ce62:	movw	r3, #259	; 0x103
    ce66:	str.w	r3, [fp]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    ce6a:	str.w	r3, [sl]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    ce6e:	str.w	r3, [r9]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    ce72:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    ce74:	str	r3, [r6, #0]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    ce76:	str	r3, [r5, #0]
  }
  // Disable GPIO.
  enableGPIO(false);

  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);
    ce78:	bl	c1c4 <setSdclk(unsigned long)>
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    ce7c:	movw	r3, #1091	; 0x443
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    ce80:	mov.w	r1, #1088	; 0x440
  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
    ce84:	movs	r2, #1
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    ce86:	str.w	r3, [fp]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    ce8a:	str.w	r3, [sl]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    ce8e:	str.w	r1, [r9]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    ce92:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    ce94:	str	r3, [r6, #0]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    ce96:	str	r3, [r5, #0]
  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
    ce98:	strb.w	r2, [r8]
  return true;
    ce9c:	b.n	cc6c <SdioCard::begin(SdioConfig)+0x11c>

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    ce9e:	mov	r1, sp
    cea0:	ldr	r0, [pc, #48]	; (ced4 <SdioCard::begin(SdioConfig)+0x384>)
    cea2:	bl	caa4 <cardCMD6(unsigned long, unsigned char*)>
  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    cea6:	cmp	r0, #0
    cea8:	beq.n	ce4c <SdioCard::begin(SdioConfig)+0x2fc>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    ceaa:	ldrb.w	r3, [sp, #16]
    ceae:	and.w	r3, r3, #15
    ceb2:	cmp	r3, #1
    ceb4:	bne.n	ce4c <SdioCard::begin(SdioConfig)+0x2fc>
    kHzSdClk = 50000;
    ceb6:	movw	r0, #50000	; 0xc350
    ceba:	b.n	ce50 <SdioCard::begin(SdioConfig)+0x300>
    cebc:	.word	0x061a0000
    cec0:	.word	0x400b1028
    cec4:	.word	0x400b1044
    cec8:	.word	0x4004d00c
    cecc:	.word	0x4004d010
    ced0:	.word	0x4004d014
    ced4:	.word	0x80fffff1
    ced8:	.word	0x4004d000
    cedc:	.word	0x4004d004
    cee0:	.word	0x4004d008

0000cee4 <SdioCard::readData(unsigned char*)>:
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readData(uint8_t* dst) {
    cee4:	push	{r3, r4, r5, lr}
  DBG_IRQSTAT();
  uint32_t* p32 = reinterpret_cast<uint32_t*>(dst);

  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_RTA)) {
    cee6:	ldr	r3, [pc, #160]	; (cf88 <SdioCard::readData(unsigned char*)+0xa4>)
    cee8:	ldr	r3, [r3, #0]
    ceea:	lsls	r0, r3, #22
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readData(uint8_t* dst) {
    ceec:	mov	r5, r1
  DBG_IRQSTAT();
  uint32_t* p32 = reinterpret_cast<uint32_t*>(dst);

  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_RTA)) {
    ceee:	bmi.n	cf0e <SdioCard::readData(unsigned char*)+0x2a>
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    cef0:	ldr	r3, [pc, #152]	; (cf8c <SdioCard::readData(unsigned char*)+0xa8>)
    cef2:	ldr	r2, [r3, #0]
    cef4:	bic.w	r2, r2, #65536	; 0x10000
    cef8:	str	r2, [r3, #0]
    noInterrupts();
    cefa:	cpsid	i
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    cefc:	ldr	r2, [r3, #0]
    cefe:	orr.w	r2, r2, #131072	; 0x20000
    cf02:	str	r2, [r3, #0]
    SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    cf04:	ldr	r2, [r3, #0]
    cf06:	orr.w	r2, r2, #65536	; 0x10000
    cf0a:	str	r2, [r3, #0]
    interrupts();
    cf0c:	cpsie	i
  }
  if (waitTimeout(isBusyFifoRead)) {
    cf0e:	ldr	r0, [pc, #128]	; (cf90 <SdioCard::readData(unsigned char*)+0xac>)
    cf10:	bl	c2f4 <waitTimeout(bool (*)())>
    cf14:	cmp	r0, #0
    cf16:	bne.n	cf76 <SdioCard::readData(unsigned char*)+0x92>
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    cf18:	ldr	r4, [pc, #108]	; (cf88 <SdioCard::readData(unsigned char*)+0xa4>)
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    cf1a:	ldr	r0, [pc, #120]	; (cf94 <SdioCard::readData(unsigned char*)+0xb0>)
    cf1c:	subs	r3, r5, #4
    cf1e:	add.w	r5, r5, #508	; 0x1fc
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    cf22:	ldr	r2, [r4, #0]
    cf24:	lsls	r1, r2, #20
    cf26:	bpl.n	cf22 <SdioCard::readData(unsigned char*)+0x3e>
    cf28:	add.w	r1, r3, #64	; 0x40
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    cf2c:	ldr	r2, [r0, #0]
    cf2e:	str.w	r2, [r3, #4]!
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
    cf32:	cmp	r1, r3
    cf34:	bne.n	cf2c <SdioCard::readData(unsigned char*)+0x48>
    interrupts();
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    cf36:	cmp	r5, r1
    cf38:	mov	r3, r1
    cf3a:	bne.n	cf22 <SdioCard::readData(unsigned char*)+0x3e>
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    }
    p32 += FIFO_WML;
  }
  if (waitTimeout(isBusyTransferComplete)) {
    cf3c:	ldr	r0, [pc, #88]	; (cf98 <SdioCard::readData(unsigned char*)+0xb4>)
    cf3e:	bl	c2f4 <waitTimeout(bool (*)())>
    cf42:	cbnz	r0, cf64 <SdioCard::readData(unsigned char*)+0x80>
    return sdError(SD_CARD_ERROR_READ_TIMEOUT);
  }
  m_irqstat = SDHC_IRQSTAT;
    cf44:	ldr	r2, [pc, #84]	; (cf9c <SdioCard::readData(unsigned char*)+0xb8>)
    cf46:	ldr	r3, [pc, #88]	; (cfa0 <SdioCard::readData(unsigned char*)+0xbc>)
    cf48:	ldr	r1, [r2, #0]
    cf4a:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    cf4c:	ldr	r1, [r3, #0]
    cf4e:	str	r1, [r2, #0]
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
    cf50:	ldr	r2, [r3, #0]
    cf52:	lsls	r2, r2, #30
    cf54:	bpl.n	cf86 <SdioCard::readData(unsigned char*)+0xa2>
    cf56:	ldr	r3, [r3, #0]
    cf58:	ldr	r0, [pc, #72]	; (cfa4 <SdioCard::readData(unsigned char*)+0xc0>)
    cf5a:	ands	r0, r3
    cf5c:	clz	r0, r0
    cf60:	lsrs	r0, r0, #5
    cf62:	pop	{r3, r4, r5, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cf64:	ldr	r1, [pc, #64]	; (cfa8 <SdioCard::readData(unsigned char*)+0xc4>)
  m_errorLine = line;
    cf66:	ldr	r3, [pc, #68]	; (cfac <SdioCard::readData(unsigned char*)+0xc8>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cf68:	movs	r0, #29
  m_errorLine = line;
    cf6a:	movw	r2, #843	; 0x34b
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cf6e:	strb	r0, [r1, #0]
  m_errorLine = line;
    cf70:	str	r2, [r3, #0]
      p32[i] = SDHC_DATPORT;
    }
    p32 += FIFO_WML;
  }
  if (waitTimeout(isBusyTransferComplete)) {
    return sdError(SD_CARD_ERROR_READ_TIMEOUT);
    cf72:	movs	r0, #0
    cf74:	pop	{r3, r4, r5, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cf76:	ldr	r1, [pc, #48]	; (cfa8 <SdioCard::readData(unsigned char*)+0xc4>)
  m_errorLine = line;
    cf78:	ldr	r3, [pc, #48]	; (cfac <SdioCard::readData(unsigned char*)+0xc8>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cf7a:	movs	r0, #26
  m_errorLine = line;
    cf7c:	mov.w	r2, #832	; 0x340
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cf80:	strb	r0, [r1, #0]
  m_errorLine = line;
    cf82:	str	r2, [r3, #0]
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    interrupts();
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
    cf84:	movs	r0, #0
    return sdError(SD_CARD_ERROR_READ_TIMEOUT);
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
    cf86:	pop	{r3, r4, r5, pc}
    cf88:	.word	0x400b1024
    cf8c:	.word	0x400b1028
    cf90:	.word	0x0000c185
    cf94:	.word	0x400b1020
    cf98:	.word	0x0000c1ad
    cf9c:	.word	0x400b1030
    cfa0:	.word	0x1fff61c0
    cfa4:	.word	0x117f0000
    cfa8:	.word	0x1fff09d4
    cfac:	.word	0x1fff61e0

0000cfb0 <SdioCard::readStart(unsigned long)>:
  }
  return true;
}
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
    cfb0:	push	{r3, r4, r5, lr}
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    cfb2:	ldr	r0, [pc, #80]	; (d004 <SdioCard::readStart(unsigned long)+0x54>)
  }
  return true;
}
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
    cfb4:	mov	r4, r1
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    cfb6:	bl	c31c <yieldTimeout(bool (*)())>
    cfba:	cbnz	r0, cff0 <SdioCard::readStart(unsigned long)+0x40>
    return sdError(SD_CARD_ERROR_CMD13);
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    cfbc:	ldr	r2, [pc, #72]	; (d008 <SdioCard::readStart(unsigned long)+0x58>)
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
#endif  // defined(__IMXRT1062__)

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    cfbe:	ldr	r1, [pc, #76]	; (d00c <SdioCard::readStart(unsigned long)+0x5c>)
bool SdioCard::readStart(uint32_t sector) {
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    cfc0:	ldr	r3, [r2, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
    cfc2:	ldr	r0, [pc, #76]	; (d010 <SdioCard::readStart(unsigned long)+0x60>)
    cfc4:	ldr	r5, [pc, #76]	; (d014 <SdioCard::readStart(unsigned long)+0x64>)
bool SdioCard::readStart(uint32_t sector) {
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    cfc6:	orr.w	r3, r3, #65536	; 0x10000
    cfca:	str	r3, [r2, #0]
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
#endif  // defined(__IMXRT1062__)

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    cfcc:	ldrb	r3, [r1, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
    cfce:	str	r5, [r0, #0]
#endif  // defined(__IMXRT1062__)

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    cfd0:	cbnz	r3, cfec <SdioCard::readStart(unsigned long)+0x3c>
    cfd2:	lsls	r1, r4, #9
    cfd4:	ldr	r0, [pc, #64]	; (d018 <SdioCard::readStart(unsigned long)+0x68>)
    cfd6:	bl	c398 <cardCommand(unsigned long, unsigned long)>
    cfda:	cbnz	r0, cfea <SdioCard::readStart(unsigned long)+0x3a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cfdc:	ldr	r1, [pc, #60]	; (d01c <SdioCard::readStart(unsigned long)+0x6c>)
  m_errorLine = line;
    cfde:	ldr	r3, [pc, #64]	; (d020 <SdioCard::readStart(unsigned long)+0x70>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cfe0:	movs	r4, #12
  m_errorLine = line;
    cfe2:	movw	r2, #937	; 0x3a9
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cfe6:	strb	r4, [r1, #0]
  m_errorLine = line;
    cfe8:	str	r2, [r3, #0]

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    return sdError(SD_CARD_ERROR_CMD18);
  }
  return true;
}
    cfea:	pop	{r3, r4, r5, pc}
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
#endif  // defined(__IMXRT1062__)

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    cfec:	mov	r1, r4
    cfee:	b.n	cfd4 <SdioCard::readStart(unsigned long)+0x24>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cff0:	ldr	r1, [pc, #40]	; (d01c <SdioCard::readStart(unsigned long)+0x6c>)
  m_errorLine = line;
    cff2:	ldr	r3, [pc, #44]	; (d020 <SdioCard::readStart(unsigned long)+0x70>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cff4:	movs	r0, #10
  m_errorLine = line;
    cff6:	movw	r2, #925	; 0x39d
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    cffa:	strb	r0, [r1, #0]
  m_errorLine = line;
    cffc:	str	r2, [r3, #0]
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    cffe:	movs	r0, #0
    d000:	pop	{r3, r4, r5, pc}
    d002:	nop
    d004:	.word	0x0000c3f5
    d008:	.word	0x400b1028
    d00c:	.word	0x1fff61b0
    d010:	.word	0x400b1004
    d014:	.word	0xffff0200
    d018:	.word	0x123a0032
    d01c:	.word	0x1fff09d4
    d020:	.word	0x1fff61e0

0000d024 <SdioCard::readSector(unsigned long, unsigned char*)>:
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    d024:	push	{r4, r5, r6, lr}
  if (m_sdioConfig.useDma()) {
    d026:	ldrb	r3, [r0, #8]
    d028:	lsls	r4, r3, #31
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    d02a:	sub.w	sp, sp, #512	; 0x200
    d02e:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    d030:	bpl.n	d058 <SdioCard::readSector(unsigned long, unsigned char*)+0x34>
    uint8_t aligned[512];

    uint8_t* ptr = (uint32_t)dst & 3 ? aligned : dst;
    d032:	lsls	r3, r2, #30
    d034:	beq.n	d07c <SdioCard::readSector(unsigned long, unsigned char*)+0x58>

    if (!rdWrSectors(CMD17_DMA_XFERTYP, sector, ptr, 1)) {
    d036:	mov	r2, sp
    d038:	movs	r3, #1
    d03a:	ldr	r0, [pc, #196]	; (d100 <SdioCard::readSector(unsigned long, unsigned char*)+0xdc>)
    d03c:	bl	c4c4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    d040:	cbz	r0, d088 <SdioCard::readSector(unsigned long, unsigned char*)+0x64>
      return sdError(SD_CARD_ERROR_CMD17);
    }
    if (ptr != dst) {
      memcpy(dst, aligned, 512);
    d042:	mov	r1, sp
    d044:	mov	r0, r5
    d046:	mov.w	r2, #512	; 0x200
    d04a:	bl	d444 <memcpy>
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
  }
  return true;
    d04e:	movs	r5, #1
}
    d050:	mov	r0, r5
    d052:	add.w	sp, sp, #512	; 0x200
    d056:	pop	{r4, r5, r6, pc}
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
  if (!m_transferActive) {
    d058:	ldr	r3, [pc, #168]	; (d104 <SdioCard::readSector(unsigned long, unsigned char*)+0xe0>)
    d05a:	ldrb	r3, [r3, #0]
    d05c:	mov	r4, r0
    d05e:	mov	r6, r1
    d060:	cbnz	r3, d0b4 <SdioCard::readSector(unsigned long, unsigned char*)+0x90>
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
      return false;
    }
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != READ_STATE || sector != m_curSector) {
    d062:	ldrb	r3, [r4, #9]
    d064:	cmp	r3, #1
    d066:	beq.n	d0a0 <SdioCard::readSector(unsigned long, unsigned char*)+0x7c>
      if (!syncDevice()) {
    d068:	ldr	r3, [r4, #0]
    d06a:	mov	r0, r4
    d06c:	ldr	r3, [r3, #24]
    d06e:	blx	r3
    d070:	cbnz	r0, d0c0 <SdioCard::readSector(unsigned long, unsigned char*)+0x9c>
      memcpy(dst, aligned, 512);
    }
  } else {
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
      return false;
    d072:	movs	r5, #0
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
  }
  return true;
}
    d074:	mov	r0, r5
    d076:	add.w	sp, sp, #512	; 0x200
    d07a:	pop	{r4, r5, r6, pc}
  if (m_sdioConfig.useDma()) {
    uint8_t aligned[512];

    uint8_t* ptr = (uint32_t)dst & 3 ? aligned : dst;

    if (!rdWrSectors(CMD17_DMA_XFERTYP, sector, ptr, 1)) {
    d07c:	movs	r3, #1
    d07e:	ldr	r0, [pc, #128]	; (d100 <SdioCard::readSector(unsigned long, unsigned char*)+0xdc>)
    d080:	bl	c4c4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    d084:	cmp	r0, #0
    d086:	bne.n	d04e <SdioCard::readSector(unsigned long, unsigned char*)+0x2a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    d088:	ldr	r1, [pc, #124]	; (d108 <SdioCard::readSector(unsigned long, unsigned char*)+0xe4>)
  m_errorLine = line;
    d08a:	ldr	r3, [pc, #128]	; (d10c <SdioCard::readSector(unsigned long, unsigned char*)+0xe8>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    d08c:	movs	r0, #11
  m_errorLine = line;
    d08e:	movw	r2, #862	; 0x35e
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    d092:	strb	r0, [r1, #0]
  m_errorLine = line;
    d094:	str	r2, [r3, #0]
    uint8_t aligned[512];

    uint8_t* ptr = (uint32_t)dst & 3 ? aligned : dst;

    if (!rdWrSectors(CMD17_DMA_XFERTYP, sector, ptr, 1)) {
      return sdError(SD_CARD_ERROR_CMD17);
    d096:	movs	r5, #0
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
  }
  return true;
}
    d098:	mov	r0, r5
    d09a:	add.w	sp, sp, #512	; 0x200
    d09e:	pop	{r4, r5, r6, pc}
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
      return false;
    }
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != READ_STATE || sector != m_curSector) {
    d0a0:	ldr	r3, [r4, #4]
    d0a2:	cmp	r6, r3
    d0a4:	beq.n	d0d2 <SdioCard::readSector(unsigned long, unsigned char*)+0xae>
      if (!syncDevice()) {
    d0a6:	ldr	r3, [r4, #0]
    d0a8:	mov	r0, r4
    d0aa:	ldr	r3, [r3, #24]
    d0ac:	blx	r3
    d0ae:	cmp	r0, #0
    d0b0:	beq.n	d072 <SdioCard::readSector(unsigned long, unsigned char*)+0x4e>
    d0b2:	b.n	d0c0 <SdioCard::readSector(unsigned long, unsigned char*)+0x9c>
    d0b4:	bl	c6d0 <waitTransferComplete() [clone .part.8]>
    if (ptr != dst) {
      memcpy(dst, aligned, 512);
    }
  } else {
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
    d0b8:	cmp	r0, #0
    d0ba:	bne.n	d062 <SdioCard::readSector(unsigned long, unsigned char*)+0x3e>
      return false;
    d0bc:	movs	r5, #0
    d0be:	b.n	d074 <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != READ_STATE || sector != m_curSector) {
      if (!syncDevice()) {
        return false;
      }
      if (!readStart(sector)) {
    d0c0:	mov	r1, r6
    d0c2:	mov	r0, r4
    d0c4:	bl	cfb0 <SdioCard::readStart(unsigned long)>
    d0c8:	cmp	r0, #0
    d0ca:	beq.n	d072 <SdioCard::readSector(unsigned long, unsigned char*)+0x4e>
        return false;
      }
      m_curSector = sector;
      m_curState = READ_STATE;
    d0cc:	movs	r3, #1
        return false;
      }
      if (!readStart(sector)) {
        return false;
      }
      m_curSector = sector;
    d0ce:	str	r6, [r4, #4]
      m_curState = READ_STATE;
    d0d0:	strb	r3, [r4, #9]
    }
    if (!readData(dst)) {
    d0d2:	mov	r1, r5
    d0d4:	mov	r0, r4
    d0d6:	bl	cee4 <SdioCard::readData(unsigned char*)>
    d0da:	mov	r5, r0
    d0dc:	cmp	r0, #0
    d0de:	beq.n	d072 <SdioCard::readSector(unsigned long, unsigned char*)+0x4e>
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
    d0e0:	ldr	r3, [pc, #44]	; (d110 <SdioCard::readSector(unsigned long, unsigned char*)+0xec>)
    d0e2:	ldr	r3, [r3, #0]
    d0e4:	lsrs	r3, r3, #16
    d0e6:	lsls	r3, r3, #16
    d0e8:	cbz	r3, d0f2 <SdioCard::readSector(unsigned long, unsigned char*)+0xce>
      if (!syncDevice()) {
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
    d0ea:	ldr	r3, [r4, #4]
    d0ec:	adds	r3, #1
    d0ee:	str	r3, [r4, #4]
    d0f0:	b.n	d098 <SdioCard::readSector(unsigned long, unsigned char*)+0x74>
    if (!readData(dst)) {
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
      if (!syncDevice()) {
    d0f2:	ldr	r3, [r4, #0]
    d0f4:	mov	r0, r4
    d0f6:	ldr	r3, [r3, #24]
    d0f8:	blx	r3
    d0fa:	cmp	r0, #0
    d0fc:	bne.n	d0ea <SdioCard::readSector(unsigned long, unsigned char*)+0xc6>
    d0fe:	b.n	d072 <SdioCard::readSector(unsigned long, unsigned char*)+0x4e>
    d100:	.word	0x113a0011
    d104:	.word	0x1fff61bc
    d108:	.word	0x1fff09d4
    d10c:	.word	0x1fff61e0
    d110:	.word	0x400b1004

0000d114 <SdioCard::stopTransmission(bool)>:
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
    d114:	push	{r4, r5, r6, lr}
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    d116:	ldr	r2, [pc, #80]	; (d168 <SdioCard::stopTransmission(bool)+0x54>)
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
  m_curState = IDLE_STATE;
    d118:	movs	r5, #0
    d11a:	strb	r5, [r0, #9]
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    d11c:	ldr	r3, [r2, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    d11e:	ldr	r0, [pc, #76]	; (d16c <SdioCard::stopTransmission(bool)+0x58>)
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    d120:	bic.w	r3, r3, #65536	; 0x10000
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
    d124:	mov	r6, r1
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    d126:	str	r3, [r2, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    d128:	mov	r1, r5
    d12a:	bl	c398 <cardCommand(unsigned long, unsigned long)>
    d12e:	mov	r4, r0
    d130:	cbz	r0, d156 <SdioCard::stopTransmission(bool)+0x42>
    return sdError(SD_CARD_ERROR_CMD12);
  }
  if (blocking) {
    d132:	cbnz	r6, d138 <SdioCard::stopTransmission(bool)+0x24>
    if (yieldTimeout(isBusyDat)) {
      return sdError(SD_CARD_ERROR_CMD13);
    }
  }
  return true;
}
    d134:	mov	r0, r4
    d136:	pop	{r4, r5, r6, pc}
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
  if (blocking) {
    if (yieldTimeout(isBusyDat)) {
    d138:	ldr	r0, [pc, #52]	; (d170 <SdioCard::stopTransmission(bool)+0x5c>)
    d13a:	bl	c31c <yieldTimeout(bool (*)())>
    d13e:	cmp	r0, #0
    d140:	beq.n	d134 <SdioCard::stopTransmission(bool)+0x20>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    d142:	ldr	r1, [pc, #48]	; (d174 <SdioCard::stopTransmission(bool)+0x60>)
  m_errorLine = line;
    d144:	ldr	r3, [pc, #48]	; (d178 <SdioCard::stopTransmission(bool)+0x64>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    d146:	movs	r0, #10
  m_errorLine = line;
    d148:	movw	r2, #963	; 0x3c3
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
  if (blocking) {
    if (yieldTimeout(isBusyDat)) {
      return sdError(SD_CARD_ERROR_CMD13);
    d14c:	mov	r4, r5
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    d14e:	strb	r0, [r1, #0]
  m_errorLine = line;
    d150:	str	r2, [r3, #0]
    if (yieldTimeout(isBusyDat)) {
      return sdError(SD_CARD_ERROR_CMD13);
    }
  }
  return true;
}
    d152:	mov	r0, r4
    d154:	pop	{r4, r5, r6, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    d156:	ldr	r1, [pc, #28]	; (d174 <SdioCard::stopTransmission(bool)+0x60>)
  m_errorLine = line;
    d158:	ldr	r3, [pc, #28]	; (d178 <SdioCard::stopTransmission(bool)+0x64>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    d15a:	movs	r0, #9
  m_errorLine = line;
    d15c:	movw	r2, #959	; 0x3bf
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    d160:	strb	r0, [r1, #0]
  m_errorLine = line;
    d162:	str	r2, [r3, #0]
    if (yieldTimeout(isBusyDat)) {
      return sdError(SD_CARD_ERROR_CMD13);
    }
  }
  return true;
}
    d164:	mov	r0, r4
    d166:	pop	{r4, r5, r6, pc}
    d168:	.word	0x400b1028
    d16c:	.word	0x0cdb0000
    d170:	.word	0x0000c165
    d174:	.word	0x1fff09d4
    d178:	.word	0x1fff61e0

0000d17c <SdioCard::isBusy()>:
//------------------------------------------------------------------------------
uint32_t SdioCard::errorLine() const {
  return m_errorLine;
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
    d17c:	push	{r4, r5, r6, lr}
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    d17e:	ldrb	r3, [r0, #8]
    d180:	ands.w	r3, r3, #1
    d184:	beq.n	d192 <SdioCard::isBusy()+0x16>
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    d186:	ldr	r3, [pc, #88]	; (d1e0 <SdioCard::isBusy()+0x64>)
    d188:	ldr	r3, [r3, #0]
    d18a:	cbz	r3, d1c4 <SdioCard::isBusy()+0x48>
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    d18c:	ldmia.w	sp!, {r4, r5, r6, lr}
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    d190:	bx	r3
  } else {
    if (m_transferActive) {
    d192:	ldr	r2, [pc, #80]	; (d1e4 <SdioCard::isBusy()+0x68>)
    d194:	ldrb	r4, [r2, #0]
    d196:	cbnz	r4, d1a8 <SdioCard::isBusy()+0x2c>
#else  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
      return false;
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    }
    // Use DAT0 low as busy.
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
    d198:	ldr	r3, [pc, #76]	; (d1e8 <SdioCard::isBusy()+0x6c>)
    d19a:	ldr	r4, [r3, #0]
    d19c:	eor.w	r4, r4, #16777216	; 0x1000000
    d1a0:	ubfx	r4, r4, #24, #1
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    d1a4:	mov	r0, r4
    d1a6:	pop	{r4, r5, r6, pc}
static bool isBusyFifoWrite() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN);
}
//------------------------------------------------------------------------------
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
    d1a8:	ldr	r5, [pc, #64]	; (d1ec <SdioCard::isBusy()+0x70>)
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
  } else {
    if (m_transferActive) {
      if (isBusyTransferComplete()) {
    d1aa:	ldr	r1, [pc, #68]	; (d1f0 <SdioCard::isBusy()+0x74>)
static bool isBusyFifoWrite() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN);
}
//------------------------------------------------------------------------------
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
    d1ac:	ldr	r5, [r5, #0]
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
  } else {
    if (m_transferActive) {
      if (isBusyTransferComplete()) {
    d1ae:	ands	r1, r5
    d1b0:	cmp	r1, #0
    d1b2:	beq.n	d1a4 <SdioCard::isBusy()+0x28>
        return true;
      }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
      if ((SDHC_BLKATTR & 0XFFFF0000) != 0) {
    d1b4:	ldr	r1, [pc, #60]	; (d1f4 <SdioCard::isBusy()+0x78>)
    d1b6:	ldr	r5, [r1, #0]
    d1b8:	lsrs	r5, r5, #16
    d1ba:	lsls	r5, r5, #16
    d1bc:	cbz	r5, d1d4 <SdioCard::isBusy()+0x58>
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    d1be:	mov	r4, r3
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    d1c0:	mov	r0, r4
    d1c2:	pop	{r4, r5, r6, pc}
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    d1c4:	ldr	r3, [pc, #48]	; (d1f8 <SdioCard::isBusy()+0x7c>)
    d1c6:	ldrb	r4, [r3, #0]
    d1c8:	cmp	r4, #0
    d1ca:	beq.n	d1a4 <SdioCard::isBusy()+0x28>
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    d1cc:	ldmia.w	sp!, {r4, r5, r6, lr}
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    d1d0:	b.w	c3f4 <isBusyCMD13()>
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
      if ((SDHC_BLKATTR & 0XFFFF0000) != 0) {
        return false;
      }
      m_transferActive = false;
      stopTransmission(false);
    d1d4:	mov	r1, r5
      }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
      if ((SDHC_BLKATTR & 0XFFFF0000) != 0) {
        return false;
      }
      m_transferActive = false;
    d1d6:	strb	r5, [r2, #0]
      stopTransmission(false);
    d1d8:	bl	d114 <SdioCard::stopTransmission(bool)>
    d1dc:	b.n	d1a4 <SdioCard::isBusy()+0x28>
    d1de:	nop
    d1e0:	.word	0x1fff61ac
    d1e4:	.word	0x1fff61bc
    d1e8:	.word	0x400b1024
    d1ec:	.word	0x400b1030
    d1f0:	.word	0x117f0002
    d1f4:	.word	0x400b1004
    d1f8:	.word	0x1fff61c4

0000d1fc <SdioCard::syncDevice()>:
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
  if (!m_transferActive) {
    d1fc:	ldr	r3, [pc, #36]	; (d224 <SdioCard::syncDevice()+0x28>)
    d1fe:	ldrb	r3, [r3, #0]
    }
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::syncDevice() {
    d200:	push	{r4, lr}
    d202:	mov	r4, r0
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
  if (!m_transferActive) {
    d204:	cbnz	r3, d21a <SdioCard::syncDevice()+0x1e>
bool SdioCard::syncDevice() {
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    return false;
  }
  if (m_curState != IDLE_STATE) {
    d206:	ldrb	r3, [r4, #9]
    d208:	cbnz	r3, d20e <SdioCard::syncDevice()+0x12>
    if (!writeStop()) {
      return false;
    }
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  return true;
    d20a:	movs	r0, #1
    d20c:	pop	{r4, pc}
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    return false;
  }
  if (m_curState != IDLE_STATE) {
    return stopTransmission(true);
    d20e:	mov	r0, r4
    d210:	movs	r1, #1
      return false;
    }
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  return true;
}
    d212:	ldmia.w	sp!, {r4, lr}
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    return false;
  }
  if (m_curState != IDLE_STATE) {
    return stopTransmission(true);
    d216:	b.w	d114 <SdioCard::stopTransmission(bool)>
    d21a:	bl	c6d0 <waitTransferComplete() [clone .part.8]>
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::syncDevice() {
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    d21e:	cmp	r0, #0
    d220:	bne.n	d206 <SdioCard::syncDevice()+0xa>
      return false;
    }
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  return true;
}
    d222:	pop	{r4, pc}
    d224:	.word	0x1fff61bc

0000d228 <SdSpiArduinoDriver::activate()>:
 */
#include "SdSpiDriver.h"
#if defined(SD_USE_CUSTOM_SPI) &&  defined(__arm__) && defined(CORE_TEENSY)
#define USE_BLOCK_TRANSFER 1
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::activate() {
    d228:	push	{r4}
  m_spi->beginTransaction(m_spiSettings);
    d22a:	ldr	r3, [r0, #0]
    d22c:	ldr	r2, [r0, #4]

	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
    d22e:	ldrb	r1, [r3, #11]
    d230:	cbz	r1, d260 <SdSpiArduinoDriver::activate()+0x38>
			__disable_irq();
    d232:	cpsid	i
			if (interruptMasksUsed & 0x01) {
    d234:	ldrb	r1, [r3, #11]
    d236:	lsls	r4, r1, #31
    d238:	bpl.n	d248 <SdSpiArduinoDriver::activate()+0x20>
				interruptSave[0] = NVIC_ICER0 & interruptMask[0];
    d23a:	ldr	r0, [pc, #80]	; (d28c <SdSpiArduinoDriver::activate()+0x64>)
    d23c:	ldr	r1, [r3, #12]
    d23e:	ldr	r4, [r0, #0]
    d240:	ands	r1, r4
    d242:	str	r1, [r3, #24]
				NVIC_ICER0 = interruptSave[0];
    d244:	str	r1, [r0, #0]
    d246:	ldrb	r1, [r3, #11]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    d248:	lsls	r0, r1, #30
    d24a:	bpl.n	d25a <SdSpiArduinoDriver::activate()+0x32>
				interruptSave[1] = NVIC_ICER1 & interruptMask[1];
    d24c:	ldr	r0, [pc, #64]	; (d290 <SdSpiArduinoDriver::activate()+0x68>)
    d24e:	ldr	r1, [r3, #16]
    d250:	ldr	r4, [r0, #0]
    d252:	ands	r1, r4
    d254:	str	r1, [r3, #28]
				NVIC_ICER1 = interruptSave[1];
    d256:	str	r1, [r0, #0]
    d258:	ldrb	r1, [r3, #11]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    d25a:	lsls	r1, r1, #29
    d25c:	bmi.n	d27e <SdSpiArduinoDriver::activate()+0x56>
			if (interruptMasksUsed & 0x08) {
				interruptSave[3] = NVIC_ICER3 & interruptMask[3];
				NVIC_ICER3 = interruptSave[3];
			}
			#endif
			__enable_irq();
    d25e:	cpsie	i
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    d260:	ldr	r3, [r3, #0]
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 1;
		#endif
		if (port().CTAR0 != settings.ctar) {
    d262:	ldr	r1, [r3, #12]
    d264:	cmp	r1, r2
    d266:	beq.n	d278 <SdSpiArduinoDriver::activate()+0x50>
			port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x3F);
    d268:	ldr	r0, [pc, #40]	; (d294 <SdSpiArduinoDriver::activate()+0x6c>)
    d26a:	str	r0, [r3, #0]
			port().CTAR0 = settings.ctar;
			port().CTAR1 = settings.ctar| SPI_CTAR_FMSZ(8);
			port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x3F);
    d26c:	ldr	r1, [pc, #40]	; (d298 <SdSpiArduinoDriver::activate()+0x70>)
		}
		inTransactionFlag = 1;
		#endif
		if (port().CTAR0 != settings.ctar) {
			port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x3F);
			port().CTAR0 = settings.ctar;
    d26e:	str	r2, [r3, #12]
			port().CTAR1 = settings.ctar| SPI_CTAR_FMSZ(8);
    d270:	orr.w	r0, r2, #1073741824	; 0x40000000
    d274:	str	r0, [r3, #16]
			port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x3F);
    d276:	str	r1, [r3, #0]
}
    d278:	ldr.w	r4, [sp], #4
    d27c:	bx	lr
				NVIC_ICER1 = interruptSave[1];
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
				interruptSave[2] = NVIC_ICER2 & interruptMask[2];
    d27e:	ldr	r0, [pc, #28]	; (d29c <SdSpiArduinoDriver::activate()+0x74>)
    d280:	ldr	r1, [r3, #20]
    d282:	ldr	r4, [r0, #0]
    d284:	ands	r1, r4
    d286:	str	r1, [r3, #32]
				NVIC_ICER2 = interruptSave[2];
    d288:	str	r1, [r0, #0]
    d28a:	b.n	d25e <SdSpiArduinoDriver::activate()+0x36>
    d28c:	.word	0xe000e180
    d290:	.word	0xe000e184
    d294:	.word	0x003f4001
    d298:	.word	0x803f0000
    d29c:	.word	0xe000e188

0000d2a0 <SdSpiArduinoDriver::begin(SdSpiConfig)>:
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::begin(SdSpiConfig spiConfig) {
    d2a0:	push	{r4, lr}
    d2a2:	sub	sp, #16
    d2a4:	add	r4, sp, #16
    d2a6:	stmdb	r4, {r1, r2, r3}
    d2aa:	ldr	r3, [sp, #12]
  if (spiConfig.spiPort) {
    d2ac:	cbz	r3, d2bc <SdSpiArduinoDriver::begin(SdSpiConfig)+0x1c>
    m_spi->setMISO(SDCARD_MISO_PIN);
    m_spi->setMOSI(SDCARD_MOSI_PIN);
    m_spi->setSCK(SDCARD_SCK_PIN);
#endif  // defined(SDCARD_SPI) && defined(SDCARD_SS_PIN)
  } else {
    m_spi = &SPI;
    d2ae:	str	r3, [r0, #0]
    d2b0:	mov	r0, r3
  }
  m_spi->begin();
}
    d2b2:	add	sp, #16
    d2b4:	ldmia.w	sp!, {r4, lr}
    m_spi->setSCK(SDCARD_SCK_PIN);
#endif  // defined(SDCARD_SPI) && defined(SDCARD_SS_PIN)
  } else {
    m_spi = &SPI;
  }
  m_spi->begin();
    d2b8:	b.w	7be0 <SPIClass::begin()>
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::begin(SdSpiConfig spiConfig) {
  if (spiConfig.spiPort) {
    m_spi = spiConfig.spiPort;
#if defined(SDCARD_SPI) && defined(SDCARD_SS_PIN)
  } else if (spiConfig.csPin == SDCARD_SS_PIN) {
    d2bc:	ldrb.w	r3, [sp, #4]
    d2c0:	cmp	r3, #62	; 0x3e
    d2c2:	beq.n	d2c8 <SdSpiArduinoDriver::begin(SdSpiConfig)+0x28>
    m_spi->setMISO(SDCARD_MISO_PIN);
    m_spi->setMOSI(SDCARD_MOSI_PIN);
    m_spi->setSCK(SDCARD_SCK_PIN);
#endif  // defined(SDCARD_SPI) && defined(SDCARD_SS_PIN)
  } else {
    m_spi = &SPI;
    d2c4:	ldr	r3, [pc, #32]	; (d2e8 <SdSpiArduinoDriver::begin(SdSpiConfig)+0x48>)
    d2c6:	b.n	d2ae <SdSpiArduinoDriver::begin(SdSpiConfig)+0xe>
    d2c8:	mov	r4, r0
void SdSpiArduinoDriver::begin(SdSpiConfig spiConfig) {
  if (spiConfig.spiPort) {
    m_spi = spiConfig.spiPort;
#if defined(SDCARD_SPI) && defined(SDCARD_SS_PIN)
  } else if (spiConfig.csPin == SDCARD_SS_PIN) {
    m_spi = &SDCARD_SPI;
    d2ca:	ldr	r0, [pc, #32]	; (d2ec <SdSpiArduinoDriver::begin(SdSpiConfig)+0x4c>)
    d2cc:	str	r0, [r4, #0]
    m_spi->setMISO(SDCARD_MISO_PIN);
    d2ce:	movs	r1, #59	; 0x3b
    d2d0:	bl	7d00 <SPIClass::setMISO(unsigned char)>
    m_spi->setMOSI(SDCARD_MOSI_PIN);
    d2d4:	movs	r1, #61	; 0x3d
    d2d6:	ldr	r0, [r4, #0]
    d2d8:	bl	7c5c <SPIClass::setMOSI(unsigned char)>
    m_spi->setSCK(SDCARD_SCK_PIN);
    d2dc:	ldr	r0, [r4, #0]
    d2de:	movs	r1, #60	; 0x3c
    d2e0:	bl	7da0 <SPIClass::setSCK(unsigned char)>
    d2e4:	ldr	r0, [r4, #0]
    d2e6:	b.n	d2b2 <SdSpiArduinoDriver::begin(SdSpiConfig)+0x12>
    d2e8:	.word	0x1fff0960
    d2ec:	.word	0x1fff0998

0000d2f0 <SdSpiArduinoDriver::deactivate()>:
  }
  m_spi->begin();
}
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::deactivate() {
  m_spi->endTransaction();
    d2f0:	ldr	r2, [r0, #0]
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
    d2f2:	ldrb	r3, [r2, #11]
    d2f4:	cbz	r3, d318 <SdSpiArduinoDriver::deactivate()+0x28>
			if (interruptMasksUsed & 0x01) {
    d2f6:	lsls	r0, r3, #31
    d2f8:	bpl.n	d302 <SdSpiArduinoDriver::deactivate()+0x12>
				NVIC_ISER0 = interruptSave[0];
    d2fa:	ldr	r3, [pc, #32]	; (d31c <SdSpiArduinoDriver::deactivate()+0x2c>)
    d2fc:	ldr	r1, [r2, #24]
    d2fe:	str	r1, [r3, #0]
    d300:	ldrb	r3, [r2, #11]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    d302:	lsls	r1, r3, #30
    d304:	bpl.n	d30e <SdSpiArduinoDriver::deactivate()+0x1e>
				NVIC_ISER1 = interruptSave[1];
    d306:	ldr	r3, [pc, #24]	; (d320 <SdSpiArduinoDriver::deactivate()+0x30>)
    d308:	ldr	r1, [r2, #28]
    d30a:	str	r1, [r3, #0]
    d30c:	ldrb	r3, [r2, #11]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    d30e:	lsls	r3, r3, #29
    d310:	bpl.n	d318 <SdSpiArduinoDriver::deactivate()+0x28>
				NVIC_ISER2 = interruptSave[2];
    d312:	ldr	r3, [pc, #16]	; (d324 <SdSpiArduinoDriver::deactivate()+0x34>)
    d314:	ldr	r2, [r2, #32]
    d316:	str	r2, [r3, #0]
    d318:	bx	lr
    d31a:	nop
    d31c:	.word	0xe000e100
    d320:	.word	0xe000e104
    d324:	.word	0xe000e108

0000d328 <SdSpiArduinoDriver::receive()>:
}
//------------------------------------------------------------------------------
uint8_t SdSpiArduinoDriver::receive() {
    d328:	ldr	r3, [r0, #0]
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    d32a:	ldr	r2, [r3, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    d32c:	mov.w	r1, #2147483648	; 0x80000000
		port().PUSHR = data;
    d330:	movs	r3, #255	; 0xff
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    d332:	str	r1, [r2, #44]	; 0x2c
		port().PUSHR = data;
    d334:	str	r3, [r2, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    d336:	ldr	r3, [r2, #44]	; 0x2c
    d338:	cmp	r3, #0
    d33a:	bge.n	d336 <SdSpiArduinoDriver::receive()+0xe>
		return port().POPR;
    d33c:	ldr	r0, [r2, #56]	; 0x38
  return m_spi->transfer(0XFF);
}
    d33e:	uxtb	r0, r0
    d340:	bx	lr
    d342:	nop

0000d344 <SdSpiArduinoDriver::receive(unsigned char*, unsigned int)>:
//------------------------------------------------------------------------------
uint8_t SdSpiArduinoDriver::receive(uint8_t* buf, size_t count) {
    d344:	push	{r4, r5, r6, lr}
    d346:	mov	r5, r0
    d348:	mov	r4, r1
    d34a:	mov	r6, r2
#if USE_BLOCK_TRANSFER
  memset(buf, 0XFF, count);
    d34c:	mov	r0, r1
    d34e:	movs	r1, #255	; 0xff
    d350:	bl	1059c <memset>
		port().PUSHR = data | SPI_PUSHR_CTAS(1);
		while (!(port().SR & SPI_SR_TCF)) ; // wait
		return port().POPR;
	}

	void inline transfer(void *buf, size_t count) {transfer(buf, buf, count);}
    d354:	ldr	r0, [r5, #0]
    d356:	mov	r3, r6
    d358:	mov	r2, r4
    d35a:	mov	r1, r4
    d35c:	bl	7e50 <SPIClass::transfer(void const*, void*, unsigned int)>
  for (size_t i = 0; i < count; i++) {
    buf[i] = m_spi->transfer(0XFF);
  }
#endif  // USE_BLOCK_TRANSFER
  return 0;
}
    d360:	movs	r0, #0
    d362:	pop	{r4, r5, r6, pc}

0000d364 <SdSpiArduinoDriver::send(unsigned char)>:
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::send(uint8_t data) {
    d364:	ldr	r3, [r0, #0]
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    d366:	ldr	r2, [r3, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    d368:	mov.w	r3, #2147483648	; 0x80000000
    d36c:	str	r3, [r2, #44]	; 0x2c
		port().PUSHR = data;
    d36e:	str	r1, [r2, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    d370:	ldr	r3, [r2, #44]	; 0x2c
    d372:	cmp	r3, #0
    d374:	bge.n	d370 <SdSpiArduinoDriver::send(unsigned char)+0xc>
		return port().POPR;
    d376:	ldr	r3, [r2, #56]	; 0x38
    d378:	bx	lr
    d37a:	nop

0000d37c <SdSpiArduinoDriver::send(unsigned char const*, unsigned int)>:
  m_spi->transfer(data);
}
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::send(const uint8_t* buf , size_t count) {
    d37c:	push	{r4, r5, lr}
#if USE_BLOCK_TRANSFER
  uint32_t tmp[128];
  if (0 < count && count <= 512) {
    d37e:	subs	r5, r2, #1
    d380:	cmp.w	r5, #512	; 0x200
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::send(uint8_t data) {
  m_spi->transfer(data);
}
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::send(const uint8_t* buf , size_t count) {
    d384:	sub.w	sp, sp, #516	; 0x204
    d388:	mov	r3, r2
#if USE_BLOCK_TRANSFER
  uint32_t tmp[128];
  if (0 < count && count <= 512) {
    d38a:	bcc.n	d3b2 <SdSpiArduinoDriver::send(unsigned char const*, unsigned int)+0x36>
    memcpy(tmp, buf, count);
    m_spi->transfer(tmp, count);
    return;
  }
#endif  // USE_BLOCK_TRANSFER
  for (size_t i = 0; i < count; i++) {
    d38c:	cbz	r2, d3ac <SdSpiArduinoDriver::send(unsigned char const*, unsigned int)+0x30>
    d38e:	ldr	r2, [r0, #0]
    d390:	ldr	r2, [r2, #0]
    d392:	adds	r0, r1, r3
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    d394:	mov.w	r4, #2147483648	; 0x80000000
    m_spi->transfer(buf[i]);
    d398:	ldrb.w	r3, [r1], #1
    d39c:	str	r4, [r2, #44]	; 0x2c
		port().PUSHR = data;
    d39e:	str	r3, [r2, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    d3a0:	ldr	r3, [r2, #44]	; 0x2c
    d3a2:	cmp	r3, #0
    d3a4:	bge.n	d3a0 <SdSpiArduinoDriver::send(unsigned char const*, unsigned int)+0x24>
    memcpy(tmp, buf, count);
    m_spi->transfer(tmp, count);
    return;
  }
#endif  // USE_BLOCK_TRANSFER
  for (size_t i = 0; i < count; i++) {
    d3a6:	cmp	r1, r0
		return port().POPR;
    d3a8:	ldr	r3, [r2, #56]	; 0x38
    d3aa:	bne.n	d398 <SdSpiArduinoDriver::send(unsigned char const*, unsigned int)+0x1c>
    m_spi->transfer(buf[i]);
  }
}
    d3ac:	add.w	sp, sp, #516	; 0x204
    d3b0:	pop	{r4, r5, pc}
    d3b2:	mov	r5, r0
    d3b4:	mov	r4, r2
//------------------------------------------------------------------------------
void SdSpiArduinoDriver::send(const uint8_t* buf , size_t count) {
#if USE_BLOCK_TRANSFER
  uint32_t tmp[128];
  if (0 < count && count <= 512) {
    memcpy(tmp, buf, count);
    d3b6:	mov	r0, sp
    d3b8:	bl	d444 <memcpy>
		port().PUSHR = data | SPI_PUSHR_CTAS(1);
		while (!(port().SR & SPI_SR_TCF)) ; // wait
		return port().POPR;
	}

	void inline transfer(void *buf, size_t count) {transfer(buf, buf, count);}
    d3bc:	mov	r3, r4
    d3be:	mov	r2, sp
    d3c0:	mov	r1, sp
    d3c2:	ldr	r0, [r5, #0]
    d3c4:	bl	7e50 <SPIClass::transfer(void const*, void*, unsigned int)>
  }
#endif  // USE_BLOCK_TRANSFER
  for (size_t i = 0; i < count; i++) {
    m_spi->transfer(buf[i]);
  }
}
    d3c8:	add.w	sp, sp, #516	; 0x204
    d3cc:	pop	{r4, r5, pc}
    d3ce:	nop

0000d3d0 <sdCsInit(unsigned char)>:
#include "SdSpiDriver.h"
#if ENABLE_ARDUINO_FEATURES
#if SD_CHIP_SELECT_MODE == 0
//------------------------------------------------------------------------------
void sdCsInit(SdCsPin_t pin) {
  pinMode(pin, OUTPUT);
    d3d0:	movs	r1, #1
    d3d2:	b.w	de7c <pinMode>
    d3d6:	nop

0000d3d8 <sdCsWrite(unsigned char, bool)>:
}
//------------------------------------------------------------------------------
void sdCsWrite(SdCsPin_t pin, bool level) {
  digitalWrite(pin, level);
    d3d8:	b.w	de70 <digitalWrite>

0000d3dc <SDClass::~SDClass()>:
	char *filename;
};



class SDClass : public FS
    d3dc:	bx	lr
    d3de:	nop

0000d3e0 <_GLOBAL__sub_I_SD>:
 */

#include <Arduino.h>
#include <SD.h>

SDClass SD;
    d3e0:	push	{r4, r5, r6, r7}
{
public:
	SDClass() { }
    d3e2:	ldr	r3, [pc, #68]	; (d428 <_GLOBAL__sub_I_SD+0x48>)
    d3e4:	ldr	r5, [pc, #68]	; (d42c <_GLOBAL__sub_I_SD+0x4c>)
#else  // HAS_SDIO_CLASS
class SdSpiCard {
#endif  // HAS_SDIO_CLASS
 public:
  /** Construct an instance of SdSpiCard. */
  SdSpiCard() {}
    d3e6:	ldr	r4, [pc, #72]	; (d430 <_GLOBAL__sub_I_SD+0x50>)
    d3e8:	str	r5, [r3, #0]
    d3ea:	str.w	r4, [r3, #1184]	; 0x4a0
    d3ee:	movs	r5, #41	; 0x29
    d3f0:	movs	r4, #0
    d3f2:	ldr	r0, [pc, #64]	; (d434 <_GLOBAL__sub_I_SD+0x54>)
		}
		if (dataMode & 0x04) {
			c |= SPI_CTAR_CPHA;
			t = (t & 0xFFFF0FFF) | ((t & 0xF000) >> 4);
		}
		ctar = c | t;
    d3f4:	ldr	r7, [pc, #64]	; (d438 <_GLOBAL__sub_I_SD+0x58>)
    d3f6:	strb.w	r5, [r3, #1203]	; 0x4b3
    d3fa:	movs	r6, #1
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    d3fc:	strb.w	r4, [r3, #1180]	; 0x49c
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    d400:	strb.w	r4, [r3, #1181]	; 0x49d
    d404:	strb.w	r4, [r3, #1206]	; 0x4b6
    d408:	str.w	r0, [r3, #1172]	; 0x494
    d40c:	str.w	r7, [r3, #1192]	; 0x4a8
    d410:	strb.w	r6, [r3, #1201]	; 0x4b1
    d414:	str.w	r4, [r3, #1156]	; 0x484
    d418:	str.w	r4, [r3, #1160]	; 0x488
    d41c:	ldr	r2, [pc, #28]	; (d43c <_GLOBAL__sub_I_SD+0x5c>)
    d41e:	ldr	r1, [pc, #32]	; (d440 <_GLOBAL__sub_I_SD+0x60>)
    d420:	mov	r0, r3
    d422:	pop	{r4, r5, r6, r7}
    d424:	b.w	f0e0 <__aeabi_atexit>
    d428:	.word	0x1fff61e4
    d42c:	.word	0x0001419c
    d430:	.word	0x00014684
    d434:	.word	0x000146dc
    d438:	.word	0x38011001
    d43c:	.word	0x1fff0938
    d440:	.word	0x0000d3dd

0000d444 <memcpy>:
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
#else
	push	{r0}
    d444:	push	{r0}
#endif
	orr	r3, r1, r0
    d446:	orr.w	r3, r1, r0
	ands	r3, r3, #3
    d44a:	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
    d44e:	bne.n	d530 <memcpy+0xec>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
    d450:	subs	r2, #64	; 0x40
	blo	.Lmid_block
    d452:	bcc.n	d4d8 <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    d454:	ldr.w	r3, [r1], #4
    d458:	str.w	r3, [r0], #4
    d45c:	ldr.w	r3, [r1], #4
    d460:	str.w	r3, [r0], #4
    d464:	ldr.w	r3, [r1], #4
    d468:	str.w	r3, [r0], #4
    d46c:	ldr.w	r3, [r1], #4
    d470:	str.w	r3, [r0], #4
    d474:	ldr.w	r3, [r1], #4
    d478:	str.w	r3, [r0], #4
    d47c:	ldr.w	r3, [r1], #4
    d480:	str.w	r3, [r0], #4
    d484:	ldr.w	r3, [r1], #4
    d488:	str.w	r3, [r0], #4
    d48c:	ldr.w	r3, [r1], #4
    d490:	str.w	r3, [r0], #4
    d494:	ldr.w	r3, [r1], #4
    d498:	str.w	r3, [r0], #4
    d49c:	ldr.w	r3, [r1], #4
    d4a0:	str.w	r3, [r0], #4
    d4a4:	ldr.w	r3, [r1], #4
    d4a8:	str.w	r3, [r0], #4
    d4ac:	ldr.w	r3, [r1], #4
    d4b0:	str.w	r3, [r0], #4
    d4b4:	ldr.w	r3, [r1], #4
    d4b8:	str.w	r3, [r0], #4
    d4bc:	ldr.w	r3, [r1], #4
    d4c0:	str.w	r3, [r0], #4
    d4c4:	ldr.w	r3, [r1], #4
    d4c8:	str.w	r3, [r0], #4
    d4cc:	ldr.w	r3, [r1], #4
    d4d0:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
    d4d4:	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
    d4d6:	bcs.n	d454 <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
    d4d8:	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
    d4da:	bcc.n	d500 <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    d4dc:	ldr.w	r3, [r1], #4
    d4e0:	str.w	r3, [r0], #4
    d4e4:	ldr.w	r3, [r1], #4
    d4e8:	str.w	r3, [r0], #4
    d4ec:	ldr.w	r3, [r1], #4
    d4f0:	str.w	r3, [r0], #4
    d4f4:	ldr.w	r3, [r1], #4
    d4f8:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
    d4fc:	subs	r2, #16
	bhs	.Lmid_block_loop
    d4fe:	bcs.n	d4dc <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
    d500:	adds	r2, #12
	blo	.Lcopy_less_than_4
    d502:	bcc.n	d510 <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
    d504:	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
    d508:	str.w	r3, [r0], #4
	subs	r2, #4
    d50c:	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
    d50e:	bcs.n	d504 <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
    d510:	adds	r2, #4
	beq	.Ldone
    d512:	beq.n	d52a <memcpy+0xe6>

	lsls	r2, r2, #31
    d514:	lsls	r2, r2, #31
	itt ne
    d516:	itt	ne
	ldrbne  r3, [r1], #1
    d518:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    d51c:	strbne.w	r3, [r0], #1

	bcc	.Ldone
    d520:	bcc.n	d52a <memcpy+0xe6>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
	strh	r3, [r0]
#else
	ldrb	r3, [r1]
    d522:	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    d524:	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    d526:	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    d528:	strb	r3, [r0, #1]

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    d52a:	pop	{r0}
#endif
	bx	lr
    d52c:	bx	lr
    d52e:	nop
	beq	.Ldst_aligned
#else
	/* if len < 12, misalignment adjustment has more overhead than
	just byte-to-byte copy.  Also, len must >=8 to guarantee code
	afterward work correctly.  */
	cmp	r2, #12
    d530:	cmp	r2, #12
	blo	.Lbyte_copy
    d532:	bcc.n	d5ca <memcpy+0x186>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
    d534:	ands.w	r3, r0, #3
	beq	.Ldst_aligned
    d538:	beq.n	d55e <memcpy+0x11a>

	rsb	r3, #4
    d53a:	rsb	r3, r3, #4
	subs	r2, r3
    d53e:	subs	r2, r2, r3

	lsls    r3, r3, #31
    d540:	lsls	r3, r3, #31
	itt ne
    d542:	itt	ne
	ldrbne  r3, [r1], #1
    d544:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    d548:	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
    d54c:	bcc.n	d55e <memcpy+0x11a>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
	strh    r3, [r0], #2
	b	.Ldst_aligned
#else
	ldrb    r3, [r1], #1
    d54e:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    d552:	strb.w	r3, [r0], #1
	ldrb    r3, [r1], #1
    d556:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    d55a:	strb.w	r3, [r0], #1
	/* Now that dst is aligned */
.Ldst_aligned:
	/* if r1 is aligned now, it means r0/r1 has the same misalignment,
	and they are both aligned now.  Go aligned copy.  */
	ands	r3, r1, #3
    d55e:	ands.w	r3, r1, #3
	beq	.Lbig_block
    d562:	beq.w	d450 <memcpy+0xc>

	/* dst is aligned, but src isn't.  Misaligned copy.  */

	push	{r4, r5}
    d566:	push	{r4, r5}
	subs	r2, #4
    d568:	subs	r2, #4

	/* Backward r1 by misaligned bytes, to make r1 aligned.
	Since we need to restore r1 to unaligned address after the loop,
	we need keep the offset bytes to ip and sub it from r1 afterward.  */
	subs	r1, r3
    d56a:	subs	r1, r1, r3
	rsb	ip, r3, #4
    d56c:	rsb	ip, r3, #4

	/* Pre-load on word */
	ldr	r4, [r1], #4
    d570:	ldr.w	r4, [r1], #4

	cmp	r3, #2
    d574:	cmp	r3, #2
	beq	.Lmisaligned_copy_2_2
    d576:	beq.n	d5ac <memcpy+0x168>
	cmp	r3, #3
    d578:	cmp	r3, #3
	beq	.Lmisaligned_copy_3_1
    d57a:	beq.n	d594 <memcpy+0x150>
	subs	r2, #4
	bhs	1b
	.endm

.Lmisaligned_copy_1_3:
	mis_src_copy shift=8
    d57c:	lsrs	r4, r4, #8
    d57e:	ldr.w	r3, [r1], #4
    d582:	lsls	r5, r3, #24
    d584:	orr.w	r4, r4, r5
    d588:	str.w	r4, [r0], #4
    d58c:	mov	r4, r3
    d58e:	subs	r2, #4
    d590:	bcs.n	d57c <memcpy+0x138>
	b	.Lsrc_misaligned_tail
    d592:	b.n	d5c2 <memcpy+0x17e>

.Lmisaligned_copy_3_1:
	mis_src_copy shift=24
    d594:	lsrs	r4, r4, #24
    d596:	ldr.w	r3, [r1], #4
    d59a:	lsls	r5, r3, #8
    d59c:	orr.w	r4, r4, r5
    d5a0:	str.w	r4, [r0], #4
    d5a4:	mov	r4, r3
    d5a6:	subs	r2, #4
    d5a8:	bcs.n	d594 <memcpy+0x150>
	b	.Lsrc_misaligned_tail
    d5aa:	b.n	d5c2 <memcpy+0x17e>

.Lmisaligned_copy_2_2:
	/* For 2_2 misalignment, ldr is still faster than 2 x ldrh.  */
	mis_src_copy shift=16
    d5ac:	lsrs	r4, r4, #16
    d5ae:	ldr.w	r3, [r1], #4
    d5b2:	lsls	r5, r3, #16
    d5b4:	orr.w	r4, r4, r5
    d5b8:	str.w	r4, [r0], #4
    d5bc:	mov	r4, r3
    d5be:	subs	r2, #4
    d5c0:	bcs.n	d5ac <memcpy+0x168>

.Lsrc_misaligned_tail:
	adds	r2, #4
    d5c2:	adds	r2, #4
	subs	r1, ip
    d5c4:	subs.w	r1, r1, ip
	pop	{r4, r5}
    d5c8:	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    d5ca:	subs	r2, #4
	blo	.Lcopy_less_than_4
    d5cc:	bcc.n	d510 <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    d5ce:	subs	r2, #1
	ldrb    r3, [r1], #1
    d5d0:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    d5d4:	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    d5d8:	bcs.n	d5ce <memcpy+0x18a>

	ldrb	r3, [r1]
    d5da:	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    d5dc:	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    d5de:	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    d5e0:	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    d5e2:	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    d5e4:	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    d5e6:	pop	{r0}
#endif
	bx	lr
    d5e8:	bx	lr
    d5ea:	nop

0000d5ec <usb_serial_getchar>:

#define TRANSMIT_FLUSH_TIMEOUT	5   /* in milliseconds */

// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
    d5ec:	push	{r3, r4, r5, lr}
	unsigned int i;
	int c;

	if (!rx_packet) {
    d5ee:	ldr	r5, [pc, #60]	; (d62c <usb_serial_getchar+0x40>)
    d5f0:	ldr	r0, [r5, #0]
    d5f2:	cbz	r0, d614 <usb_serial_getchar+0x28>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
    d5f4:	ldrh	r3, [r0, #2]
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
    d5f6:	ldrh	r2, [r0, #0]
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
    d5f8:	adds	r1, r0, r3
    d5fa:	adds	r3, #1
	if (i >= rx_packet->len) {
    d5fc:	cmp	r3, r2
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
    d5fe:	ldrb	r4, [r1, #8]
	if (i >= rx_packet->len) {
    d600:	bcs.n	d608 <usb_serial_getchar+0x1c>
		usb_free(rx_packet);
		rx_packet = NULL;
	} else {
		rx_packet->index = i;
    d602:	strh	r3, [r0, #2]
	}
	return c;
    d604:	mov	r0, r4
}
    d606:	pop	{r3, r4, r5, pc}
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
    d608:	bl	e0d0 <usb_free>
		rx_packet = NULL;
    d60c:	movs	r3, #0
	} else {
		rx_packet->index = i;
	}
	return c;
    d60e:	mov	r0, r4
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
		rx_packet = NULL;
    d610:	str	r3, [r5, #0]
    d612:	pop	{r3, r4, r5, pc}
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    d614:	ldr	r3, [pc, #24]	; (d630 <usb_serial_getchar+0x44>)
    d616:	ldrb	r3, [r3, #0]
    d618:	cbz	r3, d626 <usb_serial_getchar+0x3a>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    d61a:	movs	r0, #2
    d61c:	bl	e11c <usb_rx>
    d620:	str	r0, [r5, #0]
		if (!rx_packet) return -1;
    d622:	cmp	r0, #0
    d624:	bne.n	d5f4 <usb_serial_getchar+0x8>
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    d626:	mov.w	r0, #4294967295
    d62a:	pop	{r3, r4, r5, pc}
    d62c:	.word	0x1fff66a8
    d630:	.word	0x1fff67b4

0000d634 <usb_serial_peekchar>:
	return c;
}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
    d634:	push	{r4, lr}
	if (!rx_packet) {
    d636:	ldr	r4, [pc, #36]	; (d65c <usb_serial_peekchar+0x28>)
    d638:	ldr	r0, [r4, #0]
    d63a:	cbz	r0, d644 <usb_serial_peekchar+0x10>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	if (!rx_packet) return -1;
	return rx_packet->buf[rx_packet->index];
    d63c:	ldrh	r3, [r0, #2]
    d63e:	add	r0, r3
    d640:	ldrb	r0, [r0, #8]
}
    d642:	pop	{r4, pc}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    d644:	ldr	r3, [pc, #24]	; (d660 <usb_serial_peekchar+0x2c>)
    d646:	ldrb	r3, [r3, #0]
    d648:	cbz	r3, d656 <usb_serial_peekchar+0x22>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    d64a:	movs	r0, #2
    d64c:	bl	e11c <usb_rx>
    d650:	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    d652:	cmp	r0, #0
    d654:	bne.n	d63c <usb_serial_peekchar+0x8>

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    d656:	mov.w	r0, #4294967295
    d65a:	pop	{r4, pc}
    d65c:	.word	0x1fff66a8
    d660:	.word	0x1fff67b4

0000d664 <usb_serial_available>:
// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    d664:	ldr	r3, [pc, #16]	; (d678 <usb_serial_available+0x14>)
static inline uint32_t usb_rx_byte_count(uint32_t endpoint) __attribute__((always_inline));
static inline uint32_t usb_rx_byte_count(uint32_t endpoint)
{
        endpoint--;
        if (endpoint >= NUM_ENDPOINTS) return 0;
        return usb_rx_byte_count_data[endpoint];
    d666:	ldr	r2, [pc, #20]	; (d67c <usb_serial_available+0x18>)
    d668:	ldr	r3, [r3, #0]

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
    d66a:	ldrh	r0, [r2, #2]
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    d66c:	cbz	r3, d676 <usb_serial_available+0x12>
    d66e:	ldrh	r2, [r3, #0]
    d670:	ldrh	r3, [r3, #2]
    d672:	subs	r3, r2, r3
    d674:	add	r0, r3
	return count;
}
    d676:	bx	lr
    d678:	.word	0x1fff66a8
    d67c:	.word	0x1fff6834

0000d680 <usb_serial_flush_input>:
// discard any buffered input
void usb_serial_flush_input(void)
{
	usb_packet_t *rx;

	if (!usb_configuration) return;
    d680:	ldr	r3, [pc, #44]	; (d6b0 <usb_serial_flush_input+0x30>)
    d682:	ldrb	r3, [r3, #0]
    d684:	cbz	r3, d6ae <usb_serial_flush_input+0x2e>
	return count;
}

// discard any buffered input
void usb_serial_flush_input(void)
{
    d686:	push	{r4, lr}
	usb_packet_t *rx;

	if (!usb_configuration) return;
	if (rx_packet) {
    d688:	ldr	r4, [pc, #40]	; (d6b4 <usb_serial_flush_input+0x34>)
    d68a:	ldr	r0, [r4, #0]
    d68c:	cbz	r0, d6a2 <usb_serial_flush_input+0x22>
		usb_free(rx_packet);
    d68e:	bl	e0d0 <usb_free>
		rx_packet = NULL;
    d692:	movs	r3, #0
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    d694:	movs	r0, #2
	usb_packet_t *rx;

	if (!usb_configuration) return;
	if (rx_packet) {
		usb_free(rx_packet);
		rx_packet = NULL;
    d696:	str	r3, [r4, #0]
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    d698:	bl	e11c <usb_rx>
		if (!rx) break;
    d69c:	cbz	r0, d6ac <usb_serial_flush_input+0x2c>
		usb_free(rx);
    d69e:	bl	e0d0 <usb_free>
	if (rx_packet) {
		usb_free(rx_packet);
		rx_packet = NULL;
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    d6a2:	movs	r0, #2
    d6a4:	bl	e11c <usb_rx>
		if (!rx) break;
    d6a8:	cmp	r0, #0
    d6aa:	bne.n	d69e <usb_serial_flush_input+0x1e>
    d6ac:	pop	{r4, pc}
    d6ae:	bx	lr
    d6b0:	.word	0x1fff67b4
    d6b4:	.word	0x1fff66a8

0000d6b8 <usb_serial_write>:
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    d6b8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    d6bc:	ldr.w	r9, [pc, #248]	; d7b8 <usb_serial_write+0x100>
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    d6c0:	sub	sp, #12
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    d6c2:	movs	r2, #1
    d6c4:	strb.w	r2, [r9]
	while (size > 0) {
    d6c8:	str	r1, [sp, #4]
    d6ca:	cbz	r1, d728 <usb_serial_write+0x70>
    d6cc:	ldr.w	r8, [pc, #236]	; d7bc <usb_serial_write+0x104>
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    d6d0:	ldr	r7, [pc, #216]	; (d7ac <usb_serial_write+0xf4>)
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
	while (size > 0) {
    d6d2:	ldr	r6, [sp, #4]
    d6d4:	mov	fp, r0
		if (!tx_packet) {
    d6d6:	ldr.w	r0, [r8]
    d6da:	cbz	r0, d74a <usb_serial_write+0x92>
    d6dc:	ldr	r5, [pc, #208]	; (d7b0 <usb_serial_write+0xf8>)
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
    d6de:	ldrh	r4, [r0, #2]
    d6e0:	rsb	r1, r4, #64	; 0x40
    d6e4:	cmp	r1, r6
    d6e6:	it	cs
    d6e8:	movcs	r1, r6
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    d6ea:	add.w	lr, r4, r1
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    d6ee:	movs	r2, #0
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    d6f0:	uxth.w	lr, lr
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    d6f4:	strb	r2, [r5, #0]
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
		size -= len;
    d6f6:	subs	r6, r6, r1
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    d6f8:	strh.w	lr, [r0, #2]
			}
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
    d6fc:	add.w	r2, r0, #8
		tx_packet->index += len;
		size -= len;
		while (len-- > 0) *dest++ = *src++;
    d700:	cbz	r1, d718 <usb_serial_write+0x60>
    d702:	subs	r4, #1
    d704:	add	r2, r4
    d706:	add	r1, fp
    d708:	ldrb.w	r4, [fp], #1
    d70c:	strb.w	r4, [r2, #1]!
    d710:	cmp	fp, r1
    d712:	bne.n	d708 <usb_serial_write+0x50>
    d714:	ldrh.w	lr, [r0, #2]
		if (tx_packet->index >= CDC_TX_SIZE) {
    d718:	cmp.w	lr, #63	; 0x3f
    d71c:	bhi.n	d736 <usb_serial_write+0x7e>
			tx_packet->len = CDC_TX_SIZE;
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    d71e:	ldr	r2, [pc, #148]	; (d7b4 <usb_serial_write+0xfc>)
    d720:	movs	r1, #5
    d722:	strb	r1, [r2, #0]
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
	while (size > 0) {
    d724:	cmp	r6, #0
    d726:	bne.n	d6d6 <usb_serial_write+0x1e>
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
    d728:	ldr	r0, [sp, #4]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
    d72a:	movs	r3, #0
    d72c:	strb.w	r3, [r9]
	return ret;
}
    d730:	add	sp, #12
    d732:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
		size -= len;
		while (len-- > 0) *dest++ = *src++;
		if (tx_packet->index >= CDC_TX_SIZE) {
			tx_packet->len = CDC_TX_SIZE;
    d736:	movs	r2, #64	; 0x40
    d738:	strh	r2, [r0, #0]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
    d73a:	mov	r1, r0
    d73c:	movs	r0, #3
    d73e:	bl	e208 <usb_tx>
			tx_packet = NULL;
    d742:	movs	r2, #0
    d744:	str.w	r2, [r8]
    d748:	b.n	d71e <usb_serial_write+0x66>
	tx_noautoflush = 1;
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    d74a:	ldrb	r2, [r7, #0]
    d74c:	cbz	r2, d79a <usb_serial_write+0xe2>
    d74e:	ldr	r5, [pc, #96]	; (d7b0 <usb_serial_write+0xf8>)
    d750:	movw	r4, #41721	; 0xa2f9
					tx_noautoflush = 0;
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
					tx_noautoflush = 1;
    d754:	mov.w	sl, #1
    d758:	b.n	d76a <usb_serial_write+0xb2>
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    d75a:	subs	r4, #1
    d75c:	beq.n	d78c <usb_serial_write+0xd4>
    d75e:	ldrb	r2, [r5, #0]
    d760:	cbnz	r2, d78c <usb_serial_write+0xd4>
					transmit_previous_timeout = 1;
					return -1;
				}
				yield();
    d762:	bl	ebc4 <yield>
	tx_noautoflush = 1;
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    d766:	ldrb	r2, [r7, #0]
    d768:	cbz	r2, d79a <usb_serial_write+0xe2>
					tx_noautoflush = 0;
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
    d76a:	movs	r0, #3
    d76c:	bl	e158 <usb_tx_packet_count>
    d770:	cmp	r0, #7
    d772:	bhi.n	d75a <usb_serial_write+0xa2>
					tx_noautoflush = 1;
    d774:	strb.w	sl, [r9]
					tx_packet = usb_malloc();
    d778:	bl	e090 <usb_malloc>
    d77c:	str.w	r0, [r8]
					if (tx_packet) break;
    d780:	cmp	r0, #0
    d782:	bne.n	d6de <usb_serial_write+0x26>
					tx_noautoflush = 0;
    d784:	ldr	r3, [pc, #48]	; (d7b8 <usb_serial_write+0x100>)
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    d786:	subs	r4, #1
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
					tx_noautoflush = 1;
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
    d788:	strb	r0, [r3, #0]
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    d78a:	bne.n	d75e <usb_serial_write+0xa6>
					transmit_previous_timeout = 1;
    d78c:	movs	r3, #1
					return -1;
    d78e:	mov.w	r0, #4294967295
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
					transmit_previous_timeout = 1;
    d792:	strb	r3, [r5, #0]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
}
    d794:	add	sp, #12
    d796:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
					tx_noautoflush = 0;
    d79a:	movs	r3, #0
					return -1;
    d79c:	mov.w	r0, #4294967295
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
					tx_noautoflush = 0;
    d7a0:	strb.w	r3, [r9]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
}
    d7a4:	add	sp, #12
    d7a6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d7aa:	nop
    d7ac:	.word	0x1fff67b4
    d7b0:	.word	0x1fff66a4
    d7b4:	.word	0x1fff669c
    d7b8:	.word	0x1fff669d
    d7bc:	.word	0x1fff66a0

0000d7c0 <usb_serial_putchar>:
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    d7c0:	push	{lr}
    d7c2:	sub	sp, #12
    d7c4:	add	r3, sp, #8
	return usb_serial_write(&c, 1);
    d7c6:	movs	r1, #1
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    d7c8:	strb.w	r0, [r3, #-1]!
	return usb_serial_write(&c, 1);
    d7cc:	mov	r0, r3
    d7ce:	bl	d6b8 <usb_serial_write>
}
    d7d2:	add	sp, #12
    d7d4:	ldr.w	pc, [sp], #4

0000d7d8 <usb_serial_write_buffer_free>:
	tx_noautoflush = 0;
	return ret;
}

int usb_serial_write_buffer_free(void)
{
    d7d8:	push	{r3, r4, r5, lr}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
    d7da:	ldr	r5, [pc, #56]	; (d814 <usb_serial_write_buffer_free+0x3c>)

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    d7dc:	ldr	r4, [pc, #56]	; (d818 <usb_serial_write_buffer_free+0x40>)
	if (!tx_packet) {
    d7de:	ldr	r0, [r5, #0]

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    d7e0:	movs	r3, #1
    d7e2:	strb	r3, [r4, #0]
	if (!tx_packet) {
    d7e4:	cbz	r0, d7f2 <usb_serial_write_buffer_free+0x1a>
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    d7e6:	ldrh	r0, [r0, #2]
	// space we just promised the user could write without blocking?
	// But does this come with other performance downsides?  Could it lead to
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
    d7e8:	movs	r3, #0
    d7ea:	strb	r3, [r4, #0]
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    d7ec:	rsb	r0, r0, #64	; 0x40
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
	return len;
}
    d7f0:	pop	{r3, r4, r5, pc}
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    d7f2:	ldr	r3, [pc, #40]	; (d81c <usb_serial_write_buffer_free+0x44>)
    d7f4:	ldrb	r3, [r3, #0]
    d7f6:	cbnz	r3, d7fe <usb_serial_write_buffer_free+0x26>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
    d7f8:	movs	r0, #0
    d7fa:	strb	r0, [r4, #0]
			return 0;
    d7fc:	pop	{r3, r4, r5, pc}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    d7fe:	movs	r0, #3
    d800:	bl	e158 <usb_tx_packet_count>
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    d804:	cmp	r0, #7
    d806:	bhi.n	d7f8 <usb_serial_write_buffer_free+0x20>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
    d808:	bl	e090 <usb_malloc>
    d80c:	str	r0, [r5, #0]
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    d80e:	cmp	r0, #0
    d810:	bne.n	d7e6 <usb_serial_write_buffer_free+0xe>
    d812:	b.n	d7f8 <usb_serial_write_buffer_free+0x20>
    d814:	.word	0x1fff66a0
    d818:	.word	0x1fff669d
    d81c:	.word	0x1fff67b4

0000d820 <usb_serial_flush_output>:
	tx_noautoflush = 0;
	return len;
}

void usb_serial_flush_output(void)
{
    d820:	push	{r3, r4, r5, r6, r7, lr}
	if (!usb_configuration) return;
    d822:	ldr	r3, [pc, #68]	; (d868 <usb_serial_flush_output+0x48>)
    d824:	ldrb	r3, [r3, #0]
    d826:	cbz	r3, d84c <usb_serial_flush_output+0x2c>
	tx_noautoflush = 1;
	if (tx_packet) {
    d828:	ldr	r6, [pc, #64]	; (d86c <usb_serial_flush_output+0x4c>)
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    d82a:	ldr	r5, [pc, #68]	; (d870 <usb_serial_flush_output+0x50>)
	if (tx_packet) {
    d82c:	ldr	r4, [r6, #0]
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    d82e:	movs	r7, #1
    d830:	strb	r7, [r5, #0]
	if (tx_packet) {
    d832:	cbz	r4, d84e <usb_serial_flush_output+0x2e>
		usb_cdc_transmit_flush_timer = 0;
    d834:	ldr	r2, [pc, #60]	; (d874 <usb_serial_flush_output+0x54>)
		tx_packet->len = tx_packet->index;
    d836:	ldrh	r3, [r4, #2]
void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
    d838:	movs	r7, #0
    d83a:	strb	r7, [r2, #0]
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    d83c:	mov	r1, r4
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
    d83e:	strh	r3, [r4, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    d840:	movs	r0, #3
    d842:	bl	e208 <usb_tx>
		tx_packet = NULL;
    d846:	str	r7, [r6, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
	tx_noautoflush = 0;
    d848:	movs	r3, #0
    d84a:	strb	r3, [r5, #0]
    d84c:	pop	{r3, r4, r5, r6, r7, pc}
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
    d84e:	bl	e090 <usb_malloc>
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    d852:	ldr	r3, [pc, #32]	; (d874 <usb_serial_flush_output+0x54>)
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
    d854:	cbz	r0, d862 <usb_serial_flush_output+0x42>
			usb_cdc_transmit_flush_timer = 0;
			usb_tx(CDC_TX_ENDPOINT, tx);
    d856:	mov	r1, r0
    d858:	movs	r0, #3
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    d85a:	strb	r4, [r3, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
    d85c:	bl	e208 <usb_tx>
    d860:	b.n	d848 <usb_serial_flush_output+0x28>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    d862:	strb	r7, [r3, #0]
    d864:	b.n	d848 <usb_serial_flush_output+0x28>
    d866:	nop
    d868:	.word	0x1fff67b4
    d86c:	.word	0x1fff66a0
    d870:	.word	0x1fff669d
    d874:	.word	0x1fff669c

0000d878 <usb_serial_flush_callback>:
	}
	tx_noautoflush = 0;
}

void usb_serial_flush_callback(void)
{
    d878:	push	{r3, r4, r5, lr}
	if (tx_noautoflush) return;
    d87a:	ldr	r3, [pc, #56]	; (d8b4 <usb_serial_flush_callback+0x3c>)
    d87c:	ldrb	r3, [r3, #0]
    d87e:	cbnz	r3, d89e <usb_serial_flush_callback+0x26>
	if (tx_packet) {
    d880:	ldr	r4, [pc, #52]	; (d8b8 <usb_serial_flush_callback+0x40>)
    d882:	ldr	r1, [r4, #0]
    d884:	cbz	r1, d8a0 <usb_serial_flush_callback+0x28>
    d886:	and.w	r5, r3, #255	; 0xff
		tx_packet->len = tx_packet->index;
    d88a:	ldrh	r3, [r1, #2]
    d88c:	strh	r3, [r1, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    d88e:	movs	r0, #3
    d890:	bl	e208 <usb_tx>
		tx_packet = NULL;
    d894:	str	r5, [r4, #0]
    d896:	pop	{r3, r4, r5, pc}
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
    d898:	ldr	r3, [pc, #32]	; (d8bc <usb_serial_flush_callback+0x44>)
    d89a:	movs	r2, #1
    d89c:	strb	r2, [r3, #0]
    d89e:	pop	{r3, r4, r5, pc}
	if (tx_packet) {
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
    d8a0:	bl	e090 <usb_malloc>
		if (tx) {
    d8a4:	cmp	r0, #0
    d8a6:	beq.n	d898 <usb_serial_flush_callback+0x20>
			usb_tx(CDC_TX_ENDPOINT, tx);
    d8a8:	mov	r1, r0
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
    d8aa:	ldmia.w	sp!, {r3, r4, r5, lr}
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
    d8ae:	movs	r0, #3
    d8b0:	b.w	e208 <usb_tx>
    d8b4:	.word	0x1fff669d
    d8b8:	.word	0x1fff66a0
    d8bc:	.word	0x1fff669c

0000d8c0 <fault_isr>:
void _init_Teensyduino_internal_(void) __attribute__((noinline));
void __libc_init_array(void);


void fault_isr(void)
{
    d8c0:	push	{r3, lr}
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    d8c2:	ldr	r4, [pc, #64]	; (d904 <fault_isr+0x44>)
    d8c4:	b.n	d8d8 <fault_isr+0x18>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    d8c6:	ldr	r3, [r4, #0]
    d8c8:	lsls	r1, r3, #21
    d8ca:	bmi.n	d8e8 <fault_isr+0x28>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    d8cc:	ldr	r3, [r4, #0]
    d8ce:	lsls	r2, r3, #20
    d8d0:	bmi.n	d8f2 <fault_isr+0x32>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    d8d2:	ldr	r3, [r4, #0]
    d8d4:	lsls	r3, r3, #19
    d8d6:	bmi.n	d8fc <fault_isr+0x3c>
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    d8d8:	ldr	r3, [r4, #0]
    d8da:	lsls	r0, r3, #13
    d8dc:	bpl.n	d8c6 <fault_isr+0x6>
    d8de:	bl	e28c <usb_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    d8e2:	ldr	r3, [r4, #0]
    d8e4:	lsls	r1, r3, #21
    d8e6:	bpl.n	d8cc <fault_isr+0xc>
    d8e8:	bl	d908 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    d8ec:	ldr	r3, [r4, #0]
    d8ee:	lsls	r2, r3, #20
    d8f0:	bpl.n	d8d2 <fault_isr+0x12>
    d8f2:	bl	d908 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    d8f6:	ldr	r3, [r4, #0]
    d8f8:	lsls	r3, r3, #19
    d8fa:	bpl.n	d8d8 <fault_isr+0x18>
    d8fc:	bl	d908 <unused_isr>
    d900:	b.n	d8d8 <fault_isr+0x18>
    d902:	nop
    d904:	.word	0x40048034

0000d908 <unused_isr>:
	}
}

void unused_isr(void)
{
    d908:	push	{r3, lr}
	fault_isr();
    d90a:	bl	d8c0 <fault_isr>
    d90e:	nop

0000d910 <startup_early_hook>:
extern void rtc_set(unsigned long t);


static void startup_default_early_hook(void) {
#if defined(KINETISK)
	WDOG_STCTRLH = WDOG_STCTRLH_ALLOWUPDATE;
    d910:	ldr	r3, [pc, #4]	; (d918 <startup_early_hook+0x8>)
    d912:	movs	r2, #16
    d914:	strh	r2, [r3, #0]
    d916:	bx	lr
    d918:	.word	0x40052000

0000d91c <startup_late_hook>:
#elif defined(KINETISL)
	SIM_COPC = 0;  // disable the watchdog
#endif
}
static void startup_default_late_hook(void) {}
    d91c:	bx	lr
    d91e:	nop

0000d920 <_sbrk>:

void * _sbrk(int incr)
{
	char *prev, *stack;

	prev = __brkval;
    d920:	ldr	r1, [pc, #36]	; (d948 <_sbrk+0x28>)

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

void * _sbrk(int incr)
{
    d922:	push	{r3, lr}
	char *prev, *stack;

	prev = __brkval;
    d924:	ldr	r3, [r1, #0]
	if (incr != 0) {
    d926:	cbz	r0, d936 <_sbrk+0x16>
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
    d928:	mov	r2, sp
		if (prev + incr >= stack - STACK_MARGIN) {
    d92a:	add	r0, r3
    d92c:	sub.w	r2, r2, #8192	; 0x2000
    d930:	cmp	r0, r2
    d932:	bcs.n	d93a <_sbrk+0x1a>
			errno = ENOMEM;
			return (void *)-1;
		}
		__brkval = prev + incr;
    d934:	str	r0, [r1, #0]
	}
	return prev;
    d936:	mov	r0, r3
}
    d938:	pop	{r3, pc}

	prev = __brkval;
	if (incr != 0) {
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
		if (prev + incr >= stack - STACK_MARGIN) {
			errno = ENOMEM;
    d93a:	bl	fdb4 <__errno>
    d93e:	movs	r3, #12
    d940:	str	r3, [r0, #0]
			return (void *)-1;
    d942:	mov.w	r0, #4294967295
    d946:	pop	{r3, pc}
    d948:	.word	0x1fff09d8

0000d94c <__cxa_pure_virtual>:
	while (1);
}

__attribute__((weak)) 
void __cxa_pure_virtual()
{
    d94c:	b.n	d94c <__cxa_pure_virtual>
    d94e:	nop

0000d950 <usb_init_serialnumber>:
void usb_init_serialnumber(void)
{
	char buf[11];
	uint32_t i, num;

	__disable_irq();
    d950:	cpsid	i
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    d952:	ldr	r2, [pc, #96]	; (d9b4 <usb_init_serialnumber+0x64>)
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    d954:	ldr	r3, [pc, #96]	; (d9b8 <usb_init_serialnumber+0x68>)
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    d956:	ldr	r1, [pc, #100]	; (d9bc <usb_init_serialnumber+0x6c>)
    d958:	str	r1, [r2, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    d95a:	movs	r2, #112	; 0x70
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    d95c:	movs	r1, #128	; 0x80
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    d95e:	strb	r2, [r3, #0]
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    d960:	mov	r2, r3
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    d962:	strb	r1, [r3, #0]
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    d964:	ldrb	r3, [r2, #0]
    d966:	lsls	r3, r3, #24
    d968:	bpl.n	d964 <usb_init_serialnumber+0x14>
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    d96a:	push	{r4, lr}
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOBB;
    d96c:	ldr	r3, [pc, #80]	; (d9c0 <usb_init_serialnumber+0x70>)
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    d96e:	sub	sp, #16
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOBB;
    d970:	ldr	r0, [r3, #0]
	kinetis_hsrun_enable();
#endif
	__enable_irq();
    d972:	cpsie	i
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    d974:	ldr	r3, [pc, #76]	; (d9c4 <usb_init_serialnumber+0x74>)
    d976:	ldr	r4, [pc, #80]	; (d9c8 <usb_init_serialnumber+0x78>)
    d978:	cmp	r0, r3
    d97a:	it	ls
    d97c:	addls.w	r0, r0, r0, lsl #2
	ultoa(num, buf, 10);
    d980:	add	r1, sp, #4
	num = *(uint32_t *)&FTFL_FCCOBB;
	kinetis_hsrun_enable();
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    d982:	it	ls
    d984:	lslls	r0, r0, #1
	ultoa(num, buf, 10);
    d986:	movs	r2, #10
    d988:	bl	d9cc <ultoa>
    d98c:	add	r1, sp, #4
    d98e:	mov	r0, r4
	for (i=0; i<10; i++) {
    d990:	movs	r3, #0
		char c = buf[i];
    d992:	ldrb.w	r2, [r1], #1
    d996:	adds	r3, #1
		if (!c) break;
    d998:	cbz	r2, d9aa <usb_init_serialnumber+0x5a>
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    d99a:	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
    d99c:	strh.w	r2, [r0, #2]!
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    d9a0:	bne.n	d992 <usb_init_serialnumber+0x42>
    d9a2:	movs	r3, #22
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    d9a4:	strb	r3, [r4, #0]
}
    d9a6:	add	sp, #16
    d9a8:	pop	{r4, pc}
    d9aa:	lsls	r3, r3, #1
    d9ac:	uxtb	r3, r3
	for (i=0; i<10; i++) {
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    d9ae:	strb	r3, [r4, #0]
}
    d9b0:	add	sp, #16
    d9b2:	pop	{r4, pc}
    d9b4:	.word	0x40020004
    d9b8:	.word	0x40020000
    d9bc:	.word	0x41070000
    d9c0:	.word	0x4002000c
    d9c4:	.word	0x0098967f
    d9c8:	.word	0x1fff0ab0

0000d9cc <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    d9cc:	push	{r4, r5, r6, r7}
    d9ce:	subs	r5, r1, #1
    d9d0:	mov	r6, r5
	unsigned digit;
	int i=0, j;
    d9d2:	movs	r4, #0
    d9d4:	b.n	d9d8 <ultoa+0xc>
	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
    d9d6:	adds	r4, #1
	unsigned digit;
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
    d9d8:	udiv	r3, r0, r2
    d9dc:	mls	r0, r2, r3, r0
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    d9e0:	cmp	r0, #9
    d9e2:	add.w	r7, r0, #48	; 0x30
    d9e6:	itet	hi
    d9e8:	addhi	r0, #55	; 0x37
    d9ea:	uxtbls	r0, r7
    d9ec:	uxtbhi	r0, r0
    d9ee:	strb.w	r0, [r6, #1]!
		val /= radix;
		if (val == 0) break;
    d9f2:	mov	r0, r3
    d9f4:	cmp	r3, #0
    d9f6:	bne.n	d9d6 <ultoa+0xa>
		i++;
	}
	buf[i + 1] = 0;
    d9f8:	adds	r2, r1, r4
    d9fa:	strb	r3, [r2, #1]
	for (j=0; j < i; j++, i--) {
    d9fc:	cbz	r4, da12 <ultoa+0x46>
		t = buf[j];
		buf[j] = buf[i];
    d9fe:	ldrb	r0, [r2, #0]
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
		t = buf[j];
    da00:	ldrb.w	r6, [r5, #1]!
		buf[j] = buf[i];
    da04:	strb	r0, [r5, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    da06:	adds	r3, #1
    da08:	subs	r0, r4, r3
    da0a:	cmp	r3, r0
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
    da0c:	strb.w	r6, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    da10:	blt.n	d9fe <ultoa+0x32>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
    da12:	mov	r0, r1
    da14:	pop	{r4, r5, r6, r7}
    da16:	bx	lr

0000da18 <dtostrf>:
char * fcvtf(float, int, int *, int *);
int isnanf (float x);
int isinff (float x);

char * dtostrf(float val, int width, unsigned int precision, char *buf)
{
    da18:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    da1c:	vpush	{d8}
	int decpt, sign, reqd, pad;
	const char *s, *e;
	char *p;

	int awidth = abs(width);
	if (isnanf(val)) {
    da20:	vcmp.f32	s0, s0
{
	int decpt, sign, reqd, pad;
	const char *s, *e;
	char *p;

	int awidth = abs(width);
    da24:	eor.w	r3, r0, r0, asr #31
	if (isnanf(val)) {
    da28:	vmrs	APSR_nzcv, fpscr
char * fcvtf(float, int, int *, int *);
int isnanf (float x);
int isinff (float x);

char * dtostrf(float val, int width, unsigned int precision, char *buf)
{
    da2c:	sub	sp, #16
    da2e:	vmov.f32	s16, s0
    da32:	mov	r5, r0
    da34:	mov	r4, r2
	int decpt, sign, reqd, pad;
	const char *s, *e;
	char *p;

	int awidth = abs(width);
    da36:	sub.w	r3, r3, r0, asr #31
	if (isnanf(val)) {
    da3a:	bvs.w	dc98 <dtostrf+0x280>
			awidth--;
		}
		*buf = 0;
		return buf;
	}
	if (isinff(val)) {
    da3e:	vldr	s15, [pc, #800]	; dd60 <dtostrf+0x348>
    da42:	vabs.f32	s14, s0
    da46:	vcmp.f32	s14, s15
    da4a:	vmrs	APSR_nzcv, fpscr
    da4e:	ble.n	dad6 <dtostrf+0xbe>
		int ndigs = (val<0) ? 4 : 3;
    da50:	vcmpe.f32	s0, #0.0
    da54:	vmrs	APSR_nzcv, fpscr
    da58:	ite	mi
    da5a:	movmi	r0, #4
    da5c:	movpl	r0, #3
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    da5e:	cmp	r0, r3
    da60:	blt.n	daa6 <dtostrf+0x8e>
		if (width<0) {
    da62:	cmp	r5, #0
    da64:	blt.w	dd4e <dtostrf+0x336>
		*buf = 0;
		return buf;
	}
	if (isinff(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    da68:	movs	r0, #0
			while (awidth) {
				*buf++ = ' ';
				awidth--;
			}
		}
		if (val<0) *buf++ = '-';
    da6a:	vcmpe.f32	s16, #0.0
    da6e:	vmrs	APSR_nzcv, fpscr
    da72:	it	mi
    da74:	movmi	r3, r4
    da76:	bmi.n	dace <dtostrf+0xb6>
		if (DTOA_UPPER) {
			*buf++ = 'I';  *buf++ = 'N';  *buf++ = 'F';
    da78:	movs	r1, #73	; 0x49
    da7a:	movs	r2, #78	; 0x4e
    da7c:	movs	r3, #70	; 0x46
    da7e:	strb	r1, [r4, #0]
    da80:	strb	r2, [r4, #1]
    da82:	strb	r3, [r4, #2]
    da84:	adds	r4, #3
		} else {
			*buf++ = 'i';  *buf++ = 'n';  *buf++ = 'f';
		}
		while (awidth) {
    da86:	cmp	r0, #0
    da88:	beq.w	dd56 <dtostrf+0x33e>
    da8c:	add	r0, r4
			*buf++ = ' ';
    da8e:	movs	r3, #32
    da90:	strb.w	r3, [r4], #1
		if (DTOA_UPPER) {
			*buf++ = 'I';  *buf++ = 'N';  *buf++ = 'F';
		} else {
			*buf++ = 'i';  *buf++ = 'n';  *buf++ = 'f';
		}
		while (awidth) {
    da94:	cmp	r0, r4
    da96:	bne.n	da90 <dtostrf+0x78>
			*buf++ = ' ';
			awidth--;
		}
		*buf = 0;
    da98:	movs	r3, #0
    da9a:	strb	r3, [r0, #0]

	//char format[20];
	//sprintf(format, "%%%d.%df", width, precision);
	//sprintf(buf, format, val);
	return buf;
}
    da9c:	add	sp, #16
    da9e:	vpop	{d8}
    daa2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return buf;
	}
	if (isinff(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
    daa6:	cmp	r5, #0
		*buf = 0;
		return buf;
	}
	if (isinff(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    daa8:	sub.w	r0, r3, r0
		if (width<0) {
    daac:	bge.n	da6a <dtostrf+0x52>
			while (awidth) {
    daae:	cmp	r0, #0
    dab0:	beq.w	dd4e <dtostrf+0x336>
    dab4:	adds	r3, r2, r0
				*buf++ = ' ';
    dab6:	movs	r2, #32
    dab8:	strb.w	r2, [r4], #1
	}
	if (isinff(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
			while (awidth) {
    dabc:	cmp	r4, r3
    dabe:	bne.n	dab8 <dtostrf+0xa0>
				*buf++ = ' ';
				awidth--;
			}
		}
		if (val<0) *buf++ = '-';
    dac0:	vcmpe.f32	s16, #0.0
    dac4:	vmrs	APSR_nzcv, fpscr
    dac8:	bpl.w	dd04 <dtostrf+0x2ec>
    dacc:	movs	r0, #0
    dace:	movs	r2, #45	; 0x2d
    dad0:	strb	r2, [r3, #0]
    dad2:	adds	r4, r3, #1
    dad4:	b.n	da78 <dtostrf+0x60>
    dad6:	mov	r7, r1
		}
		*buf = 0;
		return buf;
	}

	s = fcvtf(val, precision, &decpt, &sign);
    dad8:	add	r2, sp, #8
    dada:	add	r1, sp, #4
    dadc:	mov	r0, r7
    dade:	bl	fd90 <fcvtf>
    dae2:	mov	sl, r7
    dae4:	mov	r8, r0

	// if only 1 digit in output
	if (precision == 0 && decpt == 0) {
    dae6:	ldr.w	r9, [sp, #4]
    daea:	cmp	r7, #0
    daec:	beq.n	dba2 <dtostrf+0x18a>
    daee:	rsb	r3, r9, #0
		s = (*s < '5') ? "0" : "1";
		decpt++;
	}

	// if all zeros, limit to precision
	if (-decpt  > (int)precision) {
    daf2:	cmp	r3, r7
    daf4:	bgt.w	dc24 <dtostrf+0x20c>
    daf8:	mov	r0, r8
    dafa:	bl	10c00 <strlen>
    dafe:	mov	r6, r0
	}

	reqd = strlen(s);

	// add 1 for decimal point
	if (reqd > decpt) reqd++;
    db00:	cmp	r9, r6
    db02:	it	lt
    db04:	addlt	r6, #1

	// add 1 for zero in front of decimal point
	if (decpt == 0) reqd++;
    db06:	cmp.w	r9, #0
    db0a:	bne.w	dc42 <dtostrf+0x22a>
    db0e:	adds	r6, #1
			if (newDecimalPoint - decpt == precision + 1) decpt++;
		}
	}

	// add 1 for sign if negative
	if (sign) reqd++;
    db10:	ldr.w	lr, [sp, #8]
    db14:	cmp.w	lr, #0
    db18:	beq.n	dbc6 <dtostrf+0x1ae>
    db1a:	adds	r6, #1

	p = buf;
	e = p + reqd;
	pad = width - reqd;
    db1c:	subs	r0, r5, r6
	if (pad > 0) {
    db1e:	cmp	r0, #0

	// add 1 for sign if negative
	if (sign) reqd++;

	p = buf;
	e = p + reqd;
    db20:	add.w	r1, r4, r6
	pad = width - reqd;
	if (pad > 0) {
    db24:	bgt.n	dbd2 <dtostrf+0x1ba>
	}

	// add 1 for sign if negative
	if (sign) reqd++;

	p = buf;
    db26:	mov	r3, r4
	pad = width - reqd;
	if (pad > 0) {
		e += pad;
		while (pad-- > 0) *p++ = ' ';
	}
	if (sign) *p++ = '-';
    db28:	movs	r2, #45	; 0x2d
    db2a:	strb	r2, [r3, #0]
    db2c:	adds	r3, #1
	if (decpt == 0 && precision > 0) {
    db2e:	cmp.w	r9, #0
    db32:	bne.n	dc00 <dtostrf+0x1e8>
    db34:	cbz	r7, db44 <dtostrf+0x12c>
		*p++ = '0';
    db36:	mov	r2, r3
    db38:	movs	r0, #48	; 0x30
    db3a:	strb.w	r0, [r2], #2
		*p++ = '.';
    db3e:	movs	r0, #46	; 0x2e
    db40:	strb	r0, [r3, #1]
    db42:	mov	r3, r2
			decpt++;
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
    db44:	cmp	r3, r1
    db46:	bcs.n	db8a <dtostrf+0x172>
		*p++ = *s++;
    db48:	adds	r7, r3, #1
    db4a:	ldrb.w	r2, [r8]
    db4e:	strb	r2, [r3, #0]
		if (p == e) break;
    db50:	cmp	r7, r1
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
		*p++ = *s++;
    db52:	add.w	r8, r8, #1
		if (p == e) break;
    db56:	beq.n	db8c <dtostrf+0x174>
    db58:	ldr	r2, [sp, #4]
		if (--decpt == 0) *p++ = '.';
    db5a:	mov.w	lr, #46	; 0x2e
    db5e:	b.n	db78 <dtostrf+0x160>
    db60:	strb.w	lr, [r3, #1]
    db64:	adds	r3, #2
			decpt++;
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
    db66:	cmp	r3, r1
		*p++ = *s++;
    db68:	add.w	r7, r3, #1
			decpt++;
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
    db6c:	bcs.n	db8a <dtostrf+0x172>
		*p++ = *s++;
    db6e:	ldrb.w	r0, [r8], #1
    db72:	strb	r0, [r3, #0]
		if (p == e) break;
    db74:	cmp	r7, r1
    db76:	beq.n	db8c <dtostrf+0x174>
		if (--decpt == 0) *p++ = '.';
    db78:	subs	r2, #1
    db7a:	str	r2, [sp, #4]
    db7c:	cmp	r2, #0
    db7e:	beq.n	db60 <dtostrf+0x148>
    db80:	mov	r3, r7
			decpt++;
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
    db82:	cmp	r3, r1
		*p++ = *s++;
    db84:	add.w	r7, r3, #1
			decpt++;
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
    db88:	bcc.n	db6e <dtostrf+0x156>
    db8a:	mov	r1, r3
		*p++ = *s++;
		if (p == e) break;
		if (--decpt == 0) *p++ = '.';
	}
	if (width < 0) {
    db8c:	cmp	r5, #0
    db8e:	blt.w	dcd8 <dtostrf+0x2c0>
		pad = (reqd + width) * -1;
		while (pad-- > 0) *p++ = ' ';
	}
	*p = 0;
    db92:	movs	r3, #0

	//char format[20];
	//sprintf(format, "%%%d.%df", width, precision);
	//sprintf(buf, format, val);
	return buf;
    db94:	mov	r0, r4
	}
	if (width < 0) {
		pad = (reqd + width) * -1;
		while (pad-- > 0) *p++ = ' ';
	}
	*p = 0;
    db96:	strb	r3, [r1, #0]

	//char format[20];
	//sprintf(format, "%%%d.%df", width, precision);
	//sprintf(buf, format, val);
	return buf;
}
    db98:	add	sp, #16
    db9a:	vpop	{d8}
    db9e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	}

	s = fcvtf(val, precision, &decpt, &sign);

	// if only 1 digit in output
	if (precision == 0 && decpt == 0) {
    dba2:	cmp.w	r9, #0
    dba6:	bne.n	daee <dtostrf+0xd6>
		// round and move decimal point
		s = (*s < '5') ? "0" : "1";
    dba8:	ldrb.w	r8, [r0]
    dbac:	ldr	r1, [pc, #436]	; (dd64 <dtostrf+0x34c>)
    dbae:	ldr	r2, [pc, #440]	; (dd68 <dtostrf+0x350>)
		decpt++;
    dbb0:	movs	r3, #1
    dbb2:	str	r3, [sp, #4]
    dbb4:	mov	r9, r3
	s = fcvtf(val, precision, &decpt, &sign);

	// if only 1 digit in output
	if (precision == 0 && decpt == 0) {
		// round and move decimal point
		s = (*s < '5') ? "0" : "1";
    dbb6:	cmp.w	r8, #52	; 0x34
    dbba:	ite	hi
    dbbc:	movhi	r8, r1
    dbbe:	movls	r8, r2
		decpt++;
    dbc0:	mov.w	r3, #4294967295
    dbc4:	b.n	daf2 <dtostrf+0xda>
	// add 1 for sign if negative
	if (sign) reqd++;

	p = buf;
	e = p + reqd;
	pad = width - reqd;
    dbc6:	subs	r0, r5, r6
	if (pad > 0) {
    dbc8:	cmp	r0, #0

	// add 1 for sign if negative
	if (sign) reqd++;

	p = buf;
	e = p + reqd;
    dbca:	add.w	r1, r4, r6
	pad = width - reqd;
	if (pad > 0) {
    dbce:	ble.w	dd5a <dtostrf+0x342>
		e += pad;
    dbd2:	add	r1, r0
		decpt++;
	}

	// if all zeros, limit to precision
	if (-decpt  > (int)precision) {
		s = "0";
    dbd4:	mov	r2, r4
	p = buf;
	e = p + reqd;
	pad = width - reqd;
	if (pad > 0) {
		e += pad;
		while (pad-- > 0) *p++ = ' ';
    dbd6:	subs	r0, #1
    dbd8:	mov.w	ip, #32
    dbdc:	strb.w	ip, [r2], #1
    dbe0:	rsb	r3, r2, #1
    dbe4:	add	r3, r0
    dbe6:	add	r3, r4
    dbe8:	cmp	r3, #0
    dbea:	bgt.n	dbdc <dtostrf+0x1c4>
    dbec:	bic.w	r3, r0, r0, asr #31
    dbf0:	adds	r3, #1
    dbf2:	add	r3, r4
	}
	if (sign) *p++ = '-';
    dbf4:	cmp.w	lr, #0
    dbf8:	bne.n	db28 <dtostrf+0x110>
	if (decpt == 0 && precision > 0) {
    dbfa:	cmp.w	r9, #0
    dbfe:	beq.n	db34 <dtostrf+0x11c>
		*p++ = '0';
		*p++ = '.';
	}
	else if (decpt < 0 && precision > 0) {
    dc00:	bge.n	db44 <dtostrf+0x12c>
    dc02:	cmp	r7, #0
    dc04:	beq.n	db44 <dtostrf+0x12c>
		*p++ = '0';
    dc06:	mov	r2, r3
    dc08:	movs	r0, #48	; 0x30
    dc0a:	strb.w	r0, [r2], #2
		*p++ = '.';
    dc0e:	movs	r7, #46	; 0x2e
    dc10:	strb	r7, [r3, #1]
    dc12:	rsb	r3, r9, r2
		// print leading zeros
		while ( decpt < 0 ) {
			decpt++;
			*p++ = '0';
    dc16:	strb.w	r0, [r2], #1
	}
	else if (decpt < 0 && precision > 0) {
		*p++ = '0';
		*p++ = '.';
		// print leading zeros
		while ( decpt < 0 ) {
    dc1a:	cmp	r3, r2
    dc1c:	bne.n	dc16 <dtostrf+0x1fe>
    dc1e:	movs	r2, #0
    dc20:	str	r2, [sp, #4]
    dc22:	b.n	db44 <dtostrf+0x12c>
	}

	// if all zeros, limit to precision
	if (-decpt  > (int)precision) {
		s = "0";
		decpt = -precision;
    dc24:	rsb	r9, r7, #0
    dc28:	movs	r6, #1
	}

	reqd = strlen(s);

	// add 1 for decimal point
	if (reqd > decpt) reqd++;
    dc2a:	cmp	r9, r6
	}

	// if all zeros, limit to precision
	if (-decpt  > (int)precision) {
		s = "0";
		decpt = -precision;
    dc2c:	mov	r0, r6
	}

	reqd = strlen(s);

	// add 1 for decimal point
	if (reqd > decpt) reqd++;
    dc2e:	it	lt
    dc30:	addlt	r6, #1

	// add 1 for zero in front of decimal point
	if (decpt == 0) reqd++;
    dc32:	cmp.w	r9, #0
		decpt++;
	}

	// if all zeros, limit to precision
	if (-decpt  > (int)precision) {
		s = "0";
    dc36:	ldr.w	r8, [pc, #304]	; dd68 <dtostrf+0x350>
		decpt = -precision;
    dc3a:	str.w	r9, [sp, #4]

	// add 1 for decimal point
	if (reqd > decpt) reqd++;

	// add 1 for zero in front of decimal point
	if (decpt == 0) reqd++;
    dc3e:	beq.w	db0e <dtostrf+0xf6>

	// if leading zeros after decimal point
	if (decpt < 0 && precision > 0) {
    dc42:	bge.w	db10 <dtostrf+0xf8>
    dc46:	cmp	r7, #0
    dc48:	beq.w	db10 <dtostrf+0xf8>
		// ensure enough trailing zeros, add 2 for '0.'
		reqd = precision + 2;

		if (strlen(s) > precision + decpt) {
    dc4c:	add.w	r3, r9, r7
    dc50:	cmp	r0, r3
	if (decpt == 0) reqd++;

	// if leading zeros after decimal point
	if (decpt < 0 && precision > 0) {
		// ensure enough trailing zeros, add 2 for '0.'
		reqd = precision + 2;
    dc52:	add.w	r6, r7, #2

		if (strlen(s) > precision + decpt) {
    dc56:	bls.w	db10 <dtostrf+0xf8>

			int newPrecision = precision;
			int newDecimalPoint;

			// shift decimal point
			while (newPrecision > 0) {
    dc5a:	cmp	r7, #0
    dc5c:	ble.n	dc6c <dtostrf+0x254>
				val *= 10.0;
    dc5e:	vmov.f32	s15, #36	; 0x41200000  10.0

			int newPrecision = precision;
			int newDecimalPoint;

			// shift decimal point
			while (newPrecision > 0) {
    dc62:	subs.w	sl, sl, #1
				val *= 10.0;
    dc66:	vmul.f32	s16, s16, s15

			int newPrecision = precision;
			int newDecimalPoint;

			// shift decimal point
			while (newPrecision > 0) {
    dc6a:	bne.n	dc62 <dtostrf+0x24a>
				val *= 10.0;
				newPrecision--;
			}

			// round after accounting for leading 0's
			s = fcvtf(val, newPrecision, &newDecimalPoint, &sign);
    dc6c:	add	r2, sp, #8
    dc6e:	mov	r0, sl
    dc70:	vmov.f32	s0, s16
    dc74:	add	r1, sp, #12
    dc76:	bl	fd90 <fcvtf>

			// if rounded up to new digit (e.g. 0.09 to 0.1), move decimal point
			if (newDecimalPoint - decpt == precision + 1) decpt++;
    dc7a:	ldr.w	r9, [sp, #4]
    dc7e:	ldr	r2, [sp, #12]
    dc80:	adds	r3, r7, #1
    dc82:	rsb	r2, r9, r2
    dc86:	cmp	r2, r3
    dc88:	it	eq
    dc8a:	addeq.w	r9, r9, #1
				val *= 10.0;
				newPrecision--;
			}

			// round after accounting for leading 0's
			s = fcvtf(val, newPrecision, &newDecimalPoint, &sign);
    dc8e:	mov	r8, r0

			// if rounded up to new digit (e.g. 0.09 to 0.1), move decimal point
			if (newDecimalPoint - decpt == precision + 1) decpt++;
    dc90:	it	eq
    dc92:	streq.w	r9, [sp, #4]
    dc96:	b.n	db10 <dtostrf+0xf8>
	const char *s, *e;
	char *p;

	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
    dc98:	vcmpe.f32	s0, #0.0
    dc9c:	vmrs	APSR_nzcv, fpscr
    dca0:	ite	mi
    dca2:	movmi	r0, #4
    dca4:	movpl	r0, #3
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    dca6:	cmp	r0, r3
    dca8:	bge.n	dd14 <dtostrf+0x2fc>
		if (width<0) {
    dcaa:	cmp	r5, #0
	char *p;

	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    dcac:	sub.w	r3, r3, r0
		if (width<0) {
    dcb0:	blt.n	dd26 <dtostrf+0x30e>
			while (awidth) {
				*buf++ = ' ';
				awidth--;
			}
		}
		if (copysignf(1.0f, val)<0) *buf++ = '-';
    dcb2:	vmov	r2, s16
    dcb6:	cmp	r2, #0
    dcb8:	blt.n	dd1c <dtostrf+0x304>
		if (DTOA_UPPER) {
			*buf++ = 'N';  *buf++ = 'A';  *buf++ = 'N';
    dcba:	movs	r2, #78	; 0x4e
    dcbc:	movs	r1, #65	; 0x41
    dcbe:	strb	r2, [r4, #0]
    dcc0:	strb	r2, [r4, #2]
    dcc2:	strb	r1, [r4, #1]
    dcc4:	adds	r4, #3
		} else {
			*buf++ = 'n';  *buf++ = 'a';  *buf++ = 'n';
		}
		while (awidth) {
    dcc6:	cmp	r3, #0
    dcc8:	beq.n	dd56 <dtostrf+0x33e>
    dcca:	adds	r0, r4, r3
			*buf++ = ' ';
    dccc:	movs	r3, #32
    dcce:	strb.w	r3, [r4], #1
		if (DTOA_UPPER) {
			*buf++ = 'N';  *buf++ = 'A';  *buf++ = 'N';
		} else {
			*buf++ = 'n';  *buf++ = 'a';  *buf++ = 'n';
		}
		while (awidth) {
    dcd2:	cmp	r4, r0
    dcd4:	bne.n	dcce <dtostrf+0x2b6>
    dcd6:	b.n	da98 <dtostrf+0x80>
		*p++ = *s++;
		if (p == e) break;
		if (--decpt == 0) *p++ = '.';
	}
	if (width < 0) {
		pad = (reqd + width) * -1;
    dcd8:	adds	r0, r5, r6
		while (pad-- > 0) *p++ = ' ';
    dcda:	negs	r3, r0
    dcdc:	cmp	r3, #0
    dcde:	mvn.w	r0, r0
    dce2:	ble.w	db92 <dtostrf+0x17a>
    dce6:	mov	r2, r1
    dce8:	movs	r5, #32
    dcea:	strb.w	r5, [r2], #1
    dcee:	rsb	r3, r2, #1
    dcf2:	add	r3, r0
    dcf4:	add	r3, r1
    dcf6:	cmp	r3, #0
    dcf8:	bgt.n	dcea <dtostrf+0x2d2>
    dcfa:	bic.w	r3, r0, r0, asr #31
    dcfe:	adds	r3, #1
    dd00:	add	r1, r3
    dd02:	b.n	db92 <dtostrf+0x17a>
				awidth--;
			}
		}
		if (val<0) *buf++ = '-';
		if (DTOA_UPPER) {
			*buf++ = 'I';  *buf++ = 'N';  *buf++ = 'F';
    dd04:	movs	r0, #73	; 0x49
    dd06:	movs	r1, #78	; 0x4e
    dd08:	movs	r2, #70	; 0x46
    dd0a:	strb	r0, [r3, #0]
    dd0c:	strb	r1, [r3, #1]
    dd0e:	strb	r2, [r3, #2]
    dd10:	adds	r0, r3, #3
    dd12:	b.n	da98 <dtostrf+0x80>

	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
    dd14:	cmp	r5, #0
    dd16:	blt.n	dd4a <dtostrf+0x332>
	char *p;

	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    dd18:	movs	r3, #0
    dd1a:	b.n	dcb2 <dtostrf+0x29a>
    dd1c:	mov	r0, r4
			while (awidth) {
				*buf++ = ' ';
				awidth--;
			}
		}
		if (copysignf(1.0f, val)<0) *buf++ = '-';
    dd1e:	movs	r2, #45	; 0x2d
    dd20:	strb	r2, [r0, #0]
    dd22:	adds	r4, r0, #1
    dd24:	b.n	dcba <dtostrf+0x2a2>
	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
			while (awidth) {
    dd26:	cbz	r3, dd4a <dtostrf+0x332>
    dd28:	adds	r0, r2, r3
				*buf++ = ' ';
    dd2a:	movs	r3, #32
    dd2c:	strb.w	r3, [r4], #1
	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
			while (awidth) {
    dd30:	cmp	r4, r0
    dd32:	bne.n	dd2c <dtostrf+0x314>
				*buf++ = ' ';
				awidth--;
			}
		}
		if (copysignf(1.0f, val)<0) *buf++ = '-';
    dd34:	vmov	r3, s16
    dd38:	cmp	r3, #0
    dd3a:	blt.n	dd52 <dtostrf+0x33a>
		if (DTOA_UPPER) {
			*buf++ = 'N';  *buf++ = 'A';  *buf++ = 'N';
    dd3c:	movs	r3, #78	; 0x4e
    dd3e:	movs	r2, #65	; 0x41
    dd40:	strb	r3, [r0, #0]
    dd42:	strb	r3, [r0, #2]
    dd44:	strb	r2, [r0, #1]
    dd46:	adds	r0, #3
    dd48:	b.n	da98 <dtostrf+0x80>

	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
    dd4a:	mov	r0, r4
    dd4c:	b.n	dd34 <dtostrf+0x31c>
		return buf;
	}
	if (isinff(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
    dd4e:	mov	r3, r4
    dd50:	b.n	dac0 <dtostrf+0xa8>
			while (awidth) {
				*buf++ = ' ';
				awidth--;
			}
		}
		if (copysignf(1.0f, val)<0) *buf++ = '-';
    dd52:	movs	r3, #0
    dd54:	b.n	dd1e <dtostrf+0x306>
				awidth--;
			}
		}
		if (val<0) *buf++ = '-';
		if (DTOA_UPPER) {
			*buf++ = 'I';  *buf++ = 'N';  *buf++ = 'F';
    dd56:	mov	r0, r4
    dd58:	b.n	da98 <dtostrf+0x80>
	}

	// add 1 for sign if negative
	if (sign) reqd++;

	p = buf;
    dd5a:	mov	r3, r4
    dd5c:	b.n	db2e <dtostrf+0x116>
    dd5e:	nop
    dd60:	.word	0x7f7fffff
    dd64:	.word	0x00014798
    dd68:	.word	0x00014794

0000dd6c <digitalWrite.part.1>:



// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
    dd6c:	push	{r4}
{
	if (pin >= CORE_NUM_DIGITAL) return;
#ifdef KINETISK
	if (*portModeRegister(pin)) {
    dd6e:	ldr	r3, [pc, #68]	; (ddb4 <digitalWrite.part.1+0x48>)
    dd70:	ldr.w	r2, [r3, r0, lsl #3]
    dd74:	ldrb.w	r4, [r2, #640]	; 0x280
    dd78:	cbz	r4, dd88 <digitalWrite.part.1+0x1c>
		if (val) {
			*portSetRegister(pin) = 1;
    dd7a:	movs	r3, #1
void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
#ifdef KINETISK
	if (*portModeRegister(pin)) {
		if (val) {
    dd7c:	cbz	r1, dd9e <digitalWrite.part.1+0x32>
			*portSetRegister(pin) = 1;
    dd7e:	strb.w	r3, [r2, #128]	; 0x80
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    dd82:	ldr.w	r4, [sp], #4
    dd86:	bx	lr
		} else {
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
    dd88:	add.w	r3, r3, r0, lsl #3
    dd8c:	ldr	r3, [r3, #4]
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    dd8e:	ldr	r2, [r3, #0]
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
    dd90:	cbnz	r1, dda8 <digitalWrite.part.1+0x3c>
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
			//*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else {
			// TODO use bitband for atomic read-mod-write
			*config &= ~(PORT_PCR_PE);
    dd92:	bic.w	r2, r2, #2
    dd96:	str	r2, [r3, #0]
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    dd98:	ldr.w	r4, [sp], #4
    dd9c:	bx	lr
#ifdef KINETISK
	if (*portModeRegister(pin)) {
		if (val) {
			*portSetRegister(pin) = 1;
		} else {
			*portClearRegister(pin) = 1;
    dd9e:	strb.w	r3, [r2, #256]	; 0x100
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    dda2:	ldr.w	r4, [sp], #4
    dda6:	bx	lr
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    dda8:	orr.w	r2, r2, #3
    ddac:	str	r2, [r3, #0]
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    ddae:	ldr.w	r4, [sp], #4
    ddb2:	bx	lr
    ddb4:	.word	0x0001479c

0000ddb8 <pinMode.part.2>:
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    ddb8:	ldr	r2, [pc, #112]	; (de2c <pinMode.part.2+0x74>)
    ddba:	add.w	r3, r2, r0, lsl #3

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    ddbe:	cmp	r1, #1
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    ddc0:	ldr	r3, [r3, #4]

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    ddc2:	beq.n	dde8 <pinMode.part.2+0x30>
    ddc4:	cmp	r1, #4
    ddc6:	beq.n	de00 <pinMode.part.2+0x48>
		} else {
		    *config &= ~PORT_PCR_ODE;
                }
	} else {
#ifdef KINETISK
		*portModeRegister(pin) = 0;
    ddc8:	ldr.w	r0, [r2, r0, lsl #3]
    ddcc:	movs	r2, #0
    ddce:	strb.w	r2, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
    ddd2:	cbz	r1, dde0 <pinMode.part.2+0x28>
			*config = PORT_PCR_MUX(1);
		} else if (mode == INPUT_PULLUP) {
    ddd4:	cmp	r1, #2
    ddd6:	beq.n	de1a <pinMode.part.2+0x62>
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else if (mode == INPUT_PULLDOWN) {
    ddd8:	cmp	r1, #3
    ddda:	beq.n	de22 <pinMode.part.2+0x6a>
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
		} else {
		    *config &= ~PORT_PCR_ODE;
    dddc:	str	r2, [r3, #0]
    ddde:	bx	lr
		*portModeRegister(pin) = 0;
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
			*config = PORT_PCR_MUX(1);
    dde0:	mov.w	r2, #256	; 0x100
    dde4:	str	r2, [r3, #0]
    dde6:	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    dde8:	ldr.w	r0, [r2, r0, lsl #3]
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    ddec:	mov.w	r2, #324	; 0x144
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    ddf0:	strb.w	r1, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    ddf4:	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
		} else {
		    *config &= ~PORT_PCR_ODE;
    ddf6:	ldr	r2, [r3, #0]
    ddf8:	bic.w	r2, r2, #32
    ddfc:	str	r2, [r3, #0]
    ddfe:	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    de00:	ldr.w	r1, [r2, r0, lsl #3]
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    de04:	mov.w	r2, #324	; 0x144
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    de08:	movs	r0, #1
    de0a:	strb.w	r0, [r1, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    de0e:	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
    de10:	ldr	r2, [r3, #0]
    de12:	orr.w	r2, r2, #32
    de16:	str	r2, [r3, #0]
    de18:	bx	lr
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
			*config = PORT_PCR_MUX(1);
		} else if (mode == INPUT_PULLUP) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
    de1a:	movw	r2, #259	; 0x103
    de1e:	str	r2, [r3, #0]
    de20:	bx	lr
		} else if (mode == INPUT_PULLDOWN) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE;
    de22:	mov.w	r2, #258	; 0x102
    de26:	str	r2, [r3, #0]
    de28:	bx	lr
    de2a:	nop
    de2c:	.word	0x0001479c

0000de30 <attachInterruptVector>:
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    de30:	adds	r0, #16
    de32:	ldr	r3, [pc, #8]	; (de3c <attachInterruptVector+0xc>)
    de34:	str.w	r1, [r3, r0, lsl #2]
    de38:	bx	lr
    de3a:	nop
    de3c:	.word	0x1fff0200

0000de40 <rtc_get>:

#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)

unsigned long rtc_get(void)
{
	return RTC_TSR;
    de40:	ldr	r3, [pc, #4]	; (de48 <rtc_get+0x8>)
    de42:	ldr	r0, [r3, #0]
}
    de44:	bx	lr
    de46:	nop
    de48:	.word	0x4003d000

0000de4c <rtc_set>:

void rtc_set(unsigned long t)
{
    de4c:	push	{r4, r5}
	RTC_SR = 0;
    de4e:	ldr	r3, [pc, #20]	; (de64 <rtc_set+0x18>)
	RTC_TPR = 0;
    de50:	ldr	r5, [pc, #20]	; (de68 <rtc_set+0x1c>)
	RTC_TSR = t;
    de52:	ldr	r4, [pc, #24]	; (de6c <rtc_set+0x20>)
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    de54:	movs	r2, #0
	RTC_TPR = 0;
	RTC_TSR = t;
	RTC_SR = RTC_SR_TCE;
    de56:	movs	r1, #16
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    de58:	str	r2, [r3, #0]
	RTC_TPR = 0;
    de5a:	str	r2, [r5, #0]
	RTC_TSR = t;
    de5c:	str	r0, [r4, #0]
	RTC_SR = RTC_SR_TCE;
    de5e:	str	r1, [r3, #0]
}
    de60:	pop	{r4, r5}
    de62:	bx	lr
    de64:	.word	0x4003d014
    de68:	.word	0x4003d004
    de6c:	.word	0x4003d000

0000de70 <digitalWrite>:

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    de70:	cmp	r0, #63	; 0x3f
    de72:	bhi.n	de78 <digitalWrite+0x8>
    de74:	b.w	dd6c <digitalWrite.part.1>
    de78:	bx	lr
    de7a:	nop

0000de7c <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    de7c:	cmp	r0, #63	; 0x3f
    de7e:	bhi.n	de84 <pinMode+0x8>
    de80:	b.w	ddb8 <pinMode.part.2>
    de84:	bx	lr
    de86:	nop

0000de88 <micros>:

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    de88:	cpsid	i
	current = SYST_CVR;
	count = systick_millis_count;
    de8a:	ldr	r1, [pc, #48]	; (debc <micros+0x34>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    de8c:	ldr	r3, [pc, #48]	; (dec0 <micros+0x38>)
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    de8e:	ldr	r2, [pc, #52]	; (dec4 <micros+0x3c>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    de90:	ldr	r3, [r3, #0]
	count = systick_millis_count;
    de92:	ldr	r0, [r1, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    de94:	ldr	r2, [r2, #0]
	__enable_irq();
    de96:	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    de98:	lsls	r2, r2, #5
    de9a:	bpl.n	dea2 <micros+0x1a>
    de9c:	cmp	r3, #50	; 0x32
    de9e:	it	hi
    dea0:	addhi	r0, #1
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    dea2:	ldr	r1, [pc, #36]	; (dec8 <micros+0x40>)
    dea4:	rsb	r3, r3, #95744	; 0x17600
    dea8:	mov.w	r2, #1000	; 0x3e8
    deac:	adds	r3, #255	; 0xff
    deae:	umull	r1, r3, r1, r3
    deb2:	mul.w	r0, r2, r0
}
    deb6:	add.w	r0, r0, r3, lsr #6
    deba:	bx	lr
    debc:	.word	0x1fff66b0
    dec0:	.word	0xe000e018
    dec4:	.word	0xe000ed04
    dec8:	.word	0xaaaaaaab

0000decc <delay>:

void delay(uint32_t ms)
{
    decc:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    ded0:	mov	r5, r0

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    ded2:	cpsid	i
	current = SYST_CVR;
	count = systick_millis_count;
    ded4:	ldr	r7, [pc, #128]	; (df58 <delay+0x8c>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    ded6:	ldr	r3, [pc, #132]	; (df5c <delay+0x90>)
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    ded8:	ldr	r2, [pc, #132]	; (df60 <delay+0x94>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    deda:	ldr	r3, [r3, #0]
	count = systick_millis_count;
    dedc:	ldr	r4, [r7, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    dede:	ldr	r2, [r2, #0]
	__enable_irq();
    dee0:	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    dee2:	lsls	r2, r2, #5
    dee4:	bpl.n	deec <delay+0x20>
    dee6:	cmp	r3, #50	; 0x32
    dee8:	it	hi
    deea:	addhi	r4, #1

void delay(uint32_t ms)
{
	uint32_t start = micros();

	if (ms > 0) {
    deec:	cbz	r5, df54 <delay+0x88>
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    deee:	rsb	r3, r3, #95744	; 0x17600
    def2:	ldr	r6, [pc, #112]	; (df64 <delay+0x98>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    def4:	ldr.w	r9, [pc, #100]	; df5c <delay+0x90>
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    def8:	ldr.w	r8, [pc, #100]	; df60 <delay+0x94>
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    defc:	adds	r3, #255	; 0xff
    defe:	mov.w	r2, #1000	; 0x3e8
    df02:	umull	r1, r3, r6, r3
    df06:	mul.w	r4, r2, r4
    df0a:	add.w	r4, r4, r3, lsr #6

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    df0e:	cpsid	i
	current = SYST_CVR;
    df10:	ldr.w	r1, [r9]
	count = systick_millis_count;
    df14:	ldr	r2, [r7, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    df16:	ldr.w	lr, [r8]
	__enable_irq();
    df1a:	cpsie	i
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    df1c:	rsb	r3, r1, #95744	; 0x17600
    df20:	adds	r3, #255	; 0xff
    df22:	umull	r0, r3, r6, r3
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    df26:	tst.w	lr, #67108864	; 0x4000000
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    df2a:	rsb	r3, r4, r3, lsr #6
    df2e:	mov.w	r0, #1000	; 0x3e8
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    df32:	beq.n	df3a <delay+0x6e>
    df34:	cmp	r1, #50	; 0x32
    df36:	it	hi
    df38:	addhi	r2, #1
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    df3a:	mla	r3, r0, r2, r3
    df3e:	cmp.w	r3, #1000	; 0x3e8
    df42:	bcc.n	df4e <delay+0x82>
				ms--;
				if (ms == 0) return;
    df44:	subs	r5, #1
    df46:	beq.n	df54 <delay+0x88>
				start += 1000;
    df48:	add.w	r4, r4, #1000	; 0x3e8
    df4c:	b.n	df0e <delay+0x42>
			}
			yield();
    df4e:	bl	ebc4 <yield>
		}
    df52:	b.n	df0e <delay+0x42>
    df54:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    df58:	.word	0x1fff66b0
    df5c:	.word	0xe000e018
    df60:	.word	0xe000ed04
    df64:	.word	0xaaaaaaab

0000df68 <_init_Teensyduino_internal_>:
#endif

//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
    df68:	push	{r3, r4, r5, r6, r7, lr}
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    df6a:	ldr	r3, [pc, #248]	; (e064 <_init_Teensyduino_internal_+0xfc>)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    df6c:	ldr	r1, [pc, #248]	; (e068 <_init_Teensyduino_internal_+0x100>)
	FTM0_MOD = DEFAULT_FTM_MOD;
    df6e:	ldr.w	ip, [pc, #280]	; e088 <_init_Teensyduino_internal_+0x120>
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
    df72:	ldr	r6, [pc, #248]	; (e06c <_init_Teensyduino_internal_+0x104>)
	FTM0_C2SC = 0x28;
    df74:	ldr	r2, [pc, #248]	; (e070 <_init_Teensyduino_internal_+0x108>)
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    df76:	ldr.w	lr, [pc, #276]	; e08c <_init_Teensyduino_internal_+0x124>
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
    df7a:	ldr	r5, [pc, #248]	; (e074 <_init_Teensyduino_internal_+0x10c>)
	FTM0_C4SC = 0x28;
    df7c:	ldr	r4, [pc, #248]	; (e078 <_init_Teensyduino_internal_+0x110>)
	FTM0_C5SC = 0x28;
    df7e:	ldr	r7, [pc, #252]	; (e07c <_init_Teensyduino_internal_+0x114>)
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    df80:	mov.w	r0, #134217728	; 0x8000000
    df84:	str	r0, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTB);
    df86:	mov.w	r0, #268435456	; 0x10000000
    df8a:	str	r0, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTC);
    df8c:	mov.w	r0, #536870912	; 0x20000000
    df90:	str	r0, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTD);
    df92:	mov.w	r0, #1073741824	; 0x40000000
    df96:	str	r0, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTE);
    df98:	mov.w	r0, #2147483648	; 0x80000000
    df9c:	str	r0, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    df9e:	movs	r0, #0
    dfa0:	str	r0, [r1, #0]
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    dfa2:	movs	r3, #40	; 0x28
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
    dfa4:	movw	r1, #49151	; 0xbfff
    dfa8:	str.w	r1, [ip]
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    dfac:	str.w	r3, [lr]
	FTM0_C1SC = 0x28;
    dfb0:	str	r3, [r6, #0]
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
    dfb2:	add.w	lr, lr, #528384	; 0x81000
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
    dfb6:	str	r3, [r2, #0]
	FTM0_C3SC = 0x28;
    dfb8:	str	r3, [r5, #0]
	FTM0_C4SC = 0x28;
    dfba:	str	r3, [r4, #0]
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    dfbc:	add.w	r5, r5, #524288	; 0x80000
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
    dfc0:	str	r3, [r7, #0]
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
    dfc2:	add.w	r4, r4, #524288	; 0x80000
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
    dfc6:	str	r3, [r6, #40]	; 0x28
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
    dfc8:	add.w	r7, r7, #524288	; 0x80000
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
    dfcc:	str	r3, [r2, #40]	; 0x28
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
    dfce:	add.w	r6, r6, #528384	; 0x81000
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
    dfd2:	add.w	r2, r2, #528384	; 0x81000
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
    dfd6:	add.w	lr, lr, #16
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    dfda:	addw	r5, r5, #4072	; 0xfe8
	FTM3_C1SC = 0x28;
    dfde:	addw	r4, r4, #4072	; 0xfe8
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
    dfe2:	add.w	r7, r7, #4080	; 0xff0
	FTM3_C4SC = 0x28;
    dfe6:	adds	r2, #16
	FTM3_C5SC = 0x28;
    dfe8:	adds	r6, #32
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    dfea:	str	r3, [r5, #0]
	FTM3_C1SC = 0x28;
    dfec:	str	r3, [r4, #0]
	FTM3_C2SC = 0x28;
    dfee:	str.w	r3, [lr]
	FTM3_C3SC = 0x28;
    dff2:	str	r3, [r7, #0]
	FTM3_C4SC = 0x28;
    dff4:	str	r3, [r2, #0]
	FTM3_C5SC = 0x28;
    dff6:	str	r3, [r6, #0]
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    dff8:	ldr	r6, [pc, #132]	; (e080 <_init_Teensyduino_internal_+0x118>)
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
    dffa:	str	r3, [r7, #24]
	FTM3_C7SC = 0x28;
    dffc:	str	r3, [r2, #24]
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    dffe:	movs	r2, #9
    e000:	str	r2, [r6, #0]
	FTM1_CNT = 0;
    e002:	sub.w	r7, r7, #524288	; 0x80000
	FTM1_MOD = DEFAULT_FTM_MOD;
    e006:	add.w	r6, r6, #4096	; 0x1000
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
	FTM1_CNT = 0;
    e00a:	subs	r7, #32
	FTM1_MOD = DEFAULT_FTM_MOD;
    e00c:	adds	r6, #8
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
	FTM1_CNT = 0;
    e00e:	str	r0, [r7, #0]
	FTM1_MOD = DEFAULT_FTM_MOD;
    e010:	str	r1, [r6, #0]
	FTM1_C0SC = 0x28;
    e012:	str	r3, [r7, #8]
	FTM1_C1SC = 0x28;
    e014:	str	r3, [r6, #12]
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    e016:	str.w	r2, [r7, #-4]
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    e01a:	add.w	r6, r6, #518144	; 0x7e800
	FTM2_MOD = DEFAULT_FTM_MOD;
    e01e:	add.w	r7, r7, #520192	; 0x7f000
	FTM1_MOD = DEFAULT_FTM_MOD;
	FTM1_C0SC = 0x28;
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    e022:	addw	r6, r6, #2044	; 0x7fc
	FTM2_MOD = DEFAULT_FTM_MOD;
    e026:	adds	r7, #4
	FTM1_MOD = DEFAULT_FTM_MOD;
	FTM1_C0SC = 0x28;
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    e028:	str	r0, [r6, #0]
	FTM2_MOD = DEFAULT_FTM_MOD;
    e02a:	str	r1, [r7, #0]
	FTM2_C0SC = 0x28;
    e02c:	str	r3, [r6, #8]
	FTM2_C1SC = 0x28;
    e02e:	str	r3, [r7, #12]
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    e030:	str.w	r2, [r6, #-4]
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
	FTM2_MOD = DEFAULT_FTM_MOD;
	FTM2_C0SC = 0x28;
    e034:	adds	r6, #8
	FTM2_C1SC = 0x28;
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
    e036:	str.w	r0, [r7, #4092]	; 0xffc
	FTM3_MOD = DEFAULT_FTM_MOD;
    e03a:	addw	r6, r6, #4092	; 0xffc
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    e03e:	ldr	r0, [pc, #68]	; (e084 <_init_Teensyduino_internal_+0x11c>)
	FTM2_C1SC = 0x28;
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
	FTM3_MOD = DEFAULT_FTM_MOD;
    e040:	str	r1, [r6, #0]
	FTM3_C0SC = 0x28;
    e042:	str	r3, [r5, #0]
	FTM3_C1SC = 0x28;
    e044:	str	r3, [r4, #0]
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    e046:	str	r2, [r0, #0]
	TPM1_MOD = 32767;
	TPM1_C0SC = 0x28;
	TPM1_C1SC = 0x28;
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
#endif
	analog_init();
    e048:	bl	f000 <analog_init>

	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	delay(TEENSY_INIT_USB_DELAY_BEFORE);
    e04c:	movs	r0, #25
    e04e:	bl	decc <delay>
	usb_init();
    e052:	bl	eb00 <usb_init>
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    e056:	movw	r0, #275	; 0x113
}
    e05a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	delay(TEENSY_INIT_USB_DELAY_BEFORE);
	usb_init();
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    e05e:	b.w	decc <delay>
    e062:	nop
    e064:	.word	0xe000e104
    e068:	.word	0x40038004
    e06c:	.word	0x40038014
    e070:	.word	0x4003801c
    e074:	.word	0x40038024
    e078:	.word	0x4003802c
    e07c:	.word	0x40038034
    e080:	.word	0x40038000
    e084:	.word	0x400b9000
    e088:	.word	0x40038008
    e08c:	.word	0x4003800c

0000e090 <usb_malloc>:
usb_packet_t * usb_malloc(void)
{
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    e090:	cpsid	i
	avail = usb_buffer_available;
    e092:	ldr	r0, [pc, #52]	; (e0c8 <usb_malloc+0x38>)
    e094:	ldr	r2, [r0, #0]
	n = __builtin_clz(avail); // clz = count leading zeros
    e096:	clz	r3, r2
	if (n >= NUM_USB_BUFFERS) {
    e09a:	cmp	r3, #19
    e09c:	bgt.n	e0c0 <usb_malloc+0x30>
	}
	//serial_print("malloc:");
	//serial_phex(n);
	//serial_print("\n");

	usb_buffer_available = avail & ~(0x80000000 >> n);
    e09e:	mov.w	r1, #2147483648	; 0x80000000
    e0a2:	lsrs	r1, r3
    e0a4:	bic.w	r2, r2, r1
    e0a8:	str	r2, [r0, #0]
	__enable_irq();
    e0aa:	cpsie	i
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
    e0ac:	ldr	r0, [pc, #28]	; (e0cc <usb_malloc+0x3c>)
    e0ae:	add.w	r3, r3, r3, lsl #3
    e0b2:	lsls	r3, r3, #3
    e0b4:	adds	r2, r0, r3
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
    e0b6:	movs	r1, #0
    e0b8:	str	r1, [r0, r3]
	*(uint32_t *)(p + 4) = 0;
	return (usb_packet_t *)p;
    e0ba:	mov	r0, r2
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
	*(uint32_t *)(p + 4) = 0;
    e0bc:	str	r1, [r2, #4]
	return (usb_packet_t *)p;
}
    e0be:	bx	lr

	__disable_irq();
	avail = usb_buffer_available;
	n = __builtin_clz(avail); // clz = count leading zeros
	if (n >= NUM_USB_BUFFERS) {
		__enable_irq();
    e0c0:	cpsie	i
		return NULL;
    e0c2:	movs	r0, #0
    e0c4:	bx	lr
    e0c6:	nop
    e0c8:	.word	0x1fff0ac8
    e0cc:	.word	0x1fff0398

0000e0d0 <usb_free>:
void usb_free(usb_packet_t *p)
{
	unsigned int n, mask;

	//serial_print("free:");
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    e0d0:	ldr	r3, [pc, #52]	; (e108 <usb_free+0x38>)
    e0d2:	ldr	r2, [pc, #56]	; (e10c <usb_free+0x3c>)
    e0d4:	subs	r3, r0, r3
    e0d6:	umull	r2, r3, r2, r3
    e0da:	lsrs	r3, r3, #4
	if (n >= NUM_USB_BUFFERS) return;
    e0dc:	cmp	r3, #19
    e0de:	bhi.n	e0fa <usb_free+0x2a>
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    e0e0:	ldr	r2, [pc, #44]	; (e110 <usb_free+0x40>)
    e0e2:	ldrb	r2, [r2, #0]
    e0e4:	cbnz	r2, e0fc <usb_free+0x2c>
		usb_rx_memory(p);
		return;
	}

	mask = (0x80000000 >> n);
	__disable_irq();
    e0e6:	cpsid	i
	usb_buffer_available |= mask;
    e0e8:	ldr	r0, [pc, #40]	; (e114 <usb_free+0x44>)
    e0ea:	mov.w	r1, #2147483648	; 0x80000000
    e0ee:	ldr	r2, [r0, #0]
    e0f0:	lsr.w	r3, r1, r3
    e0f4:	orrs	r2, r3
    e0f6:	str	r2, [r0, #0]
	__enable_irq();
    e0f8:	cpsie	i
    e0fa:	bx	lr
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    e0fc:	ldr	r2, [pc, #24]	; (e118 <usb_free+0x48>)
    e0fe:	ldrb	r2, [r2, #0]
    e100:	cmp	r2, #0
    e102:	beq.n	e0e6 <usb_free+0x16>
		//serial_print("give to rx:");
		//serial_phex32((int)p);
		//serial_print("\n");
		usb_rx_memory(p);
    e104:	b.w	e184 <usb_rx_memory>
    e108:	.word	0x1fff0398
    e10c:	.word	0x38e38e39
    e110:	.word	0x1fff67a9
    e114:	.word	0x1fff0ac8
    e118:	.word	0x1fff67b4

0000e11c <usb_rx>:


usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
    e11c:	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    e11e:	cmp	r3, #5
    e120:	bhi.n	e14c <usb_rx+0x30>
	__disable_irq();
    e122:	cpsid	i
	ret = rx_first[endpoint];
    e124:	ldr	r1, [pc, #40]	; (e150 <usb_rx+0x34>)
    e126:	ldr.w	r0, [r1, r3, lsl #2]
	if (ret) {
    e12a:	cbz	r0, e148 <usb_rx+0x2c>




usb_packet_t *usb_rx(uint32_t endpoint)
{
    e12c:	push	{r4, r5, r6}
	if (endpoint >= NUM_ENDPOINTS) return NULL;
	__disable_irq();
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
		usb_rx_byte_count_data[endpoint] -= ret->len;
    e12e:	ldr	r4, [pc, #36]	; (e154 <usb_rx+0x38>)
    e130:	ldrh	r5, [r0, #0]
    e132:	ldrh.w	r2, [r4, r3, lsl #1]
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
	__disable_irq();
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
    e136:	ldr	r6, [r0, #4]
    e138:	str.w	r6, [r1, r3, lsl #2]
		usb_rx_byte_count_data[endpoint] -= ret->len;
    e13c:	subs	r2, r2, r5
    e13e:	strh.w	r2, [r4, r3, lsl #1]
	}
	__enable_irq();
    e142:	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    e144:	pop	{r4, r5, r6}
    e146:	bx	lr
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
		usb_rx_byte_count_data[endpoint] -= ret->len;
	}
	__enable_irq();
    e148:	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    e14a:	bx	lr

usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    e14c:	movs	r0, #0
    e14e:	bx	lr
    e150:	.word	0x1fff6714
    e154:	.word	0x1fff6834

0000e158 <usb_tx_packet_count>:
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
    e158:	subs	r0, #1
	if (endpoint >= NUM_ENDPOINTS) return 0;
    e15a:	cmp	r0, #5
    e15c:	bhi.n	e176 <usb_tx_packet_count+0x1e>
	__disable_irq();
    e15e:	cpsid	i
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    e160:	ldr	r3, [pc, #28]	; (e180 <usb_tx_packet_count+0x28>)
    e162:	ldr.w	r3, [r3, r0, lsl #2]
    e166:	cbz	r3, e17a <usb_tx_packet_count+0x22>
    e168:	movs	r0, #0
    e16a:	ldr	r3, [r3, #4]
    e16c:	adds	r0, #1
    e16e:	cmp	r3, #0
    e170:	bne.n	e16a <usb_tx_packet_count+0x12>
	__enable_irq();
    e172:	cpsie	i
	return count;
    e174:	bx	lr
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return 0;
    e176:	movs	r0, #0
	__disable_irq();
	for (p = tx_first[endpoint]; p; p = p->next) count++;
	__enable_irq();
	return count;
}
    e178:	bx	lr
// https://forum.pjrc.com/threads/58663?p=223513&viewfull=1#post223513
//
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;
    e17a:	mov	r0, r3
    e17c:	b.n	e172 <usb_tx_packet_count+0x1a>
    e17e:	nop
    e180:	.word	0x1fff6770

0000e184 <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory(usb_packet_t *packet)
{
    e184:	push	{r4, r5, r6, r7}
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    e186:	cpsid	i
void usb_rx_memory(usb_packet_t *packet)
{
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
    e188:	ldr	r1, [pc, #104]	; (e1f4 <usb_rx_memory+0x70>)
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
    e18a:	ldr	r6, [pc, #108]	; (e1f8 <usb_rx_memory+0x74>)
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    e18c:	movs	r3, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    e18e:	ldrb.w	r4, [r1], #1
			if (table[index(i, RX, EVEN)].desc == 0) {
    e192:	ldr	r7, [pc, #100]	; (e1f8 <usb_rx_memory+0x74>)
    e194:	lsls	r2, r3, #2
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    e196:	lsls	r4, r4, #28
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    e198:	orr.w	r5, r2, #1
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    e19c:	bpl.n	e1aa <usb_rx_memory+0x26>
			if (table[index(i, RX, EVEN)].desc == 0) {
    e19e:	ldr.w	r4, [r6, r2, lsl #3]
    e1a2:	cbz	r4, e1be <usb_rx_memory+0x3a>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    e1a4:	ldr.w	r2, [r6, r5, lsl #3]
    e1a8:	cbz	r2, e1da <usb_rx_memory+0x56>
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    e1aa:	adds	r3, #1
    e1ac:	cmp	r3, #7
    e1ae:	bne.n	e18e <usb_rx_memory+0xa>
				//serial_print(",odd\n");
				return;
			}
		}
	}
	__enable_irq();
    e1b0:	cpsie	i
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
    e1b2:	ldr	r3, [pc, #72]	; (e1fc <usb_rx_memory+0x78>)
    e1b4:	movs	r2, #0
    e1b6:	strb	r2, [r3, #0]
	usb_free(packet);
	return;
}
    e1b8:	pop	{r4, r5, r6, r7}
	__enable_irq();
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
    e1ba:	b.w	e0d0 <usb_free>
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    e1be:	ldr	r4, [pc, #60]	; (e1fc <usb_rx_memory+0x78>)
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    e1c0:	ldr	r5, [pc, #60]	; (e200 <usb_rx_memory+0x7c>)
				usb_rx_memory_needed--;
    e1c2:	ldrb	r1, [r4, #0]
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
    e1c4:	add.w	r3, r7, r3, lsl #5
    e1c8:	adds	r0, #8
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    e1ca:	subs	r1, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
    e1cc:	str	r0, [r3, #4]
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    e1ce:	strb	r1, [r4, #0]
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    e1d0:	str.w	r5, [r7, r2, lsl #3]
				usb_rx_memory_needed--;
				__enable_irq();
    e1d4:	cpsie	i
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
	return;
}
    e1d6:	pop	{r4, r5, r6, r7}
    e1d8:	bx	lr
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    e1da:	ldr	r2, [pc, #32]	; (e1fc <usb_rx_memory+0x78>)
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    e1dc:	ldr	r1, [pc, #36]	; (e204 <usb_rx_memory+0x80>)
				usb_rx_memory_needed--;
    e1de:	ldrb	r3, [r2, #0]
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
    e1e0:	add.w	r4, r7, r5, lsl #3
    e1e4:	adds	r0, #8
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    e1e6:	subs	r3, #1
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
    e1e8:	str	r0, [r4, #4]
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    e1ea:	strb	r3, [r2, #0]
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    e1ec:	str.w	r1, [r7, r5, lsl #3]
				usb_rx_memory_needed--;
				__enable_irq();
    e1f0:	cpsie	i
				//serial_phex(i);
				//serial_print(",odd\n");
				return;
    e1f2:	b.n	e1d6 <usb_rx_memory+0x52>
    e1f4:	.word	0x0001472c
    e1f8:	.word	0x1fff0000
    e1fc:	.word	0x1fff67a9
    e200:	.word	0x00400088
    e204:	.word	0x004000c8

0000e208 <usb_tx>:
void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
    e208:	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return;
    e20a:	cmp	r3, #5
    e20c:	bhi.n	e24a <usb_tx+0x42>
//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    e20e:	ldr	r2, [pc, #108]	; (e27c <usb_tx+0x74>)
    e210:	lsls	r0, r0, #5
    e212:	orr.w	r0, r0, #16

//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
    e216:	push	{r4, r5}
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    e218:	add	r0, r2
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
	__disable_irq();
    e21a:	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
    e21c:	ldr	r4, [pc, #96]	; (e280 <usb_tx+0x78>)
    e21e:	ldrb	r2, [r4, r3]
    e220:	cmp	r2, #3
    e222:	bhi.n	e25c <usb_tx+0x54>
    e224:	tbb	[pc, r2]
    e228:	.word	0x17151202
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
    e22c:	movs	r2, #3
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    e22e:	ldrh	r5, [r1, #0]
		}
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
    e230:	strb	r2, [r4, r3]
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    e232:	tst.w	r0, #8
    e236:	ite	ne
    e238:	movne	r3, #200	; 0xc8
    e23a:	moveq	r3, #136	; 0x88
    e23c:	orr.w	r3, r3, r5, lsl #16
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    e240:	adds	r1, #8
    e242:	str	r1, [r0, #4]
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    e244:	str	r3, [r0, #0]
	__enable_irq();
    e246:	cpsie	i
}
    e248:	pop	{r4, r5}
    e24a:	bx	lr
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
		break;
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
    e24c:	adds	r0, #8
		next = TX_STATE_EVEN_FREE;
    e24e:	movs	r2, #2
		break;
    e250:	b.n	e22e <usb_tx+0x26>
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
    e252:	movs	r2, #5
    e254:	b.n	e22e <usb_tx+0x26>
		break;
	  case TX_STATE_ODD_FREE:
		b++;
    e256:	adds	r0, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    e258:	movs	r2, #4
		break;
    e25a:	b.n	e22e <usb_tx+0x26>
	  default:
		if (tx_first[endpoint] == NULL) {
    e25c:	ldr	r2, [pc, #36]	; (e284 <usb_tx+0x7c>)
    e25e:	ldr.w	r0, [r2, r3, lsl #2]
    e262:	cbz	r0, e274 <usb_tx+0x6c>
			tx_first[endpoint] = packet;
		} else {
			tx_last[endpoint]->next = packet;
    e264:	ldr	r2, [pc, #32]	; (e288 <usb_tx+0x80>)
    e266:	ldr.w	r0, [r2, r3, lsl #2]
    e26a:	str	r1, [r0, #4]
		}
		tx_last[endpoint] = packet;
    e26c:	str.w	r1, [r2, r3, lsl #2]
		__enable_irq();
    e270:	cpsie	i
		return;
    e272:	b.n	e248 <usb_tx+0x40>
		b++;
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
		break;
	  default:
		if (tx_first[endpoint] == NULL) {
			tx_first[endpoint] = packet;
    e274:	str.w	r1, [r2, r3, lsl #2]
    e278:	ldr	r2, [pc, #12]	; (e288 <usb_tx+0x80>)
    e27a:	b.n	e26c <usb_tx+0x64>
    e27c:	.word	0x1fff0000
    e280:	.word	0x1fff67b8
    e284:	.word	0x1fff6770
    e288:	.word	0x1fff6788

0000e28c <usb_isr>:
}



void usb_isr(void)
{
    e28c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    e290:	ldr.w	fp, [pc, #788]	; e5a8 <usb_isr+0x31c>
		USB0_ISTAT = USB_ISTAT_SOFTOK;
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
		uint8_t endpoint;
		stat = USB0_STAT;
    e294:	ldr.w	sl, [pc, #788]	; e5ac <usb_isr+0x320>
}



void usb_isr(void)
{
    e298:	sub	sp, #28
    e29a:	b.n	e326 <usb_isr+0x9a>
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
    e29c:	ldr	r7, [pc, #700]	; (e55c <usb_isr+0x2d0>)
    e29e:	mov.w	r8, r3, lsr #2
    e2a2:	add.w	r9, r7, r8, lsl #3
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    e2a6:	subs	r6, #1
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    e2a8:	ldr.w	r2, [r9, #4]
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    e2ac:	and.w	r3, r3, #8
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    e2b0:	uxtb	r6, r6
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    e2b2:	sub.w	r0, r2, #8
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    e2b6:	and.w	r4, r3, #255	; 0xff
    e2ba:	cmp	r3, #0
    e2bc:	bne.w	e5b0 <usb_isr+0x324>
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
    e2c0:	ldr.w	r3, [r7, r8, lsl #3]
    e2c4:	lsrs	r3, r3, #16
    e2c6:	uxth	r1, r3
    e2c8:	strh.w	r1, [r2, #-8]
				if (packet->len > 0) {
    e2cc:	cmp	r3, #0
    e2ce:	beq.w	e548 <usb_isr+0x2bc>
					packet->index = 0;
					packet->next = NULL;
					if (rx_first[endpoint] == NULL) {
    e2d2:	ldr	r3, [pc, #652]	; (e560 <usb_isr+0x2d4>)
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
				if (packet->len > 0) {
					packet->index = 0;
    e2d4:	strh.w	r4, [r2, #-6]
					packet->next = NULL;
    e2d8:	str.w	r4, [r2, #-4]
					if (rx_first[endpoint] == NULL) {
    e2dc:	ldr.w	r2, [r3, r6, lsl #2]
    e2e0:	cmp	r2, #0
    e2e2:	beq.w	e64c <usb_isr+0x3c0>
						//serial_print("rx Nth, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
    e2e6:	ldr	r5, [pc, #636]	; (e564 <usb_isr+0x2d8>)
    e2e8:	ldr.w	r3, [r5, r6, lsl #2]
    e2ec:	str	r0, [r3, #4]
					}
					rx_last[endpoint] = packet;
					usb_rx_byte_count_data[endpoint] += packet->len;
    e2ee:	ldr	r4, [pc, #632]	; (e568 <usb_isr+0x2dc>)
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
					}
					rx_last[endpoint] = packet;
    e2f0:	str.w	r0, [r5, r6, lsl #2]
					usb_rx_byte_count_data[endpoint] += packet->len;
    e2f4:	ldrh.w	r3, [r4, r6, lsl #1]
    e2f8:	add	r1, r3
    e2fa:	strh.w	r1, [r4, r6, lsl #1]
					// TODO: implement a per-endpoint maximum # of allocated
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
    e2fe:	bl	e090 <usb_malloc>
					if (packet) {
    e302:	cmp	r0, #0
    e304:	beq.w	e63e <usb_isr+0x3b2>
						b->addr = packet->buf;
						b->desc = BDT_DESC(64,
    e308:	ldr	r2, [pc, #608]	; (e56c <usb_isr+0x2e0>)
    e30a:	ldr	r3, [pc, #612]	; (e570 <usb_isr+0x2e4>)
    e30c:	tst.w	r9, #8
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
					if (packet) {
						b->addr = packet->buf;
    e310:	add.w	r0, r0, #8
						b->desc = BDT_DESC(64,
    e314:	it	ne
    e316:	movne	r3, r2
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
					if (packet) {
						b->addr = packet->buf;
    e318:	str.w	r0, [r9, #4]
						b->desc = BDT_DESC(64,
    e31c:	str.w	r3, [r7, r8, lsl #3]
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
				}
			}

		}
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    e320:	movs	r3, #8
    e322:	strb.w	r3, [fp]
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    e326:	ldrb.w	r4, [fp]
    e32a:	uxtb	r4, r4

	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
    e32c:	lsls	r0, r4, #29
    e32e:	bpl.n	e368 <usb_isr+0xdc>
		if (usb_configuration) {
    e330:	ldr	r3, [pc, #576]	; (e574 <usb_isr+0x2e8>)
    e332:	ldrb	r3, [r3, #0]
    e334:	cbz	r3, e362 <usb_isr+0xd6>
			t = usb_reboot_timer;
    e336:	ldr	r1, [pc, #576]	; (e578 <usb_isr+0x2ec>)
    e338:	ldrb	r2, [r1, #0]
			if (t) {
    e33a:	and.w	r3, r2, #255	; 0xff
    e33e:	cbz	r2, e34c <usb_isr+0xc0>
				usb_reboot_timer = --t;
    e340:	subs	r3, #1
    e342:	uxtb	r3, r3
    e344:	strb	r3, [r1, #0]
				if (!t) _reboot_Teensyduino_();
    e346:	cmp	r3, #0
    e348:	beq.w	eac8 <usb_isr+0x83c>
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
    e34c:	ldr	r1, [pc, #556]	; (e57c <usb_isr+0x2f0>)
    e34e:	ldrb	r2, [r1, #0]
			if (t) {
    e350:	and.w	r3, r2, #255	; 0xff
    e354:	cbz	r2, e362 <usb_isr+0xd6>
				usb_cdc_transmit_flush_timer = --t;
    e356:	subs	r3, #1
    e358:	uxtb	r3, r3
    e35a:	strb	r3, [r1, #0]
				if (t == 0) usb_serial_flush_callback();
    e35c:	cmp	r3, #0
    e35e:	beq.w	e638 <usb_isr+0x3ac>
#endif
#ifdef MULTITOUCH_INTERFACE
			usb_touchscreen_update_callback();
#endif
		}
		USB0_ISTAT = USB_ISTAT_SOFTOK;
    e362:	movs	r3, #4
    e364:	strb.w	r3, [fp]
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
    e368:	and.w	r3, r4, #8
    e36c:	and.w	r2, r3, #255	; 0xff
    e370:	cmp	r3, #0
    e372:	beq.w	e60a <usb_isr+0x37e>
		uint8_t endpoint;
		stat = USB0_STAT;
    e376:	ldrb.w	r3, [sl]
    e37a:	uxtb	r3, r3
		//serial_print("token: ep=");
		//serial_phex(stat >> 4);
		//serial_print(stat & 0x08 ? ",tx" : ",rx");
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
    e37c:	lsrs	r6, r3, #4
    e37e:	bne.n	e29c <usb_isr+0x10>
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    e380:	lsrs	r0, r3, #2
    e382:	ldr	r7, [pc, #472]	; (e55c <usb_isr+0x2d0>)
	pid = BDT_PID(b->desc);
    e384:	ldr.w	r2, [r7, r0, lsl #3]
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    e388:	add.w	r1, r7, r0, lsl #3
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    e38c:	ubfx	r2, r2, #2, #4
    e390:	subs	r2, #1
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
	pid = BDT_PID(b->desc);
	//count = b->desc >> 16;
	buf = b->addr;
    e392:	ldr	r1, [r1, #4]
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    e394:	cmp	r2, #12
    e396:	bhi.w	e52a <usb_isr+0x29e>
    e39a:	tbh	[pc, r2, lsl #1]
    e39e:	.short	0x00ca
    e3a0:	.word	0x00c600ca
    e3a4:	.word	0x00c600c6
    e3a8:	.word	0x00c600c6
    e3ac:	.word	0x008b00c6
    e3b0:	.word	0x00c600c6
    e3b4:	.word	0x000d00c6
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    e3b8:	ldr	r2, [r1, #0]
    e3ba:	ldr	r5, [pc, #452]	; (e580 <usb_isr+0x2f4>)
		setup.word2 = *(uint32_t *)(buf + 4);
    e3bc:	ldr	r1, [r1, #4]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    e3be:	ldr	r3, [pc, #452]	; (e584 <usb_isr+0x2f8>)
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    e3c0:	ldr	r6, [pc, #452]	; (e588 <usb_isr+0x2fc>)
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    e3c2:	ldr	r4, [pc, #424]	; (e56c <usb_isr+0x2e0>)
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);
    e3c4:	str	r1, [r5, #4]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    e3c6:	uxth	r1, r2
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    e3c8:	str.w	r4, [r7, r0, lsl #3]
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    e3cc:	str	r2, [r5, #0]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    e3ce:	movs	r0, #1
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    e3d0:	movs	r2, #0
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    e3d2:	cmp.w	r1, #2176	; 0x880
			//serial_print("leftover tx even\n");
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
    e3d6:	str	r2, [r7, #16]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    e3d8:	str	r3, [sp, #4]
    e3da:	str	r2, [r3, #0]
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
    e3dc:	str	r2, [r7, #24]
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    e3de:	strb	r0, [r6, #0]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    e3e0:	beq.w	ea40 <usb_isr+0x7b4>
    e3e4:	bls.w	e654 <usb_isr+0x3c8>
    e3e8:	movw	r4, #8993	; 0x2321
    e3ec:	cmp	r1, r4
    e3ee:	beq.w	ea4a <usb_isr+0x7be>
    e3f2:	bhi.w	e780 <usb_isr+0x4f4>
    e3f6:	movw	r4, #8225	; 0x2021
    e3fa:	cmp	r1, r4
    e3fc:	beq.w	e796 <usb_isr+0x50a>
    e400:	movw	r4, #8737	; 0x2221
    e404:	cmp	r1, r4
    e406:	beq.w	e8e8 <usb_isr+0x65c>
    e40a:	cmp.w	r1, #2304	; 0x900
    e40e:	bne.w	e790 <usb_isr+0x504>
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
    e412:	ldr	r2, [pc, #352]	; (e574 <usb_isr+0x2e8>)
    e414:	ldrb	r1, [r5, #2]
    e416:	strb	r1, [r2, #0]
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
			if (table[i].desc & BDT_OWN) {
    e418:	ldr	r5, [pc, #320]	; (e55c <usb_isr+0x2d0>)
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    e41a:	movs	r4, #4
    e41c:	b.n	e424 <usb_isr+0x198>
    e41e:	adds	r4, #1
    e420:	cmp	r4, #28
    e422:	beq.n	e43e <usb_isr+0x1b2>
			if (table[i].desc & BDT_OWN) {
    e424:	ldr.w	r3, [r7, r4, lsl #3]
    e428:	lsls	r1, r3, #24
    e42a:	bpl.n	e41e <usb_isr+0x192>
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    e42c:	add.w	r3, r5, r4, lsl #3
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    e430:	adds	r4, #1
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    e432:	ldr	r0, [r3, #4]
    e434:	subs	r0, #8
    e436:	bl	e0d0 <usb_free>
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    e43a:	cmp	r4, #28
    e43c:	bne.n	e424 <usb_isr+0x198>
    e43e:	ldr	r3, [pc, #288]	; (e560 <usb_isr+0x2d4>)
    e440:	ldr	r2, [pc, #328]	; (e58c <usb_isr+0x300>)
    e442:	ldr	r1, [pc, #332]	; (e590 <usb_isr+0x304>)
    e444:	ldr	r5, [pc, #284]	; (e564 <usb_isr+0x2d8>)
    e446:	ldr	r4, [pc, #288]	; (e568 <usb_isr+0x2dc>)
    e448:	ldr	r0, [pc, #328]	; (e594 <usb_isr+0x308>)
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    e44a:	str	r5, [sp, #12]
    e44c:	str	r4, [sp, #16]
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    e44e:	mov.w	r9, #0
    e452:	str	r0, [sp, #8]
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    e454:	mov	r8, r1
    e456:	str	r6, [sp, #20]
    e458:	mov	r5, r2
    e45a:	mov	r4, r3
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
    e45c:	ldr	r0, [r4, #0]
			while (p) {
    e45e:	cbz	r0, e46c <usb_isr+0x1e0>
				n = p->next;
    e460:	ldr	r6, [r0, #4]
				usb_free(p);
    e462:	bl	e0d0 <usb_free>
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
			while (p) {
    e466:	mov	r0, r6
    e468:	cmp	r6, #0
    e46a:	bne.n	e460 <usb_isr+0x1d4>
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
    e46c:	movs	r3, #0
    e46e:	str	r3, [r4, #0]
			rx_last[i] = NULL;
    e470:	ldr	r3, [sp, #12]
			p = tx_first[i];
    e472:	ldr	r0, [r5, #0]
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
			rx_last[i] = NULL;
    e474:	mov	r2, r3
    e476:	movs	r3, #0
    e478:	str.w	r3, [r2, r9, lsl #2]
			p = tx_first[i];
			while (p) {
    e47c:	cbz	r0, e48a <usb_isr+0x1fe>
				n = p->next;
    e47e:	ldr	r6, [r0, #4]
				usb_free(p);
    e480:	bl	e0d0 <usb_free>
				p = n;
			}
			rx_first[i] = NULL;
			rx_last[i] = NULL;
			p = tx_first[i];
			while (p) {
    e484:	mov	r0, r6
    e486:	cmp	r6, #0
    e488:	bne.n	e47e <usb_isr+0x1f2>
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    e48a:	ldr	r3, [sp, #8]
			while (p) {
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
    e48c:	movs	r2, #0
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    e48e:	ldrb	r3, [r3, #0]
			while (p) {
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
    e490:	str	r2, [r5, #0]
			tx_last[i] = NULL;
    e492:	str.w	r2, [r8], #4
			usb_rx_byte_count_data[i] = 0;
    e496:	ldr	r2, [sp, #16]
    e498:	mov.w	r1, #0
			switch (tx_state[i]) {
    e49c:	subs	r3, #2
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
    e49e:	strh.w	r1, [r2, r9, lsl #1]
			switch (tx_state[i]) {
    e4a2:	cmp	r3, #3
    e4a4:	bhi.w	e99c <usb_isr+0x710>
    e4a8:	tbh	[pc, r3, lsl #1]
    e4ac:	.word	0x027402c0
    e4b0:	.word	0x027402c0
		//serial_print("PID=IN:");
		//serial_phex(stat);
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
    e4b4:	ldr	r3, [pc, #204]	; (e584 <usb_isr+0x2f8>)
    e4b6:	str	r3, [sp, #4]
    e4b8:	ldr	r2, [r3, #0]
		if (data) {
    e4ba:	cbz	r2, e516 <usb_isr+0x28a>
			size = ep0_tx_len;
    e4bc:	ldr	r3, [pc, #216]	; (e598 <usb_isr+0x30c>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e4be:	ldr	r1, [pc, #220]	; (e59c <usb_isr+0x310>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e4c0:	ldr	r6, [pc, #196]	; (e588 <usb_isr+0x2fc>)
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
    e4c2:	ldrh	r0, [r3, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e4c4:	ldrb	r4, [r1, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e4c6:	ldrb.w	lr, [r6]
    e4ca:	cmp	r0, #64	; 0x40
    e4cc:	mov	r5, r0
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    e4ce:	eor.w	ip, r4, #1
    e4d2:	it	cs
    e4d4:	movcs	r5, #64	; 0x40
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e4d6:	orr.w	r4, r4, #2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e4da:	cmp.w	lr, #0
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    e4de:	strb.w	ip, [r1]
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    e4e2:	sub.w	r0, r0, r5
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e4e6:	add.w	ip, r7, r4, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e4ea:	ite	eq
    e4ec:	moveq	r1, #136	; 0x88
    e4ee:	movne	r1, #200	; 0xc8
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    e4f0:	uxth	r0, r0
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    e4f2:	eor.w	lr, lr, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e4f6:	orr.w	r1, r1, r5, lsl #16
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e4fa:	str.w	r2, [ip, #4]
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    e4fe:	strh	r0, [r3, #0]
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    e500:	strb.w	lr, [r6]
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
    e504:	add	r2, r5
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e506:	str.w	r1, [r7, r4, lsl #3]
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    e50a:	cbnz	r0, e512 <usb_isr+0x286>
    e50c:	cmp	r5, #64	; 0x40
    e50e:	it	ne
    e510:	movne	r2, #0
    e512:	ldr	r3, [sp, #4]
    e514:	str	r2, [r3, #0]
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
    e516:	ldr	r3, [pc, #104]	; (e580 <usb_isr+0x2f4>)
    e518:	ldrh	r2, [r3, #0]
    e51a:	cmp.w	r2, #1280	; 0x500
    e51e:	bne.n	e52a <usb_isr+0x29e>
			setup.bRequest = 0;
    e520:	movs	r1, #0
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    e522:	ldrb	r2, [r3, #2]
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
			setup.bRequest = 0;
    e524:	strb	r1, [r3, #1]
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    e526:	ldr	r3, [pc, #120]	; (e5a0 <usb_isr+0x314>)
    e528:	strb	r2, [r3, #0]
	//default:
		//serial_print("PID=unknown:");
		//serial_phex(pid);
		//serial_print("\n");
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    e52a:	ldr	r2, [pc, #120]	; (e5a4 <usb_isr+0x318>)
    e52c:	movs	r3, #1
    e52e:	strb	r3, [r2, #0]
    e530:	b.n	e320 <usb_isr+0x94>
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
		break;
	case 0x01:  // OUT transaction received from host
	case 0x02:
		//serial_print("PID=OUT\n");
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    e532:	ldr	r2, [pc, #76]	; (e580 <usb_isr+0x2f4>)
    e534:	ldrh	r5, [r2, #0]
    e536:	movw	r4, #8225	; 0x2021
    e53a:	cmp	r5, r4
    e53c:	beq.w	e734 <usb_isr+0x4a8>
		if (usb_audio_set_feature(&setup, buf)) {
			endpoint0_transmit(NULL, 0);
		}
#endif
		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    e540:	ldr	r2, [pc, #40]	; (e56c <usb_isr+0x2e0>)
    e542:	str.w	r2, [r7, r0, lsl #3]
    e546:	b.n	e52a <usb_isr+0x29e>
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
					}
				} else {
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
    e548:	ldr	r2, [pc, #32]	; (e56c <usb_isr+0x2e0>)
    e54a:	ldr	r3, [pc, #36]	; (e570 <usb_isr+0x2e4>)
    e54c:	tst.w	r9, #8
    e550:	it	ne
    e552:	movne	r3, r2
    e554:	str.w	r3, [r7, r8, lsl #3]
    e558:	b.n	e320 <usb_isr+0x94>
    e55a:	nop
    e55c:	.word	0x1fff0000
    e560:	.word	0x1fff6714
    e564:	.word	0x1fff66b8
    e568:	.word	0x1fff6834
    e56c:	.word	0x004000c8
    e570:	.word	0x00400088
    e574:	.word	0x1fff67b4
    e578:	.word	0x1fff672d
    e57c:	.word	0x1fff669c
    e580:	.word	0x1fff67a0
    e584:	.word	0x1fff66b4
    e588:	.word	0x1fff672c
    e58c:	.word	0x1fff6770
    e590:	.word	0x1fff6788
    e594:	.word	0x1fff67b8
    e598:	.word	0x1fff66d0
    e59c:	.word	0x1fff67a8
    e5a0:	.word	0x40072098
    e5a4:	.word	0x40072094
    e5a8:	.word	0x40072080
    e5ac:	.word	0x40072090
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
				usb_free(packet);
    e5b0:	bl	e0d0 <usb_free>
				packet = tx_first[endpoint];
    e5b4:	ldr	r2, [pc, #724]	; (e88c <usb_isr+0x600>)
				if (packet) {
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
    e5b6:	ldr	r1, [pc, #728]	; (e890 <usb_isr+0x604>)
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
				usb_free(packet);
				packet = tx_first[endpoint];
    e5b8:	ldr.w	r3, [r2, r6, lsl #2]
				if (packet) {
    e5bc:	cmp	r3, #0
    e5be:	beq.w	e716 <usb_isr+0x48a>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    e5c2:	ldr	r0, [r3, #4]
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
    e5c4:	ldrb	r4, [r1, r6]
			if (stat & 0x08) { // transmit
				usb_free(packet);
				packet = tx_first[endpoint];
				if (packet) {
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    e5c6:	str.w	r0, [r2, r6, lsl #2]
					b->addr = packet->buf;
    e5ca:	add.w	r2, r3, #8
    e5ce:	str.w	r2, [r9, #4]
					switch (tx_state[endpoint]) {
    e5d2:	cmp	r4, #3
    e5d4:	bhi.n	e5e2 <usb_isr+0x356>
    e5d6:	tbb	[pc, r4]
    e5da:	.short	0x0f12
    e5dc:	.short	0x0215
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
    e5de:	movs	r2, #4
    e5e0:	strb	r2, [r1, r6]
						break;
					  default:
						break;
					}
					b->desc = BDT_DESC(packet->len,
    e5e2:	ldrh	r2, [r3, #0]
    e5e4:	tst.w	r9, #8
    e5e8:	ite	eq
    e5ea:	moveq	r3, #136	; 0x88
    e5ec:	movne	r3, #200	; 0xc8
    e5ee:	orr.w	r3, r3, r2, lsl #16
    e5f2:	str.w	r3, [r7, r8, lsl #3]
    e5f6:	b.n	e320 <usb_isr+0x94>
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
						break;
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
    e5f8:	movs	r2, #2
    e5fa:	strb	r2, [r1, r6]
						break;
    e5fc:	b.n	e5e2 <usb_isr+0x356>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
    e5fe:	movs	r2, #3
    e600:	strb	r2, [r1, r6]
						break;
    e602:	b.n	e5e2 <usb_isr+0x356>
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
    e604:	movs	r2, #5
    e606:	strb	r2, [r1, r6]
						break;
    e608:	b.n	e5e2 <usb_isr+0x356>
		goto restart;
	}



	if (status & USB_ISTAT_USBRST /* 01 */ ) {
    e60a:	lsls	r0, r4, #31
    e60c:	bmi.w	e79e <usb_isr+0x512>
		USB0_CTL = USB_CTL_USBENSOFEN;
		return;
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
    e610:	lsls	r1, r4, #24
    e612:	bmi.w	e83a <usb_isr+0x5ae>
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    e616:	lsls	r2, r4, #30
    e618:	bpl.n	e628 <usb_isr+0x39c>
		uint8_t err = USB0_ERRSTAT;
    e61a:	ldr	r2, [pc, #632]	; (e894 <usb_isr+0x608>)
		USB0_ERRSTAT = err;
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    e61c:	ldr	r1, [pc, #632]	; (e898 <usb_isr+0x60c>)
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
		uint8_t err = USB0_ERRSTAT;
    e61e:	ldrb	r3, [r2, #0]
		USB0_ERRSTAT = err;
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    e620:	movs	r0, #2
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
		uint8_t err = USB0_ERRSTAT;
    e622:	uxtb	r3, r3
		USB0_ERRSTAT = err;
    e624:	strb	r3, [r2, #0]
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    e626:	strb	r0, [r1, #0]
	}

	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
    e628:	lsls	r3, r4, #27
    e62a:	bpl.n	e632 <usb_isr+0x3a6>
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
    e62c:	ldr	r3, [pc, #616]	; (e898 <usb_isr+0x60c>)
    e62e:	movs	r2, #16
    e630:	strb	r2, [r3, #0]
	}

}
    e632:	add	sp, #28
    e634:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
			if (t) {
				usb_cdc_transmit_flush_timer = --t;
				if (t == 0) usb_serial_flush_callback();
    e638:	bl	d878 <usb_serial_flush_callback>
    e63c:	b.n	e362 <usb_isr+0xd6>
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
    e63e:	ldr	r2, [pc, #604]	; (e89c <usb_isr+0x610>)
						b->desc = BDT_DESC(64,
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
    e640:	str.w	r0, [r7, r8, lsl #3]
						usb_rx_memory_needed++;
    e644:	ldrb	r3, [r2, #0]
    e646:	adds	r3, #1
    e648:	strb	r3, [r2, #0]
    e64a:	b.n	e320 <usb_isr+0x94>
						//serial_print("rx 1st, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_first[endpoint] = packet;
    e64c:	str.w	r0, [r3, r6, lsl #2]
    e650:	ldr	r5, [pc, #588]	; (e8a0 <usb_isr+0x614>)
    e652:	b.n	e2ee <usb_isr+0x62>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    e654:	movw	r4, #770	; 0x302
    e658:	cmp	r1, r4
    e65a:	beq.w	ea52 <usb_isr+0x7c6>
    e65e:	bhi.w	e7f8 <usb_isr+0x56c>
    e662:	cmp	r1, #130	; 0x82
    e664:	beq.w	e970 <usb_isr+0x6e4>
    e668:	cmp.w	r1, #258	; 0x102
    e66c:	beq.w	e868 <usb_isr+0x5dc>
    e670:	cmp	r1, #128	; 0x80
    e672:	bne.w	e790 <usb_isr+0x504>
		reply_buffer[0] = usb_configuration;
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    e676:	ldr	r4, [pc, #556]	; (e8a4 <usb_isr+0x618>)
		reply_buffer[1] = 0;
		datalen = 2;
    e678:	movs	r0, #2
		reply_buffer[0] = usb_configuration;
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    e67a:	strb	r2, [r4, #0]
		reply_buffer[1] = 0;
    e67c:	strb	r2, [r4, #1]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    e67e:	ldrh	r2, [r5, #6]
    e680:	cmp	r2, r0
    e682:	bcs.w	eaa8 <usb_isr+0x81c>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e686:	ldr	r1, [pc, #544]	; (e8a8 <usb_isr+0x61c>)
    e688:	ldrb	r5, [r1, #0]
    e68a:	orr.w	ip, r5, #2
    e68e:	add.w	r0, r7, ip, lsl #3
    e692:	cmp	r2, #64	; 0x40
    e694:	mov	lr, r2
    e696:	mov.w	r3, #1
    e69a:	it	cs
    e69c:	movcs.w	lr, #64	; 0x40
    e6a0:	str	r4, [r0, #4]
    e6a2:	add.w	r9, r4, lr
    e6a6:	rsb	r0, lr, r2
    e6aa:	mov.w	r8, lr, lsl #16
    e6ae:	str	r3, [sp, #8]
    e6b0:	movs	r2, #0
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e6b2:	movs	r4, #200	; 0xc8
    e6b4:	orr.w	r3, r4, r8
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    e6b8:	eor.w	r4, r5, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e6bc:	str.w	r3, [r7, ip, lsl #3]
	ep0_tx_data_toggle ^= 1;
    e6c0:	strb	r2, [r6, #0]
	ep0_tx_bdt_bank ^= 1;
    e6c2:	strb	r4, [r1, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e6c4:	ldr.w	ip, [pc, #508]	; e8c4 <usb_isr+0x638>
	ep0_tx_data_toggle ^= 1;
    e6c8:	ldr	r3, [pc, #480]	; (e8ac <usb_isr+0x620>)
	ep0_tx_bdt_bank ^= 1;
    e6ca:	ldr.w	r8, [pc, #476]	; e8a8 <usb_isr+0x61c>
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    e6ce:	cmp	r0, #0
    e6d0:	bne.w	e92a <usb_isr+0x69e>
    e6d4:	cmp.w	lr, #64	; 0x40
    e6d8:	bne.n	e796 <usb_isr+0x50a>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e6da:	orr.w	r4, r4, #2
    e6de:	add.w	r3, r7, r4, lsl #3
    e6e2:	ldr.w	lr, [pc, #480]	; e8c4 <usb_isr+0x638>
    e6e6:	str.w	r9, [r3, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e6ea:	cmp	r2, #0
    e6ec:	bne.w	e956 <usb_isr+0x6ca>
    e6f0:	lsls	r2, r0, #16
    e6f2:	orr.w	r2, r2, #136	; 0x88
	ep0_tx_data_toggle ^= 1;
    e6f6:	ldrb.w	r3, [sp, #8]
    e6fa:	strb	r3, [r6, #0]
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    e6fc:	cmp	r0, #64	; 0x40
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    e6fe:	strb	r5, [r1, #0]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    e700:	add.w	r3, r9, r0
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e704:	str.w	r2, [lr, r4, lsl #3]
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    e708:	bne.n	e796 <usb_isr+0x50a>
    e70a:	movs	r0, #0

	ep0_tx_ptr = data;
	ep0_tx_len = datalen;
    e70c:	ldr	r2, [pc, #416]	; (e8b0 <usb_isr+0x624>)
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    e70e:	ldr	r1, [sp, #4]
	ep0_tx_len = datalen;
    e710:	strh	r0, [r2, #0]
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    e712:	str	r3, [r1, #0]
    e714:	b.n	e796 <usb_isr+0x50a>
					}
					b->desc = BDT_DESC(packet->len,
						((uint32_t)b & 8) ? DATA1 : DATA0);
				} else {
					//serial_print("tx no packet\n");
					switch (tx_state[endpoint]) {
    e716:	ldrb	r3, [r1, r6]
    e718:	cmp	r3, #3
    e71a:	bhi.w	e962 <usb_isr+0x6d6>
    e71e:	add	r2, pc, #4	; (adr r2, e724 <usb_isr+0x498>)
    e720:	ldr.w	pc, [r2, r3, lsl #2]
    e724:	.word	0x0000e321
    e728:	.word	0x0000e321
    e72c:	.word	0x0000e7f3
    e730:	.word	0x0000e7ed
	case 0x02:
		//serial_print("PID=OUT\n");
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
			int i;
			uint32_t *line_coding = NULL;
			switch (setup.wIndex) {
    e734:	ldrh	r2, [r2, #4]
    e736:	cbnz	r2, e750 <usb_isr+0x4c4>
    e738:	ldr	r2, [pc, #376]	; (e8b4 <usb_isr+0x628>)
    e73a:	adds	r5, r1, #7
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
					//serial_phex(*buf);
					*dst++ = *buf++;
    e73c:	ldrb.w	r3, [r1], #1
    e740:	strb.w	r3, [r2, #1]!
#endif
			}
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
    e744:	cmp	r5, r1
    e746:	bne.n	e73c <usb_isr+0x4b0>
					//serial_phex(*buf);
					*dst++ = *buf++;
				}
				//serial_phex32(line_coding[0]);
				//serial_print("\n");
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    e748:	ldr	r2, [pc, #364]	; (e8b8 <usb_isr+0x62c>)
    e74a:	ldr	r2, [r2, #0]
    e74c:	cmp	r2, #134	; 0x86
    e74e:	beq.n	e84e <usb_isr+0x5c2>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e750:	ldr	r1, [pc, #340]	; (e8a8 <usb_isr+0x61c>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e752:	ldr	r6, [pc, #344]	; (e8ac <usb_isr+0x620>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e754:	ldrb	r4, [r1, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e756:	ldrb	r2, [r6, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e758:	orr.w	r5, r4, #2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    e75c:	eor.w	r4, r4, #1
    e760:	strb	r4, [r1, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e762:	add.w	r1, r7, r5, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e766:	cmp	r2, #0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e768:	mov.w	r4, #0
    e76c:	str	r4, [r1, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    e76e:	eor.w	r2, r2, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e772:	ite	eq
    e774:	moveq	r1, #136	; 0x88
    e776:	movne	r1, #200	; 0xc8
    e778:	str.w	r1, [r7, r5, lsl #3]
	ep0_tx_data_toggle ^= 1;
    e77c:	strb	r2, [r6, #0]
    e77e:	b.n	e540 <usb_isr+0x2b4>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    e780:	movw	r4, #26273	; 0x66a1
    e784:	cmp	r1, r4
    e786:	beq.n	e790 <usb_isr+0x504>
    e788:	movw	r4, #26529	; 0x67a1
    e78c:	cmp	r1, r4
    e78e:	beq.n	e856 <usb_isr+0x5ca>
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    e790:	ldr	r3, [pc, #296]	; (e8bc <usb_isr+0x630>)
    e792:	movs	r2, #15
    e794:	strb	r2, [r3, #0]
		serial_print("\n");
#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    e796:	ldr	r2, [pc, #296]	; (e8c0 <usb_isr+0x634>)
    e798:	movs	r3, #1
    e79a:	strb	r3, [r2, #0]
    e79c:	b.n	e52a <usb_isr+0x29e>

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    e79e:	ldr	r1, [pc, #288]	; (e8c0 <usb_isr+0x634>)
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    e7a0:	ldr	r3, [pc, #288]	; (e8c4 <usb_isr+0x638>)
    e7a2:	ldr	r0, [pc, #292]	; (e8c8 <usb_isr+0x63c>)
	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;
    e7a4:	ldr	r6, [pc, #256]	; (e8a8 <usb_isr+0x61c>)
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    e7a6:	ldr.w	ip, [pc, #276]	; e8bc <usb_isr+0x630>

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    e7aa:	ldr	r5, [pc, #232]	; (e894 <usb_isr+0x608>)
		USB0_ISTAT = 0xFF;
    e7ac:	ldr.w	lr, [pc, #232]	; e898 <usb_isr+0x60c>

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    e7b0:	ldr	r7, [pc, #280]	; (e8cc <usb_isr+0x640>)

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    e7b2:	movs	r4, #2
    e7b4:	strb	r4, [r1, #0]
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    e7b6:	ldr	r4, [pc, #280]	; (e8d0 <usb_isr+0x644>)
		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    e7b8:	str	r0, [r3, #0]
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    e7ba:	str	r4, [r3, #4]
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
    e7bc:	str	r0, [r3, #8]
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    e7be:	ldr	r0, [pc, #276]	; (e8d4 <usb_isr+0x648>)
    e7c0:	str	r0, [r3, #12]
		table[index(0, TX, EVEN)].desc = 0;
    e7c2:	str	r2, [r3, #16]
		table[index(0, TX, ODD)].desc = 0;
    e7c4:	str	r2, [r3, #24]

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    e7c6:	movs	r3, #13
	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;
    e7c8:	strb	r2, [r6, #0]
		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    e7ca:	ldr	r4, [pc, #268]	; (e8d8 <usb_isr+0x64c>)
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    e7cc:	strb.w	r3, [ip]

		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
    e7d0:	ldr	r6, [pc, #264]	; (e8dc <usb_isr+0x650>)

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    e7d2:	movs	r3, #255	; 0xff
    e7d4:	strb	r3, [r5, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    e7d6:	movs	r0, #1
		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    e7d8:	movs	r5, #159	; 0x9f
		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
		USB0_ISTAT = 0xFF;
    e7da:	strb.w	r3, [lr]

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    e7de:	strb	r2, [r7, #0]

		// enable other interrupts
		USB0_ERREN = 0xFF;
    e7e0:	strb	r3, [r6, #0]
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    e7e2:	strb	r5, [r4, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    e7e4:	strb	r0, [r1, #0]
	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
	}

}
    e7e6:	add	sp, #28
    e7e8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
    e7ec:	movs	r3, #1
    e7ee:	strb	r3, [r1, r6]
						break;
    e7f0:	b.n	e320 <usb_isr+0x94>
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    e7f2:	movs	r3, #0
    e7f4:	strb	r3, [r1, r6]
						break;
    e7f6:	b.n	e320 <usb_isr+0x94>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    e7f8:	cmp.w	r1, #1280	; 0x500
    e7fc:	beq.w	ea4a <usb_isr+0x7be>
    e800:	bcc.n	e790 <usb_isr+0x504>
    e802:	sub.w	r1, r1, #1664	; 0x680
    e806:	cmp	r1, #1
    e808:	bhi.n	e790 <usb_isr+0x504>
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
    e80a:	ldr	r2, [pc, #212]	; (e8e0 <usb_isr+0x654>)
    e80c:	ldr	r4, [r2, #4]
    e80e:	cmp	r4, #0
    e810:	beq.n	e790 <usb_isr+0x504>
    e812:	ldrh	r0, [r5, #2]
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    e814:	ldrh.w	lr, [r5, #4]
    e818:	b.n	e822 <usb_isr+0x596>
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
    e81a:	adds	r2, #12
			if (list->addr == NULL) break;
    e81c:	ldr	r4, [r2, #4]
    e81e:	cmp	r4, #0
    e820:	beq.n	e790 <usb_isr+0x504>
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    e822:	ldrh	r3, [r2, #0]
    e824:	cmp	r3, r0
    e826:	bne.n	e81a <usb_isr+0x58e>
    e828:	ldrh	r3, [r2, #2]
    e82a:	cmp	r3, lr
    e82c:	bne.n	e81a <usb_isr+0x58e>
				data = list->addr;
				if ((setup.wValue >> 8) == 3) {
    e82e:	lsrs	r0, r0, #8
    e830:	cmp	r0, #3
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured
					// length.
					datalen = *(list->addr);
    e832:	ite	eq
    e834:	ldrbeq	r0, [r4, #0]
				} else {
					datalen = list->length;
    e836:	ldrhne	r0, [r2, #8]
    e838:	b.n	e67e <usb_isr+0x3f2>
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    e83a:	ldr	r1, [pc, #128]	; (e8bc <usb_isr+0x630>)
		USB0_ISTAT = USB_ISTAT_STALL;
    e83c:	ldr	r3, [pc, #88]	; (e898 <usb_isr+0x60c>)
    e83e:	movs	r2, #128	; 0x80
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    e840:	movs	r0, #13
    e842:	strb	r0, [r1, #0]
		USB0_ISTAT = USB_ISTAT_STALL;
    e844:	strb	r2, [r3, #0]
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    e846:	lsls	r2, r4, #30
    e848:	bpl.w	e628 <usb_isr+0x39c>
    e84c:	b.n	e61a <usb_isr+0x38e>
					//serial_phex(*buf);
					*dst++ = *buf++;
				}
				//serial_phex32(line_coding[0]);
				//serial_print("\n");
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    e84e:	ldr	r2, [pc, #148]	; (e8e4 <usb_isr+0x658>)
    e850:	movs	r1, #15
    e852:	strb	r1, [r2, #0]
    e854:	b.n	e750 <usb_isr+0x4c4>
		// TODO: required by PTP spec
		endpoint0_stall();
		return;
	case 0x67A1: // Get Device Statis (PTP spec, 5.2.4, page 10)
		// For now, always respond with status ok.
		reply_buffer[0] = 0x4;
    e856:	ldr	r4, [pc, #76]	; (e8a4 <usb_isr+0x618>)
		reply_buffer[1] = 0;
		reply_buffer[2] = 0x01;
		reply_buffer[3] = 0x20;
    e858:	movs	r1, #32
		endpoint0_stall();
		return;
	case 0x67A1: // Get Device Statis (PTP spec, 5.2.4, page 10)
		// For now, always respond with status ok.
		reply_buffer[0] = 0x4;
		reply_buffer[1] = 0;
    e85a:	strb	r2, [r4, #1]
		// TODO: required by PTP spec
		endpoint0_stall();
		return;
	case 0x67A1: // Get Device Statis (PTP spec, 5.2.4, page 10)
		// For now, always respond with status ok.
		reply_buffer[0] = 0x4;
    e85c:	movs	r2, #4
		reply_buffer[1] = 0;
		reply_buffer[2] = 0x01;
    e85e:	strb	r0, [r4, #2]
		reply_buffer[3] = 0x20;
    e860:	strb	r1, [r4, #3]
		// TODO: required by PTP spec
		endpoint0_stall();
		return;
	case 0x67A1: // Get Device Statis (PTP spec, 5.2.4, page 10)
		// For now, always respond with status ok.
		reply_buffer[0] = 0x4;
    e862:	strb	r2, [r4, #0]
		reply_buffer[1] = 0;
		reply_buffer[2] = 0x01;
		reply_buffer[3] = 0x20;
		data = reply_buffer;
		datalen = 4;
    e864:	mov	r0, r2
    e866:	b.n	e67e <usb_isr+0x3f2>
    e868:	ldrh	r1, [r5, #4]
    e86a:	and.w	r1, r1, #127	; 0x7f
		data = reply_buffer;
		datalen = 2;
		break;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    e86e:	cmp	r1, #6
    e870:	bhi.n	e790 <usb_isr+0x504>
    e872:	ldrh	r2, [r5, #2]
    e874:	cmp	r2, #0
    e876:	bne.n	e790 <usb_isr+0x504>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
    e878:	ldr	r4, [pc, #64]	; (e8bc <usb_isr+0x630>)
    e87a:	str	r0, [sp, #8]
    e87c:	lsls	r1, r1, #2
    e87e:	add	r4, r1
    e880:	ldrb	r1, [r4, #0]
    e882:	bic.w	r1, r1, #2
    e886:	strb	r1, [r4, #0]
    e888:	b.n	e902 <usb_isr+0x676>
    e88a:	nop
    e88c:	.word	0x1fff6770
    e890:	.word	0x1fff67b8
    e894:	.word	0x40072088
    e898:	.word	0x40072080
    e89c:	.word	0x1fff67a9
    e8a0:	.word	0x1fff66b8
    e8a4:	.word	0x1fff67ac
    e8a8:	.word	0x1fff67a8
    e8ac:	.word	0x1fff672c
    e8b0:	.word	0x1fff66d0
    e8b4:	.word	0x1fff6827
    e8b8:	.word	0x1fff6828
    e8bc:	.word	0x400720c0
    e8c0:	.word	0x40072094
    e8c4:	.word	0x1fff0000
    e8c8:	.word	0x00400088
    e8cc:	.word	0x40072098
    e8d0:	.word	0x1fff66d4
    e8d4:	.word	0x1fff6730
    e8d8:	.word	0x40072084
    e8dc:	.word	0x4007208c
    e8e0:	.word	0x00014734
    e8e4:	.word	0x1fff672d
		}
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
    e8e8:	ldrh	r1, [r5, #4]
    e8ea:	cmp	r1, #0
    e8ec:	bne.w	ea78 <usb_isr+0x7ec>
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    e8f0:	ldr	r3, [pc, #472]	; (eacc <usb_isr+0x840>)
    e8f2:	ldr	r2, [pc, #476]	; (ead0 <usb_isr+0x844>)
			usb_cdc_line_rtsdtr = setup.wValue;
    e8f4:	ldr	r4, [pc, #476]	; (ead4 <usb_isr+0x848>)
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    e8f6:	ldr	r3, [r3, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    e8f8:	ldrb	r5, [r5, #2]
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    e8fa:	str	r3, [r2, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    e8fc:	str	r0, [sp, #8]
    e8fe:	mov	r2, r1
    e900:	strb	r5, [r4, #0]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    e902:	movs	r0, #0
    e904:	mov	r9, r0
    e906:	mov	r8, r0
    e908:	mov	lr, r0
    e90a:	mov	r4, r0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e90c:	ldr	r1, [pc, #456]	; (ead8 <usb_isr+0x84c>)
    e90e:	ldrb	r5, [r1, #0]
    e910:	orr.w	ip, r5, #2
    e914:	add.w	r3, r7, ip, lsl #3
    e918:	str	r3, [sp, #12]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e91a:	ldr	r3, [sp, #8]
    e91c:	cmp	r3, #0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e91e:	ldr	r3, [sp, #12]
    e920:	str	r4, [r3, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e922:	ite	eq
    e924:	moveq	r4, #136	; 0x88
    e926:	movne	r4, #200	; 0xc8
    e928:	b.n	e6b4 <usb_isr+0x428>
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
    e92a:	cmp	r0, #64	; 0x40
    e92c:	bls.w	e6da <usb_isr+0x44e>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    e930:	orr.w	r4, r4, #2
    e934:	add.w	r1, ip, r4, lsl #3
    e938:	str.w	r9, [r1, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e93c:	cbz	r2, e95e <usb_isr+0x6d2>
    e93e:	ldr	r2, [pc, #412]	; (eadc <usb_isr+0x850>)
	ep0_tx_data_toggle ^= 1;
    e940:	ldrb.w	r1, [sp, #8]
    e944:	strb	r1, [r3, #0]
	ep0_tx_bdt_bank ^= 1;
    e946:	strb.w	r5, [r8]
    e94a:	subs	r0, #64	; 0x40
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    e94c:	add.w	r3, r9, #64	; 0x40
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    e950:	str.w	r2, [ip, r4, lsl #3]
    e954:	b.n	e70c <usb_isr+0x480>
    e956:	lsls	r2, r0, #16
    e958:	orr.w	r2, r2, #200	; 0xc8
    e95c:	b.n	e6f6 <usb_isr+0x46a>
    e95e:	ldr	r2, [pc, #384]	; (eae0 <usb_isr+0x854>)
    e960:	b.n	e940 <usb_isr+0x6b4>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
						break;
					  default:
						tx_state[endpoint] = ((uint32_t)b & 8) ?
    e962:	tst.w	r9, #8
    e966:	ite	eq
    e968:	moveq	r3, #2
    e96a:	movne	r3, #3
    e96c:	strb	r3, [r1, r6]
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
    e96e:	b.n	e320 <usb_isr+0x94>
    e970:	ldrh	r1, [r5, #4]
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    e972:	ldr	r3, [pc, #368]	; (eae4 <usb_isr+0x858>)
    e974:	and.w	r1, r1, #127	; 0x7f
		datalen = 2;
		data = reply_buffer;
		break;
	  case 0x0082: // GET_STATUS (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS) {
    e978:	cmp	r1, #6
    e97a:	bhi.w	e792 <usb_isr+0x506>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    e97e:	ldr	r4, [pc, #360]	; (eae8 <usb_isr+0x85c>)
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    e980:	lsls	r1, r1, #2
    e982:	add	r3, r1
		if (i > NUM_ENDPOINTS) {
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    e984:	strb	r2, [r4, #0]
		reply_buffer[1] = 0;
    e986:	strb	r2, [r4, #1]
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    e988:	ldrb	r2, [r3, #0]
    e98a:	lsls	r3, r2, #30
    e98c:	bpl.n	ea7c <usb_isr+0x7f0>
    e98e:	strb	r0, [r4, #0]
		data = reply_buffer;
		datalen = 2;
    e990:	movs	r0, #2
    e992:	b.n	e67e <usb_isr+0x3f2>
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    e994:	ldr	r3, [sp, #8]
    e996:	mov.w	r2, #1
    e99a:	strb	r2, [r3, #0]
    e99c:	ldr	r3, [sp, #8]
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
    e99e:	add.w	r9, r9, #1
    e9a2:	adds	r3, #1
    e9a4:	cmp.w	r9, #6
    e9a8:	add.w	r4, r4, #4
    e9ac:	add.w	r5, r5, #4
    e9b0:	str	r3, [sp, #8]
    e9b2:	bne.w	e45c <usb_isr+0x1d0>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    e9b6:	ldr	r3, [pc, #308]	; (eaec <usb_isr+0x860>)
    e9b8:	ldr	r6, [sp, #20]
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
    e9ba:	ldr	r5, [pc, #308]	; (eaf0 <usb_isr+0x864>)
		cfg = usb_endpoint_config_table;
    e9bc:	ldr.w	r8, [pc, #316]	; eafc <usb_isr+0x870>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    e9c0:	movs	r0, #0
    e9c2:	strb	r0, [r3, #0]
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    e9c4:	mov.w	r9, #1
    e9c8:	b.n	e9ea <usb_isr+0x75e>
    e9ca:	mov.w	r4, r9, lsl #2
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    e9ce:	orr.w	r2, r4, #2
			table[index(i, TX, ODD)].desc = 0;
    e9d2:	orr.w	r4, r4, #3
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    e9d6:	movs	r3, #0
    e9d8:	str.w	r3, [r7, r2, lsl #3]
			table[index(i, TX, ODD)].desc = 0;
    e9dc:	str.w	r3, [r7, r4, lsl #3]
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    e9e0:	ldr	r3, [pc, #272]	; (eaf4 <usb_isr+0x868>)
    e9e2:	cmp	r5, r3
    e9e4:	add.w	r9, r9, #1
    e9e8:	beq.n	ea36 <usb_isr+0x7aa>
			epconf = *cfg++;
    e9ea:	ldrb.w	r3, [r8], #1
			*reg = epconf;
    e9ee:	strb.w	r3, [r5], #4
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    e9f2:	lsls	r2, r3, #28
    e9f4:	bpl.n	e9ca <usb_isr+0x73e>
				usb_packet_t *p;
				p = usb_malloc();
    e9f6:	bl	e090 <usb_malloc>
				if (p) {
    e9fa:	cmp	r0, #0
    e9fc:	beq.n	ea94 <usb_isr+0x808>
					table[index(i, RX, EVEN)].addr = p->buf;
    e9fe:	add.w	r3, r7, r9, lsl #5
    ea02:	mov.w	r4, r9, lsl #2
    ea06:	adds	r0, #8
    ea08:	str	r0, [r3, #4]
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    ea0a:	ldr	r3, [pc, #212]	; (eae0 <usb_isr+0x854>)
    ea0c:	str.w	r3, [r7, r4, lsl #3]
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
    ea10:	bl	e090 <usb_malloc>
				if (p) {
    ea14:	cmp	r0, #0
    ea16:	beq.n	ea80 <usb_isr+0x7f4>
					table[index(i, RX, ODD)].addr = p->buf;
    ea18:	orr.w	r3, r4, #1
    ea1c:	add.w	r2, r7, r3, lsl #3
    ea20:	adds	r0, #8
    ea22:	str	r0, [r2, #4]
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    ea24:	ldr	r2, [pc, #180]	; (eadc <usb_isr+0x850>)
    ea26:	str.w	r2, [r7, r3, lsl #3]
    ea2a:	b.n	e9ce <usb_isr+0x742>
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
			  case TX_STATE_EVEN_FREE:
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    ea2c:	ldr	r3, [sp, #8]
    ea2e:	mov.w	r2, #0
    ea32:	strb	r2, [r3, #0]
    ea34:	b.n	e99c <usb_isr+0x710>
    ea36:	ldrb	r3, [r6, #0]
    ea38:	str	r3, [sp, #8]
    ea3a:	eor.w	r2, r3, #1
    ea3e:	b.n	e902 <usb_isr+0x676>
			}
#endif
		}
		break;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    ea40:	ldr	r2, [pc, #180]	; (eaf8 <usb_isr+0x86c>)
    ea42:	ldr	r4, [pc, #164]	; (eae8 <usb_isr+0x85c>)
    ea44:	ldrb	r2, [r2, #0]
    ea46:	strb	r2, [r4, #0]
    ea48:	b.n	e67e <usb_isr+0x3f2>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    ea4a:	movs	r3, #1
    ea4c:	movs	r2, #0
    ea4e:	str	r3, [sp, #8]
    ea50:	b.n	e902 <usb_isr+0x676>
    ea52:	ldrh	r1, [r5, #4]
    ea54:	and.w	r1, r1, #127	; 0x7f
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
		// TODO: do we need to clear the data toggle here?
		break;
	  case 0x0302: // SET_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    ea58:	cmp	r1, #6
    ea5a:	bhi.w	e790 <usb_isr+0x504>
    ea5e:	ldrh	r2, [r5, #2]
    ea60:	cmp	r2, #0
    ea62:	bne.w	e790 <usb_isr+0x504>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) |= 0x02;
    ea66:	ldr	r4, [pc, #124]	; (eae4 <usb_isr+0x858>)
    ea68:	str	r0, [sp, #8]
    ea6a:	lsls	r1, r1, #2
    ea6c:	add	r4, r1
    ea6e:	ldrb	r1, [r4, #0]
    ea70:	orr.w	r1, r1, #2
    ea74:	strb	r1, [r4, #0]
    ea76:	b.n	e902 <usb_isr+0x676>
		}
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
    ea78:	str	r0, [sp, #8]
    ea7a:	b.n	e902 <usb_isr+0x676>
		}
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
		data = reply_buffer;
		datalen = 2;
    ea7c:	movs	r0, #2
    ea7e:	b.n	e67e <usb_isr+0x3f2>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
    ea80:	ldr	r3, [pc, #104]	; (eaec <usb_isr+0x860>)
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    ea82:	orr.w	r2, r4, #1
					usb_rx_memory_needed++;
    ea86:	ldrb	r3, [r3, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    ea88:	str.w	r0, [r7, r2, lsl #3]
					usb_rx_memory_needed++;
    ea8c:	ldr	r2, [pc, #92]	; (eaec <usb_isr+0x860>)
    ea8e:	adds	r3, #1
    ea90:	strb	r3, [r2, #0]
    ea92:	b.n	e9ce <usb_isr+0x742>
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
    ea94:	ldr	r3, [pc, #84]	; (eaec <usb_isr+0x860>)
    ea96:	ldr	r2, [pc, #84]	; (eaec <usb_isr+0x860>)
    ea98:	ldrb	r3, [r3, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    ea9a:	mov.w	r4, r9, lsl #2
					usb_rx_memory_needed++;
    ea9e:	adds	r3, #1
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    eaa0:	str.w	r0, [r7, r4, lsl #3]
					usb_rx_memory_needed++;
    eaa4:	strb	r3, [r2, #0]
    eaa6:	b.n	ea10 <usb_isr+0x784>
    eaa8:	cmp	r0, #64	; 0x40
    eaaa:	mov	lr, r0
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    eaac:	mov.w	r3, #1
    eab0:	it	cs
    eab2:	movcs.w	lr, #64	; 0x40
    eab6:	rsb	r0, lr, r0
    eaba:	mov.w	r8, lr, lsl #16
    eabe:	add.w	r9, r4, lr
    eac2:	movs	r2, #0
    eac4:	str	r3, [sp, #8]
    eac6:	b.n	e90c <usb_isr+0x680>


void _reboot_Teensyduino_(void)
{
	// TODO: initialize R0 with a code....
	__asm__ volatile("bkpt");
    eac8:	bkpt	0x0000
    eaca:	nop
    eacc:	.word	0x1fff66b0
    ead0:	.word	0x1fff6830
    ead4:	.word	0x1fff66ac
    ead8:	.word	0x1fff67a8
    eadc:	.word	0x004000c8
    eae0:	.word	0x00400088
    eae4:	.word	0x400720c0
    eae8:	.word	0x1fff67ac
    eaec:	.word	0x1fff67a9
    eaf0:	.word	0x400720c4
    eaf4:	.word	0x400720dc
    eaf8:	.word	0x1fff67b4
    eafc:	.word	0x0001472c

0000eb00 <usb_init>:
}



void usb_init(void)
{
    eb00:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int i;

	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();
    eb04:	bl	d950 <usb_init_serialnumber>

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    eb08:	movs	r3, #0
    eb0a:	ldr	r1, [pc, #140]	; (eb98 <usb_init+0x98>)
		table[i].desc = 0;
    eb0c:	mov	r2, r3
		table[i].addr = 0;
    eb0e:	add.w	r0, r1, r3, lsl #3
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
		table[i].desc = 0;
    eb12:	str.w	r2, [r1, r3, lsl #3]
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    eb16:	adds	r3, #1
    eb18:	cmp	r3, #28
		table[i].desc = 0;
		table[i].addr = 0;
    eb1a:	str	r2, [r0, #4]
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
		table[i].desc = 0;
    eb1c:	mov.w	r4, #0
    eb20:	ldr	r0, [pc, #116]	; (eb98 <usb_init+0x98>)
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    eb22:	bne.n	eb0e <usb_init+0xe>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    eb24:	ldr	r1, [pc, #116]	; (eb9c <usb_init+0x9c>)
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    eb26:	ldr	r2, [pc, #120]	; (eba0 <usb_init+0xa0>)
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    eb28:	ldr	r3, [r1, #0]
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    eb2a:	ldr.w	r8, [pc, #140]	; ebb8 <usb_init+0xb8>
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    eb2e:	ldr	r7, [pc, #116]	; (eba4 <usb_init+0xa4>)
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    eb30:	ldr	r5, [pc, #116]	; (eba8 <usb_init+0xa8>)

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
	USB0_OTGISTAT = 0xFF;
    eb32:	ldr	r6, [pc, #120]	; (ebac <usb_init+0xac>)
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    eb34:	ldr.w	ip, [pc, #132]	; ebbc <usb_init+0xbc>
	USB0_ERRSTAT = 0xFF;
    eb38:	ldr.w	lr, [pc, #132]	; ebc0 <usb_init+0xc0>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    eb3c:	orr.w	r3, r3, #262144	; 0x40000
    eb40:	str	r3, [r1, #0]
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    eb42:	ldr	r3, [r2, #0]
    eb44:	orr.w	r3, r3, #50331648	; 0x3000000
    eb48:	str	r3, [r2, #0]
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    eb4a:	ubfx	r3, r0, #8, #8
    eb4e:	strb.w	r3, [r8]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;
    eb52:	add.w	r1, r1, #172032	; 0x2a000
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    eb56:	ubfx	r3, r0, #16, #8
    eb5a:	strb	r3, [r7, #0]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    eb5c:	lsrs	r0, r0, #24

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    eb5e:	movs	r3, #255	; 0xff

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;
    eb60:	adds	r1, #204	; 0xcc
	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    eb62:	add.w	r2, r2, #411648	; 0x64800
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    eb66:	strb	r0, [r5, #0]
	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    eb68:	add.w	r2, r2, #264	; 0x108
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    eb6c:	strb.w	r3, [ip]

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    eb70:	ldr	r5, [pc, #60]	; (ebb0 <usb_init+0xb0>)
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
    eb72:	strb.w	r3, [lr]
	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    eb76:	ldr	r0, [pc, #60]	; (ebb4 <usb_init+0xb4>)
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
	USB0_OTGISTAT = 0xFF;
    eb78:	strb	r3, [r6, #0]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    eb7a:	movs	r3, #1
    eb7c:	strb.w	r3, [r8, #-8]

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    eb80:	movs	r6, #112	; 0x70

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;
    eb82:	strb	r4, [r1, #0]
	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    eb84:	mov.w	r4, #2097152	; 0x200000

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    eb88:	movs	r1, #16
	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;
    eb8a:	strb.w	r3, [r7, #-44]

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    eb8e:	strb	r6, [r5, #0]
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    eb90:	str	r4, [r0, #0]

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    eb92:	strb	r1, [r2, #0]
    eb94:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    eb98:	.word	0x1fff0000
    eb9c:	.word	0x40048034
    eba0:	.word	0x4000d800
    eba4:	.word	0x400720b0
    eba8:	.word	0x400720b4
    ebac:	.word	0x40072010
    ebb0:	.word	0xe000e435
    ebb4:	.word	0xe000e104
    ebb8:	.word	0x4007209c
    ebbc:	.word	0x40072080
    ebc0:	.word	0x40072088

0000ebc4 <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    ebc4:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    ebc8:	ldr	r6, [pc, #196]	; (ec90 <yield+0xcc>)
    ebca:	ldrb	r3, [r6, #0]
    ebcc:	cbz	r3, ebf4 <yield+0x30>
	if (running) return; // TODO: does this need to be atomic?
    ebce:	ldr	r7, [pc, #196]	; (ec94 <yield+0xd0>)
    ebd0:	ldrb	r2, [r7, #0]
    ebd2:	cbnz	r2, ebf4 <yield+0x30>
	running = 1;
    ebd4:	movs	r2, #1


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    ebd6:	lsls	r1, r3, #31
void yield(void)
{
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
	if (running) return; // TODO: does this need to be atomic?
	running = 1;
    ebd8:	strb	r2, [r7, #0]


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    ebda:	bmi.n	ec4a <yield+0x86>
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIALUSB2) {
		if (SerialUSB2.available()) serialEventUSB2();
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
    ebdc:	lsls	r2, r3, #30
    ebde:	bmi.n	ec14 <yield+0x50>
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    ebe0:	movs	r2, #0
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    ebe2:	lsls	r3, r3, #29
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    ebe4:	strb	r2, [r7, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    ebe6:	bpl.n	ebf4 <yield+0x30>
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);

	static void runFromYield() {
		if (!firstYield) return;  
    ebe8:	ldr	r3, [pc, #172]	; (ec98 <yield+0xd4>)
    ebea:	ldr	r2, [r3, #0]
    ebec:	cbz	r2, ebf4 <yield+0x30>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    ebee:	mrs	r2, IPSR
		if (ipsr != 0) return;
    ebf2:	cbz	r2, ebf8 <yield+0x34>
    ebf4:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    ebf8:	mrs	r1, PRIMASK
		__disable_irq();
    ebfc:	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    ebfe:	ldr	r0, [r3, #0]
		if (first == nullptr) {
    ec00:	cbz	r0, ec0a <yield+0x46>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    ec02:	ldr	r4, [pc, #152]	; (ec9c <yield+0xd8>)
    ec04:	ldrb	r2, [r4, #0]
    ec06:	cmp	r2, #0
    ec08:	beq.n	ec68 <yield+0xa4>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    ec0a:	cmp	r1, #0
    ec0c:	bne.n	ebf4 <yield+0x30>
    ec0e:	cpsie	i
    ec10:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    ec14:	ldr.w	r8, [pc, #144]	; eca8 <yield+0xe4>
    ec18:	ldrb.w	r2, [r8]
    ec1c:	cmp	r2, #0
    ec1e:	beq.n	ebe0 <yield+0x1c>
    ec20:	ldr.w	r9, [pc, #136]	; ecac <yield+0xe8>
    ec24:	movs	r4, #0
    ec26:	b.n	ec34 <yield+0x70>
    ec28:	adds	r4, #1
    ec2a:	ldrb.w	r3, [r8]
    ec2e:	uxtb	r4, r4
    ec30:	cmp	r3, r4
    ec32:	bls.n	ec5a <yield+0x96>
			s_serials_with_serial_events[i]->doYieldCode();
    ec34:	ldr.w	r5, [r9, r4, lsl #2]
	static HardwareSerial 	*s_serials_with_serial_events[CNT_HARDWARE_SERIAL];
	static uint8_t 			s_count_serials_with_serial_events;
	void 		(* const _serialEvent)(); 
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*_serialEvent)();
    ec38:	ldr	r3, [r5, #0]
    ec3a:	mov	r0, r5
    ec3c:	ldr	r3, [r3, #16]
    ec3e:	blx	r3
    ec40:	cmp	r0, #0
    ec42:	beq.n	ec28 <yield+0x64>
    ec44:	ldr	r3, [r5, #16]
    ec46:	blx	r3
    ec48:	b.n	ec28 <yield+0x64>
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    ec4a:	bl	d664 <usb_serial_available>
	running = 1;


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    ec4e:	cbnz	r0, ec84 <yield+0xc0>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    ec50:	ldr	r3, [pc, #76]	; (eca0 <yield+0xdc>)
    ec52:	ldrb	r3, [r3, #0]
    ec54:	cbnz	r3, ec5e <yield+0x9a>
    ec56:	ldrb	r3, [r6, #0]
    ec58:	b.n	ebdc <yield+0x18>
    ec5a:	ldrb	r3, [r6, #0]
    ec5c:	b.n	ebe0 <yield+0x1c>
    ec5e:	ldrb	r3, [r6, #0]
    ec60:	and.w	r3, r3, #254	; 0xfe
    ec64:	strb	r3, [r6, #0]
    ec66:	b.n	ebdc <yield+0x18>
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
		firstYield = first->_next;
    ec68:	ldr	r5, [r0, #20]
    ec6a:	str	r5, [r3, #0]
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    ec6c:	movs	r3, #1
    ec6e:	strb	r3, [r4, #0]
		firstYield = first->_next;
		if (firstYield) {
    ec70:	cbz	r5, ec8a <yield+0xc6>
			firstYield->_prev = nullptr;
    ec72:	str	r2, [r5, #24]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    ec74:	cbnz	r1, ec78 <yield+0xb4>
    ec76:	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    ec78:	movs	r5, #0
    ec7a:	strb	r5, [r0, #29]
		(*(first->_function))(*first);
    ec7c:	ldr	r3, [r0, #8]
    ec7e:	blx	r3
		runningFromYield = false;
    ec80:	strb	r5, [r4, #0]
    ec82:	b.n	ebf4 <yield+0x30>
	running = 1;


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    ec84:	bl	eff4 <serialEvent()>
    ec88:	b.n	ec50 <yield+0x8c>
		runningFromYield = true;
		firstYield = first->_next;
		if (firstYield) {
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
    ec8a:	ldr	r3, [pc, #24]	; (eca4 <yield+0xe0>)
    ec8c:	str	r5, [r3, #0]
    ec8e:	b.n	ec74 <yield+0xb0>
    ec90:	.word	0x1fff0acc
    ec94:	.word	0x1fff67be
    ec98:	.word	0x1fff67d0
    ec9c:	.word	0x1fff67d4
    eca0:	.word	0x1fff0ae0
    eca4:	.word	0x1fff67cc
    eca8:	.word	0x1fff67f0
    ecac:	.word	0x1fff67d8

0000ecb0 <DMAChannel::begin(bool)>:
/**                     Teensy 3.0 & 3.1                       **/
/****************************************************************/
#if defined(KINETISK)

void DMAChannel::begin(bool force_initialization)
{
    ecb0:	push	{r4, r5, r6, r7, lr}
	uint32_t ch = 0;

	__disable_irq();
    ecb2:	cpsid	i
	if (!force_initialization && TCD && channel < DMA_MAX_CHANNELS
    ecb4:	cbnz	r1, ecde <DMAChannel::begin(bool)+0x2e>
    ecb6:	ldr	r2, [r0, #0]
    ecb8:	cbz	r2, ecde <DMAChannel::begin(bool)+0x2e>
    ecba:	ldrb	r3, [r0, #4]
    ecbc:	cmp	r3, #15
    ecbe:	bhi.n	ecde <DMAChannel::begin(bool)+0x2e>
	  && (dma_channel_allocated_mask & (1 << channel))
    ecc0:	ldr	r4, [pc, #156]	; (ed60 <DMAChannel::begin(bool)+0xb0>)
    ecc2:	ldrh	r1, [r4, #0]
    ecc4:	asr.w	r5, r1, r3
    ecc8:	lsls	r5, r5, #31
    ecca:	bpl.n	ece2 <DMAChannel::begin(bool)+0x32>
	  && (uint32_t)TCD == (uint32_t)(0x40009000 + channel * 32)) {
    eccc:	add.w	r3, r3, #33554432	; 0x2000000
    ecd0:	add.w	r3, r3, #1152	; 0x480
    ecd4:	cmp.w	r2, r3, lsl #5
    ecd8:	bne.n	ece2 <DMAChannel::begin(bool)+0x32>
		// DMA channel already allocated
		__enable_irq();
    ecda:	cpsie	i
		return;
    ecdc:	pop	{r4, r5, r6, r7, pc}
    ecde:	ldr	r4, [pc, #128]	; (ed60 <DMAChannel::begin(bool)+0xb0>)
    ece0:	ldrh	r1, [r4, #0]
/**                     Teensy 3.0 & 3.1                       **/
/****************************************************************/
#if defined(KINETISK)

void DMAChannel::begin(bool force_initialization)
{
    ece2:	movs	r3, #0
		// DMA channel already allocated
		__enable_irq();
		return;
	}
	while (1) {
		if (!(dma_channel_allocated_mask & (1 << ch))) {
    ece4:	asr.w	r2, r1, r3
    ece8:	ands.w	r2, r2, #1
    ecec:	beq.n	ecfe <DMAChannel::begin(bool)+0x4e>
			dma_channel_allocated_mask |= (1 << ch);
			__enable_irq();
			break;
		}
		if (++ch >= DMA_MAX_CHANNELS) {
    ecee:	adds	r3, #1
    ecf0:	cmp	r3, #16
    ecf2:	bne.n	ece4 <DMAChannel::begin(bool)+0x34>
			__enable_irq();
    ecf4:	cpsie	i
			TCD = (TCD_t *)0;
    ecf6:	movs	r2, #0
			channel = DMA_MAX_CHANNELS;
    ecf8:	strb	r3, [r0, #4]
			__enable_irq();
			break;
		}
		if (++ch >= DMA_MAX_CHANNELS) {
			__enable_irq();
			TCD = (TCD_t *)0;
    ecfa:	str	r2, [r0, #0]
    ecfc:	pop	{r4, r5, r6, r7, pc}
		__enable_irq();
		return;
	}
	while (1) {
		if (!(dma_channel_allocated_mask & (1 << ch))) {
			dma_channel_allocated_mask |= (1 << ch);
    ecfe:	movs	r5, #1
    ed00:	lsls	r5, r3
    ed02:	orrs	r1, r5
    ed04:	strh	r1, [r4, #0]
			__enable_irq();
    ed06:	cpsie	i
			return; // no more channels available
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    ed08:	ldr	r6, [pc, #88]	; (ed64 <DMAChannel::begin(bool)+0xb4>)
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    ed0a:	ldr	r5, [pc, #92]	; (ed68 <DMAChannel::begin(bool)+0xb8>)
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
    ed0c:	ldr	r7, [pc, #92]	; (ed6c <DMAChannel::begin(bool)+0xbc>)
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
    ed0e:	ldr.w	lr, [pc, #100]	; ed74 <DMAChannel::begin(bool)+0xc4>
			channel = DMA_MAX_CHANNELS;
			return; // no more channels available
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
    ed12:	uxtb	r1, r3
    ed14:	strb	r1, [r0, #4]
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    ed16:	ldr	r4, [r6, #0]
    ed18:	orr.w	r4, r4, #2
    ed1c:	str	r4, [r6, #0]
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    ed1e:	ldr	r4, [r5, #0]
    ed20:	orr.w	r4, r4, #2
    ed24:	str	r4, [r5, #0]
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
    ed26:	sub.w	r6, r6, #262144	; 0x40000
	}
	channel = ch;
	SIM_SCGC7 |= SIM_SCGC7_DMA;
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
    ed2a:	movs	r4, #130	; 0x82
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
    ed2c:	sub.w	r5, r5, #262144	; 0x40000
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    ed30:	add.w	r3, r3, #33554432	; 0x2000000
	}
	channel = ch;
	SIM_SCGC7 |= SIM_SCGC7_DMA;
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
    ed34:	str	r4, [r7, #0]
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    ed36:	add.w	r3, r3, #1152	; 0x480
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
    ed3a:	subs	r6, #34	; 0x22
	DMA_CEEI = ch;
    ed3c:	subs	r5, #36	; 0x24
	DMA_CINT = ch;
    ed3e:	ldr	r4, [pc, #48]	; (ed70 <DMAChannel::begin(bool)+0xc0>)
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
    ed40:	strb.w	r1, [lr]
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    ed44:	lsls	r3, r3, #5
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
    ed46:	strb	r1, [r6, #0]
	DMA_CEEI = ch;
    ed48:	strb	r1, [r5, #0]
	DMA_CINT = ch;
    ed4a:	strb	r1, [r4, #0]
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    ed4c:	str	r3, [r0, #0]
	uint32_t *p = (uint32_t *)TCD;
	*p++ = 0;
    ed4e:	str	r2, [r3, #0]
	*p++ = 0;
    ed50:	str	r2, [r3, #4]
	*p++ = 0;
    ed52:	str	r2, [r3, #8]
	*p++ = 0;
    ed54:	str	r2, [r3, #12]
	*p++ = 0;
    ed56:	str	r2, [r3, #16]
	*p++ = 0;
    ed58:	str	r2, [r3, #20]
	*p++ = 0;
    ed5a:	str	r2, [r3, #24]
	*p++ = 0;
    ed5c:	str	r2, [r3, #28]
    ed5e:	pop	{r4, r5, r6, r7, pc}
    ed60:	.word	0x1fff67c0
    ed64:	.word	0x40048040
    ed68:	.word	0x4004803c
    ed6c:	.word	0x40008000
    ed70:	.word	0x4000801f
    ed74:	.word	0x4000801a

0000ed78 <DMAChannel::release()>:
}

void DMAChannel::release(void)
{
	if (channel >= DMA_MAX_CHANNELS) return;
    ed78:	ldrb	r3, [r0, #4]
    ed7a:	cmp	r3, #15
    ed7c:	bhi.n	eda4 <DMAChannel::release()+0x2c>
	DMA_CERQ = channel;
    ed7e:	ldr	r2, [pc, #40]	; (eda8 <DMAChannel::release()+0x30>)
	*p++ = 0;
	*p++ = 0;
}

void DMAChannel::release(void)
{
    ed80:	push	{r4}
	if (channel >= DMA_MAX_CHANNELS) return;
	DMA_CERQ = channel;
    ed82:	strb	r3, [r2, #0]
	__disable_irq();
    ed84:	cpsid	i
	dma_channel_allocated_mask &= ~(1 << channel);
    ed86:	ldr	r1, [pc, #36]	; (edac <DMAChannel::release()+0x34>)
    ed88:	ldrb	r4, [r0, #4]
    ed8a:	ldrh	r2, [r1, #0]
    ed8c:	movs	r3, #1
    ed8e:	lsls	r3, r4
    ed90:	bic.w	r3, r2, r3
    ed94:	strh	r3, [r1, #0]
	__enable_irq();
    ed96:	cpsie	i
	channel = DMA_MAX_CHANNELS;
    ed98:	movs	r2, #16
	TCD = (TCD_t *)0;
    ed9a:	movs	r3, #0
}
    ed9c:	ldr.w	r4, [sp], #4
	if (channel >= DMA_MAX_CHANNELS) return;
	DMA_CERQ = channel;
	__disable_irq();
	dma_channel_allocated_mask &= ~(1 << channel);
	__enable_irq();
	channel = DMA_MAX_CHANNELS;
    eda0:	strb	r2, [r0, #4]
	TCD = (TCD_t *)0;
    eda2:	str	r3, [r0, #0]
}
    eda4:	bx	lr
    eda6:	nop
    eda8:	.word	0x4000801a
    edac:	.word	0x1fff67c0

0000edb0 <EventResponder::triggerEventNotImmediate()>:
uint8_t _serialEvent_default __attribute__((weak)) PROGMEM = 0 ;	
uint8_t _serialEventUSB1_default __attribute__((weak)) PROGMEM = 0 ;	
uint8_t _serialEventUSB2_default __attribute__((weak)) PROGMEM = 0 ;	

void EventResponder::triggerEventNotImmediate()
{
    edb0:	push	{r4}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    edb2:	mrs	r2, PRIMASK
		__disable_irq();
    edb6:	cpsid	i
	bool irq = disableInterrupts();
	if (_triggered == false) {
    edb8:	ldrb	r3, [r0, #29]
    edba:	cbnz	r3, edca <EventResponder::triggerEventNotImmediate()+0x1a>
		// not already triggered
		if (_type == EventTypeYield) {
    edbc:	ldrb	r1, [r0, #28]
    edbe:	cmp	r1, #1
    edc0:	beq.n	edd4 <EventResponder::triggerEventNotImmediate()+0x24>
				_next = nullptr;
				_prev = lastYield;
				_prev->_next = this;
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
    edc2:	cmp	r1, #3
    edc4:	beq.n	ede8 <EventResponder::triggerEventNotImmediate()+0x38>
			}
			SCB_ICSR = SCB_ICSR_PENDSVSET; // set PendSV interrupt
		} else {
			// detached, easy :-)
		}
		_triggered = true;
    edc6:	movs	r3, #1
    edc8:	strb	r3, [r0, #29]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    edca:	cbnz	r2, edce <EventResponder::triggerEventNotImmediate()+0x1e>
    edcc:	cpsie	i
	}
	enableInterrupts(irq);
}
    edce:	ldr.w	r4, [sp], #4
    edd2:	bx	lr
	bool irq = disableInterrupts();
	if (_triggered == false) {
		// not already triggered
		if (_type == EventTypeYield) {
			// normal type, called from yield()
			if (firstYield == nullptr) {
    edd4:	ldr	r4, [pc, #68]	; (ee1c <EventResponder::triggerEventNotImmediate()+0x6c>)
    edd6:	ldr	r1, [r4, #0]
    edd8:	cbz	r1, ee04 <EventResponder::triggerEventNotImmediate()+0x54>
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
				_prev = lastYield;
    edda:	ldr	r1, [pc, #68]	; (ee20 <EventResponder::triggerEventNotImmediate()+0x70>)
				_next = nullptr;
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
    eddc:	str	r3, [r0, #20]
				_prev = lastYield;
    edde:	ldr	r3, [r1, #0]
    ede0:	str	r3, [r0, #24]
				_prev->_next = this;
				lastYield = this;
    ede2:	str	r0, [r1, #0]
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
				_prev = lastYield;
				_prev->_next = this;
    ede4:	str	r0, [r3, #20]
    ede6:	b.n	edc6 <EventResponder::triggerEventNotImmediate()+0x16>
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
    ede8:	ldr	r4, [pc, #56]	; (ee24 <EventResponder::triggerEventNotImmediate()+0x74>)
    edea:	ldr	r1, [r4, #0]
    edec:	cbz	r1, ee10 <EventResponder::triggerEventNotImmediate()+0x60>
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
				_prev = lastInterrupt;
    edee:	ldr	r1, [pc, #56]	; (ee28 <EventResponder::triggerEventNotImmediate()+0x78>)
				_next = nullptr;
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
    edf0:	str	r3, [r0, #20]
				_prev = lastInterrupt;
    edf2:	ldr	r3, [r1, #0]
    edf4:	str	r3, [r0, #24]
				_prev->_next = this;
				lastInterrupt = this;
    edf6:	str	r0, [r1, #0]
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
				_prev = lastInterrupt;
				_prev->_next = this;
    edf8:	str	r0, [r3, #20]
				lastInterrupt = this;
			}
			SCB_ICSR = SCB_ICSR_PENDSVSET; // set PendSV interrupt
    edfa:	ldr	r3, [pc, #48]	; (ee2c <EventResponder::triggerEventNotImmediate()+0x7c>)
    edfc:	mov.w	r1, #268435456	; 0x10000000
    ee00:	str	r1, [r3, #0]
    ee02:	b.n	edc6 <EventResponder::triggerEventNotImmediate()+0x16>
			// normal type, called from yield()
			if (firstYield == nullptr) {
				_next = nullptr;
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
    ee04:	ldr	r3, [pc, #24]	; (ee20 <EventResponder::triggerEventNotImmediate()+0x70>)
	if (_triggered == false) {
		// not already triggered
		if (_type == EventTypeYield) {
			// normal type, called from yield()
			if (firstYield == nullptr) {
				_next = nullptr;
    ee06:	str	r1, [r0, #20]
				_prev = nullptr;
    ee08:	str	r1, [r0, #24]
				firstYield = this;
    ee0a:	str	r0, [r4, #0]
				lastYield = this;
    ee0c:	str	r0, [r3, #0]
    ee0e:	b.n	edc6 <EventResponder::triggerEventNotImmediate()+0x16>
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
				_next = nullptr;
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
    ee10:	ldr	r3, [pc, #20]	; (ee28 <EventResponder::triggerEventNotImmediate()+0x78>)
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
				_next = nullptr;
    ee12:	str	r1, [r0, #20]
				_prev = nullptr;
    ee14:	str	r1, [r0, #24]
				firstInterrupt = this;
    ee16:	str	r0, [r4, #0]
				lastInterrupt = this;
    ee18:	str	r0, [r3, #0]
    ee1a:	b.n	edfa <EventResponder::triggerEventNotImmediate()+0x4a>
    ee1c:	.word	0x1fff67d0
    ee20:	.word	0x1fff67cc
    ee24:	.word	0x1fff67c4
    ee28:	.word	0x1fff67c8
    ee2c:	.word	0xe000ed04

0000ee30 <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    ee30:	push	{r4, r5, r6, lr}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    ee32:	mrs	r2, PRIMASK
		__disable_irq();
    ee36:	cpsid	i
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    ee38:	ldr	r4, [pc, #48]	; (ee6c <EventResponder::runFromInterrupt()+0x3c>)
    ee3a:	ldr	r0, [r4, #0]
		if (first) {
    ee3c:	cbz	r0, ee60 <EventResponder::runFromInterrupt()+0x30>
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    ee3e:	ldr	r6, [pc, #48]	; (ee70 <EventResponder::runFromInterrupt()+0x40>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    ee40:	movs	r5, #0
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
    ee42:	ldr	r3, [r0, #20]
    ee44:	str	r3, [r4, #0]
			if (firstInterrupt) {
    ee46:	cbz	r3, ee66 <EventResponder::runFromInterrupt()+0x36>
				firstInterrupt->_prev = nullptr;
    ee48:	str	r5, [r3, #24]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    ee4a:	cbnz	r2, ee4e <EventResponder::runFromInterrupt()+0x1e>
    ee4c:	cpsie	i
			} else {
				lastInterrupt = nullptr;
			}
			enableInterrupts(irq);
			first->_triggered = false;
    ee4e:	strb	r5, [r0, #29]
			(*(first->_function))(*first);
    ee50:	ldr	r3, [r0, #8]
    ee52:	blx	r3
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    ee54:	mrs	r2, PRIMASK
		__disable_irq();
    ee58:	cpsid	i

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    ee5a:	ldr	r0, [r4, #0]
		if (first) {
    ee5c:	cmp	r0, #0
    ee5e:	bne.n	ee42 <EventResponder::runFromInterrupt()+0x12>
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    ee60:	cbnz	r2, ee64 <EventResponder::runFromInterrupt()+0x34>
    ee62:	cpsie	i
    ee64:	pop	{r4, r5, r6, pc}
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    ee66:	str	r3, [r6, #0]
    ee68:	b.n	ee4a <EventResponder::runFromInterrupt()+0x1a>
    ee6a:	nop
    ee6c:	.word	0x1fff67c4
    ee70:	.word	0x1fff67c8

0000ee74 <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
    ee74:	b.w	ee30 <EventResponder::runFromInterrupt()>

0000ee78 <systick_isr>:

extern "C" volatile uint32_t systick_millis_count;

void systick_isr(void)
{
	systick_millis_count++;
    ee78:	ldr	r2, [pc, #8]	; (ee84 <systick_isr+0xc>)
    ee7a:	ldr	r3, [r2, #0]
    ee7c:	adds	r3, #1
    ee7e:	str	r3, [r2, #0]
    ee80:	bx	lr
    ee82:	nop
    ee84:	.word	0x1fff66b0

0000ee88 <usb_serial_class::clear()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
    ee88:	b.w	d680 <usb_serial_flush_input>

0000ee8c <usb_serial_class::peek()>:
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
    ee8c:	b.w	d634 <usb_serial_peekchar>

0000ee90 <usb_serial_class::read()>:
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    ee90:	b.w	d5ec <usb_serial_getchar>

0000ee94 <usb_serial_class::available()>:
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    ee94:	b.w	d664 <usb_serial_available>

0000ee98 <usb_serial_class::flush()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    ee98:	b.w	d820 <usb_serial_flush_output>

0000ee9c <usb_serial_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
	size_t write(unsigned long n) { return write((uint8_t)n); }
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    ee9c:	b.w	d7d8 <usb_serial_write_buffer_free>

0000eea0 <usb_serial_class::write(unsigned char const*, unsigned int)>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    eea0:	mov	r0, r1
    eea2:	mov	r1, r2
    eea4:	b.w	d6b8 <usb_serial_write>

0000eea8 <usb_serial_class::write(unsigned char)>:
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    eea8:	mov	r0, r1
    eeaa:	b.w	d7c0 <usb_serial_putchar>
    eeae:	nop

0000eeb0 <Print::write(unsigned char const*, unsigned int)>:

#include <Arduino.h>


size_t Print::write(const uint8_t *buffer, size_t size)
{
    eeb0:	push	{r3, r4, r5, r6, r7, lr}
	if (buffer == nullptr) return 0;
    eeb2:	mov	r6, r1
    eeb4:	cbz	r1, eed4 <Print::write(unsigned char const*, unsigned int)+0x24>
	size_t count = 0;
	while (size--) count += write(*buffer++);
    eeb6:	cbz	r2, eed8 <Print::write(unsigned char const*, unsigned int)+0x28>
    eeb8:	mov	r7, r0
    eeba:	mov	r4, r2
    eebc:	movs	r5, #0
    eebe:	ldr	r3, [r7, #0]
    eec0:	ldrb.w	r1, [r6], #1
    eec4:	ldr	r3, [r3, #0]
    eec6:	mov	r0, r7
    eec8:	blx	r3
    eeca:	subs	r4, #1
    eecc:	add	r5, r0
    eece:	bne.n	eebe <Print::write(unsigned char const*, unsigned int)+0xe>
    eed0:	mov	r0, r5
    eed2:	pop	{r3, r4, r5, r6, r7, pc}
#include <Arduino.h>


size_t Print::write(const uint8_t *buffer, size_t size)
{
	if (buffer == nullptr) return 0;
    eed4:	mov	r0, r1
    eed6:	pop	{r3, r4, r5, r6, r7, pc}
    eed8:	mov	r0, r2
	size_t count = 0;
	while (size--) count += write(*buffer++);
	return count;
}
    eeda:	pop	{r3, r4, r5, r6, r7, pc}

0000eedc <Print::println()>:
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    eedc:	push	{lr}
	uint8_t buf[2]={'\r', '\n'};
    eede:	ldr	r2, [pc, #24]	; (eef8 <Print::println()+0x1c>)
	return write(buf, 2);
    eee0:	ldr	r3, [r0, #0]
}


size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    eee2:	ldrh	r2, [r2, #0]
	return write(buf, 2);
    eee4:	ldr	r3, [r3, #4]
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    eee6:	sub	sp, #12
	uint8_t buf[2]={'\r', '\n'};
	return write(buf, 2);
    eee8:	add	r1, sp, #4
}


size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    eeea:	strh.w	r2, [sp, #4]
	return write(buf, 2);
    eeee:	movs	r2, #2
    eef0:	blx	r3
}
    eef2:	add	sp, #12
    eef4:	ldr.w	pc, [sp], #4
    eef8:	.word	0x000149c4

0000eefc <_write>:

extern "C" {
__attribute__((weak))
int _write(int file, char *ptr, int len)
{
    eefc:	push	{r4, lr}
	((class Print *)file)->write((uint8_t *)ptr, len);
    eefe:	ldr	r3, [r0, #0]
}

extern "C" {
__attribute__((weak))
int _write(int file, char *ptr, int len)
{
    ef00:	mov	r4, r2
	((class Print *)file)->write((uint8_t *)ptr, len);
    ef02:	ldr	r3, [r3, #4]
    ef04:	blx	r3
	return len;
}
    ef06:	mov	r0, r4
    ef08:	pop	{r4, pc}
    ef0a:	nop

0000ef0c <Print::printf(char const*, ...)>:
}

int Print::printf(const char *format, ...)
{
    ef0c:	push	{r1, r2, r3}
    ef0e:	push	{lr}
    ef10:	sub	sp, #8
    ef12:	add	r2, sp, #12
    ef14:	ldr.w	r1, [r2], #4
	va_list ap;
	va_start(ap, format);
    ef18:	str	r2, [sp, #4]
#ifdef __STRICT_ANSI__
	return 0;  // TODO: make this work with -std=c++0x
#else
	return vdprintf((int)this, format, ap);
    ef1a:	bl	124b0 <vdprintf>
#endif
}
    ef1e:	add	sp, #8
    ef20:	ldr.w	lr, [sp], #4
    ef24:	add	sp, #12
    ef26:	bx	lr

0000ef28 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>:
	if (n < 0) return printNumber64(-n, 10, 1);
	return printNumber64(n, 10, 0);
}

size_t Print::printNumber64(uint64_t n, uint8_t base, uint8_t sign)
{
    ef28:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    ef2c:	sub	sp, #72	; 0x48
    ef2e:	ldrb.w	r6, [sp, #104]	; 0x68
    ef32:	ldrb.w	sl, [sp, #108]	; 0x6c
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
    ef36:	cmp	r6, #1
    ef38:	bls.n	efda <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0xb2>
    ef3a:	mov	r4, r2
    ef3c:	mov	r5, r3
	if (n == 0) {
    ef3e:	orrs.w	r3, r4, r5
    ef42:	mov	r9, r0
    ef44:	beq.n	efce <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0xa6>
    ef46:	uxtb	r6, r6
    ef48:	movs	r7, #0
    ef4a:	mov.w	r8, #65	; 0x41
    ef4e:	b.n	ef54 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x2c>
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
			n /= base;
			if (n == 0) break;
			i--;
    ef50:	uxtb.w	r8, r3
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    ef54:	mov	r0, r4
    ef56:	mov	r1, r5
    ef58:	mov	r2, r6
    ef5a:	mov	r3, r7
    ef5c:	bl	fa0c <__aeabi_uldivmod>
    ef60:	mov	r1, r3
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    ef62:	cmp	r1, #0
    ef64:	it	eq
    ef66:	cmpeq	r2, #10
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    ef68:	uxtb	r3, r2
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
			n /= base;
    ef6a:	mov	r0, r4
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    ef6c:	add	r4, sp, #72	; 0x48
    ef6e:	add.w	lr, r3, #48	; 0x30
    ef72:	add	r4, r8
    ef74:	itte	cs
    ef76:	addcs	r3, #55	; 0x37
    ef78:	uxtbcs.w	lr, r3
    ef7c:	uxtbcc.w	lr, lr
			n /= base;
    ef80:	mov	r3, r7
    ef82:	mov	r1, r5
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    ef84:	strb.w	lr, [r4, #-68]
			n /= base;
    ef88:	mov	r2, r6
    ef8a:	bl	fa0c <__aeabi_uldivmod>
    ef8e:	mov	r4, r0
    ef90:	mov	r5, r1
			if (n == 0) break;
    ef92:	orrs.w	r3, r4, r5
			i--;
    ef96:	add.w	r3, r8, #4294967295
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
			n /= base;
			if (n == 0) break;
    ef9a:	bne.n	ef50 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x28>
			i--;
		}
	}
	if (sign) {
    ef9c:	cmp.w	sl, #0
    efa0:	beq.n	efb4 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x8c>
		i--;
    efa2:	add.w	r8, r8, #4294967295
    efa6:	uxtb.w	r8, r8
		buf[i] = '-';
    efaa:	add	r3, sp, #72	; 0x48
    efac:	add	r3, r8
    efae:	movs	r2, #45	; 0x2d
    efb0:	strb.w	r2, [r3, #-68]
	}
	return write(buf + i, sizeof(buf) - i);
    efb4:	ldr.w	r3, [r9]
    efb8:	add	r2, sp, #4
    efba:	add.w	r1, r2, r8
    efbe:	ldr	r3, [r3, #4]
    efc0:	mov	r0, r9
    efc2:	rsb	r2, r8, #66	; 0x42
    efc6:	blx	r3
}
    efc8:	add	sp, #72	; 0x48
    efca:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
    efce:	movs	r3, #48	; 0x30
    efd0:	strb.w	r3, [sp, #69]	; 0x45
		i = sizeof(buf) - 1;
    efd4:	mov.w	r8, #65	; 0x41
    efd8:	b.n	ef9c <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x74>
size_t Print::printNumber64(uint64_t n, uint8_t base, uint8_t sign)
{
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
    efda:	movs	r0, #0
	if (sign) {
		i--;
		buf[i] = '-';
	}
	return write(buf + i, sizeof(buf) - i);
}
    efdc:	add	sp, #72	; 0x48
    efde:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    efe2:	nop

0000efe4 <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    efe4:	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    efe6:	bl	1c3c <setup>
	while (1) {
		loop();
    efea:	bl	1a00 <loop>
		yield();
    efee:	bl	ebc4 <yield>
    eff2:	b.n	efea <main+0x6>

0000eff4 <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
    eff4:	bx	lr
    eff6:	nop

0000eff8 <operator new(unsigned int)>:
    eff8:	b.w	fe10 <malloc>

0000effc <operator delete(void*, unsigned int)>:
    effc:	b.w	fe20 <free>

0000f000 <analog_init>:
#else
#error "F_BUS must be 128, 120, 108, 96, 90, 80, 72, 64, 60, 56, 54, 48, 40, 36, 24, 4 or 2 MHz"
#endif

void analog_init(void)
{
    f000:	push	{r4, r5}
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    f002:	ldr	r0, [pc, #164]	; (f0a8 <analog_init+0xa8>)
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    f004:	ldr	r2, [pc, #164]	; (f0ac <analog_init+0xac>)
	#endif

	if (analog_config_bits == 8) {
    f006:	ldr	r3, [pc, #168]	; (f0b0 <analog_init+0xb0>)
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    f008:	ldr	r5, [pc, #168]	; (f0b4 <analog_init+0xb4>)
void analog_init(void)
{
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    f00a:	movs	r4, #96	; 0x60
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    f00c:	movs	r1, #225	; 0xe1
void analog_init(void)
{
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    f00e:	strb	r4, [r0, #0]
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    f010:	strb	r1, [r2, #0]
	#endif

	if (analog_config_bits == 8) {
    f012:	ldrb	r3, [r3, #0]
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    f014:	ldr	r4, [pc, #160]	; (f0b8 <analog_init+0xb8>)
	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
    f016:	cmp	r3, #8
    f018:	beq.n	f07c <analog_init+0x7c>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    f01a:	cmp	r3, #10
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    f01c:	ldr	r0, [pc, #156]	; (f0bc <analog_init+0xbc>)
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    f01e:	ldr	r1, [pc, #160]	; (f0c0 <analog_init+0xc0>)
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    f020:	beq.n	f092 <analog_init+0x92>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 12) {
    f022:	cmp	r3, #12
		ADC0_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
    f024:	ite	eq
    f026:	moveq	r2, #53	; 0x35
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    f028:	movne	r2, #61	; 0x3d
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    f02a:	movs	r3, #18
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    f02c:	str	r2, [r5, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    f02e:	str	r3, [r4, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    f030:	str	r2, [r0, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    f032:	str	r3, [r1, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    f034:	ldr	r3, [pc, #140]	; (f0c4 <analog_init+0xc4>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    f036:	ldr	r1, [pc, #144]	; (f0c8 <analog_init+0xc8>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    f038:	ldrb	r3, [r3, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    f03a:	ldr	r2, [pc, #144]	; (f0cc <analog_init+0xcc>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    f03c:	cbz	r3, f06e <analog_init+0x6e>
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    f03e:	movs	r3, #1
    f040:	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    f042:	str	r3, [r2, #0]
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    f044:	ldr	r3, [pc, #136]	; (f0d0 <analog_init+0xd0>)
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    f046:	ldr	r1, [pc, #140]	; (f0d4 <analog_init+0xd4>)
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    f048:	ldrb	r3, [r3, #0]
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    f04a:	ldr	r2, [pc, #140]	; (f0d8 <analog_init+0xd8>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
	if (num <= 1) {
    f04c:	cmp	r3, #1
    f04e:	bls.n	f09e <analog_init+0x9e>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
    f050:	cmp	r3, #4
    f052:	bls.n	f074 <analog_init+0x74>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
    f054:	cmp	r3, #8
    f056:	bls.n	f096 <analog_init+0x96>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#endif
	} else if (num <= 16) {
    f058:	cmp	r3, #16
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
    f05a:	ite	ls
    f05c:	movls	r3, #134	; 0x86
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
		#endif
	} else {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    f05e:	movhi	r3, #135	; 0x87
    f060:	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    f062:	str	r3, [r2, #0]
		#endif
	}
	calibrating = 1;
    f064:	ldr	r3, [pc, #116]	; (f0dc <analog_init+0xdc>)
    f066:	movs	r2, #1
    f068:	strb	r2, [r3, #0]
}
    f06a:	pop	{r4, r5}
    f06c:	bx	lr
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    f06e:	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    f070:	str	r3, [r2, #0]
    f072:	b.n	f044 <analog_init+0x44>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    f074:	movs	r3, #132	; 0x84
    f076:	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    f078:	str	r3, [r2, #0]
    f07a:	b.n	f064 <analog_init+0x64>

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    f07c:	add.w	r0, r0, #290816	; 0x47000
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    f080:	ldr	r1, [pc, #60]	; (f0c0 <analog_init+0xc0>)

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    f082:	adds	r0, #8
	VREF_TRM = 0x60;
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    f084:	movs	r2, #1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    f086:	movs	r3, #19
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    f088:	str	r2, [r5, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    f08a:	str	r3, [r4, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    f08c:	str	r2, [r0, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    f08e:	str	r3, [r1, #0]
    f090:	b.n	f034 <analog_init+0x34>
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    f092:	movs	r2, #57	; 0x39
    f094:	b.n	f086 <analog_init+0x86>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    f096:	movs	r3, #133	; 0x85
    f098:	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    f09a:	str	r3, [r2, #0]
    f09c:	b.n	f064 <analog_init+0x64>
	}
	#endif

	num = analog_num_average;
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    f09e:	movs	r3, #128	; 0x80
    f0a0:	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    f0a2:	str	r3, [r2, #0]
    f0a4:	b.n	f064 <analog_init+0x64>
    f0a6:	nop
    f0a8:	.word	0x40074000
    f0ac:	.word	0x40074001
    f0b0:	.word	0x1fff0ae1
    f0b4:	.word	0x4003b008
    f0b8:	.word	0x4003b00c
    f0bc:	.word	0x400bb008
    f0c0:	.word	0x400bb00c
    f0c4:	.word	0x1fff67f2
    f0c8:	.word	0x4003b020
    f0cc:	.word	0x400bb020
    f0d0:	.word	0x1fff0ae2
    f0d4:	.word	0x4003b024
    f0d8:	.word	0x400bb024
    f0dc:	.word	0x1fff67f1

0000f0e0 <__aeabi_atexit>:
    f0e0:	mov	r3, r1
    f0e2:	mov	r1, r0
    f0e4:	mov	r0, r3
    f0e6:	b.w	fd84 <__cxa_atexit>
    f0ea:	nop

0000f0ec <__aeabi_drsub>:
    f0ec:	eor.w	r1, r1, #2147483648	; 0x80000000
    f0f0:	b.n	f0f8 <__adddf3>
    f0f2:	nop

0000f0f4 <__aeabi_dsub>:
    f0f4:	eor.w	r3, r3, #2147483648	; 0x80000000

0000f0f8 <__adddf3>:
    f0f8:	push	{r4, r5, lr}
    f0fa:	mov.w	r4, r1, lsl #1
    f0fe:	mov.w	r5, r3, lsl #1
    f102:	teq	r4, r5
    f106:	it	eq
    f108:	teqeq	r0, r2
    f10c:	itttt	ne
    f10e:	orrsne.w	ip, r4, r0
    f112:	orrsne.w	ip, r5, r2
    f116:	mvnsne.w	ip, r4, asr #21
    f11a:	mvnsne.w	ip, r5, asr #21
    f11e:	beq.w	f2e6 <__adddf3+0x1ee>
    f122:	mov.w	r4, r4, lsr #21
    f126:	rsbs	r5, r4, r5, lsr #21
    f12a:	it	lt
    f12c:	neglt	r5, r5
    f12e:	ble.n	f14a <__adddf3+0x52>
    f130:	add	r4, r5
    f132:	eor.w	r2, r0, r2
    f136:	eor.w	r3, r1, r3
    f13a:	eor.w	r0, r2, r0
    f13e:	eor.w	r1, r3, r1
    f142:	eor.w	r2, r0, r2
    f146:	eor.w	r3, r1, r3
    f14a:	cmp	r5, #54	; 0x36
    f14c:	it	hi
    f14e:	pophi	{r4, r5, pc}
    f150:	tst.w	r1, #2147483648	; 0x80000000
    f154:	mov.w	r1, r1, lsl #12
    f158:	mov.w	ip, #1048576	; 0x100000
    f15c:	orr.w	r1, ip, r1, lsr #12
    f160:	beq.n	f168 <__adddf3+0x70>
    f162:	negs	r0, r0
    f164:	sbc.w	r1, r1, r1, lsl #1
    f168:	tst.w	r3, #2147483648	; 0x80000000
    f16c:	mov.w	r3, r3, lsl #12
    f170:	orr.w	r3, ip, r3, lsr #12
    f174:	beq.n	f17c <__adddf3+0x84>
    f176:	negs	r2, r2
    f178:	sbc.w	r3, r3, r3, lsl #1
    f17c:	teq	r4, r5
    f180:	beq.w	f2d2 <__adddf3+0x1da>
    f184:	sub.w	r4, r4, #1
    f188:	rsbs	lr, r5, #32
    f18c:	blt.n	f1aa <__adddf3+0xb2>
    f18e:	lsl.w	ip, r2, lr
    f192:	lsr.w	r2, r2, r5
    f196:	adds	r0, r0, r2
    f198:	adc.w	r1, r1, #0
    f19c:	lsl.w	r2, r3, lr
    f1a0:	adds	r0, r0, r2
    f1a2:	asr.w	r3, r3, r5
    f1a6:	adcs	r1, r3
    f1a8:	b.n	f1c8 <__adddf3+0xd0>
    f1aa:	sub.w	r5, r5, #32
    f1ae:	add.w	lr, lr, #32
    f1b2:	cmp	r2, #1
    f1b4:	lsl.w	ip, r3, lr
    f1b8:	it	cs
    f1ba:	orrcs.w	ip, ip, #2
    f1be:	asr.w	r3, r3, r5
    f1c2:	adds	r0, r0, r3
    f1c4:	adcs.w	r1, r1, r3, asr #31
    f1c8:	and.w	r5, r1, #2147483648	; 0x80000000
    f1cc:	bpl.n	f1de <__adddf3+0xe6>
    f1ce:	mov.w	lr, #0
    f1d2:	rsbs	ip, ip, #0
    f1d6:	sbcs.w	r0, lr, r0
    f1da:	sbc.w	r1, lr, r1
    f1de:	cmp.w	r1, #1048576	; 0x100000
    f1e2:	bcc.n	f21c <__adddf3+0x124>
    f1e4:	cmp.w	r1, #2097152	; 0x200000
    f1e8:	bcc.n	f204 <__adddf3+0x10c>
    f1ea:	lsrs	r1, r1, #1
    f1ec:	movs.w	r0, r0, rrx
    f1f0:	mov.w	ip, ip, rrx
    f1f4:	add.w	r4, r4, #1
    f1f8:	mov.w	r2, r4, lsl #21
    f1fc:	cmn.w	r2, #4194304	; 0x400000
    f200:	bcs.w	f338 <__adddf3+0x240>
    f204:	cmp.w	ip, #2147483648	; 0x80000000
    f208:	it	eq
    f20a:	movseq.w	ip, r0, lsr #1
    f20e:	adcs.w	r0, r0, #0
    f212:	adc.w	r1, r1, r4, lsl #20
    f216:	orr.w	r1, r1, r5
    f21a:	pop	{r4, r5, pc}
    f21c:	movs.w	ip, ip, lsl #1
    f220:	adcs	r0, r0
    f222:	adc.w	r1, r1, r1
    f226:	tst.w	r1, #1048576	; 0x100000
    f22a:	sub.w	r4, r4, #1
    f22e:	bne.n	f204 <__adddf3+0x10c>
    f230:	teq	r1, #0
    f234:	itt	eq
    f236:	moveq	r1, r0
    f238:	moveq	r0, #0
    f23a:	clz	r3, r1
    f23e:	it	eq
    f240:	addeq	r3, #32
    f242:	sub.w	r3, r3, #11
    f246:	subs.w	r2, r3, #32
    f24a:	bge.n	f266 <__adddf3+0x16e>
    f24c:	adds	r2, #12
    f24e:	ble.n	f262 <__adddf3+0x16a>
    f250:	add.w	ip, r2, #20
    f254:	rsb	r2, r2, #12
    f258:	lsl.w	r0, r1, ip
    f25c:	lsr.w	r1, r1, r2
    f260:	b.n	f27c <__adddf3+0x184>
    f262:	add.w	r2, r2, #20
    f266:	it	le
    f268:	rsble	ip, r2, #32
    f26c:	lsl.w	r1, r1, r2
    f270:	lsr.w	ip, r0, ip
    f274:	itt	le
    f276:	orrle.w	r1, r1, ip
    f27a:	lslle	r0, r2
    f27c:	subs	r4, r4, r3
    f27e:	ittt	ge
    f280:	addge.w	r1, r1, r4, lsl #20
    f284:	orrge	r1, r5
    f286:	popge	{r4, r5, pc}
    f288:	mvn.w	r4, r4
    f28c:	subs	r4, #31
    f28e:	bge.n	f2ca <__adddf3+0x1d2>
    f290:	adds	r4, #12
    f292:	bgt.n	f2b2 <__adddf3+0x1ba>
    f294:	add.w	r4, r4, #20
    f298:	rsb	r2, r4, #32
    f29c:	lsr.w	r0, r0, r4
    f2a0:	lsl.w	r3, r1, r2
    f2a4:	orr.w	r0, r0, r3
    f2a8:	lsr.w	r3, r1, r4
    f2ac:	orr.w	r1, r5, r3
    f2b0:	pop	{r4, r5, pc}
    f2b2:	rsb	r4, r4, #12
    f2b6:	rsb	r2, r4, #32
    f2ba:	lsr.w	r0, r0, r2
    f2be:	lsl.w	r3, r1, r4
    f2c2:	orr.w	r0, r0, r3
    f2c6:	mov	r1, r5
    f2c8:	pop	{r4, r5, pc}
    f2ca:	lsr.w	r0, r1, r4
    f2ce:	mov	r1, r5
    f2d0:	pop	{r4, r5, pc}
    f2d2:	teq	r4, #0
    f2d6:	eor.w	r3, r3, #1048576	; 0x100000
    f2da:	itte	eq
    f2dc:	eoreq.w	r1, r1, #1048576	; 0x100000
    f2e0:	addeq	r4, #1
    f2e2:	subne	r5, #1
    f2e4:	b.n	f184 <__adddf3+0x8c>
    f2e6:	mvns.w	ip, r4, asr #21
    f2ea:	it	ne
    f2ec:	mvnsne.w	ip, r5, asr #21
    f2f0:	beq.n	f346 <__adddf3+0x24e>
    f2f2:	teq	r4, r5
    f2f6:	it	eq
    f2f8:	teqeq	r0, r2
    f2fc:	beq.n	f30a <__adddf3+0x212>
    f2fe:	orrs.w	ip, r4, r0
    f302:	itt	eq
    f304:	moveq	r1, r3
    f306:	moveq	r0, r2
    f308:	pop	{r4, r5, pc}
    f30a:	teq	r1, r3
    f30e:	ittt	ne
    f310:	movne	r1, #0
    f312:	movne	r0, #0
    f314:	popne	{r4, r5, pc}
    f316:	movs.w	ip, r4, lsr #21
    f31a:	bne.n	f328 <__adddf3+0x230>
    f31c:	lsls	r0, r0, #1
    f31e:	adcs	r1, r1
    f320:	it	cs
    f322:	orrcs.w	r1, r1, #2147483648	; 0x80000000
    f326:	pop	{r4, r5, pc}
    f328:	adds.w	r4, r4, #4194304	; 0x400000
    f32c:	itt	cc
    f32e:	addcc.w	r1, r1, #1048576	; 0x100000
    f332:	popcc	{r4, r5, pc}
    f334:	and.w	r5, r1, #2147483648	; 0x80000000
    f338:	orr.w	r1, r5, #2130706432	; 0x7f000000
    f33c:	orr.w	r1, r1, #15728640	; 0xf00000
    f340:	mov.w	r0, #0
    f344:	pop	{r4, r5, pc}
    f346:	mvns.w	ip, r4, asr #21
    f34a:	itte	ne
    f34c:	movne	r1, r3
    f34e:	movne	r0, r2
    f350:	mvnseq.w	ip, r5, asr #21
    f354:	itt	ne
    f356:	movne	r3, r1
    f358:	movne	r2, r0
    f35a:	orrs.w	r4, r0, r1, lsl #12
    f35e:	itte	eq
    f360:	orrseq.w	r5, r2, r3, lsl #12
    f364:	teqeq	r1, r3
    f368:	orrne.w	r1, r1, #524288	; 0x80000
    f36c:	pop	{r4, r5, pc}
    f36e:	nop

0000f370 <__aeabi_ui2d>:
    f370:	teq	r0, #0
    f374:	itt	eq
    f376:	moveq	r1, #0
    f378:	bxeq	lr
    f37a:	push	{r4, r5, lr}
    f37c:	mov.w	r4, #1024	; 0x400
    f380:	add.w	r4, r4, #50	; 0x32
    f384:	mov.w	r5, #0
    f388:	mov.w	r1, #0
    f38c:	b.n	f230 <__adddf3+0x138>
    f38e:	nop

0000f390 <__aeabi_i2d>:
    f390:	teq	r0, #0
    f394:	itt	eq
    f396:	moveq	r1, #0
    f398:	bxeq	lr
    f39a:	push	{r4, r5, lr}
    f39c:	mov.w	r4, #1024	; 0x400
    f3a0:	add.w	r4, r4, #50	; 0x32
    f3a4:	ands.w	r5, r0, #2147483648	; 0x80000000
    f3a8:	it	mi
    f3aa:	negmi	r0, r0
    f3ac:	mov.w	r1, #0
    f3b0:	b.n	f230 <__adddf3+0x138>
    f3b2:	nop

0000f3b4 <__aeabi_f2d>:
    f3b4:	lsls	r2, r0, #1
    f3b6:	mov.w	r1, r2, asr #3
    f3ba:	mov.w	r1, r1, rrx
    f3be:	mov.w	r0, r2, lsl #28
    f3c2:	itttt	ne
    f3c4:	andsne.w	r3, r2, #4278190080	; 0xff000000
    f3c8:	teqne	r3, #4278190080	; 0xff000000
    f3cc:	eorne.w	r1, r1, #939524096	; 0x38000000
    f3d0:	bxne	lr
    f3d2:	teq	r2, #0
    f3d6:	ite	ne
    f3d8:	teqne	r3, #4278190080	; 0xff000000
    f3dc:	bxeq	lr
    f3de:	push	{r4, r5, lr}
    f3e0:	mov.w	r4, #896	; 0x380
    f3e4:	and.w	r5, r1, #2147483648	; 0x80000000
    f3e8:	bic.w	r1, r1, #2147483648	; 0x80000000
    f3ec:	b.n	f230 <__adddf3+0x138>
    f3ee:	nop

0000f3f0 <__aeabi_ul2d>:
    f3f0:	orrs.w	r2, r0, r1
    f3f4:	it	eq
    f3f6:	bxeq	lr
    f3f8:	push	{r4, r5, lr}
    f3fa:	mov.w	r5, #0
    f3fe:	b.n	f416 <__aeabi_l2d+0x16>

0000f400 <__aeabi_l2d>:
    f400:	orrs.w	r2, r0, r1
    f404:	it	eq
    f406:	bxeq	lr
    f408:	push	{r4, r5, lr}
    f40a:	ands.w	r5, r1, #2147483648	; 0x80000000
    f40e:	bpl.n	f416 <__aeabi_l2d+0x16>
    f410:	negs	r0, r0
    f412:	sbc.w	r1, r1, r1, lsl #1
    f416:	mov.w	r4, #1024	; 0x400
    f41a:	add.w	r4, r4, #50	; 0x32
    f41e:	movs.w	ip, r1, lsr #22
    f422:	beq.w	f1de <__adddf3+0xe6>
    f426:	mov.w	r2, #3
    f42a:	movs.w	ip, ip, lsr #3
    f42e:	it	ne
    f430:	addne	r2, #3
    f432:	movs.w	ip, ip, lsr #3
    f436:	it	ne
    f438:	addne	r2, #3
    f43a:	add.w	r2, r2, ip, lsr #3
    f43e:	rsb	r3, r2, #32
    f442:	lsl.w	ip, r0, r3
    f446:	lsr.w	r0, r0, r2
    f44a:	lsl.w	lr, r1, r3
    f44e:	orr.w	r0, r0, lr
    f452:	lsr.w	r1, r1, r2
    f456:	add	r4, r2
    f458:	b.n	f1de <__adddf3+0xe6>
    f45a:	nop

0000f45c <__aeabi_dmul>:
    f45c:	push	{r4, r5, r6, lr}
    f45e:	mov.w	ip, #255	; 0xff
    f462:	orr.w	ip, ip, #1792	; 0x700
    f466:	ands.w	r4, ip, r1, lsr #20
    f46a:	ittte	ne
    f46c:	andsne.w	r5, ip, r3, lsr #20
    f470:	teqne	r4, ip
    f474:	teqne	r5, ip
    f478:	bleq	f638 <__aeabi_dmul+0x1dc>
    f47c:	add	r4, r5
    f47e:	eor.w	r6, r1, r3
    f482:	bic.w	r1, r1, ip, lsl #21
    f486:	bic.w	r3, r3, ip, lsl #21
    f48a:	orrs.w	r5, r0, r1, lsl #12
    f48e:	it	ne
    f490:	orrsne.w	r5, r2, r3, lsl #12
    f494:	orr.w	r1, r1, #1048576	; 0x100000
    f498:	orr.w	r3, r3, #1048576	; 0x100000
    f49c:	beq.n	f510 <__aeabi_dmul+0xb4>
    f49e:	umull	ip, lr, r0, r2
    f4a2:	mov.w	r5, #0
    f4a6:	umlal	lr, r5, r1, r2
    f4aa:	and.w	r2, r6, #2147483648	; 0x80000000
    f4ae:	umlal	lr, r5, r0, r3
    f4b2:	mov.w	r6, #0
    f4b6:	umlal	r5, r6, r1, r3
    f4ba:	teq	ip, #0
    f4be:	it	ne
    f4c0:	orrne.w	lr, lr, #1
    f4c4:	sub.w	r4, r4, #255	; 0xff
    f4c8:	cmp.w	r6, #512	; 0x200
    f4cc:	sbc.w	r4, r4, #768	; 0x300
    f4d0:	bcs.n	f4dc <__aeabi_dmul+0x80>
    f4d2:	movs.w	lr, lr, lsl #1
    f4d6:	adcs	r5, r5
    f4d8:	adc.w	r6, r6, r6
    f4dc:	orr.w	r1, r2, r6, lsl #11
    f4e0:	orr.w	r1, r1, r5, lsr #21
    f4e4:	mov.w	r0, r5, lsl #11
    f4e8:	orr.w	r0, r0, lr, lsr #21
    f4ec:	mov.w	lr, lr, lsl #11
    f4f0:	subs.w	ip, r4, #253	; 0xfd
    f4f4:	it	hi
    f4f6:	cmphi.w	ip, #1792	; 0x700
    f4fa:	bhi.n	f53a <__aeabi_dmul+0xde>
    f4fc:	cmp.w	lr, #2147483648	; 0x80000000
    f500:	it	eq
    f502:	movseq.w	lr, r0, lsr #1
    f506:	adcs.w	r0, r0, #0
    f50a:	adc.w	r1, r1, r4, lsl #20
    f50e:	pop	{r4, r5, r6, pc}
    f510:	and.w	r6, r6, #2147483648	; 0x80000000
    f514:	orr.w	r1, r6, r1
    f518:	orr.w	r0, r0, r2
    f51c:	eor.w	r1, r1, r3
    f520:	subs.w	r4, r4, ip, lsr #1
    f524:	ittt	gt
    f526:	rsbsgt	r5, r4, ip
    f52a:	orrgt.w	r1, r1, r4, lsl #20
    f52e:	popgt	{r4, r5, r6, pc}
    f530:	orr.w	r1, r1, #1048576	; 0x100000
    f534:	mov.w	lr, #0
    f538:	subs	r4, #1
    f53a:	bgt.w	f694 <__aeabi_dmul+0x238>
    f53e:	cmn.w	r4, #54	; 0x36
    f542:	ittt	le
    f544:	movle	r0, #0
    f546:	andle.w	r1, r1, #2147483648	; 0x80000000
    f54a:	pople	{r4, r5, r6, pc}
    f54c:	rsb	r4, r4, #0
    f550:	subs	r4, #32
    f552:	bge.n	f5c0 <__aeabi_dmul+0x164>
    f554:	adds	r4, #12
    f556:	bgt.n	f590 <__aeabi_dmul+0x134>
    f558:	add.w	r4, r4, #20
    f55c:	rsb	r5, r4, #32
    f560:	lsl.w	r3, r0, r5
    f564:	lsr.w	r0, r0, r4
    f568:	lsl.w	r2, r1, r5
    f56c:	orr.w	r0, r0, r2
    f570:	and.w	r2, r1, #2147483648	; 0x80000000
    f574:	bic.w	r1, r1, #2147483648	; 0x80000000
    f578:	adds.w	r0, r0, r3, lsr #31
    f57c:	lsr.w	r6, r1, r4
    f580:	adc.w	r1, r2, r6
    f584:	orrs.w	lr, lr, r3, lsl #1
    f588:	it	eq
    f58a:	biceq.w	r0, r0, r3, lsr #31
    f58e:	pop	{r4, r5, r6, pc}
    f590:	rsb	r4, r4, #12
    f594:	rsb	r5, r4, #32
    f598:	lsl.w	r3, r0, r4
    f59c:	lsr.w	r0, r0, r5
    f5a0:	lsl.w	r2, r1, r4
    f5a4:	orr.w	r0, r0, r2
    f5a8:	and.w	r1, r1, #2147483648	; 0x80000000
    f5ac:	adds.w	r0, r0, r3, lsr #31
    f5b0:	adc.w	r1, r1, #0
    f5b4:	orrs.w	lr, lr, r3, lsl #1
    f5b8:	it	eq
    f5ba:	biceq.w	r0, r0, r3, lsr #31
    f5be:	pop	{r4, r5, r6, pc}
    f5c0:	rsb	r5, r4, #32
    f5c4:	lsl.w	r2, r0, r5
    f5c8:	orr.w	lr, lr, r2
    f5cc:	lsr.w	r3, r0, r4
    f5d0:	lsl.w	r2, r1, r5
    f5d4:	orr.w	r3, r3, r2
    f5d8:	lsr.w	r0, r1, r4
    f5dc:	and.w	r1, r1, #2147483648	; 0x80000000
    f5e0:	lsr.w	r2, r1, r4
    f5e4:	bic.w	r0, r0, r2
    f5e8:	add.w	r0, r0, r3, lsr #31
    f5ec:	orrs.w	lr, lr, r3, lsl #1
    f5f0:	it	eq
    f5f2:	biceq.w	r0, r0, r3, lsr #31
    f5f6:	pop	{r4, r5, r6, pc}
    f5f8:	teq	r4, #0
    f5fc:	bne.n	f61e <__aeabi_dmul+0x1c2>
    f5fe:	and.w	r6, r1, #2147483648	; 0x80000000
    f602:	lsls	r0, r0, #1
    f604:	adc.w	r1, r1, r1
    f608:	tst.w	r1, #1048576	; 0x100000
    f60c:	it	eq
    f60e:	subeq	r4, #1
    f610:	beq.n	f602 <__aeabi_dmul+0x1a6>
    f612:	orr.w	r1, r1, r6
    f616:	teq	r5, #0
    f61a:	it	ne
    f61c:	bxne	lr
    f61e:	and.w	r6, r3, #2147483648	; 0x80000000
    f622:	lsls	r2, r2, #1
    f624:	adc.w	r3, r3, r3
    f628:	tst.w	r3, #1048576	; 0x100000
    f62c:	it	eq
    f62e:	subeq	r5, #1
    f630:	beq.n	f622 <__aeabi_dmul+0x1c6>
    f632:	orr.w	r3, r3, r6
    f636:	bx	lr
    f638:	teq	r4, ip
    f63c:	and.w	r5, ip, r3, lsr #20
    f640:	it	ne
    f642:	teqne	r5, ip
    f646:	beq.n	f662 <__aeabi_dmul+0x206>
    f648:	orrs.w	r6, r0, r1, lsl #1
    f64c:	it	ne
    f64e:	orrsne.w	r6, r2, r3, lsl #1
    f652:	bne.n	f5f8 <__aeabi_dmul+0x19c>
    f654:	eor.w	r1, r1, r3
    f658:	and.w	r1, r1, #2147483648	; 0x80000000
    f65c:	mov.w	r0, #0
    f660:	pop	{r4, r5, r6, pc}
    f662:	orrs.w	r6, r0, r1, lsl #1
    f666:	itte	eq
    f668:	moveq	r0, r2
    f66a:	moveq	r1, r3
    f66c:	orrsne.w	r6, r2, r3, lsl #1
    f670:	beq.n	f6a6 <__aeabi_dmul+0x24a>
    f672:	teq	r4, ip
    f676:	bne.n	f67e <__aeabi_dmul+0x222>
    f678:	orrs.w	r6, r0, r1, lsl #12
    f67c:	bne.n	f6a6 <__aeabi_dmul+0x24a>
    f67e:	teq	r5, ip
    f682:	bne.n	f690 <__aeabi_dmul+0x234>
    f684:	orrs.w	r6, r2, r3, lsl #12
    f688:	itt	ne
    f68a:	movne	r0, r2
    f68c:	movne	r1, r3
    f68e:	bne.n	f6a6 <__aeabi_dmul+0x24a>
    f690:	eor.w	r1, r1, r3
    f694:	and.w	r1, r1, #2147483648	; 0x80000000
    f698:	orr.w	r1, r1, #2130706432	; 0x7f000000
    f69c:	orr.w	r1, r1, #15728640	; 0xf00000
    f6a0:	mov.w	r0, #0
    f6a4:	pop	{r4, r5, r6, pc}
    f6a6:	orr.w	r1, r1, #2130706432	; 0x7f000000
    f6aa:	orr.w	r1, r1, #16252928	; 0xf80000
    f6ae:	pop	{r4, r5, r6, pc}

0000f6b0 <__aeabi_ddiv>:
    f6b0:	push	{r4, r5, r6, lr}
    f6b2:	mov.w	ip, #255	; 0xff
    f6b6:	orr.w	ip, ip, #1792	; 0x700
    f6ba:	ands.w	r4, ip, r1, lsr #20
    f6be:	ittte	ne
    f6c0:	andsne.w	r5, ip, r3, lsr #20
    f6c4:	teqne	r4, ip
    f6c8:	teqne	r5, ip
    f6cc:	bleq	f81e <__aeabi_ddiv+0x16e>
    f6d0:	sub.w	r4, r4, r5
    f6d4:	eor.w	lr, r1, r3
    f6d8:	orrs.w	r5, r2, r3, lsl #12
    f6dc:	mov.w	r1, r1, lsl #12
    f6e0:	beq.w	f7f4 <__aeabi_ddiv+0x144>
    f6e4:	mov.w	r3, r3, lsl #12
    f6e8:	mov.w	r5, #268435456	; 0x10000000
    f6ec:	orr.w	r3, r5, r3, lsr #4
    f6f0:	orr.w	r3, r3, r2, lsr #24
    f6f4:	mov.w	r2, r2, lsl #8
    f6f8:	orr.w	r5, r5, r1, lsr #4
    f6fc:	orr.w	r5, r5, r0, lsr #24
    f700:	mov.w	r6, r0, lsl #8
    f704:	and.w	r1, lr, #2147483648	; 0x80000000
    f708:	cmp	r5, r3
    f70a:	it	eq
    f70c:	cmpeq	r6, r2
    f70e:	adc.w	r4, r4, #253	; 0xfd
    f712:	add.w	r4, r4, #768	; 0x300
    f716:	bcs.n	f71e <__aeabi_ddiv+0x6e>
    f718:	lsrs	r3, r3, #1
    f71a:	mov.w	r2, r2, rrx
    f71e:	subs	r6, r6, r2
    f720:	sbc.w	r5, r5, r3
    f724:	lsrs	r3, r3, #1
    f726:	mov.w	r2, r2, rrx
    f72a:	mov.w	r0, #1048576	; 0x100000
    f72e:	mov.w	ip, #524288	; 0x80000
    f732:	subs.w	lr, r6, r2
    f736:	sbcs.w	lr, r5, r3
    f73a:	ittt	cs
    f73c:	subcs	r6, r6, r2
    f73e:	movcs	r5, lr
    f740:	orrcs.w	r0, r0, ip
    f744:	lsrs	r3, r3, #1
    f746:	mov.w	r2, r2, rrx
    f74a:	subs.w	lr, r6, r2
    f74e:	sbcs.w	lr, r5, r3
    f752:	ittt	cs
    f754:	subcs	r6, r6, r2
    f756:	movcs	r5, lr
    f758:	orrcs.w	r0, r0, ip, lsr #1
    f75c:	lsrs	r3, r3, #1
    f75e:	mov.w	r2, r2, rrx
    f762:	subs.w	lr, r6, r2
    f766:	sbcs.w	lr, r5, r3
    f76a:	ittt	cs
    f76c:	subcs	r6, r6, r2
    f76e:	movcs	r5, lr
    f770:	orrcs.w	r0, r0, ip, lsr #2
    f774:	lsrs	r3, r3, #1
    f776:	mov.w	r2, r2, rrx
    f77a:	subs.w	lr, r6, r2
    f77e:	sbcs.w	lr, r5, r3
    f782:	ittt	cs
    f784:	subcs	r6, r6, r2
    f786:	movcs	r5, lr
    f788:	orrcs.w	r0, r0, ip, lsr #3
    f78c:	orrs.w	lr, r5, r6
    f790:	beq.n	f7c4 <__aeabi_ddiv+0x114>
    f792:	mov.w	r5, r5, lsl #4
    f796:	orr.w	r5, r5, r6, lsr #28
    f79a:	mov.w	r6, r6, lsl #4
    f79e:	mov.w	r3, r3, lsl #3
    f7a2:	orr.w	r3, r3, r2, lsr #29
    f7a6:	mov.w	r2, r2, lsl #3
    f7aa:	movs.w	ip, ip, lsr #4
    f7ae:	bne.n	f732 <__aeabi_ddiv+0x82>
    f7b0:	tst.w	r1, #1048576	; 0x100000
    f7b4:	bne.n	f7ce <__aeabi_ddiv+0x11e>
    f7b6:	orr.w	r1, r1, r0
    f7ba:	mov.w	r0, #0
    f7be:	mov.w	ip, #2147483648	; 0x80000000
    f7c2:	b.n	f732 <__aeabi_ddiv+0x82>
    f7c4:	tst.w	r1, #1048576	; 0x100000
    f7c8:	itt	eq
    f7ca:	orreq	r1, r0
    f7cc:	moveq	r0, #0
    f7ce:	subs.w	ip, r4, #253	; 0xfd
    f7d2:	it	hi
    f7d4:	cmphi.w	ip, #1792	; 0x700
    f7d8:	bhi.w	f53a <__aeabi_dmul+0xde>
    f7dc:	subs.w	ip, r5, r3
    f7e0:	itt	eq
    f7e2:	subseq.w	ip, r6, r2
    f7e6:	movseq.w	ip, r0, lsr #1
    f7ea:	adcs.w	r0, r0, #0
    f7ee:	adc.w	r1, r1, r4, lsl #20
    f7f2:	pop	{r4, r5, r6, pc}
    f7f4:	and.w	lr, lr, #2147483648	; 0x80000000
    f7f8:	orr.w	r1, lr, r1, lsr #12
    f7fc:	adds.w	r4, r4, ip, lsr #1
    f800:	ittt	gt
    f802:	rsbsgt	r5, r4, ip
    f806:	orrgt.w	r1, r1, r4, lsl #20
    f80a:	popgt	{r4, r5, r6, pc}
    f80c:	orr.w	r1, r1, #1048576	; 0x100000
    f810:	mov.w	lr, #0
    f814:	subs	r4, #1
    f816:	b.n	f53a <__aeabi_dmul+0xde>
    f818:	orr.w	lr, r5, r6
    f81c:	b.n	f53a <__aeabi_dmul+0xde>
    f81e:	and.w	r5, ip, r3, lsr #20
    f822:	teq	r4, ip
    f826:	it	eq
    f828:	teqeq	r5, ip
    f82c:	beq.w	f6a6 <__aeabi_dmul+0x24a>
    f830:	teq	r4, ip
    f834:	bne.n	f84c <__aeabi_ddiv+0x19c>
    f836:	orrs.w	r4, r0, r1, lsl #12
    f83a:	bne.w	f6a6 <__aeabi_dmul+0x24a>
    f83e:	teq	r5, ip
    f842:	bne.w	f690 <__aeabi_dmul+0x234>
    f846:	mov	r0, r2
    f848:	mov	r1, r3
    f84a:	b.n	f6a6 <__aeabi_dmul+0x24a>
    f84c:	teq	r5, ip
    f850:	bne.n	f860 <__aeabi_ddiv+0x1b0>
    f852:	orrs.w	r5, r2, r3, lsl #12
    f856:	beq.w	f654 <__aeabi_dmul+0x1f8>
    f85a:	mov	r0, r2
    f85c:	mov	r1, r3
    f85e:	b.n	f6a6 <__aeabi_dmul+0x24a>
    f860:	orrs.w	r6, r0, r1, lsl #1
    f864:	it	ne
    f866:	orrsne.w	r6, r2, r3, lsl #1
    f86a:	bne.w	f5f8 <__aeabi_dmul+0x19c>
    f86e:	orrs.w	r4, r0, r1, lsl #1
    f872:	bne.w	f690 <__aeabi_dmul+0x234>
    f876:	orrs.w	r5, r2, r3, lsl #1
    f87a:	bne.w	f654 <__aeabi_dmul+0x1f8>
    f87e:	b.n	f6a6 <__aeabi_dmul+0x24a>

0000f880 <__gedf2>:
    f880:	mov.w	ip, #4294967295
    f884:	b.n	f894 <__cmpdf2+0x4>
    f886:	nop

0000f888 <__ledf2>:
    f888:	mov.w	ip, #1
    f88c:	b.n	f894 <__cmpdf2+0x4>
    f88e:	nop

0000f890 <__cmpdf2>:
    f890:	mov.w	ip, #1
    f894:	str.w	ip, [sp, #-4]!
    f898:	mov.w	ip, r1, lsl #1
    f89c:	mvns.w	ip, ip, asr #21
    f8a0:	mov.w	ip, r3, lsl #1
    f8a4:	it	ne
    f8a6:	mvnsne.w	ip, ip, asr #21
    f8aa:	beq.n	f8e4 <__cmpdf2+0x54>
    f8ac:	add	sp, #4
    f8ae:	orrs.w	ip, r0, r1, lsl #1
    f8b2:	ite	eq
    f8b4:	orrseq.w	ip, r2, r3, lsl #1
    f8b8:	teqne	r1, r3
    f8bc:	ittt	eq
    f8be:	teqeq	r0, r2
    f8c2:	moveq	r0, #0
    f8c4:	bxeq	lr
    f8c6:	cmn.w	r0, #0
    f8ca:	teq	r1, r3
    f8ce:	it	pl
    f8d0:	cmppl	r1, r3
    f8d2:	it	eq
    f8d4:	cmpeq	r0, r2
    f8d6:	ite	cs
    f8d8:	asrcs	r0, r3, #31
    f8da:	mvncc.w	r0, r3, asr #31
    f8de:	orr.w	r0, r0, #1
    f8e2:	bx	lr
    f8e4:	mov.w	ip, r1, lsl #1
    f8e8:	mvns.w	ip, ip, asr #21
    f8ec:	bne.n	f8f4 <__cmpdf2+0x64>
    f8ee:	orrs.w	ip, r0, r1, lsl #12
    f8f2:	bne.n	f904 <__cmpdf2+0x74>
    f8f4:	mov.w	ip, r3, lsl #1
    f8f8:	mvns.w	ip, ip, asr #21
    f8fc:	bne.n	f8ac <__cmpdf2+0x1c>
    f8fe:	orrs.w	ip, r2, r3, lsl #12
    f902:	beq.n	f8ac <__cmpdf2+0x1c>
    f904:	ldr.w	r0, [sp], #4
    f908:	bx	lr
    f90a:	nop

0000f90c <__aeabi_cdrcmple>:
    f90c:	mov	ip, r0
    f90e:	mov	r0, r2
    f910:	mov	r2, ip
    f912:	mov	ip, r1
    f914:	mov	r1, r3
    f916:	mov	r3, ip
    f918:	b.n	f91c <__aeabi_cdcmpeq>
    f91a:	nop

0000f91c <__aeabi_cdcmpeq>:
    f91c:	push	{r0, lr}
    f91e:	bl	f890 <__cmpdf2>
    f922:	cmp	r0, #0
    f924:	it	mi
    f926:	cmnmi.w	r0, #0
    f92a:	pop	{r0, pc}

0000f92c <__aeabi_dcmpeq>:
    f92c:	str.w	lr, [sp, #-8]!
    f930:	bl	f91c <__aeabi_cdcmpeq>
    f934:	ite	eq
    f936:	moveq	r0, #1
    f938:	movne	r0, #0
    f93a:	ldr.w	pc, [sp], #8
    f93e:	nop

0000f940 <__aeabi_dcmplt>:
    f940:	str.w	lr, [sp, #-8]!
    f944:	bl	f91c <__aeabi_cdcmpeq>
    f948:	ite	cc
    f94a:	movcc	r0, #1
    f94c:	movcs	r0, #0
    f94e:	ldr.w	pc, [sp], #8
    f952:	nop

0000f954 <__aeabi_dcmple>:
    f954:	str.w	lr, [sp, #-8]!
    f958:	bl	f91c <__aeabi_cdcmpeq>
    f95c:	ite	ls
    f95e:	movls	r0, #1
    f960:	movhi	r0, #0
    f962:	ldr.w	pc, [sp], #8
    f966:	nop

0000f968 <__aeabi_dcmpge>:
    f968:	str.w	lr, [sp, #-8]!
    f96c:	bl	f90c <__aeabi_cdrcmple>
    f970:	ite	ls
    f972:	movls	r0, #1
    f974:	movhi	r0, #0
    f976:	ldr.w	pc, [sp], #8
    f97a:	nop

0000f97c <__aeabi_dcmpgt>:
    f97c:	str.w	lr, [sp, #-8]!
    f980:	bl	f90c <__aeabi_cdrcmple>
    f984:	ite	cc
    f986:	movcc	r0, #1
    f988:	movcs	r0, #0
    f98a:	ldr.w	pc, [sp], #8
    f98e:	nop

0000f990 <__aeabi_dcmpun>:
    f990:	mov.w	ip, r1, lsl #1
    f994:	mvns.w	ip, ip, asr #21
    f998:	bne.n	f9a0 <__aeabi_dcmpun+0x10>
    f99a:	orrs.w	ip, r0, r1, lsl #12
    f99e:	bne.n	f9b6 <__aeabi_dcmpun+0x26>
    f9a0:	mov.w	ip, r3, lsl #1
    f9a4:	mvns.w	ip, ip, asr #21
    f9a8:	bne.n	f9b0 <__aeabi_dcmpun+0x20>
    f9aa:	orrs.w	ip, r2, r3, lsl #12
    f9ae:	bne.n	f9b6 <__aeabi_dcmpun+0x26>
    f9b0:	mov.w	r0, #0
    f9b4:	bx	lr
    f9b6:	mov.w	r0, #1
    f9ba:	bx	lr

0000f9bc <__aeabi_d2iz>:
    f9bc:	mov.w	r2, r1, lsl #1
    f9c0:	adds.w	r2, r2, #2097152	; 0x200000
    f9c4:	bcs.n	f9f2 <__aeabi_d2iz+0x36>
    f9c6:	bpl.n	f9ec <__aeabi_d2iz+0x30>
    f9c8:	mvn.w	r3, #992	; 0x3e0
    f9cc:	subs.w	r2, r3, r2, asr #21
    f9d0:	bls.n	f9f8 <__aeabi_d2iz+0x3c>
    f9d2:	mov.w	r3, r1, lsl #11
    f9d6:	orr.w	r3, r3, #2147483648	; 0x80000000
    f9da:	orr.w	r3, r3, r0, lsr #21
    f9de:	tst.w	r1, #2147483648	; 0x80000000
    f9e2:	lsr.w	r0, r3, r2
    f9e6:	it	ne
    f9e8:	negne	r0, r0
    f9ea:	bx	lr
    f9ec:	mov.w	r0, #0
    f9f0:	bx	lr
    f9f2:	orrs.w	r0, r0, r1, lsl #12
    f9f6:	bne.n	fa04 <__aeabi_d2iz+0x48>
    f9f8:	ands.w	r0, r1, #2147483648	; 0x80000000
    f9fc:	it	eq
    f9fe:	mvneq.w	r0, #2147483648	; 0x80000000
    fa02:	bx	lr
    fa04:	mov.w	r0, #0
    fa08:	bx	lr
    fa0a:	nop

0000fa0c <__aeabi_uldivmod>:
    fa0c:	cbnz	r3, fa24 <__aeabi_uldivmod+0x18>
    fa0e:	cbnz	r2, fa24 <__aeabi_uldivmod+0x18>
    fa10:	cmp	r1, #0
    fa12:	it	eq
    fa14:	cmpeq	r0, #0
    fa16:	itt	ne
    fa18:	movne.w	r1, #4294967295
    fa1c:	movne.w	r0, #4294967295
    fa20:	b.w	fd20 <__aeabi_idiv0>
    fa24:	sub.w	ip, sp, #8
    fa28:	strd	ip, lr, [sp, #-16]!
    fa2c:	bl	fa3c <__udivmoddi4>
    fa30:	ldr.w	lr, [sp, #4]
    fa34:	ldrd	r2, r3, [sp, #8]
    fa38:	add	sp, #16
    fa3a:	bx	lr

0000fa3c <__udivmoddi4>:
    fa3c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    fa40:	mov	ip, r1
    fa42:	mov	r6, r1
    fa44:	mov	r4, r0
    fa46:	ldr	r5, [sp, #32]
    fa48:	cmp	r3, #0
    fa4a:	bne.n	faee <__udivmoddi4+0xb2>
    fa4c:	cmp	r2, r1
    fa4e:	mov	r7, r2
    fa50:	bls.n	fb2c <__udivmoddi4+0xf0>
    fa52:	clz	lr, r2
    fa56:	cmp.w	lr, #0
    fa5a:	beq.n	fa74 <__udivmoddi4+0x38>
    fa5c:	rsb	r4, lr, #32
    fa60:	lsr.w	r4, r0, r4
    fa64:	lsl.w	r6, r1, lr
    fa68:	orr.w	ip, r4, r6
    fa6c:	lsl.w	r7, r2, lr
    fa70:	lsl.w	r4, r0, lr
    fa74:	mov.w	r9, r7, lsr #16
    fa78:	lsrs	r2, r4, #16
    fa7a:	udiv	r0, ip, r9
    fa7e:	uxth.w	r8, r7
    fa82:	mls	r6, r9, r0, ip
    fa86:	orr.w	r6, r2, r6, lsl #16
    fa8a:	mul.w	r3, r0, r8
    fa8e:	cmp	r3, r6
    fa90:	bls.n	faa6 <__udivmoddi4+0x6a>
    fa92:	adds	r6, r6, r7
    fa94:	add.w	r2, r0, #4294967295
    fa98:	bcs.w	fce0 <__udivmoddi4+0x2a4>
    fa9c:	cmp	r3, r6
    fa9e:	bls.w	fce0 <__udivmoddi4+0x2a4>
    faa2:	subs	r0, #2
    faa4:	add	r6, r7
    faa6:	subs	r6, r6, r3
    faa8:	uxth	r2, r4
    faaa:	udiv	r3, r6, r9
    faae:	mls	r6, r9, r3, r6
    fab2:	orr.w	r4, r2, r6, lsl #16
    fab6:	mul.w	r8, r3, r8
    faba:	cmp	r8, r4
    fabc:	bls.n	fad2 <__udivmoddi4+0x96>
    fabe:	adds	r4, r4, r7
    fac0:	add.w	r2, r3, #4294967295
    fac4:	bcs.w	fcdc <__udivmoddi4+0x2a0>
    fac8:	cmp	r8, r4
    faca:	bls.w	fcdc <__udivmoddi4+0x2a0>
    face:	subs	r3, #2
    fad0:	add	r4, r7
    fad2:	rsb	r4, r8, r4
    fad6:	orr.w	r0, r3, r0, lsl #16
    fada:	movs	r1, #0
    fadc:	cmp	r5, #0
    fade:	beq.n	fba6 <__udivmoddi4+0x16a>
    fae0:	lsr.w	r4, r4, lr
    fae4:	movs	r3, #0
    fae6:	str	r4, [r5, #0]
    fae8:	str	r3, [r5, #4]
    faea:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    faee:	cmp	r3, r1
    faf0:	bls.n	fb02 <__udivmoddi4+0xc6>
    faf2:	cmp	r5, #0
    faf4:	beq.n	fba2 <__udivmoddi4+0x166>
    faf6:	movs	r1, #0
    faf8:	stmia.w	r5, {r0, r6}
    fafc:	mov	r0, r1
    fafe:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    fb02:	clz	r1, r3
    fb06:	cmp	r1, #0
    fb08:	bne.w	fc2c <__udivmoddi4+0x1f0>
    fb0c:	cmp	r3, r6
    fb0e:	bcc.n	fb16 <__udivmoddi4+0xda>
    fb10:	cmp	r2, r0
    fb12:	bhi.w	fd06 <__udivmoddi4+0x2ca>
    fb16:	subs	r4, r0, r2
    fb18:	sbc.w	r6, r6, r3
    fb1c:	movs	r0, #1
    fb1e:	mov	ip, r6
    fb20:	cmp	r5, #0
    fb22:	beq.n	fba6 <__udivmoddi4+0x16a>
    fb24:	stmia.w	r5, {r4, ip}
    fb28:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    fb2c:	cbnz	r2, fb34 <__udivmoddi4+0xf8>
    fb2e:	movs	r7, #1
    fb30:	udiv	r7, r7, r2
    fb34:	clz	lr, r7
    fb38:	cmp.w	lr, #0
    fb3c:	bne.n	fbaa <__udivmoddi4+0x16e>
    fb3e:	subs	r3, r6, r7
    fb40:	mov.w	r8, r7, lsr #16
    fb44:	uxth.w	ip, r7
    fb48:	movs	r1, #1
    fb4a:	udiv	r0, r3, r8
    fb4e:	lsrs	r2, r4, #16
    fb50:	mls	r6, r8, r0, r3
    fb54:	orr.w	r6, r2, r6, lsl #16
    fb58:	mul.w	r3, ip, r0
    fb5c:	cmp	r3, r6
    fb5e:	bls.n	fb70 <__udivmoddi4+0x134>
    fb60:	adds	r6, r6, r7
    fb62:	add.w	r2, r0, #4294967295
    fb66:	bcs.n	fb6e <__udivmoddi4+0x132>
    fb68:	cmp	r3, r6
    fb6a:	bhi.w	fd0a <__udivmoddi4+0x2ce>
    fb6e:	mov	r0, r2
    fb70:	subs	r6, r6, r3
    fb72:	uxth	r2, r4
    fb74:	udiv	r3, r6, r8
    fb78:	mls	r6, r8, r3, r6
    fb7c:	orr.w	r4, r2, r6, lsl #16
    fb80:	mul.w	ip, ip, r3
    fb84:	cmp	ip, r4
    fb86:	bls.n	fb98 <__udivmoddi4+0x15c>
    fb88:	adds	r4, r4, r7
    fb8a:	add.w	r2, r3, #4294967295
    fb8e:	bcs.n	fb96 <__udivmoddi4+0x15a>
    fb90:	cmp	ip, r4
    fb92:	bhi.w	fd00 <__udivmoddi4+0x2c4>
    fb96:	mov	r3, r2
    fb98:	rsb	r4, ip, r4
    fb9c:	orr.w	r0, r3, r0, lsl #16
    fba0:	b.n	fadc <__udivmoddi4+0xa0>
    fba2:	mov	r1, r5
    fba4:	mov	r0, r5
    fba6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    fbaa:	rsb	r1, lr, #32
    fbae:	lsl.w	r3, r6, lr
    fbb2:	lsl.w	r7, r7, lr
    fbb6:	lsr.w	r9, r0, r1
    fbba:	mov.w	r8, r7, lsr #16
    fbbe:	lsrs	r6, r1
    fbc0:	orr.w	r9, r9, r3
    fbc4:	udiv	sl, r6, r8
    fbc8:	mov.w	r4, r9, lsr #16
    fbcc:	mls	r6, r8, sl, r6
    fbd0:	uxth.w	ip, r7
    fbd4:	orr.w	r3, r4, r6, lsl #16
    fbd8:	mul.w	r2, sl, ip
    fbdc:	cmp	r2, r3
    fbde:	lsl.w	r4, r0, lr
    fbe2:	bls.n	fbfa <__udivmoddi4+0x1be>
    fbe4:	adds	r3, r3, r7
    fbe6:	add.w	r1, sl, #4294967295
    fbea:	bcs.w	fcfc <__udivmoddi4+0x2c0>
    fbee:	cmp	r2, r3
    fbf0:	bls.w	fcfc <__udivmoddi4+0x2c0>
    fbf4:	sub.w	sl, sl, #2
    fbf8:	add	r3, r7
    fbfa:	subs	r3, r3, r2
    fbfc:	uxth.w	r9, r9
    fc00:	udiv	r1, r3, r8
    fc04:	mls	r3, r8, r1, r3
    fc08:	orr.w	r3, r9, r3, lsl #16
    fc0c:	mul.w	r6, r1, ip
    fc10:	cmp	r6, r3
    fc12:	bls.n	fc24 <__udivmoddi4+0x1e8>
    fc14:	adds	r3, r3, r7
    fc16:	add.w	r2, r1, #4294967295
    fc1a:	bcs.n	fcf4 <__udivmoddi4+0x2b8>
    fc1c:	cmp	r6, r3
    fc1e:	bls.n	fcf4 <__udivmoddi4+0x2b8>
    fc20:	subs	r1, #2
    fc22:	add	r3, r7
    fc24:	subs	r3, r3, r6
    fc26:	orr.w	r1, r1, sl, lsl #16
    fc2a:	b.n	fb4a <__udivmoddi4+0x10e>
    fc2c:	rsb	lr, r1, #32
    fc30:	lsr.w	r4, r2, lr
    fc34:	lsls	r3, r1
    fc36:	orrs	r3, r4
    fc38:	lsr.w	r7, r0, lr
    fc3c:	lsl.w	r4, r6, r1
    fc40:	mov.w	ip, r3, lsr #16
    fc44:	lsr.w	r6, r6, lr
    fc48:	orrs	r4, r7
    fc4a:	udiv	r9, r6, ip
    fc4e:	lsrs	r7, r4, #16
    fc50:	mls	r6, ip, r9, r6
    fc54:	uxth.w	r8, r3
    fc58:	orr.w	r6, r7, r6, lsl #16
    fc5c:	mul.w	r7, r9, r8
    fc60:	cmp	r7, r6
    fc62:	lsl.w	r2, r2, r1
    fc66:	lsl.w	sl, r0, r1
    fc6a:	bls.n	fc7e <__udivmoddi4+0x242>
    fc6c:	adds	r6, r6, r3
    fc6e:	add.w	r0, r9, #4294967295
    fc72:	bcs.n	fcf8 <__udivmoddi4+0x2bc>
    fc74:	cmp	r7, r6
    fc76:	bls.n	fcf8 <__udivmoddi4+0x2bc>
    fc78:	sub.w	r9, r9, #2
    fc7c:	add	r6, r3
    fc7e:	subs	r6, r6, r7
    fc80:	uxth	r0, r4
    fc82:	udiv	r4, r6, ip
    fc86:	mls	r6, ip, r4, r6
    fc8a:	orr.w	r7, r0, r6, lsl #16
    fc8e:	mul.w	r8, r4, r8
    fc92:	cmp	r8, r7
    fc94:	bls.n	fca6 <__udivmoddi4+0x26a>
    fc96:	adds	r7, r7, r3
    fc98:	add.w	r0, r4, #4294967295
    fc9c:	bcs.n	fcf0 <__udivmoddi4+0x2b4>
    fc9e:	cmp	r8, r7
    fca0:	bls.n	fcf0 <__udivmoddi4+0x2b4>
    fca2:	subs	r4, #2
    fca4:	add	r7, r3
    fca6:	orr.w	r0, r4, r9, lsl #16
    fcaa:	rsb	r7, r8, r7
    fcae:	umull	r8, r9, r0, r2
    fcb2:	cmp	r7, r9
    fcb4:	mov	r4, r8
    fcb6:	mov	r6, r9
    fcb8:	bcc.n	fce4 <__udivmoddi4+0x2a8>
    fcba:	beq.n	fd10 <__udivmoddi4+0x2d4>
    fcbc:	cbz	r5, fd18 <__udivmoddi4+0x2dc>
    fcbe:	subs.w	r3, sl, r4
    fcc2:	sbc.w	r7, r7, r6
    fcc6:	lsl.w	lr, r7, lr
    fcca:	lsrs	r3, r1
    fccc:	lsrs	r7, r1
    fcce:	orr.w	r3, lr, r3
    fcd2:	stmia.w	r5, {r3, r7}
    fcd6:	movs	r1, #0
    fcd8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    fcdc:	mov	r3, r2
    fcde:	b.n	fad2 <__udivmoddi4+0x96>
    fce0:	mov	r0, r2
    fce2:	b.n	faa6 <__udivmoddi4+0x6a>
    fce4:	subs.w	r4, r8, r2
    fce8:	sbc.w	r6, r9, r3
    fcec:	subs	r0, #1
    fcee:	b.n	fcbc <__udivmoddi4+0x280>
    fcf0:	mov	r4, r0
    fcf2:	b.n	fca6 <__udivmoddi4+0x26a>
    fcf4:	mov	r1, r2
    fcf6:	b.n	fc24 <__udivmoddi4+0x1e8>
    fcf8:	mov	r9, r0
    fcfa:	b.n	fc7e <__udivmoddi4+0x242>
    fcfc:	mov	sl, r1
    fcfe:	b.n	fbfa <__udivmoddi4+0x1be>
    fd00:	subs	r3, #2
    fd02:	add	r4, r7
    fd04:	b.n	fb98 <__udivmoddi4+0x15c>
    fd06:	mov	r0, r1
    fd08:	b.n	fb20 <__udivmoddi4+0xe4>
    fd0a:	subs	r0, #2
    fd0c:	add	r6, r7
    fd0e:	b.n	fb70 <__udivmoddi4+0x134>
    fd10:	cmp	sl, r8
    fd12:	bcc.n	fce4 <__udivmoddi4+0x2a8>
    fd14:	mov	r6, r7
    fd16:	b.n	fcbc <__udivmoddi4+0x280>
    fd18:	mov	r1, r5
    fd1a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    fd1e:	nop

0000fd20 <__aeabi_idiv0>:
    fd20:	bx	lr
    fd22:	nop

0000fd24 <_calloc_r>:
    fd24:	push	{r4, lr}
    fd26:	mul.w	r1, r2, r1
    fd2a:	bl	fe30 <_malloc_r>
    fd2e:	mov	r4, r0
    fd30:	cbz	r0, fd6a <_calloc_r+0x46>
    fd32:	ldr.w	r2, [r0, #-4]
    fd36:	bic.w	r2, r2, #3
    fd3a:	subs	r2, #4
    fd3c:	cmp	r2, #36	; 0x24
    fd3e:	bhi.n	fd72 <_calloc_r+0x4e>
    fd40:	cmp	r2, #19
    fd42:	bls.n	fd6e <_calloc_r+0x4a>
    fd44:	movs	r3, #0
    fd46:	cmp	r2, #27
    fd48:	str	r3, [r0, #0]
    fd4a:	str	r3, [r0, #4]
    fd4c:	bls.n	fd7c <_calloc_r+0x58>
    fd4e:	cmp	r2, #36	; 0x24
    fd50:	str	r3, [r0, #8]
    fd52:	str	r3, [r0, #12]
    fd54:	iteee	ne
    fd56:	addne.w	r2, r0, #16
    fd5a:	streq	r3, [r0, #16]
    fd5c:	streq	r3, [r0, #20]
    fd5e:	addeq.w	r2, r0, #24
    fd62:	movs	r3, #0
    fd64:	str	r3, [r2, #0]
    fd66:	str	r3, [r2, #4]
    fd68:	str	r3, [r2, #8]
    fd6a:	mov	r0, r4
    fd6c:	pop	{r4, pc}
    fd6e:	mov	r2, r0
    fd70:	b.n	fd62 <_calloc_r+0x3e>
    fd72:	movs	r1, #0
    fd74:	bl	1059c <memset>
    fd78:	mov	r0, r4
    fd7a:	pop	{r4, pc}
    fd7c:	add.w	r2, r0, #8
    fd80:	b.n	fd62 <_calloc_r+0x3e>
    fd82:	nop

0000fd84 <__cxa_atexit>:
    fd84:	mov	r3, r2
    fd86:	mov	r2, r1
    fd88:	mov	r1, r0
    fd8a:	movs	r0, #2
    fd8c:	b.w	12510 <__register_exitproc>

0000fd90 <fcvtf>:
    fd90:	push	{r4, r5, r6, lr}
    fd92:	mov	r4, r0
    fd94:	vmov	r0, s0
    fd98:	mov	r5, r1
    fd9a:	mov	r6, r2
    fd9c:	bl	f3b4 <__aeabi_f2d>
    fda0:	mov	r2, r6
    fda2:	vmov	d0, r0, r1
    fda6:	movs	r3, #0
    fda8:	mov	r1, r5
    fdaa:	mov	r0, r4
    fdac:	ldmia.w	sp!, {r4, r5, r6, lr}
    fdb0:	b.w	13534 <fcvtbuf>

0000fdb4 <__errno>:
    fdb4:	ldr	r3, [pc, #4]	; (fdbc <__errno+0x8>)
    fdb6:	ldr	r0, [r3, #0]
    fdb8:	bx	lr
    fdba:	nop
    fdbc:	.word	0x1fff0f10

0000fdc0 <__libc_init_array>:
    fdc0:	push	{r4, r5, r6, lr}
    fdc2:	ldr	r6, [pc, #60]	; (fe00 <__libc_init_array+0x40>)
    fdc4:	ldr	r5, [pc, #60]	; (fe04 <__libc_init_array+0x44>)
    fdc6:	subs	r6, r6, r5
    fdc8:	asrs	r6, r6, #2
    fdca:	it	ne
    fdcc:	movne	r4, #0
    fdce:	beq.n	fddc <__libc_init_array+0x1c>
    fdd0:	adds	r4, #1
    fdd2:	ldr.w	r3, [r5], #4
    fdd6:	blx	r3
    fdd8:	cmp	r6, r4
    fdda:	bne.n	fdd0 <__libc_init_array+0x10>
    fddc:	ldr	r6, [pc, #40]	; (fe08 <__libc_init_array+0x48>)
    fdde:	ldr	r5, [pc, #44]	; (fe0c <__libc_init_array+0x4c>)
    fde0:	subs	r6, r6, r5
    fde2:	bl	14c4c <_init>
    fde6:	asrs	r6, r6, #2
    fde8:	it	ne
    fdea:	movne	r4, #0
    fdec:	beq.n	fdfc <__libc_init_array+0x3c>
    fdee:	adds	r4, #1
    fdf0:	ldr.w	r3, [r5], #4
    fdf4:	blx	r3
    fdf6:	cmp	r6, r4
    fdf8:	bne.n	fdee <__libc_init_array+0x2e>
    fdfa:	pop	{r4, r5, r6, pc}
    fdfc:	pop	{r4, r5, r6, pc}
    fdfe:	nop
    fe00:	.word	0x00014c58
    fe04:	.word	0x00014c58
    fe08:	.word	0x00014c68
    fe0c:	.word	0x00014c58

0000fe10 <malloc>:
    fe10:	ldr	r3, [pc, #8]	; (fe1c <malloc+0xc>)
    fe12:	mov	r1, r0
    fe14:	ldr	r0, [r3, #0]
    fe16:	b.w	fe30 <_malloc_r>
    fe1a:	nop
    fe1c:	.word	0x1fff0f10

0000fe20 <free>:
    fe20:	ldr	r3, [pc, #8]	; (fe2c <free+0xc>)
    fe22:	mov	r1, r0
    fe24:	ldr	r0, [r3, #0]
    fe26:	b.w	136f8 <_free_r>
    fe2a:	nop
    fe2c:	.word	0x1fff0f10

0000fe30 <_malloc_r>:
    fe30:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    fe34:	add.w	r5, r1, #11
    fe38:	cmp	r5, #22
    fe3a:	sub	sp, #12
    fe3c:	mov	r6, r0
    fe3e:	bls.w	ff80 <_malloc_r+0x150>
    fe42:	bics.w	r5, r5, #7
    fe46:	bmi.w	ffc8 <_malloc_r+0x198>
    fe4a:	cmp	r1, r5
    fe4c:	bhi.w	ffc8 <_malloc_r+0x198>
    fe50:	bl	10638 <__malloc_lock>
    fe54:	cmp.w	r5, #504	; 0x1f8
    fe58:	bcc.w	10394 <_malloc_r+0x564>
    fe5c:	lsrs	r3, r5, #9
    fe5e:	beq.w	ffd6 <_malloc_r+0x1a6>
    fe62:	cmp	r3, #4
    fe64:	bhi.w	1016e <_malloc_r+0x33e>
    fe68:	lsrs	r0, r5, #6
    fe6a:	add.w	lr, r0, #57	; 0x39
    fe6e:	mov.w	r3, lr, lsl #1
    fe72:	adds	r0, #56	; 0x38
    fe74:	ldr	r7, [pc, #784]	; (10188 <_malloc_r+0x358>)
    fe76:	add.w	r3, r7, r3, lsl #2
    fe7a:	sub.w	r1, r3, #8
    fe7e:	ldr	r4, [r3, #4]
    fe80:	cmp	r1, r4
    fe82:	bne.n	fe94 <_malloc_r+0x64>
    fe84:	b.n	ffe0 <_malloc_r+0x1b0>
    fe86:	cmp	r2, #0
    fe88:	bge.w	ffe4 <_malloc_r+0x1b4>
    fe8c:	ldr	r4, [r4, #12]
    fe8e:	cmp	r1, r4
    fe90:	beq.w	ffe0 <_malloc_r+0x1b0>
    fe94:	ldr	r3, [r4, #4]
    fe96:	bic.w	r3, r3, #3
    fe9a:	subs	r2, r3, r5
    fe9c:	cmp	r2, #15
    fe9e:	ble.n	fe86 <_malloc_r+0x56>
    fea0:	ldr	r1, [pc, #740]	; (10188 <_malloc_r+0x358>)
    fea2:	ldr	r4, [r7, #16]
    fea4:	add.w	lr, r1, #8
    fea8:	cmp	r4, lr
    feaa:	beq.w	10214 <_malloc_r+0x3e4>
    feae:	ldr	r3, [r4, #4]
    feb0:	bic.w	r3, r3, #3
    feb4:	subs	r2, r3, r5
    feb6:	cmp	r2, #15
    feb8:	bgt.w	101ee <_malloc_r+0x3be>
    febc:	cmp	r2, #0
    febe:	str.w	lr, [r1, #20]
    fec2:	str.w	lr, [r1, #16]
    fec6:	bge.w	10006 <_malloc_r+0x1d6>
    feca:	cmp.w	r3, #512	; 0x200
    fece:	bcs.w	101a0 <_malloc_r+0x370>
    fed2:	lsrs	r3, r3, #3
    fed4:	add.w	ip, r3, #1
    fed8:	movs	r2, #1
    feda:	asrs	r3, r3, #2
    fedc:	lsl.w	r3, r2, r3
    fee0:	ldr	r2, [r1, #4]
    fee2:	ldr.w	r8, [r1, ip, lsl #3]
    fee6:	str.w	r8, [r4, #8]
    feea:	add.w	r9, r1, ip, lsl #3
    feee:	orrs	r2, r3
    fef0:	sub.w	r3, r9, #8
    fef4:	str	r3, [r4, #12]
    fef6:	str	r2, [r1, #4]
    fef8:	str.w	r4, [r1, ip, lsl #3]
    fefc:	str.w	r4, [r8, #12]
    ff00:	asrs	r3, r0, #2
    ff02:	movs	r4, #1
    ff04:	lsls	r4, r3
    ff06:	cmp	r4, r2
    ff08:	bhi.w	10020 <_malloc_r+0x1f0>
    ff0c:	tst	r4, r2
    ff0e:	bne.n	ff1e <_malloc_r+0xee>
    ff10:	bic.w	r0, r0, #3
    ff14:	lsls	r4, r4, #1
    ff16:	tst	r4, r2
    ff18:	add.w	r0, r0, #4
    ff1c:	beq.n	ff14 <_malloc_r+0xe4>
    ff1e:	add.w	r9, r7, r0, lsl #3
    ff22:	mov	ip, r9
    ff24:	mov	r8, r0
    ff26:	ldr.w	r1, [ip, #12]
    ff2a:	cmp	ip, r1
    ff2c:	bne.n	ff3e <_malloc_r+0x10e>
    ff2e:	b.n	10218 <_malloc_r+0x3e8>
    ff30:	cmp	r2, #0
    ff32:	bge.w	10238 <_malloc_r+0x408>
    ff36:	ldr	r1, [r1, #12]
    ff38:	cmp	ip, r1
    ff3a:	beq.w	10218 <_malloc_r+0x3e8>
    ff3e:	ldr	r3, [r1, #4]
    ff40:	bic.w	r3, r3, #3
    ff44:	subs	r2, r3, r5
    ff46:	cmp	r2, #15
    ff48:	ble.n	ff30 <_malloc_r+0x100>
    ff4a:	mov	r4, r1
    ff4c:	ldr.w	ip, [r1, #12]
    ff50:	ldr.w	r8, [r4, #8]!
    ff54:	adds	r3, r1, r5
    ff56:	orr.w	r5, r5, #1
    ff5a:	str	r5, [r1, #4]
    ff5c:	orr.w	r1, r2, #1
    ff60:	str.w	ip, [r8, #12]
    ff64:	mov	r0, r6
    ff66:	str.w	r8, [ip, #8]
    ff6a:	str	r3, [r7, #20]
    ff6c:	str	r3, [r7, #16]
    ff6e:	str.w	lr, [r3, #12]
    ff72:	str.w	lr, [r3, #8]
    ff76:	str	r1, [r3, #4]
    ff78:	str	r2, [r3, r2]
    ff7a:	bl	1063c <__malloc_unlock>
    ff7e:	b.n	ffc0 <_malloc_r+0x190>
    ff80:	cmp	r1, #16
    ff82:	bhi.n	ffc8 <_malloc_r+0x198>
    ff84:	bl	10638 <__malloc_lock>
    ff88:	movs	r5, #16
    ff8a:	movs	r3, #6
    ff8c:	movs	r0, #2
    ff8e:	ldr	r7, [pc, #504]	; (10188 <_malloc_r+0x358>)
    ff90:	add.w	r3, r7, r3, lsl #2
    ff94:	sub.w	r2, r3, #8
    ff98:	ldr	r4, [r3, #4]
    ff9a:	cmp	r4, r2
    ff9c:	beq.w	1022a <_malloc_r+0x3fa>
    ffa0:	ldr	r3, [r4, #4]
    ffa2:	ldr	r1, [r4, #12]
    ffa4:	ldr	r5, [r4, #8]
    ffa6:	bic.w	r3, r3, #3
    ffaa:	add	r3, r4
    ffac:	mov	r0, r6
    ffae:	ldr	r2, [r3, #4]
    ffb0:	str	r1, [r5, #12]
    ffb2:	orr.w	r2, r2, #1
    ffb6:	str	r5, [r1, #8]
    ffb8:	str	r2, [r3, #4]
    ffba:	bl	1063c <__malloc_unlock>
    ffbe:	adds	r4, #8
    ffc0:	mov	r0, r4
    ffc2:	add	sp, #12
    ffc4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ffc8:	movs	r4, #0
    ffca:	movs	r3, #12
    ffcc:	mov	r0, r4
    ffce:	str	r3, [r6, #0]
    ffd0:	add	sp, #12
    ffd2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ffd6:	movs	r3, #128	; 0x80
    ffd8:	mov.w	lr, #64	; 0x40
    ffdc:	movs	r0, #63	; 0x3f
    ffde:	b.n	fe74 <_malloc_r+0x44>
    ffe0:	mov	r0, lr
    ffe2:	b.n	fea0 <_malloc_r+0x70>
    ffe4:	add	r3, r4
    ffe6:	ldr	r1, [r4, #12]
    ffe8:	ldr	r2, [r3, #4]
    ffea:	ldr	r5, [r4, #8]
    ffec:	orr.w	r2, r2, #1
    fff0:	str	r1, [r5, #12]
    fff2:	mov	r0, r6
    fff4:	str	r5, [r1, #8]
    fff6:	str	r2, [r3, #4]
    fff8:	bl	1063c <__malloc_unlock>
    fffc:	adds	r4, #8
    fffe:	mov	r0, r4
   10000:	add	sp, #12
   10002:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10006:	add	r3, r4
   10008:	mov	r0, r6
   1000a:	ldr	r2, [r3, #4]
   1000c:	orr.w	r2, r2, #1
   10010:	str	r2, [r3, #4]
   10012:	bl	1063c <__malloc_unlock>
   10016:	adds	r4, #8
   10018:	mov	r0, r4
   1001a:	add	sp, #12
   1001c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10020:	ldr	r4, [r7, #8]
   10022:	ldr	r3, [r4, #4]
   10024:	bic.w	r8, r3, #3
   10028:	cmp	r8, r5
   1002a:	bcc.n	10036 <_malloc_r+0x206>
   1002c:	rsb	r3, r5, r8
   10030:	cmp	r3, #15
   10032:	bgt.w	1014e <_malloc_r+0x31e>
   10036:	ldr	r3, [pc, #340]	; (1018c <_malloc_r+0x35c>)
   10038:	ldr.w	r9, [pc, #352]	; 1019c <_malloc_r+0x36c>
   1003c:	ldr	r2, [r3, #0]
   1003e:	ldr.w	r3, [r9]
   10042:	adds	r3, #1
   10044:	add	r2, r5
   10046:	add.w	sl, r4, r8
   1004a:	beq.w	1030e <_malloc_r+0x4de>
   1004e:	add.w	r2, r2, #4096	; 0x1000
   10052:	adds	r2, #15
   10054:	bic.w	r2, r2, #4080	; 0xff0
   10058:	bic.w	r2, r2, #15
   1005c:	mov	r1, r2
   1005e:	mov	r0, r6
   10060:	str	r2, [sp, #4]
   10062:	bl	10a20 <_sbrk_r>
   10066:	cmp.w	r0, #4294967295
   1006a:	mov	fp, r0
   1006c:	ldr	r2, [sp, #4]
   1006e:	beq.w	10322 <_malloc_r+0x4f2>
   10072:	cmp	sl, r0
   10074:	bhi.w	10270 <_malloc_r+0x440>
   10078:	ldr	r3, [pc, #276]	; (10190 <_malloc_r+0x360>)
   1007a:	ldr	r1, [r3, #0]
   1007c:	cmp	sl, fp
   1007e:	add	r1, r2
   10080:	str	r1, [r3, #0]
   10082:	beq.w	1032c <_malloc_r+0x4fc>
   10086:	ldr.w	r0, [r9]
   1008a:	ldr.w	lr, [pc, #272]	; 1019c <_malloc_r+0x36c>
   1008e:	adds	r0, #1
   10090:	ittet	ne
   10092:	rsbne	sl, sl, fp
   10096:	addne	r1, sl
   10098:	streq.w	fp, [lr]
   1009c:	strne	r1, [r3, #0]
   1009e:	ands.w	r1, fp, #7
   100a2:	beq.w	102d4 <_malloc_r+0x4a4>
   100a6:	rsb	r0, r1, #8
   100aa:	rsb	r1, r1, #4096	; 0x1000
   100ae:	add	fp, r0
   100b0:	adds	r1, #8
   100b2:	add	r2, fp
   100b4:	ubfx	r2, r2, #0, #12
   100b8:	rsb	r9, r2, r1
   100bc:	mov	r1, r9
   100be:	mov	r0, r6
   100c0:	str	r3, [sp, #4]
   100c2:	bl	10a20 <_sbrk_r>
   100c6:	adds	r3, r0, #1
   100c8:	ldr	r3, [sp, #4]
   100ca:	beq.w	1034c <_malloc_r+0x51c>
   100ce:	rsb	r2, fp, r0
   100d2:	add	r2, r9
   100d4:	orr.w	r2, r2, #1
   100d8:	ldr	r1, [r3, #0]
   100da:	str.w	fp, [r7, #8]
   100de:	add	r1, r9
   100e0:	cmp	r4, r7
   100e2:	str.w	r2, [fp, #4]
   100e6:	str	r1, [r3, #0]
   100e8:	ldr.w	r9, [pc, #164]	; 10190 <_malloc_r+0x360>
   100ec:	beq.n	1011c <_malloc_r+0x2ec>
   100ee:	cmp.w	r8, #15
   100f2:	bls.w	102f0 <_malloc_r+0x4c0>
   100f6:	ldr	r2, [r4, #4]
   100f8:	sub.w	r3, r8, #12
   100fc:	bic.w	r3, r3, #7
   10100:	adds	r0, r4, r3
   10102:	and.w	r2, r2, #1
   10106:	mov.w	lr, #5
   1010a:	orrs	r2, r3
   1010c:	cmp	r3, #15
   1010e:	str	r2, [r4, #4]
   10110:	str.w	lr, [r0, #4]
   10114:	str.w	lr, [r0, #8]
   10118:	bhi.w	10354 <_malloc_r+0x524>
   1011c:	ldr	r3, [pc, #116]	; (10194 <_malloc_r+0x364>)
   1011e:	ldr	r4, [r7, #8]
   10120:	ldr	r2, [r3, #0]
   10122:	cmp	r1, r2
   10124:	it	hi
   10126:	strhi	r1, [r3, #0]
   10128:	ldr	r3, [pc, #108]	; (10198 <_malloc_r+0x368>)
   1012a:	ldr	r2, [r3, #0]
   1012c:	cmp	r1, r2
   1012e:	ldr	r2, [r4, #4]
   10130:	it	hi
   10132:	strhi	r1, [r3, #0]
   10134:	bic.w	r2, r2, #3
   10138:	cmp	r5, r2
   1013a:	sub.w	r3, r2, r5
   1013e:	bhi.n	10144 <_malloc_r+0x314>
   10140:	cmp	r3, #15
   10142:	bgt.n	1014e <_malloc_r+0x31e>
   10144:	mov	r0, r6
   10146:	bl	1063c <__malloc_unlock>
   1014a:	movs	r4, #0
   1014c:	b.n	ffc0 <_malloc_r+0x190>
   1014e:	adds	r2, r4, r5
   10150:	orr.w	r3, r3, #1
   10154:	orr.w	r5, r5, #1
   10158:	str	r5, [r4, #4]
   1015a:	mov	r0, r6
   1015c:	str	r2, [r7, #8]
   1015e:	str	r3, [r2, #4]
   10160:	bl	1063c <__malloc_unlock>
   10164:	adds	r4, #8
   10166:	mov	r0, r4
   10168:	add	sp, #12
   1016a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1016e:	cmp	r3, #20
   10170:	bls.n	10256 <_malloc_r+0x426>
   10172:	cmp	r3, #84	; 0x54
   10174:	bhi.w	102c0 <_malloc_r+0x490>
   10178:	lsrs	r0, r5, #12
   1017a:	add.w	lr, r0, #111	; 0x6f
   1017e:	mov.w	r3, lr, lsl #1
   10182:	adds	r0, #110	; 0x6e
   10184:	b.n	fe74 <_malloc_r+0x44>
   10186:	nop
   10188:	.word	0x1fff1080
   1018c:	.word	0x1fff67fc
   10190:	.word	0x1fff6800
   10194:	.word	0x1fff67f8
   10198:	.word	0x1fff67f4
   1019c:	.word	0x1fff148c
   101a0:	lsrs	r2, r3, #9
   101a2:	cmp	r2, #4
   101a4:	bls.n	10264 <_malloc_r+0x434>
   101a6:	cmp	r2, #20
   101a8:	bhi.w	10312 <_malloc_r+0x4e2>
   101ac:	add.w	r1, r2, #92	; 0x5c
   101b0:	lsls	r1, r1, #1
   101b2:	adds	r2, #91	; 0x5b
   101b4:	add.w	ip, r7, r1, lsl #2
   101b8:	ldr.w	r1, [r7, r1, lsl #2]
   101bc:	ldr.w	r8, [pc, #476]	; 1039c <_malloc_r+0x56c>
   101c0:	sub.w	ip, ip, #8
   101c4:	cmp	ip, r1
   101c6:	beq.w	102da <_malloc_r+0x4aa>
   101ca:	ldr	r2, [r1, #4]
   101cc:	bic.w	r2, r2, #3
   101d0:	cmp	r3, r2
   101d2:	bcs.n	101da <_malloc_r+0x3aa>
   101d4:	ldr	r1, [r1, #8]
   101d6:	cmp	ip, r1
   101d8:	bne.n	101ca <_malloc_r+0x39a>
   101da:	ldr.w	ip, [r1, #12]
   101de:	ldr	r2, [r7, #4]
   101e0:	str.w	ip, [r4, #12]
   101e4:	str	r1, [r4, #8]
   101e6:	str.w	r4, [ip, #8]
   101ea:	str	r4, [r1, #12]
   101ec:	b.n	ff00 <_malloc_r+0xd0>
   101ee:	adds	r3, r4, r5
   101f0:	orr.w	r7, r2, #1
   101f4:	orr.w	r5, r5, #1
   101f8:	str	r5, [r4, #4]
   101fa:	mov	r0, r6
   101fc:	str	r3, [r1, #20]
   101fe:	str	r3, [r1, #16]
   10200:	str.w	lr, [r3, #12]
   10204:	str.w	lr, [r3, #8]
   10208:	str	r7, [r3, #4]
   1020a:	str	r2, [r3, r2]
   1020c:	adds	r4, #8
   1020e:	bl	1063c <__malloc_unlock>
   10212:	b.n	ffc0 <_malloc_r+0x190>
   10214:	ldr	r2, [r1, #4]
   10216:	b.n	ff00 <_malloc_r+0xd0>
   10218:	add.w	r8, r8, #1
   1021c:	tst.w	r8, #3
   10220:	add.w	ip, ip, #8
   10224:	bne.w	ff26 <_malloc_r+0xf6>
   10228:	b.n	1028c <_malloc_r+0x45c>
   1022a:	ldr	r4, [r3, #12]
   1022c:	cmp	r3, r4
   1022e:	it	eq
   10230:	addeq	r0, #2
   10232:	beq.w	fea0 <_malloc_r+0x70>
   10236:	b.n	ffa0 <_malloc_r+0x170>
   10238:	add	r3, r1
   1023a:	mov	r4, r1
   1023c:	ldr	r2, [r3, #4]
   1023e:	ldr	r1, [r1, #12]
   10240:	ldr.w	r5, [r4, #8]!
   10244:	orr.w	r2, r2, #1
   10248:	str	r2, [r3, #4]
   1024a:	mov	r0, r6
   1024c:	str	r1, [r5, #12]
   1024e:	str	r5, [r1, #8]
   10250:	bl	1063c <__malloc_unlock>
   10254:	b.n	ffc0 <_malloc_r+0x190>
   10256:	add.w	lr, r3, #92	; 0x5c
   1025a:	add.w	r0, r3, #91	; 0x5b
   1025e:	mov.w	r3, lr, lsl #1
   10262:	b.n	fe74 <_malloc_r+0x44>
   10264:	lsrs	r2, r3, #6
   10266:	add.w	r1, r2, #57	; 0x39
   1026a:	lsls	r1, r1, #1
   1026c:	adds	r2, #56	; 0x38
   1026e:	b.n	101b4 <_malloc_r+0x384>
   10270:	cmp	r4, r7
   10272:	ldr	r3, [pc, #296]	; (1039c <_malloc_r+0x56c>)
   10274:	beq.w	10078 <_malloc_r+0x248>
   10278:	ldr	r4, [r3, #8]
   1027a:	ldr	r2, [r4, #4]
   1027c:	bic.w	r2, r2, #3
   10280:	b.n	10138 <_malloc_r+0x308>
   10282:	ldr.w	r3, [r9], #-8
   10286:	cmp	r9, r3
   10288:	bne.w	10390 <_malloc_r+0x560>
   1028c:	tst.w	r0, #3
   10290:	add.w	r0, r0, #4294967295
   10294:	bne.n	10282 <_malloc_r+0x452>
   10296:	ldr	r3, [r7, #4]
   10298:	bic.w	r3, r3, r4
   1029c:	str	r3, [r7, #4]
   1029e:	lsls	r4, r4, #1
   102a0:	cmp	r4, r3
   102a2:	bhi.w	10020 <_malloc_r+0x1f0>
   102a6:	cmp	r4, #0
   102a8:	beq.w	10020 <_malloc_r+0x1f0>
   102ac:	tst	r4, r3
   102ae:	mov	r0, r8
   102b0:	bne.w	ff1e <_malloc_r+0xee>
   102b4:	lsls	r4, r4, #1
   102b6:	tst	r4, r3
   102b8:	add.w	r0, r0, #4
   102bc:	beq.n	102b4 <_malloc_r+0x484>
   102be:	b.n	ff1e <_malloc_r+0xee>
   102c0:	cmp.w	r3, #340	; 0x154
   102c4:	bhi.n	102f8 <_malloc_r+0x4c8>
   102c6:	lsrs	r0, r5, #15
   102c8:	add.w	lr, r0, #120	; 0x78
   102cc:	mov.w	r3, lr, lsl #1
   102d0:	adds	r0, #119	; 0x77
   102d2:	b.n	fe74 <_malloc_r+0x44>
   102d4:	mov.w	r1, #4096	; 0x1000
   102d8:	b.n	100b2 <_malloc_r+0x282>
   102da:	movs	r1, #1
   102dc:	ldr.w	r3, [r8, #4]
   102e0:	asrs	r2, r2, #2
   102e2:	lsl.w	r2, r1, r2
   102e6:	orrs	r2, r3
   102e8:	str.w	r2, [r8, #4]
   102ec:	mov	r1, ip
   102ee:	b.n	101e0 <_malloc_r+0x3b0>
   102f0:	movs	r3, #1
   102f2:	str.w	r3, [fp, #4]
   102f6:	b.n	10144 <_malloc_r+0x314>
   102f8:	movw	r2, #1364	; 0x554
   102fc:	cmp	r3, r2
   102fe:	bhi.n	10342 <_malloc_r+0x512>
   10300:	lsrs	r0, r5, #18
   10302:	add.w	lr, r0, #125	; 0x7d
   10306:	mov.w	r3, lr, lsl #1
   1030a:	adds	r0, #124	; 0x7c
   1030c:	b.n	fe74 <_malloc_r+0x44>
   1030e:	adds	r2, #16
   10310:	b.n	1005c <_malloc_r+0x22c>
   10312:	cmp	r2, #84	; 0x54
   10314:	bhi.n	10364 <_malloc_r+0x534>
   10316:	lsrs	r2, r3, #12
   10318:	add.w	r1, r2, #111	; 0x6f
   1031c:	lsls	r1, r1, #1
   1031e:	adds	r2, #110	; 0x6e
   10320:	b.n	101b4 <_malloc_r+0x384>
   10322:	ldr	r4, [r7, #8]
   10324:	ldr	r2, [r4, #4]
   10326:	bic.w	r2, r2, #3
   1032a:	b.n	10138 <_malloc_r+0x308>
   1032c:	ubfx	r0, sl, #0, #12
   10330:	cmp	r0, #0
   10332:	bne.w	10086 <_malloc_r+0x256>
   10336:	add	r2, r8
   10338:	ldr	r3, [r7, #8]
   1033a:	orr.w	r2, r2, #1
   1033e:	str	r2, [r3, #4]
   10340:	b.n	1011c <_malloc_r+0x2ec>
   10342:	movs	r3, #254	; 0xfe
   10344:	mov.w	lr, #127	; 0x7f
   10348:	movs	r0, #126	; 0x7e
   1034a:	b.n	fe74 <_malloc_r+0x44>
   1034c:	movs	r2, #1
   1034e:	mov.w	r9, #0
   10352:	b.n	100d8 <_malloc_r+0x2a8>
   10354:	add.w	r1, r4, #8
   10358:	mov	r0, r6
   1035a:	bl	136f8 <_free_r>
   1035e:	ldr.w	r1, [r9]
   10362:	b.n	1011c <_malloc_r+0x2ec>
   10364:	cmp.w	r2, #340	; 0x154
   10368:	bhi.n	10376 <_malloc_r+0x546>
   1036a:	lsrs	r2, r3, #15
   1036c:	add.w	r1, r2, #120	; 0x78
   10370:	lsls	r1, r1, #1
   10372:	adds	r2, #119	; 0x77
   10374:	b.n	101b4 <_malloc_r+0x384>
   10376:	movw	r1, #1364	; 0x554
   1037a:	cmp	r2, r1
   1037c:	bhi.n	1038a <_malloc_r+0x55a>
   1037e:	lsrs	r2, r3, #18
   10380:	add.w	r1, r2, #125	; 0x7d
   10384:	lsls	r1, r1, #1
   10386:	adds	r2, #124	; 0x7c
   10388:	b.n	101b4 <_malloc_r+0x384>
   1038a:	movs	r1, #254	; 0xfe
   1038c:	movs	r2, #126	; 0x7e
   1038e:	b.n	101b4 <_malloc_r+0x384>
   10390:	ldr	r3, [r7, #4]
   10392:	b.n	1029e <_malloc_r+0x46e>
   10394:	lsrs	r0, r5, #3
   10396:	adds	r3, r0, #1
   10398:	lsls	r3, r3, #1
   1039a:	b.n	ff8e <_malloc_r+0x15e>
   1039c:	.word	0x1fff1080

000103a0 <__ascii_mbtowc>:
   103a0:	sub	sp, #8
   103a2:	cbz	r1, 103b8 <__ascii_mbtowc+0x18>
   103a4:	cbz	r2, 103be <__ascii_mbtowc+0x1e>
   103a6:	cbz	r3, 103c4 <__ascii_mbtowc+0x24>
   103a8:	ldrb	r3, [r2, #0]
   103aa:	str	r3, [r1, #0]
   103ac:	ldrb	r2, [r2, #0]
   103ae:	adds	r0, r2, #0
   103b0:	it	ne
   103b2:	movne	r0, #1
   103b4:	add	sp, #8
   103b6:	bx	lr
   103b8:	add	r1, sp, #4
   103ba:	cmp	r2, #0
   103bc:	bne.n	103a6 <__ascii_mbtowc+0x6>
   103be:	mov	r0, r2
   103c0:	add	sp, #8
   103c2:	bx	lr
   103c4:	mvn.w	r0, #1
   103c8:	b.n	103b4 <__ascii_mbtowc+0x14>
   103ca:	nop
   103cc:			; <UNDEFINED> instruction: 0xffffffff

000103d0 <memchr>:
   103d0:	and.w	r1, r1, #255	; 0xff
   103d4:	cmp	r2, #16
   103d6:	blt.n	10430 <memchr+0x60>
   103d8:	tst.w	r0, #7
   103dc:	beq.n	103f0 <memchr+0x20>
   103de:	ldrb.w	r3, [r0], #1
   103e2:	subs	r2, #1
   103e4:	cmp	r3, r1
   103e6:	beq.n	10444 <memchr+0x74>
   103e8:	tst.w	r0, #7
   103ec:	cbz	r2, 10440 <memchr+0x70>
   103ee:	bne.n	103de <memchr+0xe>
   103f0:	push	{r4, r5, r6, r7}
   103f2:	orr.w	r1, r1, r1, lsl #8
   103f6:	orr.w	r1, r1, r1, lsl #16
   103fa:	bic.w	r4, r2, #7
   103fe:	mvns.w	r7, #0
   10402:	movs	r3, #0
   10404:	ldrd	r5, r6, [r0], #8
   10408:	subs	r4, #8
   1040a:	eor.w	r5, r5, r1
   1040e:	eor.w	r6, r6, r1
   10412:	uadd8	r5, r5, r7
   10416:	sel	r5, r3, r7
   1041a:	uadd8	r6, r6, r7
   1041e:	sel	r6, r5, r7
   10422:	cbnz	r6, 10448 <memchr+0x78>
   10424:	bne.n	10404 <memchr+0x34>
   10426:	pop	{r4, r5, r6, r7}
   10428:	and.w	r1, r1, #255	; 0xff
   1042c:	and.w	r2, r2, #7
   10430:	cbz	r2, 10440 <memchr+0x70>
   10432:	ldrb.w	r3, [r0], #1
   10436:	subs	r2, #1
   10438:	eor.w	r3, r3, r1
   1043c:	cbz	r3, 10444 <memchr+0x74>
   1043e:	bne.n	10432 <memchr+0x62>
   10440:	movs	r0, #0
   10442:	bx	lr
   10444:	subs	r0, #1
   10446:	bx	lr
   10448:	cmp	r5, #0
   1044a:	itte	eq
   1044c:	moveq	r5, r6
   1044e:	subeq	r0, #3
   10450:	subne	r0, #7
   10452:	tst.w	r5, #1
   10456:	bne.n	10468 <memchr+0x98>
   10458:	adds	r0, #1
   1045a:	tst.w	r5, #256	; 0x100
   1045e:	ittt	eq
   10460:	addeq	r0, #1
   10462:	tsteq.w	r5, #98304	; 0x18000
   10466:	addeq	r0, #1
   10468:	pop	{r4, r5, r6, r7}
   1046a:	subs	r0, #1
   1046c:	bx	lr
   1046e:	nop

00010470 <memcmp>:
   10470:	cmp	r2, #3
   10472:	push	{r4, r5, r6}
   10474:	bls.n	104c4 <memcmp+0x54>
   10476:	orr.w	r3, r0, r1
   1047a:	lsls	r3, r3, #30
   1047c:	beq.n	104a2 <memcmp+0x32>
   1047e:	ldrb	r4, [r0, #0]
   10480:	ldrb	r5, [r1, #0]
   10482:	cmp	r4, r5
   10484:	bne.n	104cc <memcmp+0x5c>
   10486:	add	r2, r0
   10488:	adds	r3, r0, #1
   1048a:	b.n	10498 <memcmp+0x28>
   1048c:	ldrb.w	r4, [r3], #1
   10490:	ldrb.w	r5, [r1, #1]!
   10494:	cmp	r4, r5
   10496:	bne.n	104cc <memcmp+0x5c>
   10498:	cmp	r3, r2
   1049a:	bne.n	1048c <memcmp+0x1c>
   1049c:	movs	r0, #0
   1049e:	pop	{r4, r5, r6}
   104a0:	bx	lr
   104a2:	mov	r4, r1
   104a4:	mov	r3, r0
   104a6:	ldr	r6, [r3, #0]
   104a8:	ldr	r5, [r4, #0]
   104aa:	cmp	r6, r5
   104ac:	mov	r0, r3
   104ae:	mov	r1, r4
   104b0:	add.w	r3, r3, #4
   104b4:	add.w	r4, r4, #4
   104b8:	bne.n	1047e <memcmp+0xe>
   104ba:	subs	r2, #4
   104bc:	cmp	r2, #3
   104be:	mov	r0, r3
   104c0:	mov	r1, r4
   104c2:	bhi.n	104a6 <memcmp+0x36>
   104c4:	cmp	r2, #0
   104c6:	bne.n	1047e <memcmp+0xe>
   104c8:	mov	r0, r2
   104ca:	b.n	1049e <memcmp+0x2e>
   104cc:	subs	r0, r4, r5
   104ce:	pop	{r4, r5, r6}
   104d0:	bx	lr
   104d2:	nop

000104d4 <memmove>:
   104d4:	cmp	r0, r1
   104d6:	push	{r4, r5, r6, r7, lr}
   104d8:	bls.n	104f6 <memmove+0x22>
   104da:	adds	r3, r1, r2
   104dc:	cmp	r0, r3
   104de:	bcs.n	104f6 <memmove+0x22>
   104e0:	adds	r1, r0, r2
   104e2:	cmp	r2, #0
   104e4:	beq.n	1058a <memmove+0xb6>
   104e6:	subs	r2, r3, r2
   104e8:	ldrb.w	r4, [r3, #-1]!
   104ec:	strb.w	r4, [r1, #-1]!
   104f0:	cmp	r3, r2
   104f2:	bne.n	104e8 <memmove+0x14>
   104f4:	pop	{r4, r5, r6, r7, pc}
   104f6:	cmp	r2, #15
   104f8:	bls.n	1058c <memmove+0xb8>
   104fa:	orr.w	r3, r1, r0
   104fe:	lsls	r3, r3, #30
   10500:	bne.n	10590 <memmove+0xbc>
   10502:	add.w	r4, r0, #16
   10506:	add.w	r3, r1, #16
   1050a:	mov	r5, r2
   1050c:	ldr.w	r6, [r3, #-16]
   10510:	str.w	r6, [r4, #-16]
   10514:	ldr.w	r6, [r3, #-12]
   10518:	str.w	r6, [r4, #-12]
   1051c:	ldr.w	r6, [r3, #-8]
   10520:	str.w	r6, [r4, #-8]
   10524:	subs	r5, #16
   10526:	ldr.w	r6, [r3, #-4]
   1052a:	str.w	r6, [r4, #-4]
   1052e:	cmp	r5, #15
   10530:	add.w	r3, r3, #16
   10534:	add.w	r4, r4, #16
   10538:	bhi.n	1050c <memmove+0x38>
   1053a:	sub.w	r3, r2, #16
   1053e:	bic.w	r3, r3, #15
   10542:	and.w	lr, r2, #15
   10546:	adds	r3, #16
   10548:	cmp.w	lr, #3
   1054c:	add	r1, r3
   1054e:	add	r3, r0
   10550:	bls.n	10596 <memmove+0xc2>
   10552:	subs	r6, r3, #4
   10554:	mov	r5, r1
   10556:	mov	r4, lr
   10558:	subs	r4, #4
   1055a:	ldr.w	r7, [r5], #4
   1055e:	str.w	r7, [r6, #4]!
   10562:	cmp	r4, #3
   10564:	bhi.n	10558 <memmove+0x84>
   10566:	sub.w	r4, lr, #4
   1056a:	bic.w	r4, r4, #3
   1056e:	adds	r4, #4
   10570:	add	r3, r4
   10572:	add	r1, r4
   10574:	and.w	r2, r2, #3
   10578:	cbz	r2, 10594 <memmove+0xc0>
   1057a:	subs	r3, #1
   1057c:	add	r2, r1
   1057e:	ldrb.w	r4, [r1], #1
   10582:	strb.w	r4, [r3, #1]!
   10586:	cmp	r2, r1
   10588:	bne.n	1057e <memmove+0xaa>
   1058a:	pop	{r4, r5, r6, r7, pc}
   1058c:	mov	r3, r0
   1058e:	b.n	10578 <memmove+0xa4>
   10590:	mov	r3, r0
   10592:	b.n	1057a <memmove+0xa6>
   10594:	pop	{r4, r5, r6, r7, pc}
   10596:	mov	r2, lr
   10598:	b.n	10578 <memmove+0xa4>
   1059a:	nop

0001059c <memset>:
   1059c:	push	{r4, r5, r6}
   1059e:	lsls	r4, r0, #30
   105a0:	beq.n	10630 <memset+0x94>
   105a2:	subs	r4, r2, #1
   105a4:	cmp	r2, #0
   105a6:	beq.n	1062c <memset+0x90>
   105a8:	uxtb	r5, r1
   105aa:	mov	r3, r0
   105ac:	b.n	105b4 <memset+0x18>
   105ae:	subs	r2, r4, #1
   105b0:	cbz	r4, 1062c <memset+0x90>
   105b2:	mov	r4, r2
   105b4:	strb.w	r5, [r3], #1
   105b8:	lsls	r2, r3, #30
   105ba:	bne.n	105ae <memset+0x12>
   105bc:	cmp	r4, #3
   105be:	bls.n	1061e <memset+0x82>
   105c0:	uxtb	r5, r1
   105c2:	orr.w	r5, r5, r5, lsl #8
   105c6:	cmp	r4, #15
   105c8:	orr.w	r5, r5, r5, lsl #16
   105cc:	bls.n	10602 <memset+0x66>
   105ce:	add.w	r2, r3, #16
   105d2:	mov	r6, r4
   105d4:	subs	r6, #16
   105d6:	cmp	r6, #15
   105d8:	str.w	r5, [r2, #-16]
   105dc:	str.w	r5, [r2, #-12]
   105e0:	str.w	r5, [r2, #-8]
   105e4:	str.w	r5, [r2, #-4]
   105e8:	add.w	r2, r2, #16
   105ec:	bhi.n	105d4 <memset+0x38>
   105ee:	sub.w	r2, r4, #16
   105f2:	bic.w	r2, r2, #15
   105f6:	and.w	r4, r4, #15
   105fa:	adds	r2, #16
   105fc:	cmp	r4, #3
   105fe:	add	r3, r2
   10600:	bls.n	1061e <memset+0x82>
   10602:	mov	r6, r3
   10604:	mov	r2, r4
   10606:	subs	r2, #4
   10608:	cmp	r2, #3
   1060a:	str.w	r5, [r6], #4
   1060e:	bhi.n	10606 <memset+0x6a>
   10610:	subs	r2, r4, #4
   10612:	bic.w	r2, r2, #3
   10616:	adds	r2, #4
   10618:	add	r3, r2
   1061a:	and.w	r4, r4, #3
   1061e:	cbz	r4, 1062c <memset+0x90>
   10620:	uxtb	r1, r1
   10622:	add	r4, r3
   10624:	strb.w	r1, [r3], #1
   10628:	cmp	r3, r4
   1062a:	bne.n	10624 <memset+0x88>
   1062c:	pop	{r4, r5, r6}
   1062e:	bx	lr
   10630:	mov	r4, r2
   10632:	mov	r3, r0
   10634:	b.n	105bc <memset+0x20>
   10636:	nop

00010638 <__malloc_lock>:
   10638:	bx	lr
   1063a:	nop

0001063c <__malloc_unlock>:
   1063c:	bx	lr
   1063e:	nop

00010640 <_realloc_r>:
   10640:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10644:	mov	r7, r2
   10646:	sub	sp, #12
   10648:	cmp	r1, #0
   1064a:	beq.w	107d0 <_realloc_r+0x190>
   1064e:	mov	r6, r1
   10650:	mov	r9, r0
   10652:	add.w	r5, r7, #11
   10656:	bl	10638 <__malloc_lock>
   1065a:	ldr.w	lr, [r6, #-4]
   1065e:	cmp	r5, #22
   10660:	bic.w	r4, lr, #3
   10664:	sub.w	r8, r6, #8
   10668:	bhi.n	106ec <_realloc_r+0xac>
   1066a:	movs	r2, #16
   1066c:	mov	r5, r2
   1066e:	cmp	r7, r5
   10670:	bhi.n	106f6 <_realloc_r+0xb6>
   10672:	cmp	r4, r2
   10674:	bge.n	10762 <_realloc_r+0x122>
   10676:	ldr	r3, [pc, #804]	; (1099c <_realloc_r+0x35c>)
   10678:	ldr	r1, [r3, #8]
   1067a:	add.w	r0, r8, r4
   1067e:	cmp	r0, r1
   10680:	ldr	r1, [r0, #4]
   10682:	beq.w	10838 <_realloc_r+0x1f8>
   10686:	bic.w	r3, r1, #1
   1068a:	add	r3, r0
   1068c:	ldr	r3, [r3, #4]
   1068e:	lsls	r3, r3, #31
   10690:	bpl.n	1078e <_realloc_r+0x14e>
   10692:	tst.w	lr, #1
   10696:	beq.n	10704 <_realloc_r+0xc4>
   10698:	mov	r1, r7
   1069a:	mov	r0, r9
   1069c:	bl	fe30 <_malloc_r>
   106a0:	mov	r7, r0
   106a2:	cbz	r0, 106de <_realloc_r+0x9e>
   106a4:	ldr.w	r3, [r6, #-4]
   106a8:	bic.w	r3, r3, #1
   106ac:	add	r3, r8
   106ae:	sub.w	r2, r0, #8
   106b2:	cmp	r2, r3
   106b4:	beq.w	10940 <_realloc_r+0x300>
   106b8:	subs	r2, r4, #4
   106ba:	cmp	r2, #36	; 0x24
   106bc:	bhi.w	10922 <_realloc_r+0x2e2>
   106c0:	cmp	r2, #19
   106c2:	bhi.w	108ce <_realloc_r+0x28e>
   106c6:	mov	r3, r0
   106c8:	mov	r2, r6
   106ca:	ldr	r1, [r2, #0]
   106cc:	str	r1, [r3, #0]
   106ce:	ldr	r1, [r2, #4]
   106d0:	str	r1, [r3, #4]
   106d2:	ldr	r2, [r2, #8]
   106d4:	str	r2, [r3, #8]
   106d6:	mov	r1, r6
   106d8:	mov	r0, r9
   106da:	bl	136f8 <_free_r>
   106de:	mov	r0, r9
   106e0:	bl	1063c <__malloc_unlock>
   106e4:	mov	r0, r7
   106e6:	add	sp, #12
   106e8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   106ec:	bic.w	r5, r5, #7
   106f0:	cmp	r5, #0
   106f2:	mov	r2, r5
   106f4:	bge.n	1066e <_realloc_r+0x2e>
   106f6:	movs	r3, #12
   106f8:	movs	r0, #0
   106fa:	str.w	r3, [r9]
   106fe:	add	sp, #12
   10700:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10704:	ldr.w	r3, [r6, #-8]
   10708:	rsb	sl, r3, r8
   1070c:	ldr.w	r3, [sl, #4]
   10710:	bic.w	ip, r3, #3
   10714:	add.w	r3, r4, ip
   10718:	cmp	r3, r2
   1071a:	blt.n	10698 <_realloc_r+0x58>
   1071c:	mov	r7, sl
   1071e:	ldr.w	r1, [sl, #12]
   10722:	ldr.w	r0, [r7, #8]!
   10726:	subs	r2, r4, #4
   10728:	cmp	r2, #36	; 0x24
   1072a:	str	r1, [r0, #12]
   1072c:	str	r0, [r1, #8]
   1072e:	bhi.w	10960 <_realloc_r+0x320>
   10732:	cmp	r2, #19
   10734:	bls.w	1095c <_realloc_r+0x31c>
   10738:	ldr	r1, [r6, #0]
   1073a:	str.w	r1, [sl, #8]
   1073e:	ldr	r1, [r6, #4]
   10740:	str.w	r1, [sl, #12]
   10744:	cmp	r2, #27
   10746:	bhi.w	109a0 <_realloc_r+0x360>
   1074a:	adds	r6, #8
   1074c:	add.w	r2, sl, #16
   10750:	ldr	r1, [r6, #0]
   10752:	str	r1, [r2, #0]
   10754:	ldr	r1, [r6, #4]
   10756:	str	r1, [r2, #4]
   10758:	ldr	r1, [r6, #8]
   1075a:	str	r1, [r2, #8]
   1075c:	mov	r6, r7
   1075e:	mov	r4, r3
   10760:	mov	r8, sl
   10762:	subs	r3, r4, r5
   10764:	cmp	r3, #15
   10766:	bhi.n	107a4 <_realloc_r+0x164>
   10768:	ldr.w	r3, [r8, #4]
   1076c:	and.w	r3, r3, #1
   10770:	orrs	r3, r4
   10772:	add	r4, r8
   10774:	str.w	r3, [r8, #4]
   10778:	ldr	r3, [r4, #4]
   1077a:	orr.w	r3, r3, #1
   1077e:	str	r3, [r4, #4]
   10780:	mov	r0, r9
   10782:	bl	1063c <__malloc_unlock>
   10786:	mov	r0, r6
   10788:	add	sp, #12
   1078a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1078e:	bic.w	r1, r1, #3
   10792:	add	r1, r4
   10794:	cmp	r1, r2
   10796:	blt.n	107dc <_realloc_r+0x19c>
   10798:	ldr	r3, [r0, #12]
   1079a:	ldr	r2, [r0, #8]
   1079c:	mov	r4, r1
   1079e:	str	r3, [r2, #12]
   107a0:	str	r2, [r3, #8]
   107a2:	b.n	10762 <_realloc_r+0x122>
   107a4:	ldr.w	r2, [r8, #4]
   107a8:	add.w	r1, r8, r5
   107ac:	and.w	r2, r2, #1
   107b0:	orrs	r5, r2
   107b2:	orr.w	r2, r3, #1
   107b6:	add	r3, r1
   107b8:	str.w	r5, [r8, #4]
   107bc:	str	r2, [r1, #4]
   107be:	ldr	r2, [r3, #4]
   107c0:	orr.w	r2, r2, #1
   107c4:	adds	r1, #8
   107c6:	str	r2, [r3, #4]
   107c8:	mov	r0, r9
   107ca:	bl	136f8 <_free_r>
   107ce:	b.n	10780 <_realloc_r+0x140>
   107d0:	mov	r1, r2
   107d2:	add	sp, #12
   107d4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   107d8:	b.w	fe30 <_malloc_r>
   107dc:	tst.w	lr, #1
   107e0:	bne.w	10698 <_realloc_r+0x58>
   107e4:	ldr.w	r3, [r6, #-8]
   107e8:	rsb	sl, r3, r8
   107ec:	ldr.w	r3, [sl, #4]
   107f0:	bic.w	ip, r3, #3
   107f4:	add.w	lr, r1, ip
   107f8:	cmp	lr, r2
   107fa:	blt.n	10714 <_realloc_r+0xd4>
   107fc:	ldr	r3, [r0, #12]
   107fe:	ldr	r2, [r0, #8]
   10800:	mov	r7, sl
   10802:	str	r3, [r2, #12]
   10804:	str	r2, [r3, #8]
   10806:	ldr.w	r1, [r7, #8]!
   1080a:	ldr.w	r3, [sl, #12]
   1080e:	str	r3, [r1, #12]
   10810:	subs	r2, r4, #4
   10812:	cmp	r2, #36	; 0x24
   10814:	str	r1, [r3, #8]
   10816:	bhi.w	1094c <_realloc_r+0x30c>
   1081a:	cmp	r2, #19
   1081c:	bls.n	108e4 <_realloc_r+0x2a4>
   1081e:	ldr	r3, [r6, #0]
   10820:	str.w	r3, [sl, #8]
   10824:	ldr	r3, [r6, #4]
   10826:	str.w	r3, [sl, #12]
   1082a:	cmp	r2, #27
   1082c:	bhi.w	10970 <_realloc_r+0x330>
   10830:	adds	r6, #8
   10832:	add.w	r3, sl, #16
   10836:	b.n	108e6 <_realloc_r+0x2a6>
   10838:	bic.w	fp, r1, #3
   1083c:	add	fp, r4
   1083e:	add.w	r0, r5, #16
   10842:	cmp	fp, r0
   10844:	bge.n	108fa <_realloc_r+0x2ba>
   10846:	tst.w	lr, #1
   1084a:	bne.w	10698 <_realloc_r+0x58>
   1084e:	ldr.w	r1, [r6, #-8]
   10852:	rsb	sl, r1, r8
   10856:	ldr.w	r1, [sl, #4]
   1085a:	bic.w	ip, r1, #3
   1085e:	add	fp, ip
   10860:	cmp	r0, fp
   10862:	bgt.w	10714 <_realloc_r+0xd4>
   10866:	mov	r7, sl
   10868:	ldr.w	r1, [sl, #12]
   1086c:	ldr.w	r0, [r7, #8]!
   10870:	subs	r2, r4, #4
   10872:	cmp	r2, #36	; 0x24
   10874:	str	r1, [r0, #12]
   10876:	str	r0, [r1, #8]
   10878:	bhi.w	109e4 <_realloc_r+0x3a4>
   1087c:	cmp	r2, #19
   1087e:	bls.w	109cc <_realloc_r+0x38c>
   10882:	ldr	r1, [r6, #0]
   10884:	str.w	r1, [sl, #8]
   10888:	ldr	r1, [r6, #4]
   1088a:	str.w	r1, [sl, #12]
   1088e:	cmp	r2, #27
   10890:	bhi.w	109f2 <_realloc_r+0x3b2>
   10894:	adds	r6, #8
   10896:	add.w	r2, sl, #16
   1089a:	ldr	r1, [r6, #0]
   1089c:	str	r1, [r2, #0]
   1089e:	ldr	r1, [r6, #4]
   108a0:	str	r1, [r2, #4]
   108a2:	ldr	r1, [r6, #8]
   108a4:	str	r1, [r2, #8]
   108a6:	add.w	r1, sl, r5
   108aa:	rsb	r2, r5, fp
   108ae:	orr.w	r2, r2, #1
   108b2:	str	r1, [r3, #8]
   108b4:	str	r2, [r1, #4]
   108b6:	ldr.w	r3, [sl, #4]
   108ba:	and.w	r3, r3, #1
   108be:	orrs	r5, r3
   108c0:	mov	r0, r9
   108c2:	str.w	r5, [sl, #4]
   108c6:	bl	1063c <__malloc_unlock>
   108ca:	mov	r0, r7
   108cc:	b.n	10788 <_realloc_r+0x148>
   108ce:	ldr	r3, [r6, #0]
   108d0:	str	r3, [r0, #0]
   108d2:	ldr	r3, [r6, #4]
   108d4:	str	r3, [r0, #4]
   108d6:	cmp	r2, #27
   108d8:	bhi.n	1092a <_realloc_r+0x2ea>
   108da:	add.w	r3, r0, #8
   108de:	add.w	r2, r6, #8
   108e2:	b.n	106ca <_realloc_r+0x8a>
   108e4:	mov	r3, r7
   108e6:	ldr	r2, [r6, #0]
   108e8:	str	r2, [r3, #0]
   108ea:	ldr	r2, [r6, #4]
   108ec:	str	r2, [r3, #4]
   108ee:	ldr	r2, [r6, #8]
   108f0:	str	r2, [r3, #8]
   108f2:	mov	r6, r7
   108f4:	mov	r4, lr
   108f6:	mov	r8, sl
   108f8:	b.n	10762 <_realloc_r+0x122>
   108fa:	add.w	r1, r8, r5
   108fe:	rsb	fp, r5, fp
   10902:	orr.w	r2, fp, #1
   10906:	str	r1, [r3, #8]
   10908:	str	r2, [r1, #4]
   1090a:	ldr.w	r3, [r6, #-4]
   1090e:	and.w	r3, r3, #1
   10912:	orrs	r5, r3
   10914:	mov	r0, r9
   10916:	str.w	r5, [r6, #-4]
   1091a:	bl	1063c <__malloc_unlock>
   1091e:	mov	r0, r6
   10920:	b.n	10788 <_realloc_r+0x148>
   10922:	mov	r1, r6
   10924:	bl	104d4 <memmove>
   10928:	b.n	106d6 <_realloc_r+0x96>
   1092a:	ldr	r3, [r6, #8]
   1092c:	str	r3, [r0, #8]
   1092e:	ldr	r3, [r6, #12]
   10930:	str	r3, [r0, #12]
   10932:	cmp	r2, #36	; 0x24
   10934:	beq.n	10988 <_realloc_r+0x348>
   10936:	add.w	r3, r0, #16
   1093a:	add.w	r2, r6, #16
   1093e:	b.n	106ca <_realloc_r+0x8a>
   10940:	ldr.w	r3, [r0, #-4]
   10944:	bic.w	r3, r3, #3
   10948:	add	r4, r3
   1094a:	b.n	10762 <_realloc_r+0x122>
   1094c:	mov	r1, r6
   1094e:	mov	r0, r7
   10950:	mov	r4, lr
   10952:	mov	r8, sl
   10954:	bl	104d4 <memmove>
   10958:	mov	r6, r7
   1095a:	b.n	10762 <_realloc_r+0x122>
   1095c:	mov	r2, r7
   1095e:	b.n	10750 <_realloc_r+0x110>
   10960:	mov	r1, r6
   10962:	mov	r0, r7
   10964:	mov	r4, r3
   10966:	mov	r8, sl
   10968:	bl	104d4 <memmove>
   1096c:	mov	r6, r7
   1096e:	b.n	10762 <_realloc_r+0x122>
   10970:	ldr	r3, [r6, #8]
   10972:	str.w	r3, [sl, #16]
   10976:	ldr	r3, [r6, #12]
   10978:	str.w	r3, [sl, #20]
   1097c:	cmp	r2, #36	; 0x24
   1097e:	beq.n	109b8 <_realloc_r+0x378>
   10980:	adds	r6, #16
   10982:	add.w	r3, sl, #24
   10986:	b.n	108e6 <_realloc_r+0x2a6>
   10988:	ldr	r3, [r6, #16]
   1098a:	str	r3, [r0, #16]
   1098c:	ldr	r3, [r6, #20]
   1098e:	str	r3, [r0, #20]
   10990:	add.w	r2, r6, #24
   10994:	add.w	r3, r0, #24
   10998:	b.n	106ca <_realloc_r+0x8a>
   1099a:	nop
   1099c:	.word	0x1fff1080
   109a0:	ldr	r1, [r6, #8]
   109a2:	str.w	r1, [sl, #16]
   109a6:	ldr	r1, [r6, #12]
   109a8:	str.w	r1, [sl, #20]
   109ac:	cmp	r2, #36	; 0x24
   109ae:	beq.n	109d0 <_realloc_r+0x390>
   109b0:	adds	r6, #16
   109b2:	add.w	r2, sl, #24
   109b6:	b.n	10750 <_realloc_r+0x110>
   109b8:	ldr	r3, [r6, #16]
   109ba:	str.w	r3, [sl, #24]
   109be:	ldr	r3, [r6, #20]
   109c0:	str.w	r3, [sl, #28]
   109c4:	adds	r6, #24
   109c6:	add.w	r3, sl, #32
   109ca:	b.n	108e6 <_realloc_r+0x2a6>
   109cc:	mov	r2, r7
   109ce:	b.n	1089a <_realloc_r+0x25a>
   109d0:	ldr	r2, [r6, #16]
   109d2:	str.w	r2, [sl, #24]
   109d6:	ldr	r2, [r6, #20]
   109d8:	str.w	r2, [sl, #28]
   109dc:	adds	r6, #24
   109de:	add.w	r2, sl, #32
   109e2:	b.n	10750 <_realloc_r+0x110>
   109e4:	mov	r1, r6
   109e6:	mov	r0, r7
   109e8:	str	r3, [sp, #4]
   109ea:	bl	104d4 <memmove>
   109ee:	ldr	r3, [sp, #4]
   109f0:	b.n	108a6 <_realloc_r+0x266>
   109f2:	ldr	r1, [r6, #8]
   109f4:	str.w	r1, [sl, #16]
   109f8:	ldr	r1, [r6, #12]
   109fa:	str.w	r1, [sl, #20]
   109fe:	cmp	r2, #36	; 0x24
   10a00:	beq.n	10a0a <_realloc_r+0x3ca>
   10a02:	adds	r6, #16
   10a04:	add.w	r2, sl, #24
   10a08:	b.n	1089a <_realloc_r+0x25a>
   10a0a:	ldr	r2, [r6, #16]
   10a0c:	str.w	r2, [sl, #24]
   10a10:	ldr	r2, [r6, #20]
   10a12:	str.w	r2, [sl, #28]
   10a16:	adds	r6, #24
   10a18:	add.w	r2, sl, #32
   10a1c:	b.n	1089a <_realloc_r+0x25a>
   10a1e:	nop

00010a20 <_sbrk_r>:
   10a20:	push	{r3, r4, r5, lr}
   10a22:	ldr	r4, [pc, #28]	; (10a40 <_sbrk_r+0x20>)
   10a24:	movs	r3, #0
   10a26:	mov	r5, r0
   10a28:	mov	r0, r1
   10a2a:	str	r3, [r4, #0]
   10a2c:	bl	d920 <_sbrk>
   10a30:	adds	r3, r0, #1
   10a32:	beq.n	10a36 <_sbrk_r+0x16>
   10a34:	pop	{r3, r4, r5, pc}
   10a36:	ldr	r3, [r4, #0]
   10a38:	cmp	r3, #0
   10a3a:	beq.n	10a34 <_sbrk_r+0x14>
   10a3c:	str	r3, [r5, #0]
   10a3e:	pop	{r3, r4, r5, pc}
   10a40:	.word	0x1fff6840

00010a44 <sprintf>:
   10a44:	push	{r1, r2, r3}
   10a46:	push	{r4, r5, r6, r7, lr}
   10a48:	sub	sp, #112	; 0x70
   10a4a:	add	r3, sp, #132	; 0x84
   10a4c:	ldr	r1, [pc, #60]	; (10a8c <sprintf+0x48>)
   10a4e:	ldr.w	r2, [r3], #4
   10a52:	str	r3, [sp, #4]
   10a54:	mov	r5, r0
   10a56:	mvn.w	r4, #2147483648	; 0x80000000
   10a5a:	ldr	r0, [r1, #0]
   10a5c:	str	r5, [sp, #8]
   10a5e:	mov.w	r7, #520	; 0x208
   10a62:	movw	r6, #65535	; 0xffff
   10a66:	add	r1, sp, #8
   10a68:	str	r5, [sp, #24]
   10a6a:	strh.w	r7, [sp, #20]
   10a6e:	str	r4, [sp, #16]
   10a70:	str	r4, [sp, #28]
   10a72:	strh.w	r6, [sp, #22]
   10a76:	bl	10d80 <_svfprintf_r>
   10a7a:	ldr	r3, [sp, #8]
   10a7c:	movs	r2, #0
   10a7e:	strb	r2, [r3, #0]
   10a80:	add	sp, #112	; 0x70
   10a82:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   10a86:	add	sp, #12
   10a88:	bx	lr
   10a8a:	nop
   10a8c:	.word	0x1fff0f10

00010a90 <strcpy>:
   10a90:	eor.w	r2, r0, r1
   10a94:	mov	ip, r0
   10a96:	tst.w	r2, #3
   10a9a:	bne.n	10b3c <strcpy+0xac>
   10a9c:	tst.w	r1, #3
   10aa0:	bne.n	10b08 <strcpy+0x78>
   10aa2:	str.w	r4, [sp, #-4]!
   10aa6:	tst.w	r1, #4
   10aaa:	ldr.w	r3, [r1], #4
   10aae:	beq.n	10ac8 <strcpy+0x38>
   10ab0:	sub.w	r2, r3, #16843009	; 0x1010101
   10ab4:	bics	r2, r3
   10ab6:	tst.w	r2, #2155905152	; 0x80808080
   10aba:	itt	eq
   10abc:	streq.w	r3, [ip], #4
   10ac0:	ldreq.w	r3, [r1], #4
   10ac4:	bne.n	10af4 <strcpy+0x64>
   10ac6:	nop
   10ac8:	ldr.w	r4, [r1], #4
   10acc:	sub.w	r2, r3, #16843009	; 0x1010101
   10ad0:	bics	r2, r3
   10ad2:	tst.w	r2, #2155905152	; 0x80808080
   10ad6:	sub.w	r2, r4, #16843009	; 0x1010101
   10ada:	bne.n	10af4 <strcpy+0x64>
   10adc:	str.w	r3, [ip], #4
   10ae0:	bics	r2, r4
   10ae2:	tst.w	r2, #2155905152	; 0x80808080
   10ae6:	itt	eq
   10ae8:	ldreq.w	r3, [r1], #4
   10aec:	streq.w	r4, [ip], #4
   10af0:	beq.n	10ac8 <strcpy+0x38>
   10af2:	mov	r3, r4
   10af4:	strb.w	r3, [ip], #1
   10af8:	tst.w	r3, #255	; 0xff
   10afc:	mov.w	r3, r3, ror #8
   10b00:	bne.n	10af4 <strcpy+0x64>
   10b02:	ldr.w	r4, [sp], #4
   10b06:	bx	lr
   10b08:	tst.w	r1, #1
   10b0c:	beq.n	10b1c <strcpy+0x8c>
   10b0e:	ldrb.w	r2, [r1], #1
   10b12:	strb.w	r2, [ip], #1
   10b16:	cmp	r2, #0
   10b18:	it	eq
   10b1a:	bxeq	lr
   10b1c:	tst.w	r1, #2
   10b20:	beq.n	10aa2 <strcpy+0x12>
   10b22:	ldrh.w	r2, [r1], #2
   10b26:	tst.w	r2, #255	; 0xff
   10b2a:	itet	ne
   10b2c:	strhne.w	r2, [ip], #2
   10b30:	strbeq.w	r2, [ip]
   10b34:	tstne.w	r2, #65280	; 0xff00
   10b38:	bne.n	10aa2 <strcpy+0x12>
   10b3a:	bx	lr
   10b3c:	ldrb.w	r2, [r1], #1
   10b40:	strb.w	r2, [ip], #1
   10b44:	cmp	r2, #0
   10b46:	bne.n	10b3c <strcpy+0xac>
   10b48:	bx	lr
   10b4a:	nop

00010b4c <strlcat>:
   10b4c:	push	{r4, r5, r6, lr}
   10b4e:	cbz	r2, 10b8e <strlcat+0x42>
   10b50:	ldrb	r6, [r0, #0]
   10b52:	cbz	r6, 10b9a <strlcat+0x4e>
   10b54:	adds	r3, r0, #1
   10b56:	adds	r6, r0, r2
   10b58:	b.n	10b60 <strlcat+0x14>
   10b5a:	ldrb	r5, [r3, #0]
   10b5c:	adds	r3, #1
   10b5e:	cbz	r5, 10b66 <strlcat+0x1a>
   10b60:	cmp	r6, r3
   10b62:	mov	r4, r3
   10b64:	bne.n	10b5a <strlcat+0xe>
   10b66:	subs	r6, r4, r0
   10b68:	subs	r2, r2, r6
   10b6a:	beq.n	10b90 <strlcat+0x44>
   10b6c:	ldrb	r3, [r1, #0]
   10b6e:	mov	r5, r1
   10b70:	cbz	r3, 10b86 <strlcat+0x3a>
   10b72:	cmp	r2, #1
   10b74:	beq.n	10b7c <strlcat+0x30>
   10b76:	strb	r3, [r4, #0]
   10b78:	subs	r2, #1
   10b7a:	adds	r4, #1
   10b7c:	ldrb.w	r3, [r5, #1]!
   10b80:	cmp	r3, #0
   10b82:	bne.n	10b72 <strlcat+0x26>
   10b84:	subs	r3, r5, r1
   10b86:	movs	r2, #0
   10b88:	strb	r2, [r4, #0]
   10b8a:	adds	r0, r6, r3
   10b8c:	pop	{r4, r5, r6, pc}
   10b8e:	mov	r6, r2
   10b90:	mov	r0, r1
   10b92:	bl	10c00 <strlen>
   10b96:	add	r0, r6
   10b98:	pop	{r4, r5, r6, pc}
   10b9a:	mov	r4, r0
   10b9c:	b.n	10b6c <strlcat+0x20>
   10b9e:	nop

00010ba0 <strlcpy>:
   10ba0:	push	{r4}
   10ba2:	mov	r3, r1
   10ba4:	cbz	r2, 10bba <strlcpy+0x1a>
   10ba6:	b.n	10bb2 <strlcpy+0x12>
   10ba8:	ldrb.w	r4, [r3], #1
   10bac:	strb.w	r4, [r0], #1
   10bb0:	cbz	r4, 10bc2 <strlcpy+0x22>
   10bb2:	subs	r2, #1
   10bb4:	bne.n	10ba8 <strlcpy+0x8>
   10bb6:	movs	r2, #0
   10bb8:	strb	r2, [r0, #0]
   10bba:	ldrb.w	r2, [r3], #1
   10bbe:	cmp	r2, #0
   10bc0:	bne.n	10bba <strlcpy+0x1a>
   10bc2:	subs	r0, r3, r1
   10bc4:	subs	r0, #1
   10bc6:	ldr.w	r4, [sp], #4
   10bca:	bx	lr
   10bcc:			; <UNDEFINED> instruction: 0xffffffff
   10bd0:			; <UNDEFINED> instruction: 0xffffffff
   10bd4:			; <UNDEFINED> instruction: 0xffffffff
   10bd8:			; <UNDEFINED> instruction: 0xffffffff
   10bdc:			; <UNDEFINED> instruction: 0xffffffff
   10be0:			; <UNDEFINED> instruction: 0xffffffff
   10be4:			; <UNDEFINED> instruction: 0xffffffff
   10be8:			; <UNDEFINED> instruction: 0xffffffff
   10bec:			; <UNDEFINED> instruction: 0xffffffff
   10bf0:			; <UNDEFINED> instruction: 0xffffffff
   10bf4:			; <UNDEFINED> instruction: 0xffffffff
   10bf8:			; <UNDEFINED> instruction: 0xffffffff
   10bfc:			; <UNDEFINED> instruction: 0xffffffff

00010c00 <strlen>:
   10c00:	pld	[r0]
   10c04:	strd	r4, r5, [sp, #-8]!
   10c08:	bic.w	r1, r0, #7
   10c0c:	mvn.w	ip, #0
   10c10:	ands.w	r4, r0, #7
   10c14:	pld	[r1, #32]
   10c18:	bne.w	10cae <strlen+0xae>
   10c1c:	mov.w	r4, #0
   10c20:	mvn.w	r0, #7
   10c24:	ldrd	r2, r3, [r1]
   10c28:	pld	[r1, #64]	; 0x40
   10c2c:	add.w	r0, r0, #8
   10c30:	uadd8	r2, r2, ip
   10c34:	sel	r2, r4, ip
   10c38:	uadd8	r3, r3, ip
   10c3c:	sel	r3, r2, ip
   10c40:	cbnz	r3, 10c96 <strlen+0x96>
   10c42:	ldrd	r2, r3, [r1, #8]
   10c46:	uadd8	r2, r2, ip
   10c4a:	add.w	r0, r0, #8
   10c4e:	sel	r2, r4, ip
   10c52:	uadd8	r3, r3, ip
   10c56:	sel	r3, r2, ip
   10c5a:	cbnz	r3, 10c96 <strlen+0x96>
   10c5c:	ldrd	r2, r3, [r1, #16]
   10c60:	uadd8	r2, r2, ip
   10c64:	add.w	r0, r0, #8
   10c68:	sel	r2, r4, ip
   10c6c:	uadd8	r3, r3, ip
   10c70:	sel	r3, r2, ip
   10c74:	cbnz	r3, 10c96 <strlen+0x96>
   10c76:	ldrd	r2, r3, [r1, #24]
   10c7a:	add.w	r1, r1, #32
   10c7e:	uadd8	r2, r2, ip
   10c82:	add.w	r0, r0, #8
   10c86:	sel	r2, r4, ip
   10c8a:	uadd8	r3, r3, ip
   10c8e:	sel	r3, r2, ip
   10c92:	cmp	r3, #0
   10c94:	beq.n	10c24 <strlen+0x24>
   10c96:	cmp	r2, #0
   10c98:	itt	eq
   10c9a:	addeq	r0, #4
   10c9c:	moveq	r2, r3
   10c9e:	rev	r2, r2
   10ca0:	clz	r2, r2
   10ca4:	ldrd	r4, r5, [sp], #8
   10ca8:	add.w	r0, r0, r2, lsr #3
   10cac:	bx	lr
   10cae:	ldrd	r2, r3, [r1]
   10cb2:	and.w	r5, r4, #3
   10cb6:	rsb	r0, r4, #0
   10cba:	mov.w	r5, r5, lsl #3
   10cbe:	tst.w	r4, #4
   10cc2:	pld	[r1, #64]	; 0x40
   10cc6:	lsl.w	r5, ip, r5
   10cca:	orn	r2, r2, r5
   10cce:	itt	ne
   10cd0:	ornne	r3, r3, r5
   10cd4:	movne	r2, ip
   10cd6:	mov.w	r4, #0
   10cda:	b.n	10c30 <strlen+0x30>

00010cdc <strncmp>:
   10cdc:	cmp	r2, #0
   10cde:	beq.n	10d64 <strncmp+0x88>
   10ce0:	orr.w	r3, r0, r1
   10ce4:	ands.w	r3, r3, #3
   10ce8:	push	{r4, r5, r6, r7}
   10cea:	bne.n	10d38 <strncmp+0x5c>
   10cec:	cmp	r2, #3
   10cee:	bls.n	10d38 <strncmp+0x5c>
   10cf0:	ldr	r4, [r0, #0]
   10cf2:	ldr	r5, [r1, #0]
   10cf4:	cmp	r4, r5
   10cf6:	bne.n	10d38 <strncmp+0x5c>
   10cf8:	subs	r2, #4
   10cfa:	beq.n	10d68 <strncmp+0x8c>
   10cfc:	sub.w	r5, r4, #16843009	; 0x1010101
   10d00:	bic.w	r4, r5, r4
   10d04:	tst.w	r4, #2155905152	; 0x80808080
   10d08:	bne.n	10d6e <strncmp+0x92>
   10d0a:	adds	r7, r0, #4
   10d0c:	adds	r5, r1, #4
   10d0e:	b.n	10d2c <strncmp+0x50>
   10d10:	ldr.w	r3, [r7], #4
   10d14:	ldr	r6, [r1, #0]
   10d16:	sub.w	r4, r3, #16843009	; 0x1010101
   10d1a:	cmp	r3, r6
   10d1c:	bic.w	r4, r4, r3
   10d20:	bne.n	10d38 <strncmp+0x5c>
   10d22:	subs	r2, #4
   10d24:	beq.n	10d68 <strncmp+0x8c>
   10d26:	tst.w	r4, #2155905152	; 0x80808080
   10d2a:	bne.n	10d74 <strncmp+0x98>
   10d2c:	cmp	r2, #3
   10d2e:	mov	r1, r5
   10d30:	mov	r0, r7
   10d32:	add.w	r5, r5, #4
   10d36:	bhi.n	10d10 <strncmp+0x34>
   10d38:	ldrb	r3, [r0, #0]
   10d3a:	ldrb	r4, [r1, #0]
   10d3c:	cmp	r4, r3
   10d3e:	add.w	r2, r2, #4294967295
   10d42:	bne.n	10d5e <strncmp+0x82>
   10d44:	cbz	r2, 10d68 <strncmp+0x8c>
   10d46:	cbnz	r4, 10d4e <strncmp+0x72>
   10d48:	b.n	10d78 <strncmp+0x9c>
   10d4a:	cbz	r2, 10d68 <strncmp+0x8c>
   10d4c:	cbz	r3, 10d6e <strncmp+0x92>
   10d4e:	ldrb.w	r3, [r0, #1]!
   10d52:	ldrb.w	r4, [r1, #1]!
   10d56:	cmp	r3, r4
   10d58:	add.w	r2, r2, #4294967295
   10d5c:	beq.n	10d4a <strncmp+0x6e>
   10d5e:	subs	r0, r3, r4
   10d60:	pop	{r4, r5, r6, r7}
   10d62:	bx	lr
   10d64:	mov	r0, r2
   10d66:	bx	lr
   10d68:	mov	r0, r2
   10d6a:	pop	{r4, r5, r6, r7}
   10d6c:	bx	lr
   10d6e:	mov	r0, r3
   10d70:	pop	{r4, r5, r6, r7}
   10d72:	bx	lr
   10d74:	movs	r0, #0
   10d76:	b.n	10d60 <strncmp+0x84>
   10d78:	mov	r0, r4
   10d7a:	b.n	10d60 <strncmp+0x84>
   10d7c:			; <UNDEFINED> instruction: 0xffffffff

00010d80 <_svfprintf_r>:
   10d80:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10d84:	sub	sp, #260	; 0x104
   10d86:	mov	r4, r1
   10d88:	str	r1, [sp, #20]
   10d8a:	mov	r5, r2
   10d8c:	str	r3, [sp, #40]	; 0x28
   10d8e:	str	r0, [sp, #24]
   10d90:	bl	138c8 <_localeconv_r>
   10d94:	ldr	r3, [r0, #0]
   10d96:	str	r3, [sp, #76]	; 0x4c
   10d98:	mov	r0, r3
   10d9a:	bl	10c00 <strlen>
   10d9e:	ldrh	r3, [r4, #12]
   10da0:	str	r0, [sp, #72]	; 0x48
   10da2:	lsls	r6, r3, #24
   10da4:	bpl.n	10dae <_svfprintf_r+0x2e>
   10da6:	ldr	r3, [r4, #16]
   10da8:	cmp	r3, #0
   10daa:	beq.w	12010 <_svfprintf_r+0x1290>
   10dae:	vldr	d7, [pc, #664]	; 11048 <_svfprintf_r+0x2c8>
   10db2:	movs	r3, #0
   10db4:	vstr	d7, [sp, #64]	; 0x40
   10db8:	str	r3, [sp, #56]	; 0x38
   10dba:	str	r3, [sp, #148]	; 0x94
   10dbc:	str	r3, [sp, #144]	; 0x90
   10dbe:	str	r3, [sp, #84]	; 0x54
   10dc0:	str	r3, [sp, #28]
   10dc2:	ldr.w	sl, [pc, #656]	; 11054 <_svfprintf_r+0x2d4>
   10dc6:	add	r3, sp, #192	; 0xc0
   10dc8:	str	r3, [sp, #140]	; 0x8c
   10dca:	mov	r9, r3
   10dcc:	mov	r8, r5
   10dce:	ldrb.w	r3, [r8]
   10dd2:	mov	r4, r8
   10dd4:	cbz	r3, 10e12 <_svfprintf_r+0x92>
   10dd6:	cmp	r3, #37	; 0x25
   10dd8:	bne.n	10de0 <_svfprintf_r+0x60>
   10dda:	b.n	10e12 <_svfprintf_r+0x92>
   10ddc:	cmp	r3, #37	; 0x25
   10dde:	beq.n	10de8 <_svfprintf_r+0x68>
   10de0:	ldrb.w	r3, [r4, #1]!
   10de4:	cmp	r3, #0
   10de6:	bne.n	10ddc <_svfprintf_r+0x5c>
   10de8:	rsb	r5, r8, r4
   10dec:	cbz	r5, 10e12 <_svfprintf_r+0x92>
   10dee:	ldr	r3, [sp, #144]	; 0x90
   10df0:	ldr	r2, [sp, #148]	; 0x94
   10df2:	str.w	r8, [r9]
   10df6:	adds	r3, #1
   10df8:	add	r2, r5
   10dfa:	cmp	r3, #7
   10dfc:	str.w	r5, [r9, #4]
   10e00:	str	r2, [sp, #148]	; 0x94
   10e02:	str	r3, [sp, #144]	; 0x90
   10e04:	bgt.w	10f54 <_svfprintf_r+0x1d4>
   10e08:	add.w	r9, r9, #8
   10e0c:	ldr	r3, [sp, #28]
   10e0e:	add	r3, r5
   10e10:	str	r3, [sp, #28]
   10e12:	ldrb	r3, [r4, #0]
   10e14:	cmp	r3, #0
   10e16:	beq.w	10f66 <_svfprintf_r+0x1e6>
   10e1a:	movs	r3, #0
   10e1c:	mov	r2, r3
   10e1e:	strb.w	r3, [sp, #111]	; 0x6f
   10e22:	mov	r1, r3
   10e24:	str	r3, [sp, #32]
   10e26:	str	r3, [sp, #12]
   10e28:	mov.w	fp, #4294967295
   10e2c:	ldrb	r3, [r4, #1]
   10e2e:	add.w	r8, r4, #1
   10e32:	mov	r5, fp
   10e34:	add.w	r8, r8, #1
   10e38:	sub.w	r0, r3, #32
   10e3c:	cmp	r0, #88	; 0x58
   10e3e:	bhi.w	116aa <_svfprintf_r+0x92a>
   10e42:	tbh	[pc, r0, lsl #1]
   10e46:	.short	0x03a0
   10e48:	.word	0x04320432
   10e4c:	.word	0x043203a8
   10e50:	.word	0x04320432
   10e54:	.word	0x04320432
   10e58:	.word	0x03af0432
   10e5c:	.word	0x043203bd
   10e60:	.word	0x00e2005d
   10e64:	.word	0x01090432
   10e68:	.word	0x01100110
   10e6c:	.word	0x01100110
   10e70:	.word	0x01100110
   10e74:	.word	0x01100110
   10e78:	.word	0x04320110
   10e7c:	.word	0x04320432
   10e80:	.word	0x04320432
   10e84:	.word	0x04320432
   10e88:	.word	0x04320432
   10e8c:	.word	0x01200432
   10e90:	.word	0x04320286
   10e94:	.word	0x04320286
   10e98:	.word	0x04320432
   10e9c:	.word	0x02d40432
   10ea0:	.word	0x04320432
   10ea4:	.word	0x043202e5
   10ea8:	.word	0x04320432
   10eac:	.word	0x04320432
   10eb0:	.word	0x0432030f
   10eb4:	.word	0x033d0432
   10eb8:	.word	0x04320432
   10ebc:	.word	0x04320432
   10ec0:	.word	0x04320432
   10ec4:	.word	0x04320432
   10ec8:	.word	0x04320432
   10ecc:	.word	0x0391037e
   10ed0:	.word	0x02860286
   10ed4:	.word	0x03990286
   10ed8:	.word	0x04320391
   10edc:	.word	0x04070432
   10ee0:	.word	0x04120432
   10ee4:	.word	0x006400a3
   10ee8:	.word	0x043203c2
   10eec:	.word	0x043203c9
   10ef0:	.word	0x043203ea
   10ef4:	.word	0x03f20432
   10ef8:	ldr	r0, [sp, #32]
   10efa:	str	r3, [sp, #40]	; 0x28
   10efc:	negs	r0, r0
   10efe:	str	r0, [sp, #32]
   10f00:	ldr	r3, [sp, #12]
   10f02:	orr.w	r3, r3, #4
   10f06:	str	r3, [sp, #12]
   10f08:	ldrb.w	r3, [r8]
   10f0c:	b.n	10e34 <_svfprintf_r+0xb4>
   10f0e:	ldr	r0, [sp, #40]	; 0x28
   10f10:	mov	fp, r5
   10f12:	movs	r1, #0
   10f14:	ldr	r4, [r0, #0]
   10f16:	strb.w	r1, [sp, #111]	; 0x6f
   10f1a:	adds	r7, r0, #4
   10f1c:	ldr	r0, [sp, #12]
   10f1e:	movs	r3, #48	; 0x30
   10f20:	movs	r2, #120	; 0x78
   10f22:	cmp	fp, r1
   10f24:	strb.w	r3, [sp, #112]	; 0x70
   10f28:	mov.w	r5, #0
   10f2c:	strb.w	r2, [sp, #113]	; 0x71
   10f30:	orr.w	r3, r0, #2
   10f34:	blt.w	116e4 <_svfprintf_r+0x964>
   10f38:	bic.w	r3, r0, #128	; 0x80
   10f3c:	orr.w	r3, r3, #2
   10f40:	str	r3, [sp, #12]
   10f42:	orrs.w	r3, r4, r5
   10f46:	str	r7, [sp, #40]	; 0x28
   10f48:	beq.w	11690 <_svfprintf_r+0x910>
   10f4c:	mov	r7, r1
   10f4e:	str	r2, [sp, #52]	; 0x34
   10f50:	ldr	r0, [pc, #252]	; (11050 <_svfprintf_r+0x2d0>)
   10f52:	b.n	11522 <_svfprintf_r+0x7a2>
   10f54:	add	r2, sp, #140	; 0x8c
   10f56:	ldr	r1, [sp, #20]
   10f58:	ldr	r0, [sp, #24]
   10f5a:	bl	13f08 <__ssprint_r>
   10f5e:	cbnz	r0, 10f74 <_svfprintf_r+0x1f4>
   10f60:	add.w	r9, sp, #192	; 0xc0
   10f64:	b.n	10e0c <_svfprintf_r+0x8c>
   10f66:	ldr	r3, [sp, #148]	; 0x94
   10f68:	cbz	r3, 10f74 <_svfprintf_r+0x1f4>
   10f6a:	ldr	r0, [sp, #24]
   10f6c:	ldr	r1, [sp, #20]
   10f6e:	add	r2, sp, #140	; 0x8c
   10f70:	bl	13f08 <__ssprint_r>
   10f74:	ldr	r3, [sp, #20]
   10f76:	ldrh	r3, [r3, #12]
   10f78:	tst.w	r3, #64	; 0x40
   10f7c:	ldr	r3, [sp, #28]
   10f7e:	it	ne
   10f80:	movne.w	r3, #4294967295
   10f84:	mov	r0, r3
   10f86:	add	sp, #260	; 0x104
   10f88:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10f8c:	str	r3, [sp, #52]	; 0x34
   10f8e:	mov	fp, r5
   10f90:	cmp	r2, #0
   10f92:	bne.w	123fc <_svfprintf_r+0x167c>
   10f96:	ldr	r2, [sp, #12]
   10f98:	ands.w	r3, r2, #32
   10f9c:	beq.w	1142c <_svfprintf_r+0x6ac>
   10fa0:	ldr	r7, [sp, #40]	; 0x28
   10fa2:	adds	r7, #7
   10fa4:	bic.w	r3, r7, #7
   10fa8:	movs	r7, #0
   10faa:	add.w	r1, r3, #8
   10fae:	cmp	fp, r7
   10fb0:	str	r1, [sp, #40]	; 0x28
   10fb2:	ldrd	r4, r5, [r3]
   10fb6:	strb.w	r7, [sp, #111]	; 0x6f
   10fba:	blt.w	11e82 <_svfprintf_r+0x1102>
   10fbe:	bic.w	r3, r2, #128	; 0x80
   10fc2:	str	r3, [sp, #12]
   10fc4:	orrs.w	r3, r4, r5
   10fc8:	beq.w	116d4 <_svfprintf_r+0x954>
   10fcc:	add	r6, sp, #192	; 0xc0
   10fce:	lsrs	r2, r4, #3
   10fd0:	orr.w	r2, r2, r5, lsl #29
   10fd4:	lsrs	r1, r5, #3
   10fd6:	and.w	r3, r4, #7
   10fda:	mov	r5, r1
   10fdc:	mov	r4, r2
   10fde:	adds	r3, #48	; 0x30
   10fe0:	orrs.w	r2, r4, r5
   10fe4:	strb.w	r3, [r6, #-1]!
   10fe8:	bne.n	10fce <_svfprintf_r+0x24e>
   10fea:	ldr	r2, [sp, #12]
   10fec:	lsls	r1, r2, #31
   10fee:	bpl.w	11110 <_svfprintf_r+0x390>
   10ff2:	cmp	r3, #48	; 0x30
   10ff4:	beq.w	11110 <_svfprintf_r+0x390>
   10ff8:	movs	r2, #48	; 0x30
   10ffa:	subs	r3, r6, #1
   10ffc:	strb.w	r2, [r6, #-1]
   11000:	add	r2, sp, #192	; 0xc0
   11002:	subs	r2, r2, r3
   11004:	str	r2, [sp, #36]	; 0x24
   11006:	mov	r6, r3
   11008:	b.n	11116 <_svfprintf_r+0x396>
   1100a:	ldrb.w	r3, [r8]
   1100e:	cmp	r3, #42	; 0x2a
   11010:	add.w	r4, r8, #1
   11014:	beq.w	123e0 <_svfprintf_r+0x1660>
   11018:	sub.w	r0, r3, #48	; 0x30
   1101c:	cmp	r0, #9
   1101e:	it	ls
   11020:	movls	r5, #0
   11022:	bhi.w	12332 <_svfprintf_r+0x15b2>
   11026:	ldrb.w	r3, [r4], #1
   1102a:	add.w	r5, r5, r5, lsl #2
   1102e:	add.w	r5, r0, r5, lsl #1
   11032:	sub.w	r0, r3, #48	; 0x30
   11036:	cmp	r0, #9
   11038:	bls.n	11026 <_svfprintf_r+0x2a6>
   1103a:	orr.w	r5, r5, r5, asr #31
   1103e:	mov	r8, r4
   11040:	b.n	10e38 <_svfprintf_r+0xb8>
   11042:	nop
   11044:	nop.w
	...
   11050:	.word	0x00014a10
   11054:	.word	0x000149dc
   11058:	ldr	r3, [sp, #12]
   1105a:	orr.w	r3, r3, #128	; 0x80
   1105e:	str	r3, [sp, #12]
   11060:	ldrb.w	r3, [r8]
   11064:	b.n	10e34 <_svfprintf_r+0xb4>
   11066:	sub.w	r0, r3, #48	; 0x30
   1106a:	movs	r3, #0
   1106c:	mov	r4, r3
   1106e:	ldrb.w	r3, [r8], #1
   11072:	add.w	r4, r4, r4, lsl #2
   11076:	add.w	r4, r0, r4, lsl #1
   1107a:	sub.w	r0, r3, #48	; 0x30
   1107e:	cmp	r0, #9
   11080:	bls.n	1106e <_svfprintf_r+0x2ee>
   11082:	str	r4, [sp, #32]
   11084:	b.n	10e38 <_svfprintf_r+0xb8>
   11086:	str	r3, [sp, #52]	; 0x34
   11088:	mov	fp, r5
   1108a:	cmp	r2, #0
   1108c:	bne.w	12418 <_svfprintf_r+0x1698>
   11090:	ldr	r3, [sp, #12]
   11092:	orr.w	r3, r3, #16
   11096:	str	r3, [sp, #12]
   11098:	ldr	r3, [sp, #12]
   1109a:	lsls	r4, r3, #26
   1109c:	bpl.w	11b0e <_svfprintf_r+0xd8e>
   110a0:	ldr	r7, [sp, #40]	; 0x28
   110a2:	adds	r7, #7
   110a4:	bic.w	r7, r7, #7
   110a8:	ldrd	r2, r3, [r7]
   110ac:	add.w	r1, r7, #8
   110b0:	str	r1, [sp, #40]	; 0x28
   110b2:	mov	r4, r2
   110b4:	mov	r5, r3
   110b6:	cmp	r2, #0
   110b8:	sbcs.w	r3, r3, #0
   110bc:	blt.w	11b84 <_svfprintf_r+0xe04>
   110c0:	cmp.w	fp, #0
   110c4:	ldrb.w	r7, [sp, #111]	; 0x6f
   110c8:	blt.w	11b4a <_svfprintf_r+0xdca>
   110cc:	ldr	r3, [sp, #12]
   110ce:	bic.w	r3, r3, #128	; 0x80
   110d2:	str	r3, [sp, #12]
   110d4:	orrs.w	r3, r4, r5
   110d8:	beq.w	114ac <_svfprintf_r+0x72c>
   110dc:	cmp	r5, #0
   110de:	it	eq
   110e0:	cmpeq	r4, #10
   110e2:	bcc.w	114b6 <_svfprintf_r+0x736>
   110e6:	add	r6, sp, #192	; 0xc0
   110e8:	mov	r0, r4
   110ea:	mov	r1, r5
   110ec:	movs	r2, #10
   110ee:	movs	r3, #0
   110f0:	bl	fa0c <__aeabi_uldivmod>
   110f4:	adds	r2, #48	; 0x30
   110f6:	strb.w	r2, [r6, #-1]!
   110fa:	mov	r0, r4
   110fc:	mov	r1, r5
   110fe:	movs	r3, #0
   11100:	movs	r2, #10
   11102:	bl	fa0c <__aeabi_uldivmod>
   11106:	mov	r4, r0
   11108:	mov	r5, r1
   1110a:	orrs.w	r3, r4, r5
   1110e:	bne.n	110e8 <_svfprintf_r+0x368>
   11110:	add	r3, sp, #192	; 0xc0
   11112:	subs	r3, r3, r6
   11114:	str	r3, [sp, #36]	; 0x24
   11116:	ldr	r3, [sp, #36]	; 0x24
   11118:	cmp	r3, fp
   1111a:	it	lt
   1111c:	movlt	r3, fp
   1111e:	str	r3, [sp, #16]
   11120:	movs	r3, #0
   11122:	str	r3, [sp, #60]	; 0x3c
   11124:	cbz	r7, 1112c <_svfprintf_r+0x3ac>
   11126:	ldr	r3, [sp, #16]
   11128:	adds	r3, #1
   1112a:	str	r3, [sp, #16]
   1112c:	ldr	r3, [sp, #12]
   1112e:	ands.w	r3, r3, #2
   11132:	str	r3, [sp, #44]	; 0x2c
   11134:	beq.n	1113c <_svfprintf_r+0x3bc>
   11136:	ldr	r3, [sp, #16]
   11138:	adds	r3, #2
   1113a:	str	r3, [sp, #16]
   1113c:	ldr	r3, [sp, #12]
   1113e:	ands.w	r3, r3, #132	; 0x84
   11142:	str	r3, [sp, #48]	; 0x30
   11144:	bne.w	116fe <_svfprintf_r+0x97e>
   11148:	ldr	r3, [sp, #32]
   1114a:	ldr	r2, [sp, #16]
   1114c:	subs	r5, r3, r2
   1114e:	cmp	r5, #0
   11150:	ble.w	116fe <_svfprintf_r+0x97e>
   11154:	cmp	r5, #16
   11156:	ldr	r1, [sp, #148]	; 0x94
   11158:	ldr	r2, [sp, #144]	; 0x90
   1115a:	ldr	r7, [pc, #672]	; (113fc <_svfprintf_r+0x67c>)
   1115c:	ble.n	111ae <_svfprintf_r+0x42e>
   1115e:	str	r6, [sp, #80]	; 0x50
   11160:	mov	r0, r9
   11162:	movs	r4, #16
   11164:	mov	r9, r7
   11166:	ldr	r6, [sp, #20]
   11168:	mov	r7, r5
   1116a:	ldr	r5, [sp, #24]
   1116c:	b.n	11178 <_svfprintf_r+0x3f8>
   1116e:	subs	r7, #16
   11170:	cmp	r7, #16
   11172:	add.w	r0, r0, #8
   11176:	ble.n	111a6 <_svfprintf_r+0x426>
   11178:	adds	r2, #1
   1117a:	ldr	r3, [pc, #640]	; (113fc <_svfprintf_r+0x67c>)
   1117c:	str	r2, [sp, #144]	; 0x90
   1117e:	adds	r1, #16
   11180:	cmp	r2, #7
   11182:	str	r1, [sp, #148]	; 0x94
   11184:	stmia.w	r0, {r3, r4}
   11188:	ble.n	1116e <_svfprintf_r+0x3ee>
   1118a:	add	r2, sp, #140	; 0x8c
   1118c:	mov	r1, r6
   1118e:	mov	r0, r5
   11190:	bl	13f08 <__ssprint_r>
   11194:	cmp	r0, #0
   11196:	bne.w	10f74 <_svfprintf_r+0x1f4>
   1119a:	subs	r7, #16
   1119c:	cmp	r7, #16
   1119e:	ldr	r1, [sp, #148]	; 0x94
   111a0:	ldr	r2, [sp, #144]	; 0x90
   111a2:	add	r0, sp, #192	; 0xc0
   111a4:	bgt.n	11178 <_svfprintf_r+0x3f8>
   111a6:	ldr	r6, [sp, #80]	; 0x50
   111a8:	mov	r5, r7
   111aa:	mov	r7, r9
   111ac:	mov	r9, r0
   111ae:	adds	r2, #1
   111b0:	adds	r4, r5, r1
   111b2:	cmp	r2, #7
   111b4:	str	r4, [sp, #148]	; 0x94
   111b6:	str	r2, [sp, #144]	; 0x90
   111b8:	str.w	r7, [r9]
   111bc:	str.w	r5, [r9, #4]
   111c0:	bgt.w	11a1e <_svfprintf_r+0xc9e>
   111c4:	ldrb.w	r7, [sp, #111]	; 0x6f
   111c8:	add.w	r9, r9, #8
   111cc:	cbz	r7, 111ec <_svfprintf_r+0x46c>
   111ce:	ldr	r3, [sp, #144]	; 0x90
   111d0:	adds	r3, #1
   111d2:	adds	r4, #1
   111d4:	add.w	r1, sp, #111	; 0x6f
   111d8:	movs	r2, #1
   111da:	cmp	r3, #7
   111dc:	str	r4, [sp, #148]	; 0x94
   111de:	str	r3, [sp, #144]	; 0x90
   111e0:	stmia.w	r9, {r1, r2}
   111e4:	bgt.w	11932 <_svfprintf_r+0xbb2>
   111e8:	add.w	r9, r9, #8
   111ec:	ldr	r3, [sp, #44]	; 0x2c
   111ee:	cbz	r3, 1120c <_svfprintf_r+0x48c>
   111f0:	ldr	r3, [sp, #144]	; 0x90
   111f2:	adds	r3, #1
   111f4:	adds	r4, #2
   111f6:	add	r1, sp, #112	; 0x70
   111f8:	movs	r2, #2
   111fa:	cmp	r3, #7
   111fc:	str	r4, [sp, #148]	; 0x94
   111fe:	str	r3, [sp, #144]	; 0x90
   11200:	stmia.w	r9, {r1, r2}
   11204:	bgt.w	1194a <_svfprintf_r+0xbca>
   11208:	add.w	r9, r9, #8
   1120c:	ldr	r3, [sp, #48]	; 0x30
   1120e:	cmp	r3, #128	; 0x80
   11210:	beq.w	117d6 <_svfprintf_r+0xa56>
   11214:	ldr	r3, [sp, #36]	; 0x24
   11216:	rsb	r7, r3, fp
   1121a:	cmp	r7, #0
   1121c:	ble.n	11286 <_svfprintf_r+0x506>
   1121e:	ldr	r2, [pc, #480]	; (11400 <_svfprintf_r+0x680>)
   11220:	ldr	r3, [sp, #144]	; 0x90
   11222:	str	r2, [sp, #44]	; 0x2c
   11224:	cmp	r7, #16
   11226:	ble.n	1126e <_svfprintf_r+0x4ee>
   11228:	mov	r2, r4
   1122a:	mov.w	fp, #16
   1122e:	ldr	r5, [sp, #24]
   11230:	ldr	r4, [sp, #20]
   11232:	b.n	1123e <_svfprintf_r+0x4be>
   11234:	subs	r7, #16
   11236:	cmp	r7, #16
   11238:	add.w	r9, r9, #8
   1123c:	ble.n	1126c <_svfprintf_r+0x4ec>
   1123e:	adds	r3, #1
   11240:	adds	r2, #16
   11242:	cmp	r3, #7
   11244:	str	r2, [sp, #148]	; 0x94
   11246:	str	r3, [sp, #144]	; 0x90
   11248:	stmia.w	r9, {sl, fp}
   1124c:	ble.n	11234 <_svfprintf_r+0x4b4>
   1124e:	add	r2, sp, #140	; 0x8c
   11250:	mov	r1, r4
   11252:	mov	r0, r5
   11254:	bl	13f08 <__ssprint_r>
   11258:	cmp	r0, #0
   1125a:	bne.w	10f74 <_svfprintf_r+0x1f4>
   1125e:	subs	r7, #16
   11260:	cmp	r7, #16
   11262:	ldr	r2, [sp, #148]	; 0x94
   11264:	ldr	r3, [sp, #144]	; 0x90
   11266:	add.w	r9, sp, #192	; 0xc0
   1126a:	bgt.n	1123e <_svfprintf_r+0x4be>
   1126c:	mov	r4, r2
   1126e:	adds	r3, #1
   11270:	ldr	r2, [sp, #44]	; 0x2c
   11272:	str	r3, [sp, #144]	; 0x90
   11274:	add	r4, r7
   11276:	cmp	r3, #7
   11278:	str	r4, [sp, #148]	; 0x94
   1127a:	stmia.w	r9, {r2, r7}
   1127e:	bgt.w	1191a <_svfprintf_r+0xb9a>
   11282:	add.w	r9, r9, #8
   11286:	ldr	r3, [sp, #12]
   11288:	lsls	r2, r3, #23
   1128a:	bmi.w	11702 <_svfprintf_r+0x982>
   1128e:	ldr	r3, [sp, #144]	; 0x90
   11290:	ldr	r1, [sp, #36]	; 0x24
   11292:	str.w	r6, [r9]
   11296:	adds	r3, #1
   11298:	add	r4, r1
   1129a:	cmp	r3, #7
   1129c:	str	r4, [sp, #148]	; 0x94
   1129e:	str.w	r1, [r9, #4]
   112a2:	str	r3, [sp, #144]	; 0x90
   112a4:	bgt.w	118ee <_svfprintf_r+0xb6e>
   112a8:	add.w	r9, r9, #8
   112ac:	ldr	r3, [sp, #12]
   112ae:	lsls	r1, r3, #29
   112b0:	bpl.n	11332 <_svfprintf_r+0x5b2>
   112b2:	ldr	r3, [sp, #32]
   112b4:	ldr	r2, [sp, #16]
   112b6:	subs	r5, r3, r2
   112b8:	cmp	r5, #0
   112ba:	ble.n	11332 <_svfprintf_r+0x5b2>
   112bc:	cmp	r5, #16
   112be:	ldr	r3, [sp, #144]	; 0x90
   112c0:	ldr	r7, [pc, #312]	; (113fc <_svfprintf_r+0x67c>)
   112c2:	ble.n	1130c <_svfprintf_r+0x58c>
   112c4:	mov	r2, r4
   112c6:	movs	r6, #16
   112c8:	ldr.w	fp, [sp, #24]
   112cc:	ldr	r4, [sp, #20]
   112ce:	b.n	112da <_svfprintf_r+0x55a>
   112d0:	subs	r5, #16
   112d2:	cmp	r5, #16
   112d4:	add.w	r9, r9, #8
   112d8:	ble.n	1130a <_svfprintf_r+0x58a>
   112da:	adds	r3, #1
   112dc:	ldr	r1, [pc, #284]	; (113fc <_svfprintf_r+0x67c>)
   112de:	str	r3, [sp, #144]	; 0x90
   112e0:	adds	r2, #16
   112e2:	cmp	r3, #7
   112e4:	str	r2, [sp, #148]	; 0x94
   112e6:	stmia.w	r9, {r1, r6}
   112ea:	ble.n	112d0 <_svfprintf_r+0x550>
   112ec:	add	r2, sp, #140	; 0x8c
   112ee:	mov	r1, r4
   112f0:	mov	r0, fp
   112f2:	bl	13f08 <__ssprint_r>
   112f6:	cmp	r0, #0
   112f8:	bne.w	10f74 <_svfprintf_r+0x1f4>
   112fc:	subs	r5, #16
   112fe:	cmp	r5, #16
   11300:	ldr	r2, [sp, #148]	; 0x94
   11302:	ldr	r3, [sp, #144]	; 0x90
   11304:	add.w	r9, sp, #192	; 0xc0
   11308:	bgt.n	112da <_svfprintf_r+0x55a>
   1130a:	mov	r4, r2
   1130c:	adds	r3, #1
   1130e:	add	r4, r5
   11310:	cmp	r3, #7
   11312:	str	r4, [sp, #148]	; 0x94
   11314:	str	r3, [sp, #144]	; 0x90
   11316:	str.w	r7, [r9]
   1131a:	str.w	r5, [r9, #4]
   1131e:	ble.n	11332 <_svfprintf_r+0x5b2>
   11320:	add	r2, sp, #140	; 0x8c
   11322:	ldr	r1, [sp, #20]
   11324:	ldr	r0, [sp, #24]
   11326:	bl	13f08 <__ssprint_r>
   1132a:	cmp	r0, #0
   1132c:	bne.w	10f74 <_svfprintf_r+0x1f4>
   11330:	ldr	r4, [sp, #148]	; 0x94
   11332:	ldr	r3, [sp, #28]
   11334:	ldr	r2, [sp, #32]
   11336:	ldr	r1, [sp, #16]
   11338:	cmp	r2, r1
   1133a:	ite	ge
   1133c:	addge	r3, r3, r2
   1133e:	addlt	r3, r3, r1
   11340:	str	r3, [sp, #28]
   11342:	cmp	r4, #0
   11344:	bne.w	11906 <_svfprintf_r+0xb86>
   11348:	movs	r3, #0
   1134a:	str	r3, [sp, #144]	; 0x90
   1134c:	add.w	r9, sp, #192	; 0xc0
   11350:	b.n	10dce <_svfprintf_r+0x4e>
   11352:	str	r3, [sp, #52]	; 0x34
   11354:	mov	fp, r5
   11356:	cmp	r2, #0
   11358:	bne.w	12420 <_svfprintf_r+0x16a0>
   1135c:	ldr	r3, [sp, #12]
   1135e:	ldr	r7, [sp, #40]	; 0x28
   11360:	lsls	r2, r3, #28
   11362:	add.w	r7, r7, #7
   11366:	bpl.w	11e52 <_svfprintf_r+0x10d2>
   1136a:	bic.w	r3, r7, #7
   1136e:	vldr	d7, [r3]
   11372:	vstr	d7, [sp, #64]	; 0x40
   11376:	add.w	r2, r3, #8
   1137a:	str	r2, [sp, #40]	; 0x28
   1137c:	ldrd	r1, r2, [sp, #64]	; 0x40
   11380:	bic.w	r3, r2, #2147483648	; 0x80000000
   11384:	str	r1, [sp, #88]	; 0x58
   11386:	str	r3, [sp, #92]	; 0x5c
   11388:	ldrd	r4, r5, [sp, #88]	; 0x58
   1138c:	mov.w	r2, #4294967295
   11390:	mov	r0, r4
   11392:	mov	r1, r5
   11394:	ldr	r3, [pc, #108]	; (11404 <_svfprintf_r+0x684>)
   11396:	bl	f990 <__aeabi_dcmpun>
   1139a:	cmp	r0, #0
   1139c:	bne.w	11d54 <_svfprintf_r+0xfd4>
   113a0:	mov.w	r2, #4294967295
   113a4:	ldr	r3, [pc, #92]	; (11404 <_svfprintf_r+0x684>)
   113a6:	mov	r0, r4
   113a8:	mov	r1, r5
   113aa:	bl	f954 <__aeabi_dcmple>
   113ae:	cmp	r0, #0
   113b0:	bne.w	11d54 <_svfprintf_r+0xfd4>
   113b4:	movs	r2, #0
   113b6:	movs	r3, #0
   113b8:	ldrd	r0, r1, [sp, #64]	; 0x40
   113bc:	bl	f940 <__aeabi_dcmplt>
   113c0:	cmp	r0, #0
   113c2:	bne.w	1226a <_svfprintf_r+0x14ea>
   113c6:	ldrb.w	r7, [sp, #111]	; 0x6f
   113ca:	ldr	r6, [pc, #60]	; (11408 <_svfprintf_r+0x688>)
   113cc:	ldr	r3, [pc, #60]	; (1140c <_svfprintf_r+0x68c>)
   113ce:	ldr	r1, [sp, #12]
   113d0:	bic.w	r1, r1, #128	; 0x80
   113d4:	str	r1, [sp, #12]
   113d6:	ldr	r1, [sp, #52]	; 0x34
   113d8:	movs	r2, #3
   113da:	mov.w	fp, #0
   113de:	str	r2, [sp, #16]
   113e0:	cmp	r1, #71	; 0x47
   113e2:	it	le
   113e4:	movle	r6, r3
   113e6:	str	r2, [sp, #36]	; 0x24
   113e8:	str.w	fp, [sp, #60]	; 0x3c
   113ec:	b.n	11124 <_svfprintf_r+0x3a4>
   113ee:	ldr	r3, [sp, #12]
   113f0:	orr.w	r3, r3, #8
   113f4:	str	r3, [sp, #12]
   113f6:	ldrb.w	r3, [r8]
   113fa:	b.n	10e34 <_svfprintf_r+0xb4>
   113fc:	.word	0x00014a2c
   11400:	.word	0x000149dc
   11404:	.word	0x7fefffff
   11408:	.word	0x000149f0
   1140c:	.word	0x000149ec
   11410:	str	r3, [sp, #52]	; 0x34
   11412:	mov	fp, r5
   11414:	cmp	r2, #0
   11416:	bne.w	12438 <_svfprintf_r+0x16b8>
   1141a:	ldr	r3, [sp, #12]
   1141c:	orr.w	r3, r3, #16
   11420:	str	r3, [sp, #12]
   11422:	ldr	r2, [sp, #12]
   11424:	ands.w	r3, r2, #32
   11428:	bne.w	10fa0 <_svfprintf_r+0x220>
   1142c:	ldr	r1, [sp, #12]
   1142e:	ands.w	r2, r1, #16
   11432:	beq.w	11cec <_svfprintf_r+0xf6c>
   11436:	ldr	r0, [sp, #40]	; 0x28
   11438:	strb.w	r3, [sp, #111]	; 0x6f
   1143c:	cmp.w	fp, #0
   11440:	ldr	r4, [r0, #0]
   11442:	add.w	r7, r0, #4
   11446:	mov.w	r5, #0
   1144a:	blt.w	11e80 <_svfprintf_r+0x1100>
   1144e:	mov	r2, r1
   11450:	bic.w	r2, r2, #128	; 0x80
   11454:	str	r2, [sp, #12]
   11456:	orrs.w	r2, r4, r5
   1145a:	str	r7, [sp, #40]	; 0x28
   1145c:	beq.w	116d4 <_svfprintf_r+0x954>
   11460:	mov	r7, r3
   11462:	b.n	10fcc <_svfprintf_r+0x24c>
   11464:	str	r3, [sp, #52]	; 0x34
   11466:	mov	fp, r5
   11468:	cmp	r2, #0
   1146a:	bne.w	12430 <_svfprintf_r+0x16b0>
   1146e:	ldr	r3, [sp, #12]
   11470:	orr.w	r3, r3, #16
   11474:	str	r3, [sp, #12]
   11476:	ldr	r2, [sp, #12]
   11478:	ands.w	r3, r2, #32
   1147c:	beq.w	11ad8 <_svfprintf_r+0xd58>
   11480:	ldr	r7, [sp, #40]	; 0x28
   11482:	adds	r7, #7
   11484:	bic.w	r3, r7, #7
   11488:	movs	r7, #0
   1148a:	add.w	r1, r3, #8
   1148e:	cmp	fp, r7
   11490:	str	r1, [sp, #40]	; 0x28
   11492:	ldrd	r4, r5, [r3]
   11496:	strb.w	r7, [sp, #111]	; 0x6f
   1149a:	blt.w	11b4a <_svfprintf_r+0xdca>
   1149e:	bic.w	r3, r2, #128	; 0x80
   114a2:	str	r3, [sp, #12]
   114a4:	orrs.w	r3, r4, r5
   114a8:	bne.w	110dc <_svfprintf_r+0x35c>
   114ac:	cmp.w	fp, #0
   114b0:	beq.w	1169e <_svfprintf_r+0x91e>
   114b4:	movs	r4, #0
   114b6:	add	r6, sp, #256	; 0x100
   114b8:	adds	r4, #48	; 0x30
   114ba:	strb.w	r4, [r6, #-65]!
   114be:	b.n	11110 <_svfprintf_r+0x390>
   114c0:	str	r3, [sp, #52]	; 0x34
   114c2:	mov	fp, r5
   114c4:	cmp	r2, #0
   114c6:	bne.w	12428 <_svfprintf_r+0x16a8>
   114ca:	ldr	r3, [sp, #12]
   114cc:	ldr	r0, [pc, #700]	; (1178c <_svfprintf_r+0xa0c>)
   114ce:	lsls	r5, r3, #26
   114d0:	bpl.w	1163e <_svfprintf_r+0x8be>
   114d4:	ldr	r7, [sp, #40]	; 0x28
   114d6:	adds	r7, #7
   114d8:	bic.w	r3, r7, #7
   114dc:	ldrd	r4, r5, [r3]
   114e0:	add.w	r2, r3, #8
   114e4:	str	r2, [sp, #40]	; 0x28
   114e6:	ldr	r2, [sp, #12]
   114e8:	ands.w	r7, r2, #1
   114ec:	beq.w	11962 <_svfprintf_r+0xbe2>
   114f0:	orrs.w	r3, r4, r5
   114f4:	beq.w	11efc <_svfprintf_r+0x117c>
   114f8:	ldrb.w	r2, [sp, #52]	; 0x34
   114fc:	strb.w	r2, [sp, #113]	; 0x71
   11500:	movs	r7, #0
   11502:	ldr	r2, [sp, #12]
   11504:	strb.w	r7, [sp, #111]	; 0x6f
   11508:	movs	r3, #48	; 0x30
   1150a:	cmp	fp, r7
   1150c:	strb.w	r3, [sp, #112]	; 0x70
   11510:	orr.w	r3, r2, #2
   11514:	blt.w	12274 <_svfprintf_r+0x14f4>
   11518:	bic.w	r3, r2, #128	; 0x80
   1151c:	orr.w	r3, r3, #2
   11520:	str	r3, [sp, #12]
   11522:	add	r6, sp, #192	; 0xc0
   11524:	lsrs	r3, r4, #4
   11526:	and.w	r1, r4, #15
   1152a:	orr.w	r3, r3, r5, lsl #28
   1152e:	lsrs	r2, r5, #4
   11530:	mov	r4, r3
   11532:	mov	r5, r2
   11534:	ldrb	r3, [r0, r1]
   11536:	strb.w	r3, [r6, #-1]!
   1153a:	orrs.w	r3, r4, r5
   1153e:	bne.n	11524 <_svfprintf_r+0x7a4>
   11540:	b.n	11110 <_svfprintf_r+0x390>
   11542:	ldr	r1, [sp, #40]	; 0x28
   11544:	str	r3, [sp, #52]	; 0x34
   11546:	ldr	r2, [r1, #0]
   11548:	strb.w	r2, [sp, #152]	; 0x98
   1154c:	movs	r3, #0
   1154e:	mov	r2, r1
   11550:	mov	r7, r3
   11552:	strb.w	r3, [sp, #111]	; 0x6f
   11556:	adds	r2, #4
   11558:	movs	r3, #1
   1155a:	str	r3, [sp, #16]
   1155c:	mov	fp, r7
   1155e:	str	r7, [sp, #60]	; 0x3c
   11560:	str	r2, [sp, #40]	; 0x28
   11562:	str	r3, [sp, #36]	; 0x24
   11564:	add	r6, sp, #152	; 0x98
   11566:	b.n	1112c <_svfprintf_r+0x3ac>
   11568:	str	r3, [sp, #52]	; 0x34
   1156a:	mov	fp, r5
   1156c:	cmp	r2, #0
   1156e:	beq.w	11098 <_svfprintf_r+0x318>
   11572:	strb.w	r1, [sp, #111]	; 0x6f
   11576:	b.n	11098 <_svfprintf_r+0x318>
   11578:	ldr	r3, [sp, #12]
   1157a:	orr.w	r3, r3, #64	; 0x40
   1157e:	str	r3, [sp, #12]
   11580:	ldrb.w	r3, [r8]
   11584:	b.n	10e34 <_svfprintf_r+0xb4>
   11586:	ldrb.w	r3, [r8]
   1158a:	cmp	r1, #0
   1158c:	bne.w	10e34 <_svfprintf_r+0xb4>
   11590:	movs	r2, #1
   11592:	movs	r1, #32
   11594:	b.n	10e34 <_svfprintf_r+0xb4>
   11596:	ldr	r3, [sp, #12]
   11598:	orr.w	r3, r3, #1
   1159c:	str	r3, [sp, #12]
   1159e:	ldrb.w	r3, [r8]
   115a2:	b.n	10e34 <_svfprintf_r+0xb4>
   115a4:	ldr	r4, [sp, #40]	; 0x28
   115a6:	ldr	r3, [r4, #0]
   115a8:	str	r3, [sp, #32]
   115aa:	mov	r0, r3
   115ac:	cmp	r0, #0
   115ae:	mov	r3, r4
   115b0:	add.w	r3, r3, #4
   115b4:	blt.w	10ef8 <_svfprintf_r+0x178>
   115b8:	str	r3, [sp, #40]	; 0x28
   115ba:	ldrb.w	r3, [r8]
   115be:	b.n	10e34 <_svfprintf_r+0xb4>
   115c0:	ldrb.w	r3, [r8]
   115c4:	movs	r2, #1
   115c6:	movs	r1, #43	; 0x2b
   115c8:	b.n	10e34 <_svfprintf_r+0xb4>
   115ca:	ldr	r3, [sp, #12]
   115cc:	orr.w	r3, r3, #32
   115d0:	str	r3, [sp, #12]
   115d2:	ldrb.w	r3, [r8]
   115d6:	b.n	10e34 <_svfprintf_r+0xb4>
   115d8:	ldr	r2, [sp, #40]	; 0x28
   115da:	str	r3, [sp, #52]	; 0x34
   115dc:	ldr	r6, [r2, #0]
   115de:	movs	r4, #0
   115e0:	strb.w	r4, [sp, #111]	; 0x6f
   115e4:	adds	r7, r2, #4
   115e6:	cmp	r6, #0
   115e8:	beq.w	12224 <_svfprintf_r+0x14a4>
   115ec:	cmp	r5, #0
   115ee:	blt.w	120b4 <_svfprintf_r+0x1334>
   115f2:	mov	r2, r5
   115f4:	mov	r1, r4
   115f6:	mov	r0, r6
   115f8:	bl	103d0 <memchr>
   115fc:	cmp	r0, #0
   115fe:	beq.w	122c8 <_svfprintf_r+0x1548>
   11602:	subs	r3, r0, r6
   11604:	str	r3, [sp, #36]	; 0x24
   11606:	mov	fp, r4
   11608:	bic.w	r3, r3, r3, asr #31
   1160c:	str	r7, [sp, #40]	; 0x28
   1160e:	str	r3, [sp, #16]
   11610:	str.w	fp, [sp, #60]	; 0x3c
   11614:	ldrb.w	r7, [sp, #111]	; 0x6f
   11618:	b.n	11124 <_svfprintf_r+0x3a4>
   1161a:	str	r3, [sp, #52]	; 0x34
   1161c:	mov	fp, r5
   1161e:	cmp	r2, #0
   11620:	beq.w	11476 <_svfprintf_r+0x6f6>
   11624:	strb.w	r1, [sp, #111]	; 0x6f
   11628:	b.n	11476 <_svfprintf_r+0x6f6>
   1162a:	str	r3, [sp, #52]	; 0x34
   1162c:	mov	fp, r5
   1162e:	cmp	r2, #0
   11630:	bne.w	12450 <_svfprintf_r+0x16d0>
   11634:	ldr	r3, [sp, #12]
   11636:	ldr	r0, [pc, #344]	; (11790 <_svfprintf_r+0xa10>)
   11638:	lsls	r5, r3, #26
   1163a:	bmi.w	114d4 <_svfprintf_r+0x754>
   1163e:	ldr	r3, [sp, #12]
   11640:	lsls	r4, r3, #27
   11642:	bpl.w	11ec2 <_svfprintf_r+0x1142>
   11646:	ldr	r2, [sp, #40]	; 0x28
   11648:	mov	r3, r2
   1164a:	adds	r3, #4
   1164c:	ldr	r4, [r2, #0]
   1164e:	str	r3, [sp, #40]	; 0x28
   11650:	movs	r5, #0
   11652:	b.n	114e6 <_svfprintf_r+0x766>
   11654:	ldrb.w	r3, [r8]
   11658:	cmp	r3, #108	; 0x6c
   1165a:	beq.w	11fe2 <_svfprintf_r+0x1262>
   1165e:	ldr	r0, [sp, #12]
   11660:	orr.w	r0, r0, #16
   11664:	str	r0, [sp, #12]
   11666:	b.w	10e34 <_svfprintf_r+0xb4>
   1166a:	cmp	r2, #0
   1166c:	bne.w	12448 <_svfprintf_r+0x16c8>
   11670:	ldr	r3, [sp, #12]
   11672:	lsls	r3, r3, #26
   11674:	bpl.w	11d26 <_svfprintf_r+0xfa6>
   11678:	ldr	r2, [sp, #40]	; 0x28
   1167a:	ldr	r1, [sp, #28]
   1167c:	ldr	r3, [r2, #0]
   1167e:	asrs	r5, r1, #31
   11680:	mov	r0, r1
   11682:	adds	r2, #4
   11684:	mov	r1, r5
   11686:	str	r2, [sp, #40]	; 0x28
   11688:	strd	r0, r1, [r3]
   1168c:	b.w	10dce <_svfprintf_r+0x4e>
   11690:	ldr	r0, [pc, #252]	; (11790 <_svfprintf_r+0xa10>)
   11692:	str	r2, [sp, #52]	; 0x34
   11694:	cmp.w	fp, #0
   11698:	bne.w	11984 <_svfprintf_r+0xc04>
   1169c:	mov	r7, fp
   1169e:	mov.w	fp, #0
   116a2:	str.w	fp, [sp, #36]	; 0x24
   116a6:	add	r6, sp, #192	; 0xc0
   116a8:	b.n	11116 <_svfprintf_r+0x396>
   116aa:	str	r3, [sp, #52]	; 0x34
   116ac:	cmp	r2, #0
   116ae:	bne.w	12440 <_svfprintf_r+0x16c0>
   116b2:	ldr	r2, [sp, #52]	; 0x34
   116b4:	cmp	r2, #0
   116b6:	beq.w	10f66 <_svfprintf_r+0x1e6>
   116ba:	movs	r3, #0
   116bc:	movs	r1, #1
   116be:	mov	r7, r3
   116c0:	str	r1, [sp, #16]
   116c2:	strb.w	r2, [sp, #152]	; 0x98
   116c6:	strb.w	r3, [sp, #111]	; 0x6f
   116ca:	mov	fp, r3
   116cc:	str	r3, [sp, #60]	; 0x3c
   116ce:	str	r1, [sp, #36]	; 0x24
   116d0:	add	r6, sp, #152	; 0x98
   116d2:	b.n	1112c <_svfprintf_r+0x3ac>
   116d4:	cmp.w	fp, #0
   116d8:	beq.w	122f8 <_svfprintf_r+0x1578>
   116dc:	movs	r7, #0
   116de:	movs	r4, #0
   116e0:	movs	r5, #0
   116e2:	b.n	10fcc <_svfprintf_r+0x24c>
   116e4:	ldr	r0, [pc, #168]	; (11790 <_svfprintf_r+0xa10>)
   116e6:	str	r3, [sp, #12]
   116e8:	str	r2, [sp, #52]	; 0x34
   116ea:	orrs.w	r3, r4, r5
   116ee:	str	r7, [sp, #40]	; 0x28
   116f0:	mov.w	r7, #0
   116f4:	bne.w	11522 <_svfprintf_r+0x7a2>
   116f8:	movs	r4, #0
   116fa:	movs	r5, #0
   116fc:	b.n	11522 <_svfprintf_r+0x7a2>
   116fe:	ldr	r4, [sp, #148]	; 0x94
   11700:	b.n	111cc <_svfprintf_r+0x44c>
   11702:	ldr	r3, [sp, #52]	; 0x34
   11704:	cmp	r3, #101	; 0x65
   11706:	ble.w	1185e <_svfprintf_r+0xade>
   1170a:	movs	r2, #0
   1170c:	movs	r3, #0
   1170e:	ldrd	r0, r1, [sp, #64]	; 0x40
   11712:	bl	f92c <__aeabi_dcmpeq>
   11716:	cmp	r0, #0
   11718:	beq.w	11988 <_svfprintf_r+0xc08>
   1171c:	ldr	r3, [sp, #144]	; 0x90
   1171e:	ldr	r2, [pc, #116]	; (11794 <_svfprintf_r+0xa14>)
   11720:	str.w	r2, [r9]
   11724:	adds	r3, #1
   11726:	adds	r4, #1
   11728:	movs	r2, #1
   1172a:	cmp	r3, #7
   1172c:	str	r4, [sp, #148]	; 0x94
   1172e:	str	r3, [sp, #144]	; 0x90
   11730:	str.w	r2, [r9, #4]
   11734:	bgt.w	11f14 <_svfprintf_r+0x1194>
   11738:	add.w	r9, r9, #8
   1173c:	ldr	r3, [sp, #116]	; 0x74
   1173e:	ldr	r2, [sp, #56]	; 0x38
   11740:	cmp	r3, r2
   11742:	blt.n	1174c <_svfprintf_r+0x9cc>
   11744:	ldr	r3, [sp, #12]
   11746:	lsls	r3, r3, #31
   11748:	bpl.w	112ac <_svfprintf_r+0x52c>
   1174c:	ldr	r3, [sp, #144]	; 0x90
   1174e:	ldr	r1, [sp, #72]	; 0x48
   11750:	ldr	r2, [sp, #76]	; 0x4c
   11752:	str.w	r2, [r9]
   11756:	adds	r3, #1
   11758:	add	r4, r1
   1175a:	cmp	r3, #7
   1175c:	str	r4, [sp, #148]	; 0x94
   1175e:	str.w	r1, [r9, #4]
   11762:	str	r3, [sp, #144]	; 0x90
   11764:	bgt.w	11ff6 <_svfprintf_r+0x1276>
   11768:	add.w	r9, r9, #8
   1176c:	ldr	r3, [sp, #56]	; 0x38
   1176e:	subs	r5, r3, #1
   11770:	cmp	r5, #0
   11772:	ble.w	112ac <_svfprintf_r+0x52c>
   11776:	ldr	r2, [pc, #32]	; (11798 <_svfprintf_r+0xa18>)
   11778:	ldr	r3, [sp, #144]	; 0x90
   1177a:	str	r2, [sp, #44]	; 0x2c
   1177c:	cmp	r5, #16
   1177e:	ble.w	11b54 <_svfprintf_r+0xdd4>
   11782:	movs	r6, #16
   11784:	ldr	r7, [sp, #24]
   11786:	ldr.w	fp, [sp, #20]
   1178a:	b.n	117a8 <_svfprintf_r+0xa28>
   1178c:	.word	0x000149fc
   11790:	.word	0x00014a10
   11794:	.word	0x00014794
   11798:	.word	0x000149dc
   1179c:	add.w	r9, r9, #8
   117a0:	subs	r5, #16
   117a2:	cmp	r5, #16
   117a4:	ble.w	11b54 <_svfprintf_r+0xdd4>
   117a8:	adds	r3, #1
   117aa:	adds	r4, #16
   117ac:	cmp	r3, #7
   117ae:	str	r4, [sp, #148]	; 0x94
   117b0:	str	r3, [sp, #144]	; 0x90
   117b2:	str.w	sl, [r9]
   117b6:	str.w	r6, [r9, #4]
   117ba:	ble.n	1179c <_svfprintf_r+0xa1c>
   117bc:	add	r2, sp, #140	; 0x8c
   117be:	mov	r1, fp
   117c0:	mov	r0, r7
   117c2:	bl	13f08 <__ssprint_r>
   117c6:	cmp	r0, #0
   117c8:	bne.w	10f74 <_svfprintf_r+0x1f4>
   117cc:	ldr	r4, [sp, #148]	; 0x94
   117ce:	ldr	r3, [sp, #144]	; 0x90
   117d0:	add.w	r9, sp, #192	; 0xc0
   117d4:	b.n	117a0 <_svfprintf_r+0xa20>
   117d6:	ldr	r3, [sp, #32]
   117d8:	ldr	r2, [sp, #16]
   117da:	subs	r7, r3, r2
   117dc:	cmp	r7, #0
   117de:	ble.w	11214 <_svfprintf_r+0x494>
   117e2:	ldr	r2, [pc, #752]	; (11ad4 <_svfprintf_r+0xd54>)
   117e4:	ldr	r3, [sp, #144]	; 0x90
   117e6:	str	r2, [sp, #44]	; 0x2c
   117e8:	cmp	r7, #16
   117ea:	ble.n	11844 <_svfprintf_r+0xac4>
   117ec:	mov	r2, r9
   117ee:	mov	r1, r4
   117f0:	mov	r9, r7
   117f2:	movs	r5, #16
   117f4:	mov	r7, r6
   117f6:	ldr	r4, [sp, #24]
   117f8:	ldr	r6, [sp, #20]
   117fa:	b.n	1180a <_svfprintf_r+0xa8a>
   117fc:	sub.w	r9, r9, #16
   11800:	cmp.w	r9, #16
   11804:	add.w	r2, r2, #8
   11808:	ble.n	1183c <_svfprintf_r+0xabc>
   1180a:	adds	r3, #1
   1180c:	adds	r1, #16
   1180e:	cmp	r3, #7
   11810:	str	r1, [sp, #148]	; 0x94
   11812:	str	r3, [sp, #144]	; 0x90
   11814:	str.w	sl, [r2]
   11818:	str	r5, [r2, #4]
   1181a:	ble.n	117fc <_svfprintf_r+0xa7c>
   1181c:	add	r2, sp, #140	; 0x8c
   1181e:	mov	r1, r6
   11820:	mov	r0, r4
   11822:	bl	13f08 <__ssprint_r>
   11826:	cmp	r0, #0
   11828:	bne.w	10f74 <_svfprintf_r+0x1f4>
   1182c:	sub.w	r9, r9, #16
   11830:	cmp.w	r9, #16
   11834:	ldr	r1, [sp, #148]	; 0x94
   11836:	ldr	r3, [sp, #144]	; 0x90
   11838:	add	r2, sp, #192	; 0xc0
   1183a:	bgt.n	1180a <_svfprintf_r+0xa8a>
   1183c:	mov	r6, r7
   1183e:	mov	r4, r1
   11840:	mov	r7, r9
   11842:	mov	r9, r2
   11844:	adds	r3, #1
   11846:	ldr	r2, [sp, #44]	; 0x2c
   11848:	str	r3, [sp, #144]	; 0x90
   1184a:	add	r4, r7
   1184c:	cmp	r3, #7
   1184e:	str	r4, [sp, #148]	; 0x94
   11850:	stmia.w	r9, {r2, r7}
   11854:	bgt.w	11cd2 <_svfprintf_r+0xf52>
   11858:	add.w	r9, r9, #8
   1185c:	b.n	11214 <_svfprintf_r+0x494>
   1185e:	ldr	r3, [sp, #56]	; 0x38
   11860:	ldr	r5, [sp, #144]	; 0x90
   11862:	cmp	r3, #1
   11864:	ble.w	11c7c <_svfprintf_r+0xefc>
   11868:	adds	r5, #1
   1186a:	adds	r4, #1
   1186c:	movs	r3, #1
   1186e:	cmp	r5, #7
   11870:	str	r4, [sp, #148]	; 0x94
   11872:	str	r5, [sp, #144]	; 0x90
   11874:	str.w	r6, [r9]
   11878:	str.w	r3, [r9, #4]
   1187c:	bgt.w	11c9e <_svfprintf_r+0xf1e>
   11880:	add.w	r9, r9, #8
   11884:	ldr	r2, [sp, #72]	; 0x48
   11886:	ldr	r3, [sp, #76]	; 0x4c
   11888:	str.w	r3, [r9]
   1188c:	adds	r5, #1
   1188e:	add	r4, r2
   11890:	cmp	r5, #7
   11892:	str	r4, [sp, #148]	; 0x94
   11894:	str	r5, [sp, #144]	; 0x90
   11896:	str.w	r2, [r9, #4]
   1189a:	bgt.w	11cb8 <_svfprintf_r+0xf38>
   1189e:	add.w	r9, r9, #8
   118a2:	movs	r3, #0
   118a4:	movs	r2, #0
   118a6:	ldrd	r0, r1, [sp, #64]	; 0x40
   118aa:	bl	f92c <__aeabi_dcmpeq>
   118ae:	ldr	r3, [sp, #56]	; 0x38
   118b0:	cmp	r0, #0
   118b2:	bne.w	11a3c <_svfprintf_r+0xcbc>
   118b6:	subs	r3, #1
   118b8:	adds	r5, #1
   118ba:	adds	r6, #1
   118bc:	add	r4, r3
   118be:	cmp	r5, #7
   118c0:	str	r5, [sp, #144]	; 0x90
   118c2:	str	r4, [sp, #148]	; 0x94
   118c4:	str.w	r6, [r9]
   118c8:	str.w	r3, [r9, #4]
   118cc:	bgt.w	11aba <_svfprintf_r+0xd3a>
   118d0:	add.w	r9, r9, #8
   118d4:	ldr	r2, [sp, #84]	; 0x54
   118d6:	str.w	r2, [r9, #4]
   118da:	adds	r5, #1
   118dc:	add	r4, r2
   118de:	add	r3, sp, #124	; 0x7c
   118e0:	cmp	r5, #7
   118e2:	str	r4, [sp, #148]	; 0x94
   118e4:	str	r5, [sp, #144]	; 0x90
   118e6:	str.w	r3, [r9]
   118ea:	ble.w	112a8 <_svfprintf_r+0x528>
   118ee:	add	r2, sp, #140	; 0x8c
   118f0:	ldr	r1, [sp, #20]
   118f2:	ldr	r0, [sp, #24]
   118f4:	bl	13f08 <__ssprint_r>
   118f8:	cmp	r0, #0
   118fa:	bne.w	10f74 <_svfprintf_r+0x1f4>
   118fe:	ldr	r4, [sp, #148]	; 0x94
   11900:	add.w	r9, sp, #192	; 0xc0
   11904:	b.n	112ac <_svfprintf_r+0x52c>
   11906:	add	r2, sp, #140	; 0x8c
   11908:	ldr	r1, [sp, #20]
   1190a:	ldr	r0, [sp, #24]
   1190c:	bl	13f08 <__ssprint_r>
   11910:	cmp	r0, #0
   11912:	beq.w	11348 <_svfprintf_r+0x5c8>
   11916:	b.w	10f74 <_svfprintf_r+0x1f4>
   1191a:	add	r2, sp, #140	; 0x8c
   1191c:	ldr	r1, [sp, #20]
   1191e:	ldr	r0, [sp, #24]
   11920:	bl	13f08 <__ssprint_r>
   11924:	cmp	r0, #0
   11926:	bne.w	10f74 <_svfprintf_r+0x1f4>
   1192a:	ldr	r4, [sp, #148]	; 0x94
   1192c:	add.w	r9, sp, #192	; 0xc0
   11930:	b.n	11286 <_svfprintf_r+0x506>
   11932:	add	r2, sp, #140	; 0x8c
   11934:	ldr	r1, [sp, #20]
   11936:	ldr	r0, [sp, #24]
   11938:	bl	13f08 <__ssprint_r>
   1193c:	cmp	r0, #0
   1193e:	bne.w	10f74 <_svfprintf_r+0x1f4>
   11942:	ldr	r4, [sp, #148]	; 0x94
   11944:	add.w	r9, sp, #192	; 0xc0
   11948:	b.n	111ec <_svfprintf_r+0x46c>
   1194a:	add	r2, sp, #140	; 0x8c
   1194c:	ldr	r1, [sp, #20]
   1194e:	ldr	r0, [sp, #24]
   11950:	bl	13f08 <__ssprint_r>
   11954:	cmp	r0, #0
   11956:	bne.w	10f74 <_svfprintf_r+0x1f4>
   1195a:	ldr	r4, [sp, #148]	; 0x94
   1195c:	add.w	r9, sp, #192	; 0xc0
   11960:	b.n	1120c <_svfprintf_r+0x48c>
   11962:	cmp.w	fp, #0
   11966:	strb.w	r7, [sp, #111]	; 0x6f
   1196a:	blt.w	11f2c <_svfprintf_r+0x11ac>
   1196e:	bic.w	r3, r2, #128	; 0x80
   11972:	str	r3, [sp, #12]
   11974:	orrs.w	r3, r4, r5
   11978:	bne.w	11522 <_svfprintf_r+0x7a2>
   1197c:	cmp.w	fp, #0
   11980:	beq.w	1169c <_svfprintf_r+0x91c>
   11984:	movs	r7, #0
   11986:	b.n	116f8 <_svfprintf_r+0x978>
   11988:	ldr	r5, [sp, #116]	; 0x74
   1198a:	cmp	r5, #0
   1198c:	ble.w	11f32 <_svfprintf_r+0x11b2>
   11990:	ldr	r3, [sp, #60]	; 0x3c
   11992:	ldr	r2, [sp, #56]	; 0x38
   11994:	cmp	r3, r2
   11996:	it	ge
   11998:	movge	r3, r2
   1199a:	cmp	r3, #0
   1199c:	mov	r5, r3
   1199e:	ble.n	119bc <_svfprintf_r+0xc3c>
   119a0:	ldr	r3, [sp, #144]	; 0x90
   119a2:	str.w	r6, [r9]
   119a6:	adds	r3, #1
   119a8:	add	r4, r5
   119aa:	cmp	r3, #7
   119ac:	str	r4, [sp, #148]	; 0x94
   119ae:	str.w	r5, [r9, #4]
   119b2:	str	r3, [sp, #144]	; 0x90
   119b4:	bgt.w	1210a <_svfprintf_r+0x138a>
   119b8:	add.w	r9, r9, #8
   119bc:	ldr	r3, [sp, #60]	; 0x3c
   119be:	cmp	r5, #0
   119c0:	it	ge
   119c2:	subge	r3, r3, r5
   119c4:	cmp	r3, #0
   119c6:	mov	r5, r3
   119c8:	ble.w	11bbc <_svfprintf_r+0xe3c>
   119cc:	ldr	r2, [pc, #260]	; (11ad4 <_svfprintf_r+0xd54>)
   119ce:	ldr	r3, [sp, #144]	; 0x90
   119d0:	str	r2, [sp, #44]	; 0x2c
   119d2:	cmp	r5, #16
   119d4:	ble.w	11ede <_svfprintf_r+0x115e>
   119d8:	mov	r2, r4
   119da:	movs	r7, #16
   119dc:	ldr.w	fp, [sp, #24]
   119e0:	ldr	r4, [sp, #20]
   119e2:	b.n	119f0 <_svfprintf_r+0xc70>
   119e4:	add.w	r9, r9, #8
   119e8:	subs	r5, #16
   119ea:	cmp	r5, #16
   119ec:	ble.w	11edc <_svfprintf_r+0x115c>
   119f0:	adds	r3, #1
   119f2:	adds	r2, #16
   119f4:	cmp	r3, #7
   119f6:	str	r2, [sp, #148]	; 0x94
   119f8:	str	r3, [sp, #144]	; 0x90
   119fa:	str.w	sl, [r9]
   119fe:	str.w	r7, [r9, #4]
   11a02:	ble.n	119e4 <_svfprintf_r+0xc64>
   11a04:	add	r2, sp, #140	; 0x8c
   11a06:	mov	r1, r4
   11a08:	mov	r0, fp
   11a0a:	bl	13f08 <__ssprint_r>
   11a0e:	cmp	r0, #0
   11a10:	bne.w	10f74 <_svfprintf_r+0x1f4>
   11a14:	ldr	r2, [sp, #148]	; 0x94
   11a16:	ldr	r3, [sp, #144]	; 0x90
   11a18:	add.w	r9, sp, #192	; 0xc0
   11a1c:	b.n	119e8 <_svfprintf_r+0xc68>
   11a1e:	add	r2, sp, #140	; 0x8c
   11a20:	ldr	r1, [sp, #20]
   11a22:	ldr	r0, [sp, #24]
   11a24:	bl	13f08 <__ssprint_r>
   11a28:	cmp	r0, #0
   11a2a:	bne.w	10f74 <_svfprintf_r+0x1f4>
   11a2e:	ldrb.w	r7, [sp, #111]	; 0x6f
   11a32:	ldr	r4, [sp, #148]	; 0x94
   11a34:	add.w	r9, sp, #192	; 0xc0
   11a38:	b.w	111cc <_svfprintf_r+0x44c>
   11a3c:	subs	r6, r3, #1
   11a3e:	cmp	r6, #0
   11a40:	ble.w	118d4 <_svfprintf_r+0xb54>
   11a44:	ldr	r3, [pc, #140]	; (11ad4 <_svfprintf_r+0xd54>)
   11a46:	str	r3, [sp, #44]	; 0x2c
   11a48:	cmp	r6, #16
   11a4a:	ble.n	11aa6 <_svfprintf_r+0xd26>
   11a4c:	str.w	r8, [sp, #36]	; 0x24
   11a50:	movs	r7, #16
   11a52:	mov	r8, r6
   11a54:	ldr.w	fp, [sp, #24]
   11a58:	ldr	r6, [sp, #20]
   11a5a:	b.n	11a6a <_svfprintf_r+0xcea>
   11a5c:	sub.w	r8, r8, #16
   11a60:	cmp.w	r8, #16
   11a64:	add.w	r9, r9, #8
   11a68:	ble.n	11aa0 <_svfprintf_r+0xd20>
   11a6a:	adds	r5, #1
   11a6c:	adds	r4, #16
   11a6e:	cmp	r5, #7
   11a70:	str	r4, [sp, #148]	; 0x94
   11a72:	str	r5, [sp, #144]	; 0x90
   11a74:	str.w	sl, [r9]
   11a78:	str.w	r7, [r9, #4]
   11a7c:	ble.n	11a5c <_svfprintf_r+0xcdc>
   11a7e:	add	r2, sp, #140	; 0x8c
   11a80:	mov	r1, r6
   11a82:	mov	r0, fp
   11a84:	bl	13f08 <__ssprint_r>
   11a88:	cmp	r0, #0
   11a8a:	bne.w	10f74 <_svfprintf_r+0x1f4>
   11a8e:	sub.w	r8, r8, #16
   11a92:	cmp.w	r8, #16
   11a96:	ldr	r4, [sp, #148]	; 0x94
   11a98:	ldr	r5, [sp, #144]	; 0x90
   11a9a:	add.w	r9, sp, #192	; 0xc0
   11a9e:	bgt.n	11a6a <_svfprintf_r+0xcea>
   11aa0:	mov	r6, r8
   11aa2:	ldr.w	r8, [sp, #36]	; 0x24
   11aa6:	ldr	r3, [sp, #44]	; 0x2c
   11aa8:	adds	r5, #1
   11aaa:	add	r4, r6
   11aac:	cmp	r5, #7
   11aae:	str	r4, [sp, #148]	; 0x94
   11ab0:	str	r5, [sp, #144]	; 0x90
   11ab2:	stmia.w	r9, {r3, r6}
   11ab6:	ble.w	118d0 <_svfprintf_r+0xb50>
   11aba:	add	r2, sp, #140	; 0x8c
   11abc:	ldr	r1, [sp, #20]
   11abe:	ldr	r0, [sp, #24]
   11ac0:	bl	13f08 <__ssprint_r>
   11ac4:	cmp	r0, #0
   11ac6:	bne.w	10f74 <_svfprintf_r+0x1f4>
   11aca:	ldr	r4, [sp, #148]	; 0x94
   11acc:	ldr	r5, [sp, #144]	; 0x90
   11ace:	add.w	r9, sp, #192	; 0xc0
   11ad2:	b.n	118d4 <_svfprintf_r+0xb54>
   11ad4:	.word	0x000149dc
   11ad8:	ldr	r1, [sp, #12]
   11ada:	ands.w	r2, r1, #16
   11ade:	beq.w	11e88 <_svfprintf_r+0x1108>
   11ae2:	ldr	r0, [sp, #40]	; 0x28
   11ae4:	strb.w	r3, [sp, #111]	; 0x6f
   11ae8:	cmp.w	fp, #0
   11aec:	ldr	r4, [r0, #0]
   11aee:	add.w	r7, r0, #4
   11af2:	mov.w	r5, #0
   11af6:	blt.n	11b46 <_svfprintf_r+0xdc6>
   11af8:	mov	r2, r1
   11afa:	bic.w	r2, r2, #128	; 0x80
   11afe:	str	r2, [sp, #12]
   11b00:	orrs.w	r2, r4, r5
   11b04:	str	r7, [sp, #40]	; 0x28
   11b06:	mov	r7, r3
   11b08:	bne.w	110dc <_svfprintf_r+0x35c>
   11b0c:	b.n	114ac <_svfprintf_r+0x72c>
   11b0e:	ldr	r3, [sp, #12]
   11b10:	lsls	r0, r3, #27
   11b12:	bmi.n	11b6a <_svfprintf_r+0xdea>
   11b14:	ldr	r3, [sp, #12]
   11b16:	lsls	r1, r3, #25
   11b18:	bpl.n	11b6a <_svfprintf_r+0xdea>
   11b1a:	ldr	r1, [sp, #40]	; 0x28
   11b1c:	ldrsh.w	r4, [r1]
   11b20:	adds	r1, #4
   11b22:	asrs	r5, r4, #31
   11b24:	mov	r2, r4
   11b26:	mov	r3, r5
   11b28:	str	r1, [sp, #40]	; 0x28
   11b2a:	b.w	110b6 <_svfprintf_r+0x336>
   11b2e:	ldr	r1, [sp, #40]	; 0x28
   11b30:	strb.w	r3, [sp, #111]	; 0x6f
   11b34:	cmp.w	fp, #0
   11b38:	ldr	r4, [r1, #0]
   11b3a:	add.w	r7, r1, #4
   11b3e:	mov.w	r5, #0
   11b42:	bge.w	11fde <_svfprintf_r+0x125e>
   11b46:	str	r7, [sp, #40]	; 0x28
   11b48:	mov	r7, r3
   11b4a:	orrs.w	r3, r4, r5
   11b4e:	bne.w	110dc <_svfprintf_r+0x35c>
   11b52:	b.n	114b6 <_svfprintf_r+0x736>
   11b54:	adds	r3, #1
   11b56:	ldr	r2, [sp, #44]	; 0x2c
   11b58:	str	r3, [sp, #144]	; 0x90
   11b5a:	add	r4, r5
   11b5c:	cmp	r3, #7
   11b5e:	str	r4, [sp, #148]	; 0x94
   11b60:	stmia.w	r9, {r2, r5}
   11b64:	ble.w	112a8 <_svfprintf_r+0x528>
   11b68:	b.n	118ee <_svfprintf_r+0xb6e>
   11b6a:	ldr	r2, [sp, #40]	; 0x28
   11b6c:	ldr	r4, [r2, #0]
   11b6e:	mov	r3, r2
   11b70:	adds	r3, #4
   11b72:	asrs	r5, r4, #31
   11b74:	mov	r2, r4
   11b76:	str	r3, [sp, #40]	; 0x28
   11b78:	cmp	r2, #0
   11b7a:	mov	r3, r5
   11b7c:	sbcs.w	r3, r3, #0
   11b80:	bge.w	110c0 <_svfprintf_r+0x340>
   11b84:	negs	r4, r4
   11b86:	mov.w	r7, #45	; 0x2d
   11b8a:	sbc.w	r5, r5, r5, lsl #1
   11b8e:	cmp.w	fp, #0
   11b92:	strb.w	r7, [sp, #111]	; 0x6f
   11b96:	blt.w	110dc <_svfprintf_r+0x35c>
   11b9a:	ldr	r3, [sp, #12]
   11b9c:	bic.w	r3, r3, #128	; 0x80
   11ba0:	str	r3, [sp, #12]
   11ba2:	b.w	110dc <_svfprintf_r+0x35c>
   11ba6:	add	r2, sp, #140	; 0x8c
   11ba8:	ldr	r1, [sp, #20]
   11baa:	ldr	r0, [sp, #24]
   11bac:	bl	13f08 <__ssprint_r>
   11bb0:	cmp	r0, #0
   11bb2:	bne.w	10f74 <_svfprintf_r+0x1f4>
   11bb6:	ldr	r4, [sp, #148]	; 0x94
   11bb8:	add.w	r9, sp, #192	; 0xc0
   11bbc:	ldr	r2, [sp, #60]	; 0x3c
   11bbe:	ldr	r3, [sp, #116]	; 0x74
   11bc0:	add	r2, r6
   11bc2:	mov	r7, r2
   11bc4:	ldr	r2, [sp, #56]	; 0x38
   11bc6:	cmp	r3, r2
   11bc8:	blt.n	11c5a <_svfprintf_r+0xeda>
   11bca:	ldr	r2, [sp, #12]
   11bcc:	lsls	r5, r2, #31
   11bce:	bmi.n	11c5a <_svfprintf_r+0xeda>
   11bd0:	ldr	r1, [sp, #56]	; 0x38
   11bd2:	add	r6, r1
   11bd4:	subs	r5, r6, r7
   11bd6:	subs	r3, r1, r3
   11bd8:	cmp	r5, r3
   11bda:	it	ge
   11bdc:	movge	r5, r3
   11bde:	cmp	r5, #0
   11be0:	mov	r6, r5
   11be2:	ble.n	11c00 <_svfprintf_r+0xe80>
   11be4:	ldr	r2, [sp, #144]	; 0x90
   11be6:	str.w	r7, [r9]
   11bea:	adds	r2, #1
   11bec:	add	r4, r5
   11bee:	cmp	r2, #7
   11bf0:	str	r4, [sp, #148]	; 0x94
   11bf2:	str.w	r5, [r9, #4]
   11bf6:	str	r2, [sp, #144]	; 0x90
   11bf8:	bgt.w	121f8 <_svfprintf_r+0x1478>
   11bfc:	add.w	r9, r9, #8
   11c00:	cmp	r6, #0
   11c02:	ite	ge
   11c04:	subge	r5, r3, r6
   11c06:	movlt	r5, r3
   11c08:	cmp	r5, #0
   11c0a:	ble.w	112ac <_svfprintf_r+0x52c>
   11c0e:	ldr	r2, [pc, #744]	; (11ef8 <_svfprintf_r+0x1178>)
   11c10:	ldr	r3, [sp, #144]	; 0x90
   11c12:	str	r2, [sp, #44]	; 0x2c
   11c14:	cmp	r5, #16
   11c16:	ble.n	11b54 <_svfprintf_r+0xdd4>
   11c18:	movs	r6, #16
   11c1a:	ldr	r7, [sp, #24]
   11c1c:	ldr.w	fp, [sp, #20]
   11c20:	b.n	11c2c <_svfprintf_r+0xeac>
   11c22:	add.w	r9, r9, #8
   11c26:	subs	r5, #16
   11c28:	cmp	r5, #16
   11c2a:	ble.n	11b54 <_svfprintf_r+0xdd4>
   11c2c:	adds	r3, #1
   11c2e:	adds	r4, #16
   11c30:	cmp	r3, #7
   11c32:	str	r4, [sp, #148]	; 0x94
   11c34:	str	r3, [sp, #144]	; 0x90
   11c36:	str.w	sl, [r9]
   11c3a:	str.w	r6, [r9, #4]
   11c3e:	ble.n	11c22 <_svfprintf_r+0xea2>
   11c40:	add	r2, sp, #140	; 0x8c
   11c42:	mov	r1, fp
   11c44:	mov	r0, r7
   11c46:	bl	13f08 <__ssprint_r>
   11c4a:	cmp	r0, #0
   11c4c:	bne.w	10f74 <_svfprintf_r+0x1f4>
   11c50:	ldr	r4, [sp, #148]	; 0x94
   11c52:	ldr	r3, [sp, #144]	; 0x90
   11c54:	add.w	r9, sp, #192	; 0xc0
   11c58:	b.n	11c26 <_svfprintf_r+0xea6>
   11c5a:	ldr	r2, [sp, #144]	; 0x90
   11c5c:	ldr	r0, [sp, #72]	; 0x48
   11c5e:	ldr	r1, [sp, #76]	; 0x4c
   11c60:	str.w	r1, [r9]
   11c64:	adds	r2, #1
   11c66:	add	r4, r0
   11c68:	cmp	r2, #7
   11c6a:	str	r4, [sp, #148]	; 0x94
   11c6c:	str.w	r0, [r9, #4]
   11c70:	str	r2, [sp, #144]	; 0x90
   11c72:	bgt.w	121de <_svfprintf_r+0x145e>
   11c76:	add.w	r9, r9, #8
   11c7a:	b.n	11bd0 <_svfprintf_r+0xe50>
   11c7c:	ldr	r3, [sp, #12]
   11c7e:	lsls	r0, r3, #31
   11c80:	bmi.w	11868 <_svfprintf_r+0xae8>
   11c84:	adds	r5, #1
   11c86:	adds	r4, #1
   11c88:	movs	r3, #1
   11c8a:	cmp	r5, #7
   11c8c:	str	r4, [sp, #148]	; 0x94
   11c8e:	str	r5, [sp, #144]	; 0x90
   11c90:	str.w	r6, [r9]
   11c94:	str.w	r3, [r9, #4]
   11c98:	ble.w	118d0 <_svfprintf_r+0xb50>
   11c9c:	b.n	11aba <_svfprintf_r+0xd3a>
   11c9e:	add	r2, sp, #140	; 0x8c
   11ca0:	ldr	r1, [sp, #20]
   11ca2:	ldr	r0, [sp, #24]
   11ca4:	bl	13f08 <__ssprint_r>
   11ca8:	cmp	r0, #0
   11caa:	bne.w	10f74 <_svfprintf_r+0x1f4>
   11cae:	ldr	r4, [sp, #148]	; 0x94
   11cb0:	ldr	r5, [sp, #144]	; 0x90
   11cb2:	add.w	r9, sp, #192	; 0xc0
   11cb6:	b.n	11884 <_svfprintf_r+0xb04>
   11cb8:	add	r2, sp, #140	; 0x8c
   11cba:	ldr	r1, [sp, #20]
   11cbc:	ldr	r0, [sp, #24]
   11cbe:	bl	13f08 <__ssprint_r>
   11cc2:	cmp	r0, #0
   11cc4:	bne.w	10f74 <_svfprintf_r+0x1f4>
   11cc8:	ldr	r4, [sp, #148]	; 0x94
   11cca:	ldr	r5, [sp, #144]	; 0x90
   11ccc:	add.w	r9, sp, #192	; 0xc0
   11cd0:	b.n	118a2 <_svfprintf_r+0xb22>
   11cd2:	add	r2, sp, #140	; 0x8c
   11cd4:	ldr	r1, [sp, #20]
   11cd6:	ldr	r0, [sp, #24]
   11cd8:	bl	13f08 <__ssprint_r>
   11cdc:	cmp	r0, #0
   11cde:	bne.w	10f74 <_svfprintf_r+0x1f4>
   11ce2:	ldr	r4, [sp, #148]	; 0x94
   11ce4:	add.w	r9, sp, #192	; 0xc0
   11ce8:	b.w	11214 <_svfprintf_r+0x494>
   11cec:	ldr	r1, [sp, #12]
   11cee:	ands.w	r3, r1, #64	; 0x40
   11cf2:	beq.w	11e68 <_svfprintf_r+0x10e8>
   11cf6:	ldr	r0, [sp, #40]	; 0x28
   11cf8:	strb.w	r2, [sp, #111]	; 0x6f
   11cfc:	mov	r3, r0
   11cfe:	cmp.w	fp, #0
   11d02:	add.w	r3, r3, #4
   11d06:	ldrh	r4, [r0, #0]
   11d08:	mov.w	r5, #0
   11d0c:	blt.w	12090 <_svfprintf_r+0x1310>
   11d10:	bic.w	r1, r1, #128	; 0x80
   11d14:	str	r1, [sp, #12]
   11d16:	orrs.w	r1, r4, r5
   11d1a:	str	r3, [sp, #40]	; 0x28
   11d1c:	beq.w	116d4 <_svfprintf_r+0x954>
   11d20:	mov	r7, r2
   11d22:	b.w	10fcc <_svfprintf_r+0x24c>
   11d26:	ldr	r3, [sp, #12]
   11d28:	lsls	r7, r3, #27
   11d2a:	bmi.n	11d44 <_svfprintf_r+0xfc4>
   11d2c:	ldr	r3, [sp, #12]
   11d2e:	lsls	r6, r3, #25
   11d30:	bpl.n	11d44 <_svfprintf_r+0xfc4>
   11d32:	ldr	r2, [sp, #40]	; 0x28
   11d34:	ldr	r3, [r2, #0]
   11d36:	adds	r2, #4
   11d38:	str	r2, [sp, #40]	; 0x28
   11d3a:	ldrh.w	r2, [sp, #28]
   11d3e:	strh	r2, [r3, #0]
   11d40:	b.w	10dce <_svfprintf_r+0x4e>
   11d44:	ldr	r2, [sp, #40]	; 0x28
   11d46:	ldr	r3, [r2, #0]
   11d48:	adds	r2, #4
   11d4a:	str	r2, [sp, #40]	; 0x28
   11d4c:	ldr	r2, [sp, #28]
   11d4e:	str	r2, [r3, #0]
   11d50:	b.w	10dce <_svfprintf_r+0x4e>
   11d54:	ldrd	r0, r1, [sp, #64]	; 0x40
   11d58:	mov	r2, r0
   11d5a:	mov	r3, r1
   11d5c:	bl	f990 <__aeabi_dcmpun>
   11d60:	cmp	r0, #0
   11d62:	bne.w	12360 <_svfprintf_r+0x15e0>
   11d66:	ldr	r3, [sp, #52]	; 0x34
   11d68:	cmp.w	fp, #4294967295
   11d6c:	bic.w	r7, r3, #32
   11d70:	beq.w	12242 <_svfprintf_r+0x14c2>
   11d74:	cmp	r7, #71	; 0x47
   11d76:	beq.w	1207e <_svfprintf_r+0x12fe>
   11d7a:	ldr	r3, [sp, #68]	; 0x44
   11d7c:	ldr	r2, [sp, #12]
   11d7e:	cmp	r3, #0
   11d80:	orr.w	r2, r2, #256	; 0x100
   11d84:	str	r2, [sp, #44]	; 0x2c
   11d86:	blt.w	1227a <_svfprintf_r+0x14fa>
   11d8a:	vldr	d7, [sp, #64]	; 0x40
   11d8e:	vstr	d7, [sp, #96]	; 0x60
   11d92:	movs	r3, #0
   11d94:	str	r3, [sp, #16]
   11d96:	ldr	r3, [sp, #52]	; 0x34
   11d98:	cmp	r3, #102	; 0x66
   11d9a:	beq.w	12248 <_svfprintf_r+0x14c8>
   11d9e:	cmp	r3, #70	; 0x46
   11da0:	beq.w	1202e <_svfprintf_r+0x12ae>
   11da4:	cmp	r7, #69	; 0x45
   11da6:	ite	eq
   11da8:	addeq.w	r5, fp, #1
   11dac:	movne	r5, fp
   11dae:	add	r2, sp, #132	; 0x84
   11db0:	add	r3, sp, #120	; 0x78
   11db2:	str	r2, [sp, #4]
   11db4:	str	r3, [sp, #0]
   11db6:	mov	r2, r5
   11db8:	add	r3, sp, #116	; 0x74
   11dba:	movs	r1, #2
   11dbc:	vldr	d0, [sp, #96]	; 0x60
   11dc0:	ldr	r0, [sp, #24]
   11dc2:	bl	12700 <_dtoa_r>
   11dc6:	ldr	r3, [sp, #52]	; 0x34
   11dc8:	cmp	r3, #103	; 0x67
   11dca:	mov	r6, r0
   11dcc:	bne.w	122a6 <_svfprintf_r+0x1526>
   11dd0:	ldr	r3, [sp, #12]
   11dd2:	lsls	r2, r3, #31
   11dd4:	bpl.w	1234a <_svfprintf_r+0x15ca>
   11dd8:	adds	r4, r6, r5
   11dda:	movs	r2, #0
   11ddc:	movs	r3, #0
   11dde:	ldrd	r0, r1, [sp, #96]	; 0x60
   11de2:	bl	f92c <__aeabi_dcmpeq>
   11de6:	cmp	r0, #0
   11de8:	bne.w	12106 <_svfprintf_r+0x1386>
   11dec:	ldr	r3, [sp, #132]	; 0x84
   11dee:	cmp	r4, r3
   11df0:	bls.n	11e00 <_svfprintf_r+0x1080>
   11df2:	movs	r1, #48	; 0x30
   11df4:	adds	r2, r3, #1
   11df6:	str	r2, [sp, #132]	; 0x84
   11df8:	strb	r1, [r3, #0]
   11dfa:	ldr	r3, [sp, #132]	; 0x84
   11dfc:	cmp	r4, r3
   11dfe:	bhi.n	11df4 <_svfprintf_r+0x1074>
   11e00:	subs	r3, r3, r6
   11e02:	cmp	r7, #71	; 0x47
   11e04:	str	r3, [sp, #56]	; 0x38
   11e06:	beq.w	120f8 <_svfprintf_r+0x1378>
   11e0a:	ldr	r3, [sp, #52]	; 0x34
   11e0c:	cmp	r3, #101	; 0x65
   11e0e:	ble.w	122c4 <_svfprintf_r+0x1544>
   11e12:	ldr	r3, [sp, #52]	; 0x34
   11e14:	cmp	r3, #102	; 0x66
   11e16:	ldr	r3, [sp, #116]	; 0x74
   11e18:	str	r3, [sp, #60]	; 0x3c
   11e1a:	beq.w	122de <_svfprintf_r+0x155e>
   11e1e:	ldr	r2, [sp, #60]	; 0x3c
   11e20:	ldr	r1, [sp, #56]	; 0x38
   11e22:	cmp	r2, r1
   11e24:	blt.w	1228c <_svfprintf_r+0x150c>
   11e28:	ldr	r3, [sp, #12]
   11e2a:	lsls	r1, r3, #31
   11e2c:	bmi.w	1234e <_svfprintf_r+0x15ce>
   11e30:	bic.w	r3, r2, r2, asr #31
   11e34:	str	r2, [sp, #36]	; 0x24
   11e36:	movs	r2, #103	; 0x67
   11e38:	str	r2, [sp, #52]	; 0x34
   11e3a:	ldr	r2, [sp, #16]
   11e3c:	cmp	r2, #0
   11e3e:	bne.w	120a0 <_svfprintf_r+0x1320>
   11e42:	str	r3, [sp, #16]
   11e44:	ldr	r3, [sp, #44]	; 0x2c
   11e46:	str	r3, [sp, #12]
   11e48:	mov	fp, r2
   11e4a:	ldrb.w	r7, [sp, #111]	; 0x6f
   11e4e:	b.w	11124 <_svfprintf_r+0x3a4>
   11e52:	bic.w	r7, r7, #7
   11e56:	vldr	d7, [r7]
   11e5a:	add.w	r3, r7, #8
   11e5e:	vstr	d7, [sp, #64]	; 0x40
   11e62:	str	r3, [sp, #40]	; 0x28
   11e64:	b.w	1137c <_svfprintf_r+0x5fc>
   11e68:	ldr	r1, [sp, #40]	; 0x28
   11e6a:	strb.w	r3, [sp, #111]	; 0x6f
   11e6e:	cmp.w	fp, #0
   11e72:	ldr	r4, [r1, #0]
   11e74:	add.w	r7, r1, #4
   11e78:	mov.w	r5, #0
   11e7c:	bge.w	11fd8 <_svfprintf_r+0x1258>
   11e80:	str	r7, [sp, #40]	; 0x28
   11e82:	movs	r7, #0
   11e84:	b.w	10fcc <_svfprintf_r+0x24c>
   11e88:	ldr	r1, [sp, #12]
   11e8a:	ands.w	r3, r1, #64	; 0x40
   11e8e:	beq.w	11b2e <_svfprintf_r+0xdae>
   11e92:	ldr	r0, [sp, #40]	; 0x28
   11e94:	strb.w	r2, [sp, #111]	; 0x6f
   11e98:	mov	r3, r0
   11e9a:	cmp.w	fp, #0
   11e9e:	add.w	r3, r3, #4
   11ea2:	ldrh	r4, [r0, #0]
   11ea4:	mov.w	r5, #0
   11ea8:	blt.w	1208a <_svfprintf_r+0x130a>
   11eac:	bic.w	r1, r1, #128	; 0x80
   11eb0:	str	r1, [sp, #12]
   11eb2:	orrs.w	r1, r4, r5
   11eb6:	str	r3, [sp, #40]	; 0x28
   11eb8:	mov	r7, r2
   11eba:	bne.w	110dc <_svfprintf_r+0x35c>
   11ebe:	b.w	114ac <_svfprintf_r+0x72c>
   11ec2:	ldr	r3, [sp, #12]
   11ec4:	ldr	r2, [sp, #40]	; 0x28
   11ec6:	tst.w	r3, #64	; 0x40
   11eca:	mov	r3, r2
   11ecc:	beq.w	12094 <_svfprintf_r+0x1314>
   11ed0:	adds	r3, #4
   11ed2:	ldrh	r4, [r2, #0]
   11ed4:	str	r3, [sp, #40]	; 0x28
   11ed6:	movs	r5, #0
   11ed8:	b.w	114e6 <_svfprintf_r+0x766>
   11edc:	mov	r4, r2
   11ede:	adds	r3, #1
   11ee0:	ldr	r2, [sp, #44]	; 0x2c
   11ee2:	str	r3, [sp, #144]	; 0x90
   11ee4:	add	r4, r5
   11ee6:	cmp	r3, #7
   11ee8:	str	r4, [sp, #148]	; 0x94
   11eea:	stmia.w	r9, {r2, r5}
   11eee:	bgt.w	11ba6 <_svfprintf_r+0xe26>
   11ef2:	add.w	r9, r9, #8
   11ef6:	b.n	11bbc <_svfprintf_r+0xe3c>
   11ef8:	.word	0x000149dc
   11efc:	movs	r7, #0
   11efe:	cmp	fp, r7
   11f00:	strb.w	r7, [sp, #111]	; 0x6f
   11f04:	blt.w	116f8 <_svfprintf_r+0x978>
   11f08:	ldr	r3, [sp, #12]
   11f0a:	bic.w	r3, r3, #128	; 0x80
   11f0e:	str	r3, [sp, #12]
   11f10:	b.w	11694 <_svfprintf_r+0x914>
   11f14:	add	r2, sp, #140	; 0x8c
   11f16:	ldr	r1, [sp, #20]
   11f18:	ldr	r0, [sp, #24]
   11f1a:	bl	13f08 <__ssprint_r>
   11f1e:	cmp	r0, #0
   11f20:	bne.w	10f74 <_svfprintf_r+0x1f4>
   11f24:	ldr	r4, [sp, #148]	; 0x94
   11f26:	add.w	r9, sp, #192	; 0xc0
   11f2a:	b.n	1173c <_svfprintf_r+0x9bc>
   11f2c:	ldr	r7, [sp, #40]	; 0x28
   11f2e:	b.w	116ea <_svfprintf_r+0x96a>
   11f32:	ldr	r3, [sp, #144]	; 0x90
   11f34:	ldr	r2, [pc, #736]	; (12218 <_svfprintf_r+0x1498>)
   11f36:	str.w	r2, [r9]
   11f3a:	adds	r3, #1
   11f3c:	adds	r4, #1
   11f3e:	movs	r2, #1
   11f40:	cmp	r3, #7
   11f42:	str	r4, [sp, #148]	; 0x94
   11f44:	str	r3, [sp, #144]	; 0x90
   11f46:	str.w	r2, [r9, #4]
   11f4a:	bgt.w	12064 <_svfprintf_r+0x12e4>
   11f4e:	add.w	r9, r9, #8
   11f52:	cbnz	r5, 11f60 <_svfprintf_r+0x11e0>
   11f54:	ldr	r3, [sp, #56]	; 0x38
   11f56:	cbnz	r3, 11f60 <_svfprintf_r+0x11e0>
   11f58:	ldr	r3, [sp, #12]
   11f5a:	lsls	r7, r3, #31
   11f5c:	bpl.w	112ac <_svfprintf_r+0x52c>
   11f60:	ldr	r3, [sp, #144]	; 0x90
   11f62:	ldr	r1, [sp, #72]	; 0x48
   11f64:	ldr	r2, [sp, #76]	; 0x4c
   11f66:	str.w	r2, [r9]
   11f6a:	adds	r3, #1
   11f6c:	add	r4, r1
   11f6e:	cmp	r3, #7
   11f70:	str	r4, [sp, #148]	; 0x94
   11f72:	str.w	r1, [r9, #4]
   11f76:	str	r3, [sp, #144]	; 0x90
   11f78:	bgt.w	12316 <_svfprintf_r+0x1596>
   11f7c:	add.w	r9, r9, #8
   11f80:	negs	r5, r5
   11f82:	cmp	r5, #0
   11f84:	ble.w	120dc <_svfprintf_r+0x135c>
   11f88:	ldr	r2, [pc, #656]	; (1221c <_svfprintf_r+0x149c>)
   11f8a:	str	r2, [sp, #44]	; 0x2c
   11f8c:	cmp	r5, #16
   11f8e:	ble.w	12124 <_svfprintf_r+0x13a4>
   11f92:	mov	r2, r4
   11f94:	movs	r7, #16
   11f96:	ldr.w	fp, [sp, #24]
   11f9a:	ldr	r4, [sp, #20]
   11f9c:	b.n	11faa <_svfprintf_r+0x122a>
   11f9e:	add.w	r9, r9, #8
   11fa2:	subs	r5, #16
   11fa4:	cmp	r5, #16
   11fa6:	ble.w	12122 <_svfprintf_r+0x13a2>
   11faa:	adds	r3, #1
   11fac:	adds	r2, #16
   11fae:	cmp	r3, #7
   11fb0:	str	r2, [sp, #148]	; 0x94
   11fb2:	str	r3, [sp, #144]	; 0x90
   11fb4:	str.w	sl, [r9]
   11fb8:	str.w	r7, [r9, #4]
   11fbc:	ble.n	11f9e <_svfprintf_r+0x121e>
   11fbe:	add	r2, sp, #140	; 0x8c
   11fc0:	mov	r1, r4
   11fc2:	mov	r0, fp
   11fc4:	bl	13f08 <__ssprint_r>
   11fc8:	cmp	r0, #0
   11fca:	bne.w	10f74 <_svfprintf_r+0x1f4>
   11fce:	ldr	r2, [sp, #148]	; 0x94
   11fd0:	ldr	r3, [sp, #144]	; 0x90
   11fd2:	add.w	r9, sp, #192	; 0xc0
   11fd6:	b.n	11fa2 <_svfprintf_r+0x1222>
   11fd8:	ldr	r2, [sp, #12]
   11fda:	b.w	11450 <_svfprintf_r+0x6d0>
   11fde:	ldr	r2, [sp, #12]
   11fe0:	b.n	11afa <_svfprintf_r+0xd7a>
   11fe2:	ldr	r3, [sp, #12]
   11fe4:	orr.w	r3, r3, #32
   11fe8:	str	r3, [sp, #12]
   11fea:	add.w	r8, r8, #1
   11fee:	ldrb.w	r3, [r8]
   11ff2:	b.w	10e34 <_svfprintf_r+0xb4>
   11ff6:	add	r2, sp, #140	; 0x8c
   11ff8:	ldr	r1, [sp, #20]
   11ffa:	ldr	r0, [sp, #24]
   11ffc:	bl	13f08 <__ssprint_r>
   12000:	cmp	r0, #0
   12002:	bne.w	10f74 <_svfprintf_r+0x1f4>
   12006:	ldr	r4, [sp, #148]	; 0x94
   12008:	add.w	r9, sp, #192	; 0xc0
   1200c:	b.w	1176c <_svfprintf_r+0x9ec>
   12010:	movs	r1, #64	; 0x40
   12012:	ldr	r0, [sp, #24]
   12014:	bl	fe30 <_malloc_r>
   12018:	ldr	r2, [sp, #20]
   1201a:	str	r0, [r2, #0]
   1201c:	str	r0, [r2, #16]
   1201e:	cmp	r0, #0
   12020:	beq.w	1240a <_svfprintf_r+0x168a>
   12024:	ldr	r2, [sp, #20]
   12026:	movs	r3, #64	; 0x40
   12028:	str	r3, [r2, #20]
   1202a:	b.w	10dae <_svfprintf_r+0x2e>
   1202e:	add	r2, sp, #132	; 0x84
   12030:	add	r3, sp, #120	; 0x78
   12032:	str	r2, [sp, #4]
   12034:	str	r3, [sp, #0]
   12036:	mov	r2, fp
   12038:	add	r3, sp, #116	; 0x74
   1203a:	movs	r1, #3
   1203c:	vldr	d0, [sp, #96]	; 0x60
   12040:	ldr	r0, [sp, #24]
   12042:	bl	12700 <_dtoa_r>
   12046:	mov	r5, fp
   12048:	mov	r6, r0
   1204a:	ldr	r3, [sp, #52]	; 0x34
   1204c:	cmp	r3, #70	; 0x46
   1204e:	add.w	r4, r6, r5
   12052:	bne.w	11dda <_svfprintf_r+0x105a>
   12056:	ldrb	r3, [r6, #0]
   12058:	cmp	r3, #48	; 0x30
   1205a:	beq.w	1236c <_svfprintf_r+0x15ec>
   1205e:	ldr	r5, [sp, #116]	; 0x74
   12060:	add	r4, r5
   12062:	b.n	11dda <_svfprintf_r+0x105a>
   12064:	add	r2, sp, #140	; 0x8c
   12066:	ldr	r1, [sp, #20]
   12068:	ldr	r0, [sp, #24]
   1206a:	bl	13f08 <__ssprint_r>
   1206e:	cmp	r0, #0
   12070:	bne.w	10f74 <_svfprintf_r+0x1f4>
   12074:	ldr	r5, [sp, #116]	; 0x74
   12076:	ldr	r4, [sp, #148]	; 0x94
   12078:	add.w	r9, sp, #192	; 0xc0
   1207c:	b.n	11f52 <_svfprintf_r+0x11d2>
   1207e:	cmp.w	fp, #0
   12082:	it	eq
   12084:	moveq.w	fp, #1
   12088:	b.n	11d7a <_svfprintf_r+0xffa>
   1208a:	str	r3, [sp, #40]	; 0x28
   1208c:	mov	r7, r2
   1208e:	b.n	11b4a <_svfprintf_r+0xdca>
   12090:	str	r3, [sp, #40]	; 0x28
   12092:	b.n	11e82 <_svfprintf_r+0x1102>
   12094:	adds	r3, #4
   12096:	ldr	r4, [r2, #0]
   12098:	str	r3, [sp, #40]	; 0x28
   1209a:	movs	r5, #0
   1209c:	b.w	114e6 <_svfprintf_r+0x766>
   120a0:	movs	r7, #45	; 0x2d
   120a2:	str	r3, [sp, #16]
   120a4:	ldr	r3, [sp, #44]	; 0x2c
   120a6:	str	r3, [sp, #12]
   120a8:	strb.w	r7, [sp, #111]	; 0x6f
   120ac:	mov.w	fp, #0
   120b0:	b.w	11126 <_svfprintf_r+0x3a6>
   120b4:	mov	r0, r6
   120b6:	bl	10c00 <strlen>
   120ba:	mov	fp, r4
   120bc:	mov	r3, r0
   120be:	str	r0, [sp, #36]	; 0x24
   120c0:	b.w	11608 <_svfprintf_r+0x888>
   120c4:	add	r2, sp, #140	; 0x8c
   120c6:	ldr	r1, [sp, #20]
   120c8:	ldr	r0, [sp, #24]
   120ca:	bl	13f08 <__ssprint_r>
   120ce:	cmp	r0, #0
   120d0:	bne.w	10f74 <_svfprintf_r+0x1f4>
   120d4:	ldr	r4, [sp, #148]	; 0x94
   120d6:	ldr	r3, [sp, #144]	; 0x90
   120d8:	add.w	r9, sp, #192	; 0xc0
   120dc:	ldr	r1, [sp, #56]	; 0x38
   120de:	str.w	r6, [r9]
   120e2:	adds	r3, #1
   120e4:	add	r4, r1
   120e6:	cmp	r3, #7
   120e8:	str	r4, [sp, #148]	; 0x94
   120ea:	str	r3, [sp, #144]	; 0x90
   120ec:	str.w	r1, [r9, #4]
   120f0:	ble.w	112a8 <_svfprintf_r+0x528>
   120f4:	b.w	118ee <_svfprintf_r+0xb6e>
   120f8:	ldr	r3, [sp, #116]	; 0x74
   120fa:	adds	r5, r3, #3
   120fc:	blt.n	1213c <_svfprintf_r+0x13bc>
   120fe:	cmp	fp, r3
   12100:	blt.n	1213c <_svfprintf_r+0x13bc>
   12102:	str	r3, [sp, #60]	; 0x3c
   12104:	b.n	11e1e <_svfprintf_r+0x109e>
   12106:	mov	r3, r4
   12108:	b.n	11e00 <_svfprintf_r+0x1080>
   1210a:	add	r2, sp, #140	; 0x8c
   1210c:	ldr	r1, [sp, #20]
   1210e:	ldr	r0, [sp, #24]
   12110:	bl	13f08 <__ssprint_r>
   12114:	cmp	r0, #0
   12116:	bne.w	10f74 <_svfprintf_r+0x1f4>
   1211a:	ldr	r4, [sp, #148]	; 0x94
   1211c:	add.w	r9, sp, #192	; 0xc0
   12120:	b.n	119bc <_svfprintf_r+0xc3c>
   12122:	mov	r4, r2
   12124:	adds	r3, #1
   12126:	ldr	r2, [sp, #44]	; 0x2c
   12128:	str	r3, [sp, #144]	; 0x90
   1212a:	add	r4, r5
   1212c:	cmp	r3, #7
   1212e:	str	r4, [sp, #148]	; 0x94
   12130:	stmia.w	r9, {r2, r5}
   12134:	bgt.n	120c4 <_svfprintf_r+0x1344>
   12136:	add.w	r9, r9, #8
   1213a:	b.n	120dc <_svfprintf_r+0x135c>
   1213c:	ldr	r2, [sp, #52]	; 0x34
   1213e:	subs	r2, #2
   12140:	str	r2, [sp, #52]	; 0x34
   12142:	subs	r3, #1
   12144:	cmp	r3, #0
   12146:	ldrb.w	r2, [sp, #52]	; 0x34
   1214a:	str	r3, [sp, #116]	; 0x74
   1214c:	it	lt
   1214e:	neglt	r3, r3
   12150:	strb.w	r2, [sp, #124]	; 0x7c
   12154:	ite	lt
   12156:	movlt	r2, #45	; 0x2d
   12158:	movge	r2, #43	; 0x2b
   1215a:	cmp	r3, #9
   1215c:	strb.w	r2, [sp, #125]	; 0x7d
   12160:	ble.w	1233a <_svfprintf_r+0x15ba>
   12164:	add.w	r0, sp, #139	; 0x8b
   12168:	mov	r4, r0
   1216a:	ldr	r2, [pc, #180]	; (12220 <_svfprintf_r+0x14a0>)
   1216c:	smull	r2, r1, r2, r3
   12170:	asrs	r2, r3, #31
   12172:	rsb	r2, r2, r1, asr #2
   12176:	add.w	r1, r2, r2, lsl #2
   1217a:	sub.w	r3, r3, r1, lsl #1
   1217e:	add.w	r1, r3, #48	; 0x30
   12182:	cmp	r2, #9
   12184:	mov	r3, r2
   12186:	strb.w	r1, [r4, #-1]!
   1218a:	bgt.n	1216a <_svfprintf_r+0x13ea>
   1218c:	mov	r1, r4
   1218e:	adds	r3, #48	; 0x30
   12190:	uxtb	r2, r3
   12192:	strb.w	r2, [r1, #-1]!
   12196:	cmp	r0, r1
   12198:	bls.w	12404 <_svfprintf_r+0x1684>
   1219c:	add.w	r1, sp, #126	; 0x7e
   121a0:	mov	r3, r4
   121a2:	b.n	121a8 <_svfprintf_r+0x1428>
   121a4:	ldrb.w	r2, [r3], #1
   121a8:	strb.w	r2, [r1], #1
   121ac:	cmp	r0, r3
   121ae:	bne.n	121a4 <_svfprintf_r+0x1424>
   121b0:	adds	r3, r0, #1
   121b2:	subs	r3, r3, r4
   121b4:	add.w	r2, sp, #126	; 0x7e
   121b8:	add	r3, r2
   121ba:	add	r2, sp, #124	; 0x7c
   121bc:	subs	r3, r3, r2
   121be:	ldr	r2, [sp, #56]	; 0x38
   121c0:	str	r3, [sp, #84]	; 0x54
   121c2:	cmp	r2, #1
   121c4:	add	r3, r2
   121c6:	str	r3, [sp, #36]	; 0x24
   121c8:	ble.w	1239a <_svfprintf_r+0x161a>
   121cc:	ldr	r3, [sp, #36]	; 0x24
   121ce:	ldr	r2, [sp, #72]	; 0x48
   121d0:	add	r3, r2
   121d2:	movs	r2, #0
   121d4:	str	r3, [sp, #36]	; 0x24
   121d6:	str	r2, [sp, #60]	; 0x3c
   121d8:	bic.w	r3, r3, r3, asr #31
   121dc:	b.n	11e3a <_svfprintf_r+0x10ba>
   121de:	add	r2, sp, #140	; 0x8c
   121e0:	ldr	r1, [sp, #20]
   121e2:	ldr	r0, [sp, #24]
   121e4:	bl	13f08 <__ssprint_r>
   121e8:	cmp	r0, #0
   121ea:	bne.w	10f74 <_svfprintf_r+0x1f4>
   121ee:	ldr	r3, [sp, #116]	; 0x74
   121f0:	ldr	r4, [sp, #148]	; 0x94
   121f2:	add.w	r9, sp, #192	; 0xc0
   121f6:	b.n	11bd0 <_svfprintf_r+0xe50>
   121f8:	add	r2, sp, #140	; 0x8c
   121fa:	ldr	r1, [sp, #20]
   121fc:	ldr	r0, [sp, #24]
   121fe:	bl	13f08 <__ssprint_r>
   12202:	cmp	r0, #0
   12204:	bne.w	10f74 <_svfprintf_r+0x1f4>
   12208:	ldr	r3, [sp, #116]	; 0x74
   1220a:	ldr	r2, [sp, #56]	; 0x38
   1220c:	ldr	r4, [sp, #148]	; 0x94
   1220e:	subs	r3, r2, r3
   12210:	add.w	r9, sp, #192	; 0xc0
   12214:	b.n	11c00 <_svfprintf_r+0xe80>
   12216:	nop
   12218:	.word	0x00014794
   1221c:	.word	0x000149dc
   12220:	.word	0x66666667
   12224:	cmp	r5, #6
   12226:	mov	r3, r5
   12228:	it	cs
   1222a:	movcs	r3, #6
   1222c:	str	r3, [sp, #36]	; 0x24
   1222e:	bic.w	r3, r3, r3, asr #31
   12232:	mov	fp, r6
   12234:	str	r7, [sp, #40]	; 0x28
   12236:	str	r6, [sp, #60]	; 0x3c
   12238:	mov	r7, r6
   1223a:	str	r3, [sp, #16]
   1223c:	ldr	r6, [pc, #536]	; (12458 <_svfprintf_r+0x16d8>)
   1223e:	b.w	11124 <_svfprintf_r+0x3a4>
   12242:	mov.w	fp, #6
   12246:	b.n	11d7a <_svfprintf_r+0xffa>
   12248:	add	r2, sp, #132	; 0x84
   1224a:	add	r3, sp, #120	; 0x78
   1224c:	str	r2, [sp, #4]
   1224e:	str	r3, [sp, #0]
   12250:	mov	r2, fp
   12252:	add	r3, sp, #116	; 0x74
   12254:	movs	r1, #3
   12256:	vldr	d0, [sp, #96]	; 0x60
   1225a:	ldr	r0, [sp, #24]
   1225c:	bl	12700 <_dtoa_r>
   12260:	mov	r5, fp
   12262:	mov	r6, r0
   12264:	add.w	r4, r0, fp
   12268:	b.n	12056 <_svfprintf_r+0x12d6>
   1226a:	movs	r7, #45	; 0x2d
   1226c:	strb.w	r7, [sp, #111]	; 0x6f
   12270:	b.w	113ca <_svfprintf_r+0x64a>
   12274:	str	r3, [sp, #12]
   12276:	b.w	11522 <_svfprintf_r+0x7a2>
   1227a:	ldrd	r1, r2, [sp, #64]	; 0x40
   1227e:	add.w	r3, r2, #2147483648	; 0x80000000
   12282:	str	r3, [sp, #100]	; 0x64
   12284:	movs	r3, #45	; 0x2d
   12286:	str	r1, [sp, #96]	; 0x60
   12288:	str	r3, [sp, #16]
   1228a:	b.n	11d96 <_svfprintf_r+0x1016>
   1228c:	ldr	r2, [sp, #72]	; 0x48
   1228e:	ldr	r3, [sp, #56]	; 0x38
   12290:	add	r3, r2
   12292:	ldr	r2, [sp, #60]	; 0x3c
   12294:	str	r3, [sp, #36]	; 0x24
   12296:	cmp	r2, #0
   12298:	ble.w	123ae <_svfprintf_r+0x162e>
   1229c:	movs	r2, #103	; 0x67
   1229e:	bic.w	r3, r3, r3, asr #31
   122a2:	str	r2, [sp, #52]	; 0x34
   122a4:	b.n	11e3a <_svfprintf_r+0x10ba>
   122a6:	ldr	r3, [sp, #52]	; 0x34
   122a8:	cmp	r3, #71	; 0x47
   122aa:	bne.w	11dd8 <_svfprintf_r+0x1058>
   122ae:	ldr	r3, [sp, #12]
   122b0:	lsls	r3, r3, #31
   122b2:	bmi.w	1204a <_svfprintf_r+0x12ca>
   122b6:	ldr	r3, [sp, #132]	; 0x84
   122b8:	cmp	r7, #71	; 0x47
   122ba:	sub.w	r3, r3, r6
   122be:	str	r3, [sp, #56]	; 0x38
   122c0:	beq.w	120f8 <_svfprintf_r+0x1378>
   122c4:	ldr	r3, [sp, #116]	; 0x74
   122c6:	b.n	12142 <_svfprintf_r+0x13c2>
   122c8:	bic.w	r3, r5, r5, asr #31
   122cc:	str	r7, [sp, #40]	; 0x28
   122ce:	str	r3, [sp, #16]
   122d0:	str	r5, [sp, #36]	; 0x24
   122d2:	mov	fp, r0
   122d4:	str	r0, [sp, #60]	; 0x3c
   122d6:	ldrb.w	r7, [sp, #111]	; 0x6f
   122da:	b.w	11124 <_svfprintf_r+0x3a4>
   122de:	cmp	r3, #0
   122e0:	ble.n	123be <_svfprintf_r+0x163e>
   122e2:	cmp.w	fp, #0
   122e6:	bne.n	12388 <_svfprintf_r+0x1608>
   122e8:	ldr	r2, [sp, #12]
   122ea:	lsls	r4, r2, #31
   122ec:	bmi.n	12388 <_svfprintf_r+0x1608>
   122ee:	mov	r2, r3
   122f0:	str	r2, [sp, #36]	; 0x24
   122f2:	bic.w	r3, r3, r3, asr #31
   122f6:	b.n	11e3a <_svfprintf_r+0x10ba>
   122f8:	ldr	r3, [sp, #12]
   122fa:	lsls	r3, r3, #31
   122fc:	mov	r7, fp
   122fe:	bpl.n	1230c <_svfprintf_r+0x158c>
   12300:	add	r6, sp, #256	; 0x100
   12302:	movs	r3, #48	; 0x30
   12304:	strb.w	r3, [r6, #-65]!
   12308:	b.w	11110 <_svfprintf_r+0x390>
   1230c:	str.w	fp, [sp, #36]	; 0x24
   12310:	add	r6, sp, #192	; 0xc0
   12312:	b.w	11116 <_svfprintf_r+0x396>
   12316:	add	r2, sp, #140	; 0x8c
   12318:	ldr	r1, [sp, #20]
   1231a:	ldr	r0, [sp, #24]
   1231c:	bl	13f08 <__ssprint_r>
   12320:	cmp	r0, #0
   12322:	bne.w	10f74 <_svfprintf_r+0x1f4>
   12326:	ldr	r5, [sp, #116]	; 0x74
   12328:	ldr	r4, [sp, #148]	; 0x94
   1232a:	ldr	r3, [sp, #144]	; 0x90
   1232c:	add.w	r9, sp, #192	; 0xc0
   12330:	b.n	11f80 <_svfprintf_r+0x1200>
   12332:	mov	r8, r4
   12334:	movs	r5, #0
   12336:	b.w	10e38 <_svfprintf_r+0xb8>
   1233a:	adds	r3, #48	; 0x30
   1233c:	movs	r2, #48	; 0x30
   1233e:	strb.w	r3, [sp, #127]	; 0x7f
   12342:	strb.w	r2, [sp, #126]	; 0x7e
   12346:	add	r3, sp, #128	; 0x80
   12348:	b.n	121ba <_svfprintf_r+0x143a>
   1234a:	ldr	r3, [sp, #132]	; 0x84
   1234c:	b.n	11e00 <_svfprintf_r+0x1080>
   1234e:	ldr	r2, [sp, #72]	; 0x48
   12350:	ldr	r3, [sp, #60]	; 0x3c
   12352:	add	r3, r2
   12354:	movs	r2, #103	; 0x67
   12356:	str	r3, [sp, #36]	; 0x24
   12358:	str	r2, [sp, #52]	; 0x34
   1235a:	bic.w	r3, r3, r3, asr #31
   1235e:	b.n	11e3a <_svfprintf_r+0x10ba>
   12360:	ldr	r6, [pc, #248]	; (1245c <_svfprintf_r+0x16dc>)
   12362:	ldr	r3, [pc, #252]	; (12460 <_svfprintf_r+0x16e0>)
   12364:	ldrb.w	r7, [sp, #111]	; 0x6f
   12368:	b.w	113ce <_svfprintf_r+0x64e>
   1236c:	movs	r2, #0
   1236e:	movs	r3, #0
   12370:	ldrd	r0, r1, [sp, #96]	; 0x60
   12374:	bl	f92c <__aeabi_dcmpeq>
   12378:	cmp	r0, #0
   1237a:	bne.w	1205e <_svfprintf_r+0x12de>
   1237e:	rsb	r5, r5, #1
   12382:	str	r5, [sp, #116]	; 0x74
   12384:	add	r4, r5
   12386:	b.n	11dda <_svfprintf_r+0x105a>
   12388:	ldr	r3, [sp, #60]	; 0x3c
   1238a:	ldr	r2, [sp, #72]	; 0x48
   1238c:	adds	r5, r3, r2
   1238e:	add.w	r3, r5, fp
   12392:	str	r3, [sp, #36]	; 0x24
   12394:	bic.w	r3, r3, r3, asr #31
   12398:	b.n	11e3a <_svfprintf_r+0x10ba>
   1239a:	ldr	r3, [sp, #12]
   1239c:	ands.w	r3, r3, #1
   123a0:	bne.w	121cc <_svfprintf_r+0x144c>
   123a4:	str	r3, [sp, #60]	; 0x3c
   123a6:	ldr	r3, [sp, #36]	; 0x24
   123a8:	bic.w	r3, r3, r3, asr #31
   123ac:	b.n	11e3a <_svfprintf_r+0x10ba>
   123ae:	ldr	r3, [sp, #60]	; 0x3c
   123b0:	ldr	r2, [sp, #36]	; 0x24
   123b2:	rsb	r3, r3, #1
   123b6:	add	r2, r3
   123b8:	mov	r3, r2
   123ba:	str	r2, [sp, #36]	; 0x24
   123bc:	b.n	1229c <_svfprintf_r+0x151c>
   123be:	cmp.w	fp, #0
   123c2:	bne.n	123ca <_svfprintf_r+0x164a>
   123c4:	ldr	r3, [sp, #12]
   123c6:	lsls	r0, r3, #31
   123c8:	bpl.n	123da <_svfprintf_r+0x165a>
   123ca:	ldr	r3, [sp, #72]	; 0x48
   123cc:	adds	r5, r3, #1
   123ce:	add.w	r3, r5, fp
   123d2:	str	r3, [sp, #36]	; 0x24
   123d4:	bic.w	r3, r3, r3, asr #31
   123d8:	b.n	11e3a <_svfprintf_r+0x10ba>
   123da:	movs	r3, #1
   123dc:	str	r3, [sp, #36]	; 0x24
   123de:	b.n	11e3a <_svfprintf_r+0x10ba>
   123e0:	ldr	r0, [sp, #40]	; 0x28
   123e2:	ldrb.w	r3, [r8, #1]
   123e6:	ldr	r5, [r0, #0]
   123e8:	adds	r0, #4
   123ea:	cmp	r5, #0
   123ec:	str	r0, [sp, #40]	; 0x28
   123ee:	mov	r8, r4
   123f0:	bge.w	10e34 <_svfprintf_r+0xb4>
   123f4:	mov.w	r5, #4294967295
   123f8:	b.w	10e34 <_svfprintf_r+0xb4>
   123fc:	strb.w	r1, [sp, #111]	; 0x6f
   12400:	b.w	10f96 <_svfprintf_r+0x216>
   12404:	add.w	r3, sp, #126	; 0x7e
   12408:	b.n	121ba <_svfprintf_r+0x143a>
   1240a:	ldr	r2, [sp, #24]
   1240c:	movs	r3, #12
   1240e:	str	r3, [r2, #0]
   12410:	mov.w	r0, #4294967295
   12414:	b.w	10f86 <_svfprintf_r+0x206>
   12418:	strb.w	r1, [sp, #111]	; 0x6f
   1241c:	b.w	11090 <_svfprintf_r+0x310>
   12420:	strb.w	r1, [sp, #111]	; 0x6f
   12424:	b.w	1135c <_svfprintf_r+0x5dc>
   12428:	strb.w	r1, [sp, #111]	; 0x6f
   1242c:	b.w	114ca <_svfprintf_r+0x74a>
   12430:	strb.w	r1, [sp, #111]	; 0x6f
   12434:	b.w	1146e <_svfprintf_r+0x6ee>
   12438:	strb.w	r1, [sp, #111]	; 0x6f
   1243c:	b.w	1141a <_svfprintf_r+0x69a>
   12440:	strb.w	r1, [sp, #111]	; 0x6f
   12444:	b.w	116b2 <_svfprintf_r+0x932>
   12448:	strb.w	r1, [sp, #111]	; 0x6f
   1244c:	b.w	11670 <_svfprintf_r+0x8f0>
   12450:	strb.w	r1, [sp, #111]	; 0x6f
   12454:	b.w	11634 <_svfprintf_r+0x8b4>
   12458:	.word	0x00014a24
   1245c:	.word	0x000149f8
   12460:	.word	0x000149f4

00012464 <_vdprintf_r>:
   12464:	push	{r4, r5, r6, r7, lr}
   12466:	sub.w	sp, sp, #532	; 0x214
   1246a:	add	r5, sp, #16
   1246c:	str	r3, [sp, #0]
   1246e:	mov	r7, r1
   12470:	mov	r3, r2
   12472:	mov.w	r4, #512	; 0x200
   12476:	add	r2, sp, #12
   12478:	mov	r1, r5
   1247a:	str	r4, [sp, #12]
   1247c:	mov	r6, r0
   1247e:	bl	14008 <_vasnprintf_r>
   12482:	cbz	r0, 124a8 <_vdprintf_r+0x44>
   12484:	mov	r4, r0
   12486:	mov	r2, r0
   12488:	mov	r1, r7
   1248a:	ldr	r3, [sp, #12]
   1248c:	mov	r0, r6
   1248e:	bl	124e4 <_write_r>
   12492:	cmp	r4, r5
   12494:	str	r0, [sp, #12]
   12496:	beq.n	124a2 <_vdprintf_r+0x3e>
   12498:	mov	r0, r6
   1249a:	mov	r1, r4
   1249c:	bl	136f8 <_free_r>
   124a0:	ldr	r0, [sp, #12]
   124a2:	add.w	sp, sp, #532	; 0x214
   124a6:	pop	{r4, r5, r6, r7, pc}
   124a8:	mov.w	r0, #4294967295
   124ac:	b.n	124a2 <_vdprintf_r+0x3e>
   124ae:	nop

000124b0 <vdprintf>:
   124b0:	push	{r4}
   124b2:	ldr	r4, [pc, #16]	; (124c4 <vdprintf+0x14>)
   124b4:	mov	r3, r2
   124b6:	mov	r2, r1
   124b8:	mov	r1, r0
   124ba:	ldr	r0, [r4, #0]
   124bc:	ldr.w	r4, [sp], #4
   124c0:	b.w	12464 <_vdprintf_r>
   124c4:	.word	0x1fff0f10

000124c8 <__ascii_wctomb>:
   124c8:	cbz	r1, 124d4 <__ascii_wctomb+0xc>
   124ca:	cmp	r2, #255	; 0xff
   124cc:	bhi.n	124d8 <__ascii_wctomb+0x10>
   124ce:	strb	r2, [r1, #0]
   124d0:	movs	r0, #1
   124d2:	bx	lr
   124d4:	mov	r0, r1
   124d6:	bx	lr
   124d8:	movs	r3, #138	; 0x8a
   124da:	str	r3, [r0, #0]
   124dc:	mov.w	r0, #4294967295
   124e0:	bx	lr
   124e2:	nop

000124e4 <_write_r>:
   124e4:	push	{r4, r5, r6, lr}
   124e6:	mov	r5, r1
   124e8:	ldr	r4, [pc, #32]	; (1250c <_write_r+0x28>)
   124ea:	mov	r1, r2
   124ec:	mov	r6, r0
   124ee:	mov	r2, r3
   124f0:	mov	r0, r5
   124f2:	movs	r3, #0
   124f4:	str	r3, [r4, #0]
   124f6:	bl	eefc <_write>
   124fa:	adds	r3, r0, #1
   124fc:	beq.n	12500 <_write_r+0x1c>
   124fe:	pop	{r4, r5, r6, pc}
   12500:	ldr	r3, [r4, #0]
   12502:	cmp	r3, #0
   12504:	beq.n	124fe <_write_r+0x1a>
   12506:	str	r3, [r6, #0]
   12508:	pop	{r4, r5, r6, pc}
   1250a:	nop
   1250c:	.word	0x1fff6840

00012510 <__register_exitproc>:
   12510:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12514:	ldr	r4, [pc, #148]	; (125ac <__register_exitproc+0x9c>)
   12516:	ldr	r5, [r4, #0]
   12518:	ldr.w	r4, [r5, #328]	; 0x148
   1251c:	mov	r6, r0
   1251e:	mov	r8, r1
   12520:	mov	sl, r2
   12522:	mov	r9, r3
   12524:	cbz	r4, 12598 <__register_exitproc+0x88>
   12526:	ldr	r0, [r4, #4]
   12528:	cmp	r0, #31
   1252a:	bgt.n	1255c <__register_exitproc+0x4c>
   1252c:	adds	r3, r0, #1
   1252e:	cbz	r6, 1254e <__register_exitproc+0x3e>
   12530:	add.w	r5, r4, r0, lsl #2
   12534:	movs	r2, #1
   12536:	str.w	sl, [r5, #136]	; 0x88
   1253a:	ldr.w	r1, [r4, #392]	; 0x188
   1253e:	lsls	r2, r0
   12540:	orrs	r1, r2
   12542:	cmp	r6, #2
   12544:	str.w	r1, [r4, #392]	; 0x188
   12548:	str.w	r9, [r5, #264]	; 0x108
   1254c:	beq.n	1258c <__register_exitproc+0x7c>
   1254e:	adds	r0, #2
   12550:	str	r3, [r4, #4]
   12552:	str.w	r8, [r4, r0, lsl #2]
   12556:	movs	r0, #0
   12558:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1255c:	ldr	r3, [pc, #80]	; (125b0 <__register_exitproc+0xa0>)
   1255e:	cbz	r3, 125a2 <__register_exitproc+0x92>
   12560:	mov.w	r0, #400	; 0x190
   12564:	bl	fe10 <malloc>
   12568:	mov	r4, r0
   1256a:	cbz	r0, 125a2 <__register_exitproc+0x92>
   1256c:	ldr.w	r3, [r5, #328]	; 0x148
   12570:	movs	r7, #0
   12572:	stmia.w	r0, {r3, r7}
   12576:	str.w	r4, [r5, #328]	; 0x148
   1257a:	mov	r0, r7
   1257c:	movs	r3, #1
   1257e:	str.w	r7, [r4, #392]	; 0x188
   12582:	str.w	r7, [r4, #396]	; 0x18c
   12586:	cmp	r6, #0
   12588:	beq.n	1254e <__register_exitproc+0x3e>
   1258a:	b.n	12530 <__register_exitproc+0x20>
   1258c:	ldr.w	r1, [r4, #396]	; 0x18c
   12590:	orrs	r2, r1
   12592:	str.w	r2, [r4, #396]	; 0x18c
   12596:	b.n	1254e <__register_exitproc+0x3e>
   12598:	add.w	r4, r5, #332	; 0x14c
   1259c:	str.w	r4, [r5, #328]	; 0x148
   125a0:	b.n	12526 <__register_exitproc+0x16>
   125a2:	mov.w	r0, #4294967295
   125a6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   125aa:	nop
   125ac:	.word	0x000149c8
   125b0:	.word	0x0000fe11

000125b4 <register_fini>:
   125b4:	ldr	r3, [pc, #8]	; (125c0 <register_fini+0xc>)
   125b6:	cbz	r3, 125be <register_fini+0xa>
   125b8:	ldr	r0, [pc, #8]	; (125c4 <register_fini+0x10>)
   125ba:	b.w	125c8 <atexit>
   125be:	bx	lr
   125c0:	.word	0x00000000
   125c4:	.word	0x00013635

000125c8 <atexit>:
   125c8:	movs	r3, #0
   125ca:	mov	r1, r0
   125cc:	mov	r2, r3
   125ce:	mov	r0, r3
   125d0:	b.w	12510 <__register_exitproc>

000125d4 <quorem>:
   125d4:	ldr	r2, [r0, #16]
   125d6:	ldr	r3, [r1, #16]
   125d8:	cmp	r3, r2
   125da:	bgt.w	126f8 <quorem+0x124>
   125de:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   125e2:	add.w	r8, r3, #4294967295
   125e6:	add.w	r7, r1, #20
   125ea:	add.w	fp, r0, #20
   125ee:	ldr.w	r2, [r7, r8, lsl #2]
   125f2:	ldr.w	r3, [fp, r8, lsl #2]
   125f6:	mov.w	r4, r8, lsl #2
   125fa:	sub	sp, #12
   125fc:	adds	r2, #1
   125fe:	udiv	r9, r3, r2
   12602:	add.w	r3, fp, r4
   12606:	str	r4, [sp, #0]
   12608:	add.w	sl, r7, r4
   1260c:	str	r3, [sp, #4]
   1260e:	cmp.w	r9, #0
   12612:	beq.n	12688 <quorem+0xb4>
   12614:	movs	r5, #0
   12616:	mov	ip, r7
   12618:	mov	lr, fp
   1261a:	mov	r3, r5
   1261c:	ldr.w	r6, [ip], #4
   12620:	ldr.w	r2, [lr]
   12624:	uxth	r4, r6
   12626:	mla	r5, r9, r4, r5
   1262a:	lsrs	r6, r6, #16
   1262c:	lsrs	r4, r5, #16
   1262e:	mla	r4, r9, r6, r4
   12632:	uxth	r5, r5
   12634:	subs	r3, r3, r5
   12636:	uxth	r6, r4
   12638:	uxtah	r3, r3, r2
   1263c:	rsb	r6, r6, r2, lsr #16
   12640:	add.w	r6, r6, r3, asr #16
   12644:	uxth	r3, r3
   12646:	orr.w	r3, r3, r6, lsl #16
   1264a:	cmp	sl, ip
   1264c:	str.w	r3, [lr], #4
   12650:	mov.w	r5, r4, lsr #16
   12654:	mov.w	r3, r6, asr #16
   12658:	bcs.n	1261c <quorem+0x48>
   1265a:	ldr	r3, [sp, #0]
   1265c:	ldr.w	r3, [fp, r3]
   12660:	cbnz	r3, 12688 <quorem+0xb4>
   12662:	ldr	r4, [sp, #4]
   12664:	subs	r3, r4, #4
   12666:	cmp	fp, r3
   12668:	bcs.n	12684 <quorem+0xb0>
   1266a:	ldr.w	r3, [r4, #-4]
   1266e:	cbnz	r3, 12684 <quorem+0xb0>
   12670:	sub.w	r3, r4, #8
   12674:	b.n	1267c <quorem+0xa8>
   12676:	ldr	r2, [r3, #0]
   12678:	subs	r3, #4
   1267a:	cbnz	r2, 12684 <quorem+0xb0>
   1267c:	cmp	fp, r3
   1267e:	add.w	r8, r8, #4294967295
   12682:	bcc.n	12676 <quorem+0xa2>
   12684:	str.w	r8, [r0, #16]
   12688:	mov	r4, r0
   1268a:	bl	13cf4 <__mcmp>
   1268e:	cmp	r0, #0
   12690:	blt.n	126f0 <quorem+0x11c>
   12692:	add.w	r9, r9, #1
   12696:	mov	r5, fp
   12698:	movs	r3, #0
   1269a:	ldr.w	r1, [r7], #4
   1269e:	ldr	r0, [r5, #0]
   126a0:	uxth	r2, r1
   126a2:	subs	r2, r3, r2
   126a4:	lsrs	r1, r1, #16
   126a6:	uxtah	r2, r2, r0
   126aa:	rsb	r3, r1, r0, lsr #16
   126ae:	add.w	r3, r3, r2, asr #16
   126b2:	uxth	r1, r2
   126b4:	orr.w	r1, r1, r3, lsl #16
   126b8:	cmp	sl, r7
   126ba:	str.w	r1, [r5], #4
   126be:	mov.w	r3, r3, asr #16
   126c2:	bcs.n	1269a <quorem+0xc6>
   126c4:	ldr.w	r2, [fp, r8, lsl #2]
   126c8:	add.w	r3, fp, r8, lsl #2
   126cc:	cbnz	r2, 126f0 <quorem+0x11c>
   126ce:	subs	r2, r3, #4
   126d0:	cmp	fp, r2
   126d2:	bcs.n	126ec <quorem+0x118>
   126d4:	ldr.w	r2, [r3, #-4]
   126d8:	cbnz	r2, 126ec <quorem+0x118>
   126da:	subs	r3, #8
   126dc:	b.n	126e4 <quorem+0x110>
   126de:	ldr	r2, [r3, #0]
   126e0:	subs	r3, #4
   126e2:	cbnz	r2, 126ec <quorem+0x118>
   126e4:	cmp	fp, r3
   126e6:	add.w	r8, r8, #4294967295
   126ea:	bcc.n	126de <quorem+0x10a>
   126ec:	str.w	r8, [r4, #16]
   126f0:	mov	r0, r9
   126f2:	add	sp, #12
   126f4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   126f8:	movs	r0, #0
   126fa:	bx	lr
   126fc:			; <UNDEFINED> instruction: 0xffffffff

00012700 <_dtoa_r>:
   12700:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12704:	vmov	r6, r7, d0
   12708:	sub	sp, #108	; 0x6c
   1270a:	ldr	r4, [r0, #64]	; 0x40
   1270c:	ldr	r5, [sp, #144]	; 0x90
   1270e:	str	r1, [sp, #0]
   12710:	mov	r9, r0
   12712:	str	r2, [sp, #20]
   12714:	str	r3, [sp, #12]
   12716:	vmov	sl, s0
   1271a:	mov	fp, r7
   1271c:	cbz	r4, 12734 <_dtoa_r+0x34>
   1271e:	ldr	r2, [r0, #68]	; 0x44
   12720:	str	r2, [r4, #4]
   12722:	movs	r3, #1
   12724:	lsls	r3, r2
   12726:	str	r3, [r4, #8]
   12728:	mov	r1, r4
   1272a:	bl	13930 <_Bfree>
   1272e:	movs	r3, #0
   12730:	str.w	r3, [r9, #64]	; 0x40
   12734:	cmp.w	fp, #0
   12738:	mov	r4, fp
   1273a:	blt.n	127a6 <_dtoa_r+0xa6>
   1273c:	movs	r3, #0
   1273e:	str	r3, [r5, #0]
   12740:	ldr	r3, [pc, #644]	; (129c8 <_dtoa_r+0x2c8>)
   12742:	mov	r2, r3
   12744:	ands	r3, r4
   12746:	cmp	r3, r2
   12748:	beq.n	12778 <_dtoa_r+0x78>
   1274a:	movs	r2, #0
   1274c:	movs	r3, #0
   1274e:	mov	r0, sl
   12750:	mov	r1, fp
   12752:	bl	f92c <__aeabi_dcmpeq>
   12756:	mov	r6, sl
   12758:	mov	r7, fp
   1275a:	mov	r8, r0
   1275c:	cbz	r0, 127b2 <_dtoa_r+0xb2>
   1275e:	ldr	r2, [sp, #12]
   12760:	movs	r3, #1
   12762:	str	r3, [r2, #0]
   12764:	ldr	r3, [sp, #148]	; 0x94
   12766:	cmp	r3, #0
   12768:	beq.w	128e8 <_dtoa_r+0x1e8>
   1276c:	ldr	r0, [pc, #604]	; (129cc <_dtoa_r+0x2cc>)
   1276e:	str	r0, [r3, #0]
   12770:	subs	r0, #1
   12772:	add	sp, #108	; 0x6c
   12774:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12778:	ldr	r2, [sp, #12]
   1277a:	movw	r3, #9999	; 0x270f
   1277e:	str	r3, [r2, #0]
   12780:	cmp.w	sl, #0
   12784:	beq.w	128bc <_dtoa_r+0x1bc>
   12788:	ldr	r0, [pc, #580]	; (129d0 <_dtoa_r+0x2d0>)
   1278a:	ldr	r3, [sp, #148]	; 0x94
   1278c:	cmp	r3, #0
   1278e:	beq.n	12772 <_dtoa_r+0x72>
   12790:	ldrb	r3, [r0, #3]
   12792:	cmp	r3, #0
   12794:	beq.w	128ec <_dtoa_r+0x1ec>
   12798:	add.w	r3, r0, #8
   1279c:	ldr	r2, [sp, #148]	; 0x94
   1279e:	str	r3, [r2, #0]
   127a0:	add	sp, #108	; 0x6c
   127a2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   127a6:	movs	r3, #1
   127a8:	bic.w	r4, fp, #2147483648	; 0x80000000
   127ac:	str	r3, [r5, #0]
   127ae:	mov	fp, r4
   127b0:	b.n	12740 <_dtoa_r+0x40>
   127b2:	add	r2, sp, #96	; 0x60
   127b4:	add	r1, sp, #100	; 0x64
   127b6:	vmov	d0, r6, r7
   127ba:	mov	r0, r9
   127bc:	bl	13e4c <__d2b>
   127c0:	lsrs	r5, r4, #20
   127c2:	str	r0, [sp, #40]	; 0x28
   127c4:	bne.w	128ce <_dtoa_r+0x1ce>
   127c8:	ldr	r5, [sp, #96]	; 0x60
   127ca:	ldr	r6, [sp, #100]	; 0x64
   127cc:	add	r6, r5
   127ce:	addw	r3, r6, #1074	; 0x432
   127d2:	cmp	r3, #32
   127d4:	ble.w	12ce8 <_dtoa_r+0x5e8>
   127d8:	rsb	r3, r3, #64	; 0x40
   127dc:	addw	r0, r6, #1042	; 0x412
   127e0:	lsls	r4, r3
   127e2:	lsr.w	r0, sl, r0
   127e6:	orrs	r0, r4
   127e8:	bl	f370 <__aeabi_ui2d>
   127ec:	movs	r3, #1
   127ee:	subs	r4, r6, #1
   127f0:	sub.w	r1, r1, #32505856	; 0x1f00000
   127f4:	str	r3, [sp, #60]	; 0x3c
   127f6:	movs	r2, #0
   127f8:	ldr	r3, [pc, #472]	; (129d4 <_dtoa_r+0x2d4>)
   127fa:	bl	f0f4 <__aeabi_dsub>
   127fe:	add	r3, pc, #432	; (adr r3, 129b0 <_dtoa_r+0x2b0>)
   12800:	ldrd	r2, r3, [r3]
   12804:	bl	f45c <__aeabi_dmul>
   12808:	add	r3, pc, #428	; (adr r3, 129b8 <_dtoa_r+0x2b8>)
   1280a:	ldrd	r2, r3, [r3]
   1280e:	bl	f0f8 <__adddf3>
   12812:	mov	r6, r0
   12814:	mov	r0, r4
   12816:	mov	r7, r1
   12818:	bl	f390 <__aeabi_i2d>
   1281c:	add	r3, pc, #416	; (adr r3, 129c0 <_dtoa_r+0x2c0>)
   1281e:	ldrd	r2, r3, [r3]
   12822:	bl	f45c <__aeabi_dmul>
   12826:	mov	r2, r0
   12828:	mov	r3, r1
   1282a:	mov	r0, r6
   1282c:	mov	r1, r7
   1282e:	bl	f0f8 <__adddf3>
   12832:	mov	r6, r0
   12834:	mov	r7, r1
   12836:	bl	f9bc <__aeabi_d2iz>
   1283a:	movs	r2, #0
   1283c:	str	r0, [sp, #16]
   1283e:	movs	r3, #0
   12840:	mov	r0, r6
   12842:	mov	r1, r7
   12844:	bl	f940 <__aeabi_dcmplt>
   12848:	cmp	r0, #0
   1284a:	bne.w	12c9e <_dtoa_r+0x59e>
   1284e:	ldr	r6, [sp, #16]
   12850:	cmp	r6, #22
   12852:	bhi.w	12c98 <_dtoa_r+0x598>
   12856:	ldr	r3, [pc, #384]	; (129d8 <_dtoa_r+0x2d8>)
   12858:	add.w	r3, r3, r6, lsl #3
   1285c:	ldrd	r0, r1, [r3]
   12860:	mov	r2, sl
   12862:	mov	r3, fp
   12864:	bl	f97c <__aeabi_dcmpgt>
   12868:	cmp	r0, #0
   1286a:	beq.w	12cf2 <_dtoa_r+0x5f2>
   1286e:	subs	r3, r6, #1
   12870:	str	r3, [sp, #16]
   12872:	movs	r3, #0
   12874:	str	r3, [sp, #52]	; 0x34
   12876:	subs	r5, r5, r4
   12878:	subs.w	r8, r5, #1
   1287c:	bmi.w	12cd4 <_dtoa_r+0x5d4>
   12880:	movs	r3, #0
   12882:	str	r3, [sp, #28]
   12884:	ldr	r3, [sp, #16]
   12886:	cmp	r3, #0
   12888:	blt.w	12cc2 <_dtoa_r+0x5c2>
   1288c:	add	r8, r3
   1288e:	str	r3, [sp, #48]	; 0x30
   12890:	movs	r3, #0
   12892:	str	r3, [sp, #24]
   12894:	ldr	r3, [sp, #0]
   12896:	cmp	r3, #9
   12898:	bhi.n	128f0 <_dtoa_r+0x1f0>
   1289a:	cmp	r3, #5
   1289c:	ble.w	13528 <_dtoa_r+0xe28>
   128a0:	subs	r3, #4
   128a2:	str	r3, [sp, #0]
   128a4:	movs	r6, #0
   128a6:	ldr	r3, [sp, #0]
   128a8:	subs	r3, #2
   128aa:	cmp	r3, #3
   128ac:	bhi.w	134f6 <_dtoa_r+0xdf6>
   128b0:	tbh	[pc, r3, lsl #1]
   128b4:	.word	0x0224032b
   128b8:	.word	0x04500336
   128bc:	ldr	r3, [pc, #272]	; (129d0 <_dtoa_r+0x2d0>)
   128be:	ldr	r2, [pc, #284]	; (129dc <_dtoa_r+0x2dc>)
   128c0:	ubfx	r0, r4, #0, #20
   128c4:	cmp	r0, #0
   128c6:	ite	ne
   128c8:	movne	r0, r3
   128ca:	moveq	r0, r2
   128cc:	b.n	1278a <_dtoa_r+0x8a>
   128ce:	ubfx	r3, fp, #0, #20
   128d2:	orr.w	r1, r3, #1069547520	; 0x3fc00000
   128d6:	subw	r4, r5, #1023	; 0x3ff
   128da:	mov	r0, sl
   128dc:	str.w	r8, [sp, #60]	; 0x3c
   128e0:	orr.w	r1, r1, #3145728	; 0x300000
   128e4:	ldr	r5, [sp, #96]	; 0x60
   128e6:	b.n	127f6 <_dtoa_r+0xf6>
   128e8:	ldr	r0, [pc, #244]	; (129e0 <_dtoa_r+0x2e0>)
   128ea:	b.n	12772 <_dtoa_r+0x72>
   128ec:	adds	r3, r0, #3
   128ee:	b.n	1279c <_dtoa_r+0x9c>
   128f0:	movs	r1, #0
   128f2:	str.w	r1, [r9, #68]	; 0x44
   128f6:	mov	r0, r9
   128f8:	mov	r4, r1
   128fa:	str	r1, [sp, #0]
   128fc:	bl	138e4 <_Balloc>
   12900:	mov.w	r3, #4294967295
   12904:	str	r3, [sp, #32]
   12906:	str	r3, [sp, #56]	; 0x38
   12908:	movs	r3, #1
   1290a:	str	r0, [sp, #36]	; 0x24
   1290c:	str.w	r0, [r9, #64]	; 0x40
   12910:	str	r4, [sp, #20]
   12912:	str	r3, [sp, #44]	; 0x2c
   12914:	ldr	r3, [sp, #100]	; 0x64
   12916:	cmp	r3, #0
   12918:	blt.w	12abc <_dtoa_r+0x3bc>
   1291c:	ldr	r2, [sp, #16]
   1291e:	cmp	r2, #14
   12920:	bgt.w	12abc <_dtoa_r+0x3bc>
   12924:	ldr	r3, [pc, #176]	; (129d8 <_dtoa_r+0x2d8>)
   12926:	add.w	r3, r3, r2, lsl #3
   1292a:	vldr	d7, [r3]
   1292e:	ldr	r3, [sp, #20]
   12930:	cmp	r3, #0
   12932:	vstr	d7, [sp]
   12936:	blt.w	12f36 <_dtoa_r+0x836>
   1293a:	mov	r6, sl
   1293c:	mov	r7, fp
   1293e:	ldrd	sl, fp, [sp]
   12942:	mov	r0, r6
   12944:	mov	r2, sl
   12946:	mov	r3, fp
   12948:	mov	r1, r7
   1294a:	bl	f6b0 <__aeabi_ddiv>
   1294e:	bl	f9bc <__aeabi_d2iz>
   12952:	mov	r4, r0
   12954:	bl	f390 <__aeabi_i2d>
   12958:	mov	r2, sl
   1295a:	mov	r3, fp
   1295c:	bl	f45c <__aeabi_dmul>
   12960:	mov	r3, r1
   12962:	mov	r2, r0
   12964:	mov	r1, r7
   12966:	mov	r0, r6
   12968:	bl	f0f4 <__aeabi_dsub>
   1296c:	ldr	r5, [sp, #36]	; 0x24
   1296e:	add.w	r3, r4, #48	; 0x30
   12972:	strb	r3, [r5, #0]
   12974:	ldr	r3, [sp, #32]
   12976:	cmp	r3, #1
   12978:	mov	r6, r0
   1297a:	mov	r7, r1
   1297c:	add.w	r5, r5, #1
   12980:	beq.n	12a46 <_dtoa_r+0x346>
   12982:	movs	r2, #0
   12984:	ldr	r3, [pc, #92]	; (129e4 <_dtoa_r+0x2e4>)
   12986:	bl	f45c <__aeabi_dmul>
   1298a:	movs	r2, #0
   1298c:	movs	r3, #0
   1298e:	mov	r6, r0
   12990:	mov	r7, r1
   12992:	bl	f92c <__aeabi_dcmpeq>
   12996:	cmp	r0, #0
   12998:	bne.n	12a96 <_dtoa_r+0x396>
   1299a:	str.w	r9, [sp, #20]
   1299e:	ldr.w	sl, [sp, #32]
   129a2:	ldr.w	fp, [sp, #36]	; 0x24
   129a6:	ldrd	r8, r9, [sp]
   129aa:	b.n	129fe <_dtoa_r+0x2fe>
   129ac:	nop.w
   129b0:	.word	0x636f4361
   129b4:	.word	0x3fd287a7
   129b8:	.word	0x8b60c8b3
   129bc:	.word	0x3fc68a28
   129c0:	.word	0x509f79fb
   129c4:	.word	0x3fd34413
   129c8:	.word	0x7ff00000
   129cc:	.word	0x00014795
   129d0:	.word	0x00014b4c
   129d4:	.word	0x3ff80000
   129d8:	.word	0x00014b50
   129dc:	.word	0x00014b40
   129e0:	.word	0x00014794
   129e4:	.word	0x40240000
   129e8:	bl	f45c <__aeabi_dmul>
   129ec:	movs	r2, #0
   129ee:	movs	r3, #0
   129f0:	mov	r6, r0
   129f2:	mov	r7, r1
   129f4:	bl	f92c <__aeabi_dcmpeq>
   129f8:	cmp	r0, #0
   129fa:	bne.w	1315a <_dtoa_r+0xa5a>
   129fe:	mov	r2, r8
   12a00:	mov	r3, r9
   12a02:	mov	r0, r6
   12a04:	mov	r1, r7
   12a06:	bl	f6b0 <__aeabi_ddiv>
   12a0a:	bl	f9bc <__aeabi_d2iz>
   12a0e:	mov	r4, r0
   12a10:	bl	f390 <__aeabi_i2d>
   12a14:	mov	r2, r8
   12a16:	mov	r3, r9
   12a18:	bl	f45c <__aeabi_dmul>
   12a1c:	mov	r2, r0
   12a1e:	mov	r3, r1
   12a20:	mov	r0, r6
   12a22:	mov	r1, r7
   12a24:	bl	f0f4 <__aeabi_dsub>
   12a28:	add.w	lr, r4, #48	; 0x30
   12a2c:	strb.w	lr, [r5], #1
   12a30:	rsb	lr, fp, r5
   12a34:	cmp	lr, sl
   12a36:	mov	r6, r0
   12a38:	mov	r7, r1
   12a3a:	mov.w	r2, #0
   12a3e:	ldr	r3, [pc, #696]	; (12cf8 <_dtoa_r+0x5f8>)
   12a40:	bne.n	129e8 <_dtoa_r+0x2e8>
   12a42:	ldr.w	r9, [sp, #20]
   12a46:	mov	r2, r6
   12a48:	mov	r3, r7
   12a4a:	mov	r0, r6
   12a4c:	mov	r1, r7
   12a4e:	bl	f0f8 <__adddf3>
   12a52:	mov	r6, r0
   12a54:	mov	r7, r1
   12a56:	mov	r2, r0
   12a58:	mov	r3, r1
   12a5a:	ldrd	r0, r1, [sp]
   12a5e:	bl	f940 <__aeabi_dcmplt>
   12a62:	cbnz	r0, 12a76 <_dtoa_r+0x376>
   12a64:	mov	r2, r6
   12a66:	mov	r3, r7
   12a68:	ldrd	r0, r1, [sp]
   12a6c:	bl	f92c <__aeabi_dcmpeq>
   12a70:	cbz	r0, 12a96 <_dtoa_r+0x396>
   12a72:	lsls	r3, r4, #31
   12a74:	bpl.n	12a96 <_dtoa_r+0x396>
   12a76:	ldrb.w	r4, [r5, #-1]
   12a7a:	ldr	r2, [sp, #36]	; 0x24
   12a7c:	subs	r3, r5, #1
   12a7e:	b.n	12a8a <_dtoa_r+0x38a>
   12a80:	cmp	r2, r3
   12a82:	beq.w	1327e <_dtoa_r+0xb7e>
   12a86:	ldrb.w	r4, [r3, #-1]!
   12a8a:	cmp	r4, #57	; 0x39
   12a8c:	add.w	r5, r3, #1
   12a90:	beq.n	12a80 <_dtoa_r+0x380>
   12a92:	adds	r4, #1
   12a94:	strb	r4, [r3, #0]
   12a96:	ldr	r1, [sp, #40]	; 0x28
   12a98:	mov	r0, r9
   12a9a:	bl	13930 <_Bfree>
   12a9e:	movs	r2, #0
   12aa0:	ldr	r3, [sp, #16]
   12aa2:	strb	r2, [r5, #0]
   12aa4:	ldr	r2, [sp, #12]
   12aa6:	adds	r3, #1
   12aa8:	str	r3, [r2, #0]
   12aaa:	ldr	r3, [sp, #148]	; 0x94
   12aac:	cmp	r3, #0
   12aae:	beq.w	131e8 <_dtoa_r+0xae8>
   12ab2:	ldr	r0, [sp, #36]	; 0x24
   12ab4:	str	r5, [r3, #0]
   12ab6:	add	sp, #108	; 0x6c
   12ab8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12abc:	ldr	r2, [sp, #44]	; 0x2c
   12abe:	cmp	r2, #0
   12ac0:	beq.w	12ce0 <_dtoa_r+0x5e0>
   12ac4:	ldr	r2, [sp, #0]
   12ac6:	cmp	r2, #1
   12ac8:	ble.w	12f7a <_dtoa_r+0x87a>
   12acc:	ldr	r3, [sp, #32]
   12ace:	ldr	r2, [sp, #24]
   12ad0:	subs	r7, r3, #1
   12ad2:	cmp	r2, r7
   12ad4:	blt.w	131ee <_dtoa_r+0xaee>
   12ad8:	subs	r7, r2, r7
   12ada:	ldr	r3, [sp, #32]
   12adc:	cmp	r3, #0
   12ade:	blt.w	133e2 <_dtoa_r+0xce2>
   12ae2:	ldr	r5, [sp, #28]
   12ae4:	ldr	r3, [sp, #32]
   12ae6:	ldr	r2, [sp, #28]
   12ae8:	movs	r1, #1
   12aea:	add	r2, r3
   12aec:	mov	r0, r9
   12aee:	str	r2, [sp, #28]
   12af0:	add	r8, r3
   12af2:	bl	13a60 <__i2b>
   12af6:	mov	r6, r0
   12af8:	cbz	r5, 12b14 <_dtoa_r+0x414>
   12afa:	cmp.w	r8, #0
   12afe:	ble.n	12b14 <_dtoa_r+0x414>
   12b00:	cmp	r5, r8
   12b02:	ldr	r2, [sp, #28]
   12b04:	mov	r3, r5
   12b06:	it	ge
   12b08:	movge	r3, r8
   12b0a:	subs	r2, r2, r3
   12b0c:	str	r2, [sp, #28]
   12b0e:	subs	r5, r5, r3
   12b10:	rsb	r8, r3, r8
   12b14:	ldr	r3, [sp, #24]
   12b16:	cmp	r3, #0
   12b18:	ble.w	13106 <_dtoa_r+0xa06>
   12b1c:	ldr	r2, [sp, #44]	; 0x2c
   12b1e:	cmp	r2, #0
   12b20:	beq.w	12f28 <_dtoa_r+0x828>
   12b24:	cmp	r7, #0
   12b26:	beq.w	12f28 <_dtoa_r+0x828>
   12b2a:	mov	r1, r6
   12b2c:	mov	r2, r7
   12b2e:	mov	r0, r9
   12b30:	bl	13ba4 <__pow5mult>
   12b34:	ldr	r2, [sp, #40]	; 0x28
   12b36:	mov	r1, r0
   12b38:	mov	r6, r0
   12b3a:	mov	r0, r9
   12b3c:	bl	13a74 <__multiply>
   12b40:	ldr	r1, [sp, #40]	; 0x28
   12b42:	mov	r4, r0
   12b44:	mov	r0, r9
   12b46:	bl	13930 <_Bfree>
   12b4a:	ldr	r3, [sp, #24]
   12b4c:	subs	r3, r3, r7
   12b4e:	str	r3, [sp, #24]
   12b50:	bne.w	12f26 <_dtoa_r+0x826>
   12b54:	movs	r1, #1
   12b56:	mov	r0, r9
   12b58:	bl	13a60 <__i2b>
   12b5c:	ldr	r3, [sp, #48]	; 0x30
   12b5e:	str	r0, [sp, #24]
   12b60:	cmp	r3, #0
   12b62:	beq.w	12f90 <_dtoa_r+0x890>
   12b66:	mov	r1, r0
   12b68:	mov	r2, r3
   12b6a:	mov	r0, r9
   12b6c:	bl	13ba4 <__pow5mult>
   12b70:	ldr	r3, [sp, #0]
   12b72:	str	r0, [sp, #24]
   12b74:	cmp	r3, #1
   12b76:	ble.w	13160 <_dtoa_r+0xa60>
   12b7a:	movs	r7, #0
   12b7c:	ldr	r2, [sp, #24]
   12b7e:	ldr	r3, [r2, #16]
   12b80:	add.w	r3, r2, r3, lsl #2
   12b84:	ldr	r0, [r3, #16]
   12b86:	bl	139c4 <__hi0bits>
   12b8a:	rsb	r0, r0, #32
   12b8e:	add	r0, r8
   12b90:	ands.w	r0, r0, #31
   12b94:	beq.w	12f8c <_dtoa_r+0x88c>
   12b98:	rsb	r3, r0, #32
   12b9c:	cmp	r3, #4
   12b9e:	ble.w	1351c <_dtoa_r+0xe1c>
   12ba2:	rsb	r0, r0, #28
   12ba6:	ldr	r3, [sp, #28]
   12ba8:	add	r3, r0
   12baa:	str	r3, [sp, #28]
   12bac:	add	r5, r0
   12bae:	add	r8, r0
   12bb0:	ldr	r3, [sp, #28]
   12bb2:	cmp	r3, #0
   12bb4:	ble.n	12bc2 <_dtoa_r+0x4c2>
   12bb6:	mov	r1, r4
   12bb8:	mov	r2, r3
   12bba:	mov	r0, r9
   12bbc:	bl	13c44 <__lshift>
   12bc0:	mov	r4, r0
   12bc2:	cmp.w	r8, #0
   12bc6:	ble.n	12bd4 <_dtoa_r+0x4d4>
   12bc8:	mov	r2, r8
   12bca:	ldr	r1, [sp, #24]
   12bcc:	mov	r0, r9
   12bce:	bl	13c44 <__lshift>
   12bd2:	str	r0, [sp, #24]
   12bd4:	ldr	r3, [sp, #52]	; 0x34
   12bd6:	cmp	r3, #0
   12bd8:	bne.w	130d0 <_dtoa_r+0x9d0>
   12bdc:	ldr	r3, [sp, #32]
   12bde:	cmp	r3, #0
   12be0:	ble.w	1310a <_dtoa_r+0xa0a>
   12be4:	ldr	r3, [sp, #44]	; 0x2c
   12be6:	cmp	r3, #0
   12be8:	bne.w	12fd4 <_dtoa_r+0x8d4>
   12bec:	ldr.w	fp, [sp, #36]	; 0x24
   12bf0:	ldr	r7, [sp, #32]
   12bf2:	ldr.w	r8, [sp, #24]
   12bf6:	mov	r5, fp
   12bf8:	b.n	12c00 <_dtoa_r+0x500>
   12bfa:	bl	13944 <__multadd>
   12bfe:	mov	r4, r0
   12c00:	mov	r1, r8
   12c02:	mov	r0, r4
   12c04:	bl	125d4 <quorem>
   12c08:	add.w	sl, r0, #48	; 0x30
   12c0c:	strb.w	sl, [r5], #1
   12c10:	rsb	r3, fp, r5
   12c14:	cmp	r3, r7
   12c16:	mov.w	r2, #10
   12c1a:	mov.w	r3, #0
   12c1e:	mov	r1, r4
   12c20:	mov	r0, r9
   12c22:	blt.n	12bfa <_dtoa_r+0x4fa>
   12c24:	ldr	r3, [sp, #36]	; 0x24
   12c26:	ldr	r2, [sp, #32]
   12c28:	cmp	r2, #1
   12c2a:	ite	ge
   12c2c:	addge	r3, r3, r2
   12c2e:	addlt	r3, #1
   12c30:	mov	r5, r3
   12c32:	mov.w	fp, #0
   12c36:	mov	r1, r4
   12c38:	movs	r2, #1
   12c3a:	mov	r0, r9
   12c3c:	bl	13c44 <__lshift>
   12c40:	ldr	r1, [sp, #24]
   12c42:	str	r0, [sp, #40]	; 0x28
   12c44:	bl	13cf4 <__mcmp>
   12c48:	cmp	r0, #0
   12c4a:	ble.w	13258 <_dtoa_r+0xb58>
   12c4e:	ldrb.w	r2, [r5, #-1]
   12c52:	ldr	r1, [sp, #36]	; 0x24
   12c54:	subs	r3, r5, #1
   12c56:	b.n	12c62 <_dtoa_r+0x562>
   12c58:	cmp	r3, r1
   12c5a:	beq.w	13146 <_dtoa_r+0xa46>
   12c5e:	ldrb.w	r2, [r3, #-1]!
   12c62:	cmp	r2, #57	; 0x39
   12c64:	add.w	r5, r3, #1
   12c68:	beq.n	12c58 <_dtoa_r+0x558>
   12c6a:	adds	r2, #1
   12c6c:	strb	r2, [r3, #0]
   12c6e:	ldr	r1, [sp, #24]
   12c70:	mov	r0, r9
   12c72:	bl	13930 <_Bfree>
   12c76:	cmp	r6, #0
   12c78:	beq.w	12a96 <_dtoa_r+0x396>
   12c7c:	cmp.w	fp, #0
   12c80:	beq.n	12c8e <_dtoa_r+0x58e>
   12c82:	cmp	fp, r6
   12c84:	beq.n	12c8e <_dtoa_r+0x58e>
   12c86:	mov	r1, fp
   12c88:	mov	r0, r9
   12c8a:	bl	13930 <_Bfree>
   12c8e:	mov	r1, r6
   12c90:	mov	r0, r9
   12c92:	bl	13930 <_Bfree>
   12c96:	b.n	12a96 <_dtoa_r+0x396>
   12c98:	movs	r3, #1
   12c9a:	str	r3, [sp, #52]	; 0x34
   12c9c:	b.n	12876 <_dtoa_r+0x176>
   12c9e:	ldr.w	r8, [sp, #16]
   12ca2:	mov	r0, r8
   12ca4:	bl	f390 <__aeabi_i2d>
   12ca8:	mov	r2, r0
   12caa:	mov	r3, r1
   12cac:	mov	r0, r6
   12cae:	mov	r1, r7
   12cb0:	bl	f92c <__aeabi_dcmpeq>
   12cb4:	cmp	r0, #0
   12cb6:	bne.w	1284e <_dtoa_r+0x14e>
   12cba:	add.w	r3, r8, #4294967295
   12cbe:	str	r3, [sp, #16]
   12cc0:	b.n	1284e <_dtoa_r+0x14e>
   12cc2:	ldr	r2, [sp, #28]
   12cc4:	ldr	r3, [sp, #16]
   12cc6:	subs	r2, r2, r3
   12cc8:	negs	r3, r3
   12cca:	str	r3, [sp, #24]
   12ccc:	movs	r3, #0
   12cce:	str	r2, [sp, #28]
   12cd0:	str	r3, [sp, #48]	; 0x30
   12cd2:	b.n	12894 <_dtoa_r+0x194>
   12cd4:	rsb	r3, r8, #0
   12cd8:	str	r3, [sp, #28]
   12cda:	mov.w	r8, #0
   12cde:	b.n	12884 <_dtoa_r+0x184>
   12ce0:	ldr	r7, [sp, #24]
   12ce2:	ldr	r5, [sp, #28]
   12ce4:	ldr	r6, [sp, #44]	; 0x2c
   12ce6:	b.n	12af8 <_dtoa_r+0x3f8>
   12ce8:	rsb	r4, r3, #32
   12cec:	lsl.w	r0, sl, r4
   12cf0:	b.n	127e8 <_dtoa_r+0xe8>
   12cf2:	str	r0, [sp, #52]	; 0x34
   12cf4:	b.n	12876 <_dtoa_r+0x176>
   12cf6:	nop
   12cf8:	.word	0x40240000
   12cfc:	movs	r3, #0
   12cfe:	str	r3, [sp, #44]	; 0x2c
   12d00:	ldr	r3, [sp, #16]
   12d02:	ldr	r2, [sp, #20]
   12d04:	add	r3, r2
   12d06:	str	r3, [sp, #56]	; 0x38
   12d08:	adds	r3, #1
   12d0a:	cmp	r3, #0
   12d0c:	str	r3, [sp, #32]
   12d0e:	ble.w	1320c <_dtoa_r+0xb0c>
   12d12:	ldr	r4, [sp, #32]
   12d14:	mov	r5, r4
   12d16:	movs	r1, #0
   12d18:	cmp	r5, #23
   12d1a:	str.w	r1, [r9, #68]	; 0x44
   12d1e:	bls.n	12d38 <_dtoa_r+0x638>
   12d20:	movs	r2, #1
   12d22:	movs	r3, #4
   12d24:	lsls	r3, r3, #1
   12d26:	add.w	r0, r3, #20
   12d2a:	cmp	r0, r5
   12d2c:	mov	r1, r2
   12d2e:	add.w	r2, r2, #1
   12d32:	bls.n	12d24 <_dtoa_r+0x624>
   12d34:	str.w	r1, [r9, #68]	; 0x44
   12d38:	mov	r0, r9
   12d3a:	bl	138e4 <_Balloc>
   12d3e:	cmp	r4, #14
   12d40:	str	r0, [sp, #36]	; 0x24
   12d42:	str.w	r0, [r9, #64]	; 0x40
   12d46:	bhi.w	12914 <_dtoa_r+0x214>
   12d4a:	cmp	r6, #0
   12d4c:	beq.w	12914 <_dtoa_r+0x214>
   12d50:	ldr	r1, [sp, #16]
   12d52:	cmp	r1, #0
   12d54:	strd	sl, fp, [sp, #64]	; 0x40
   12d58:	ble.w	13290 <_dtoa_r+0xb90>
   12d5c:	ldr	r3, [pc, #576]	; (12fa0 <_dtoa_r+0x8a0>)
   12d5e:	and.w	r2, r1, #15
   12d62:	asrs	r6, r1, #4
   12d64:	add.w	r3, r3, r2, lsl #3
   12d68:	lsls	r0, r6, #27
   12d6a:	ldrd	r4, r5, [r3]
   12d6e:	bpl.w	131fe <_dtoa_r+0xafe>
   12d72:	ldr	r3, [pc, #560]	; (12fa4 <_dtoa_r+0x8a4>)
   12d74:	mov	r0, sl
   12d76:	mov	r1, fp
   12d78:	ldrd	r2, r3, [r3, #32]
   12d7c:	bl	f6b0 <__aeabi_ddiv>
   12d80:	strd	r0, r1, [sp, #72]	; 0x48
   12d84:	and.w	r6, r6, #15
   12d88:	mov.w	sl, #3
   12d8c:	cbz	r6, 12db0 <_dtoa_r+0x6b0>
   12d8e:	ldr	r7, [pc, #532]	; (12fa4 <_dtoa_r+0x8a4>)
   12d90:	lsls	r1, r6, #31
   12d92:	bpl.n	12da8 <_dtoa_r+0x6a8>
   12d94:	mov	r0, r4
   12d96:	mov	r1, r5
   12d98:	ldrd	r2, r3, [r7]
   12d9c:	bl	f45c <__aeabi_dmul>
   12da0:	add.w	sl, sl, #1
   12da4:	mov	r4, r0
   12da6:	mov	r5, r1
   12da8:	asrs	r6, r6, #1
   12daa:	add.w	r7, r7, #8
   12dae:	bne.n	12d90 <_dtoa_r+0x690>
   12db0:	mov	r2, r4
   12db2:	mov	r3, r5
   12db4:	ldrd	r0, r1, [sp, #72]	; 0x48
   12db8:	bl	f6b0 <__aeabi_ddiv>
   12dbc:	mov	r6, r0
   12dbe:	mov	r7, r1
   12dc0:	ldr	r3, [sp, #52]	; 0x34
   12dc2:	cbz	r3, 12dd6 <_dtoa_r+0x6d6>
   12dc4:	movs	r2, #0
   12dc6:	ldr	r3, [pc, #480]	; (12fa8 <_dtoa_r+0x8a8>)
   12dc8:	mov	r0, r6
   12dca:	mov	r1, r7
   12dcc:	bl	f940 <__aeabi_dcmplt>
   12dd0:	cmp	r0, #0
   12dd2:	bne.w	1340a <_dtoa_r+0xd0a>
   12dd6:	mov	r0, sl
   12dd8:	bl	f390 <__aeabi_i2d>
   12ddc:	mov	r2, r6
   12dde:	mov	r3, r7
   12de0:	bl	f45c <__aeabi_dmul>
   12de4:	ldr	r3, [pc, #452]	; (12fac <_dtoa_r+0x8ac>)
   12de6:	movs	r2, #0
   12de8:	bl	f0f8 <__adddf3>
   12dec:	ldr	r3, [sp, #32]
   12dee:	mov	r4, r0
   12df0:	sub.w	r5, r1, #54525952	; 0x3400000
   12df4:	cmp	r3, #0
   12df6:	beq.w	131b0 <_dtoa_r+0xab0>
   12dfa:	ldr	r3, [sp, #16]
   12dfc:	str	r3, [sp, #88]	; 0x58
   12dfe:	ldr	r3, [sp, #32]
   12e00:	str	r3, [sp, #72]	; 0x48
   12e02:	ldr	r3, [sp, #44]	; 0x2c
   12e04:	cmp	r3, #0
   12e06:	beq.w	13332 <_dtoa_r+0xc32>
   12e0a:	ldr	r2, [sp, #72]	; 0x48
   12e0c:	ldr	r3, [pc, #400]	; (12fa0 <_dtoa_r+0x8a0>)
   12e0e:	ldr	r1, [pc, #416]	; (12fb0 <_dtoa_r+0x8b0>)
   12e10:	add.w	r3, r3, r2, lsl #3
   12e14:	ldrd	r2, r3, [r3, #-8]
   12e18:	movs	r0, #0
   12e1a:	bl	f6b0 <__aeabi_ddiv>
   12e1e:	mov	r2, r4
   12e20:	mov	r3, r5
   12e22:	bl	f0f4 <__aeabi_dsub>
   12e26:	mov	sl, r0
   12e28:	mov	fp, r1
   12e2a:	mov	r0, r6
   12e2c:	mov	r1, r7
   12e2e:	bl	f9bc <__aeabi_d2iz>
   12e32:	mov	r4, r0
   12e34:	bl	f390 <__aeabi_i2d>
   12e38:	mov	r2, r0
   12e3a:	mov	r3, r1
   12e3c:	mov	r0, r6
   12e3e:	mov	r1, r7
   12e40:	bl	f0f4 <__aeabi_dsub>
   12e44:	adds	r4, #48	; 0x30
   12e46:	ldr	r5, [sp, #36]	; 0x24
   12e48:	uxtb	r4, r4
   12e4a:	mov	r6, r0
   12e4c:	mov	r7, r1
   12e4e:	strb	r4, [r5, #0]
   12e50:	mov	r2, r0
   12e52:	mov	r3, r1
   12e54:	mov	r0, sl
   12e56:	mov	r1, fp
   12e58:	adds	r5, #1
   12e5a:	bl	f97c <__aeabi_dcmpgt>
   12e5e:	cmp	r0, #0
   12e60:	bne.n	12f04 <_dtoa_r+0x804>
   12e62:	mov	r2, r6
   12e64:	mov	r3, r7
   12e66:	movs	r0, #0
   12e68:	ldr	r1, [pc, #316]	; (12fa8 <_dtoa_r+0x8a8>)
   12e6a:	bl	f0f4 <__aeabi_dsub>
   12e6e:	mov	r2, r0
   12e70:	mov	r3, r1
   12e72:	mov	r0, sl
   12e74:	mov	r1, fp
   12e76:	bl	f97c <__aeabi_dcmpgt>
   12e7a:	cmp	r0, #0
   12e7c:	bne.w	13490 <_dtoa_r+0xd90>
   12e80:	ldr	r2, [sp, #72]	; 0x48
   12e82:	cmp	r2, #1
   12e84:	ble.w	13276 <_dtoa_r+0xb76>
   12e88:	ldr	r3, [sp, #72]	; 0x48
   12e8a:	ldr	r2, [sp, #36]	; 0x24
   12e8c:	str.w	r8, [sp, #72]	; 0x48
   12e90:	add	r3, r2
   12e92:	mov	r8, r3
   12e94:	b.n	12eb2 <_dtoa_r+0x7b2>
   12e96:	movs	r0, #0
   12e98:	ldr	r1, [pc, #268]	; (12fa8 <_dtoa_r+0x8a8>)
   12e9a:	bl	f0f4 <__aeabi_dsub>
   12e9e:	mov	r2, sl
   12ea0:	mov	r3, fp
   12ea2:	bl	f940 <__aeabi_dcmplt>
   12ea6:	cmp	r0, #0
   12ea8:	bne.w	13490 <_dtoa_r+0xd90>
   12eac:	cmp	r5, r8
   12eae:	beq.w	13272 <_dtoa_r+0xb72>
   12eb2:	mov	r0, sl
   12eb4:	mov	r1, fp
   12eb6:	movs	r2, #0
   12eb8:	ldr	r3, [pc, #248]	; (12fb4 <_dtoa_r+0x8b4>)
   12eba:	bl	f45c <__aeabi_dmul>
   12ebe:	movs	r2, #0
   12ec0:	ldr	r3, [pc, #240]	; (12fb4 <_dtoa_r+0x8b4>)
   12ec2:	mov	sl, r0
   12ec4:	mov	fp, r1
   12ec6:	mov	r0, r6
   12ec8:	mov	r1, r7
   12eca:	bl	f45c <__aeabi_dmul>
   12ece:	mov	r7, r1
   12ed0:	mov	r6, r0
   12ed2:	bl	f9bc <__aeabi_d2iz>
   12ed6:	mov	r4, r0
   12ed8:	bl	f390 <__aeabi_i2d>
   12edc:	mov	r2, r0
   12ede:	mov	r3, r1
   12ee0:	mov	r0, r6
   12ee2:	mov	r1, r7
   12ee4:	bl	f0f4 <__aeabi_dsub>
   12ee8:	adds	r4, #48	; 0x30
   12eea:	uxtb	r4, r4
   12eec:	mov	r2, sl
   12eee:	mov	r3, fp
   12ef0:	strb.w	r4, [r5], #1
   12ef4:	mov	r6, r0
   12ef6:	mov	r7, r1
   12ef8:	bl	f940 <__aeabi_dcmplt>
   12efc:	mov	r2, r6
   12efe:	mov	r3, r7
   12f00:	cmp	r0, #0
   12f02:	beq.n	12e96 <_dtoa_r+0x796>
   12f04:	ldr	r3, [sp, #88]	; 0x58
   12f06:	str	r3, [sp, #16]
   12f08:	b.n	12a96 <_dtoa_r+0x396>
   12f0a:	movs	r3, #0
   12f0c:	str	r3, [sp, #44]	; 0x2c
   12f0e:	ldr	r3, [sp, #20]
   12f10:	cmp	r3, #0
   12f12:	ble.w	13216 <_dtoa_r+0xb16>
   12f16:	mov	r5, r3
   12f18:	mov	r4, r3
   12f1a:	str	r3, [sp, #56]	; 0x38
   12f1c:	str	r3, [sp, #32]
   12f1e:	b.n	12d16 <_dtoa_r+0x616>
   12f20:	movs	r3, #1
   12f22:	str	r3, [sp, #44]	; 0x2c
   12f24:	b.n	12f0e <_dtoa_r+0x80e>
   12f26:	str	r4, [sp, #40]	; 0x28
   12f28:	ldr	r2, [sp, #24]
   12f2a:	ldr	r1, [sp, #40]	; 0x28
   12f2c:	mov	r0, r9
   12f2e:	bl	13ba4 <__pow5mult>
   12f32:	mov	r4, r0
   12f34:	b.n	12b54 <_dtoa_r+0x454>
   12f36:	ldr	r3, [sp, #32]
   12f38:	cmp	r3, #0
   12f3a:	bgt.w	1293a <_dtoa_r+0x23a>
   12f3e:	bne.w	131e0 <_dtoa_r+0xae0>
   12f42:	movs	r2, #0
   12f44:	ldr	r3, [pc, #112]	; (12fb8 <_dtoa_r+0x8b8>)
   12f46:	ldrd	r0, r1, [sp]
   12f4a:	bl	f45c <__aeabi_dmul>
   12f4e:	mov	r3, fp
   12f50:	mov	r2, sl
   12f52:	bl	f968 <__aeabi_dcmpge>
   12f56:	ldr	r3, [sp, #32]
   12f58:	str	r3, [sp, #24]
   12f5a:	mov	r6, r3
   12f5c:	cmp	r0, #0
   12f5e:	beq.w	13136 <_dtoa_r+0xa36>
   12f62:	ldr	r3, [sp, #20]
   12f64:	ldr	r5, [sp, #36]	; 0x24
   12f66:	mvns	r3, r3
   12f68:	str	r3, [sp, #16]
   12f6a:	ldr	r1, [sp, #24]
   12f6c:	mov	r0, r9
   12f6e:	bl	13930 <_Bfree>
   12f72:	cmp	r6, #0
   12f74:	beq.w	12a96 <_dtoa_r+0x396>
   12f78:	b.n	12c8e <_dtoa_r+0x58e>
   12f7a:	ldr	r2, [sp, #60]	; 0x3c
   12f7c:	cmp	r2, #0
   12f7e:	beq.w	133f2 <_dtoa_r+0xcf2>
   12f82:	addw	r3, r3, #1075	; 0x433
   12f86:	ldr	r7, [sp, #24]
   12f88:	ldr	r5, [sp, #28]
   12f8a:	b.n	12ae6 <_dtoa_r+0x3e6>
   12f8c:	movs	r0, #28
   12f8e:	b.n	12ba6 <_dtoa_r+0x4a6>
   12f90:	ldr	r3, [sp, #0]
   12f92:	cmp	r3, #1
   12f94:	ble.w	13498 <_dtoa_r+0xd98>
   12f98:	ldr	r7, [sp, #48]	; 0x30
   12f9a:	movs	r0, #1
   12f9c:	b.n	12b8e <_dtoa_r+0x48e>
   12f9e:	nop
   12fa0:	.word	0x00014b50
   12fa4:	.word	0x00014c18
   12fa8:	.word	0x3ff00000
   12fac:	.word	0x401c0000
   12fb0:	.word	0x3fe00000
   12fb4:	.word	0x40240000
   12fb8:	.word	0x40140000
   12fbc:	mov	r1, r6
   12fbe:	movs	r3, #0
   12fc0:	movs	r2, #10
   12fc2:	mov	r0, r9
   12fc4:	bl	13944 <__multadd>
   12fc8:	ldr	r3, [sp, #56]	; 0x38
   12fca:	cmp	r3, #0
   12fcc:	mov	r6, r0
   12fce:	ble.w	134ec <_dtoa_r+0xdec>
   12fd2:	str	r3, [sp, #32]
   12fd4:	cmp	r5, #0
   12fd6:	ble.n	12fe4 <_dtoa_r+0x8e4>
   12fd8:	mov	r1, r6
   12fda:	mov	r2, r5
   12fdc:	mov	r0, r9
   12fde:	bl	13c44 <__lshift>
   12fe2:	mov	r6, r0
   12fe4:	cmp	r7, #0
   12fe6:	bne.w	132e2 <_dtoa_r+0xbe2>
   12fea:	mov	r8, r6
   12fec:	ldr	r3, [sp, #32]
   12fee:	ldr	r2, [sp, #36]	; 0x24
   12ff0:	subs	r3, #1
   12ff2:	adds	r3, r2, r3
   12ff4:	str	r3, [sp, #32]
   12ff6:	and.w	r3, sl, #1
   12ffa:	str	r3, [sp, #40]	; 0x28
   12ffc:	mov	r7, r2
   12ffe:	ldr.w	fp, [sp, #24]
   13002:	mov	r0, r4
   13004:	mov	r1, fp
   13006:	bl	125d4 <quorem>
   1300a:	mov	r1, r6
   1300c:	mov	r5, r0
   1300e:	mov	r0, r4
   13010:	bl	13cf4 <__mcmp>
   13014:	mov	r2, r8
   13016:	mov	r1, fp
   13018:	mov	sl, r0
   1301a:	mov	r0, r9
   1301c:	bl	13d38 <__mdiff>
   13020:	ldr	r2, [r0, #12]
   13022:	mov	fp, r0
   13024:	add.w	r3, r5, #48	; 0x30
   13028:	cmp	r2, #0
   1302a:	bne.n	130c0 <_dtoa_r+0x9c0>
   1302c:	mov	r1, r0
   1302e:	mov	r0, r4
   13030:	str	r3, [sp, #28]
   13032:	bl	13cf4 <__mcmp>
   13036:	mov	r1, fp
   13038:	str	r0, [sp, #20]
   1303a:	mov	r0, r9
   1303c:	bl	13930 <_Bfree>
   13040:	ldr	r2, [sp, #20]
   13042:	ldr	r3, [sp, #28]
   13044:	cbnz	r2, 13052 <_dtoa_r+0x952>
   13046:	ldr	r1, [sp, #0]
   13048:	cbnz	r1, 13052 <_dtoa_r+0x952>
   1304a:	ldr	r1, [sp, #40]	; 0x28
   1304c:	cmp	r1, #0
   1304e:	beq.w	134bc <_dtoa_r+0xdbc>
   13052:	cmp.w	sl, #0
   13056:	blt.w	13220 <_dtoa_r+0xb20>
   1305a:	bne.n	13068 <_dtoa_r+0x968>
   1305c:	ldr	r1, [sp, #0]
   1305e:	cbnz	r1, 13068 <_dtoa_r+0x968>
   13060:	ldr	r1, [sp, #40]	; 0x28
   13062:	cmp	r1, #0
   13064:	beq.w	13220 <_dtoa_r+0xb20>
   13068:	cmp	r2, #0
   1306a:	bgt.w	1330a <_dtoa_r+0xc0a>
   1306e:	ldr	r2, [sp, #32]
   13070:	strb	r3, [r7, #0]
   13072:	add.w	sl, r7, #1
   13076:	cmp	r7, r2
   13078:	mov	r5, sl
   1307a:	beq.w	13322 <_dtoa_r+0xc22>
   1307e:	mov	r1, r4
   13080:	movs	r3, #0
   13082:	movs	r2, #10
   13084:	mov	r0, r9
   13086:	bl	13944 <__multadd>
   1308a:	cmp	r6, r8
   1308c:	mov	r4, r0
   1308e:	mov	r1, r6
   13090:	mov.w	r3, #0
   13094:	mov.w	r2, #10
   13098:	mov	r0, r9
   1309a:	beq.n	130b4 <_dtoa_r+0x9b4>
   1309c:	bl	13944 <__multadd>
   130a0:	mov	r1, r8
   130a2:	mov	r6, r0
   130a4:	movs	r3, #0
   130a6:	movs	r2, #10
   130a8:	mov	r0, r9
   130aa:	bl	13944 <__multadd>
   130ae:	mov	r7, sl
   130b0:	mov	r8, r0
   130b2:	b.n	12ffe <_dtoa_r+0x8fe>
   130b4:	bl	13944 <__multadd>
   130b8:	mov	r7, sl
   130ba:	mov	r6, r0
   130bc:	mov	r8, r0
   130be:	b.n	12ffe <_dtoa_r+0x8fe>
   130c0:	mov	r1, r0
   130c2:	mov	r0, r9
   130c4:	str	r3, [sp, #20]
   130c6:	bl	13930 <_Bfree>
   130ca:	movs	r2, #1
   130cc:	ldr	r3, [sp, #20]
   130ce:	b.n	13052 <_dtoa_r+0x952>
   130d0:	ldr	r1, [sp, #24]
   130d2:	mov	r0, r4
   130d4:	bl	13cf4 <__mcmp>
   130d8:	cmp	r0, #0
   130da:	bge.w	12bdc <_dtoa_r+0x4dc>
   130de:	mov	r1, r4
   130e0:	ldr	r4, [sp, #16]
   130e2:	movs	r3, #0
   130e4:	subs	r4, #1
   130e6:	movs	r2, #10
   130e8:	mov	r0, r9
   130ea:	str	r4, [sp, #16]
   130ec:	bl	13944 <__multadd>
   130f0:	ldr	r3, [sp, #44]	; 0x2c
   130f2:	mov	r4, r0
   130f4:	cmp	r3, #0
   130f6:	bne.w	12fbc <_dtoa_r+0x8bc>
   130fa:	ldr	r3, [sp, #56]	; 0x38
   130fc:	cmp	r3, #0
   130fe:	ble.w	134dc <_dtoa_r+0xddc>
   13102:	str	r3, [sp, #32]
   13104:	b.n	12bec <_dtoa_r+0x4ec>
   13106:	ldr	r4, [sp, #40]	; 0x28
   13108:	b.n	12b54 <_dtoa_r+0x454>
   1310a:	ldr	r3, [sp, #0]
   1310c:	cmp	r3, #2
   1310e:	ble.w	12be4 <_dtoa_r+0x4e4>
   13112:	ldr	r3, [sp, #32]
   13114:	cmp	r3, #0
   13116:	bne.w	13454 <_dtoa_r+0xd54>
   1311a:	ldr	r1, [sp, #24]
   1311c:	movs	r2, #5
   1311e:	mov	r0, r9
   13120:	bl	13944 <__multadd>
   13124:	mov	r1, r0
   13126:	str	r0, [sp, #24]
   13128:	mov	r0, r4
   1312a:	bl	13cf4 <__mcmp>
   1312e:	cmp	r0, #0
   13130:	str	r4, [sp, #40]	; 0x28
   13132:	ble.w	12f62 <_dtoa_r+0x862>
   13136:	ldr	r2, [sp, #16]
   13138:	ldr	r1, [sp, #36]	; 0x24
   1313a:	movs	r3, #49	; 0x31
   1313c:	adds	r2, #1
   1313e:	str	r2, [sp, #16]
   13140:	strb	r3, [r1, #0]
   13142:	adds	r5, r1, #1
   13144:	b.n	12f6a <_dtoa_r+0x86a>
   13146:	ldr	r2, [sp, #16]
   13148:	adds	r2, #1
   1314a:	str	r2, [sp, #16]
   1314c:	ldr	r2, [sp, #36]	; 0x24
   1314e:	movs	r3, #49	; 0x31
   13150:	strb	r3, [r2, #0]
   13152:	b.n	12c6e <_dtoa_r+0x56e>
   13154:	movs	r3, #1
   13156:	str	r3, [sp, #44]	; 0x2c
   13158:	b.n	12d00 <_dtoa_r+0x600>
   1315a:	ldr.w	r9, [sp, #20]
   1315e:	b.n	12a96 <_dtoa_r+0x396>
   13160:	cmp.w	sl, #0
   13164:	bne.w	12b7a <_dtoa_r+0x47a>
   13168:	ubfx	r3, fp, #0, #20
   1316c:	cmp	r3, #0
   1316e:	bne.w	133ee <_dtoa_r+0xcee>
   13172:	bic.w	r7, fp, #2147483648	; 0x80000000
   13176:	lsrs	r7, r7, #20
   13178:	lsls	r7, r7, #20
   1317a:	cbz	r7, 13188 <_dtoa_r+0xa88>
   1317c:	ldr	r3, [sp, #28]
   1317e:	adds	r3, #1
   13180:	str	r3, [sp, #28]
   13182:	add.w	r8, r8, #1
   13186:	movs	r7, #1
   13188:	ldr	r3, [sp, #48]	; 0x30
   1318a:	movs	r0, #1
   1318c:	cmp	r3, #0
   1318e:	beq.w	12b8e <_dtoa_r+0x48e>
   13192:	b.n	12b7c <_dtoa_r+0x47c>
   13194:	mov	r0, sl
   13196:	bl	f390 <__aeabi_i2d>
   1319a:	mov	r2, r6
   1319c:	mov	r3, r7
   1319e:	bl	f45c <__aeabi_dmul>
   131a2:	movs	r2, #0
   131a4:	ldr	r3, [pc, #764]	; (134a4 <_dtoa_r+0xda4>)
   131a6:	bl	f0f8 <__adddf3>
   131aa:	mov	r4, r0
   131ac:	sub.w	r5, r1, #54525952	; 0x3400000
   131b0:	mov	r0, r6
   131b2:	mov	r1, r7
   131b4:	movs	r2, #0
   131b6:	ldr	r3, [pc, #752]	; (134a8 <_dtoa_r+0xda8>)
   131b8:	bl	f0f4 <__aeabi_dsub>
   131bc:	mov	r2, r4
   131be:	mov	r3, r5
   131c0:	mov	r6, r0
   131c2:	mov	r7, r1
   131c4:	bl	f97c <__aeabi_dcmpgt>
   131c8:	cmp	r0, #0
   131ca:	bne.w	1332a <_dtoa_r+0xc2a>
   131ce:	mov	r2, r4
   131d0:	add.w	r3, r5, #2147483648	; 0x80000000
   131d4:	mov	r0, r6
   131d6:	mov	r1, r7
   131d8:	bl	f940 <__aeabi_dcmplt>
   131dc:	cmp	r0, #0
   131de:	beq.n	13276 <_dtoa_r+0xb76>
   131e0:	movs	r3, #0
   131e2:	str	r3, [sp, #24]
   131e4:	mov	r6, r3
   131e6:	b.n	12f62 <_dtoa_r+0x862>
   131e8:	ldr	r0, [sp, #36]	; 0x24
   131ea:	b.w	12772 <_dtoa_r+0x72>
   131ee:	ldr	r3, [sp, #24]
   131f0:	ldr	r2, [sp, #48]	; 0x30
   131f2:	str	r7, [sp, #24]
   131f4:	subs	r3, r7, r3
   131f6:	add	r2, r3
   131f8:	str	r2, [sp, #48]	; 0x30
   131fa:	movs	r7, #0
   131fc:	b.n	12ada <_dtoa_r+0x3da>
   131fe:	vldr	d7, [sp, #64]	; 0x40
   13202:	mov.w	sl, #2
   13206:	vstr	d7, [sp, #72]	; 0x48
   1320a:	b.n	12d8c <_dtoa_r+0x68c>
   1320c:	mov	r4, r3
   1320e:	movs	r1, #0
   13210:	str.w	r1, [r9, #68]	; 0x44
   13214:	b.n	12d38 <_dtoa_r+0x638>
   13216:	movs	r4, #1
   13218:	str	r4, [sp, #56]	; 0x38
   1321a:	str	r4, [sp, #32]
   1321c:	str	r4, [sp, #20]
   1321e:	b.n	1320e <_dtoa_r+0xb0e>
   13220:	cmp	r2, #0
   13222:	mov	sl, r3
   13224:	ble.n	1324a <_dtoa_r+0xb4a>
   13226:	mov	r1, r4
   13228:	movs	r2, #1
   1322a:	mov	r0, r9
   1322c:	bl	13c44 <__lshift>
   13230:	ldr	r1, [sp, #24]
   13232:	mov	r4, r0
   13234:	bl	13cf4 <__mcmp>
   13238:	cmp	r0, #0
   1323a:	ble.w	134ce <_dtoa_r+0xdce>
   1323e:	cmp.w	sl, #57	; 0x39
   13242:	beq.w	13458 <_dtoa_r+0xd58>
   13246:	add.w	sl, r5, #49	; 0x31
   1324a:	mov	fp, r6
   1324c:	strb.w	sl, [r7]
   13250:	adds	r5, r7, #1
   13252:	mov	r6, r8
   13254:	str	r4, [sp, #40]	; 0x28
   13256:	b.n	12c6e <_dtoa_r+0x56e>
   13258:	bne.n	13264 <_dtoa_r+0xb64>
   1325a:	tst.w	sl, #1
   1325e:	beq.n	13264 <_dtoa_r+0xb64>
   13260:	b.n	12c4e <_dtoa_r+0x54e>
   13262:	mov	r5, r2
   13264:	ldrb.w	r3, [r5, #-1]
   13268:	cmp	r3, #48	; 0x30
   1326a:	add.w	r2, r5, #4294967295
   1326e:	beq.n	13262 <_dtoa_r+0xb62>
   13270:	b.n	12c6e <_dtoa_r+0x56e>
   13272:	ldr.w	r8, [sp, #72]	; 0x48
   13276:	ldrd	sl, fp, [sp, #64]	; 0x40
   1327a:	b.w	12914 <_dtoa_r+0x214>
   1327e:	ldr	r1, [sp, #36]	; 0x24
   13280:	movs	r2, #48	; 0x30
   13282:	strb	r2, [r1, #0]
   13284:	ldr	r2, [sp, #16]
   13286:	ldrb.w	r4, [r5, #-1]
   1328a:	adds	r2, #1
   1328c:	str	r2, [sp, #16]
   1328e:	b.n	12a92 <_dtoa_r+0x392>
   13290:	ldr	r3, [sp, #16]
   13292:	negs	r4, r3
   13294:	cmp	r4, #0
   13296:	beq.w	13400 <_dtoa_r+0xd00>
   1329a:	ldr	r3, [pc, #528]	; (134ac <_dtoa_r+0xdac>)
   1329c:	and.w	r2, r4, #15
   132a0:	add.w	r3, r3, r2, lsl #3
   132a4:	ldrd	r2, r3, [r3]
   132a8:	ldrd	r0, r1, [sp, #64]	; 0x40
   132ac:	bl	f45c <__aeabi_dmul>
   132b0:	asrs	r4, r4, #4
   132b2:	mov	r6, r0
   132b4:	mov	r7, r1
   132b6:	beq.w	134e6 <_dtoa_r+0xde6>
   132ba:	ldr	r5, [pc, #500]	; (134b0 <_dtoa_r+0xdb0>)
   132bc:	mov.w	sl, #2
   132c0:	lsls	r2, r4, #31
   132c2:	bpl.n	132d8 <_dtoa_r+0xbd8>
   132c4:	mov	r0, r6
   132c6:	mov	r1, r7
   132c8:	ldrd	r2, r3, [r5]
   132cc:	bl	f45c <__aeabi_dmul>
   132d0:	add.w	sl, sl, #1
   132d4:	mov	r6, r0
   132d6:	mov	r7, r1
   132d8:	asrs	r4, r4, #1
   132da:	add.w	r5, r5, #8
   132de:	bne.n	132c0 <_dtoa_r+0xbc0>
   132e0:	b.n	12dc0 <_dtoa_r+0x6c0>
   132e2:	ldr	r1, [r6, #4]
   132e4:	mov	r0, r9
   132e6:	bl	138e4 <_Balloc>
   132ea:	ldr	r3, [r6, #16]
   132ec:	adds	r2, r3, #2
   132ee:	mov	r5, r0
   132f0:	lsls	r2, r2, #2
   132f2:	add.w	r1, r6, #12
   132f6:	adds	r0, #12
   132f8:	bl	d444 <memcpy>
   132fc:	mov	r1, r5
   132fe:	movs	r2, #1
   13300:	mov	r0, r9
   13302:	bl	13c44 <__lshift>
   13306:	mov	r8, r0
   13308:	b.n	12fec <_dtoa_r+0x8ec>
   1330a:	cmp	r3, #57	; 0x39
   1330c:	beq.w	13458 <_dtoa_r+0xd58>
   13310:	add.w	sl, r3, #1
   13314:	mov	fp, r6
   13316:	strb.w	sl, [r7]
   1331a:	adds	r5, r7, #1
   1331c:	mov	r6, r8
   1331e:	str	r4, [sp, #40]	; 0x28
   13320:	b.n	12c6e <_dtoa_r+0x56e>
   13322:	mov	fp, r6
   13324:	mov	sl, r3
   13326:	mov	r6, r8
   13328:	b.n	12c36 <_dtoa_r+0x536>
   1332a:	movs	r3, #0
   1332c:	str	r3, [sp, #24]
   1332e:	mov	r6, r3
   13330:	b.n	13136 <_dtoa_r+0xa36>
   13332:	ldr	r3, [sp, #72]	; 0x48
   13334:	ldr	r1, [pc, #372]	; (134ac <_dtoa_r+0xdac>)
   13336:	subs	r2, r3, #1
   13338:	add.w	r1, r1, r2, lsl #3
   1333c:	mov	r3, r5
   1333e:	str	r2, [sp, #92]	; 0x5c
   13340:	ldrd	r0, r1, [r1]
   13344:	mov	r2, r4
   13346:	bl	f45c <__aeabi_dmul>
   1334a:	strd	r0, r1, [sp, #80]	; 0x50
   1334e:	mov	r1, r7
   13350:	mov	r0, r6
   13352:	bl	f9bc <__aeabi_d2iz>
   13356:	mov	r4, r0
   13358:	bl	f390 <__aeabi_i2d>
   1335c:	mov	r3, r1
   1335e:	mov	r2, r0
   13360:	mov	r1, r7
   13362:	mov	r0, r6
   13364:	bl	f0f4 <__aeabi_dsub>
   13368:	ldr	r3, [sp, #72]	; 0x48
   1336a:	mov	r7, r1
   1336c:	ldr	r1, [sp, #36]	; 0x24
   1336e:	adds	r4, #48	; 0x30
   13370:	cmp	r3, #1
   13372:	mov	r6, r0
   13374:	strb	r4, [r1, #0]
   13376:	add.w	r5, r1, #1
   1337a:	beq.n	133be <_dtoa_r+0xcbe>
   1337c:	ldr	r3, [sp, #72]	; 0x48
   1337e:	ldr	r2, [sp, #36]	; 0x24
   13380:	add	r3, r2
   13382:	mov	sl, r3
   13384:	mov	fp, r5
   13386:	movs	r2, #0
   13388:	ldr	r3, [pc, #296]	; (134b4 <_dtoa_r+0xdb4>)
   1338a:	mov	r0, r6
   1338c:	mov	r1, r7
   1338e:	bl	f45c <__aeabi_dmul>
   13392:	mov	r7, r1
   13394:	mov	r6, r0
   13396:	bl	f9bc <__aeabi_d2iz>
   1339a:	mov	r4, r0
   1339c:	bl	f390 <__aeabi_i2d>
   133a0:	adds	r4, #48	; 0x30
   133a2:	mov	r2, r0
   133a4:	mov	r3, r1
   133a6:	mov	r0, r6
   133a8:	mov	r1, r7
   133aa:	bl	f0f4 <__aeabi_dsub>
   133ae:	strb.w	r4, [fp], #1
   133b2:	cmp	sl, fp
   133b4:	mov	r6, r0
   133b6:	mov	r7, r1
   133b8:	bne.n	13386 <_dtoa_r+0xc86>
   133ba:	ldr	r3, [sp, #92]	; 0x5c
   133bc:	add	r5, r3
   133be:	movs	r2, #0
   133c0:	ldr	r3, [pc, #244]	; (134b8 <_dtoa_r+0xdb8>)
   133c2:	ldrd	r0, r1, [sp, #80]	; 0x50
   133c6:	bl	f0f8 <__adddf3>
   133ca:	mov	r2, r6
   133cc:	mov	r3, r7
   133ce:	bl	f940 <__aeabi_dcmplt>
   133d2:	cmp	r0, #0
   133d4:	beq.n	13468 <_dtoa_r+0xd68>
   133d6:	ldr	r3, [sp, #88]	; 0x58
   133d8:	str	r3, [sp, #16]
   133da:	ldrb.w	r4, [r5, #-1]
   133de:	b.w	12a7a <_dtoa_r+0x37a>
   133e2:	ldr	r3, [sp, #28]
   133e4:	ldr	r2, [sp, #32]
   133e6:	subs	r5, r3, r2
   133e8:	movs	r3, #0
   133ea:	b.w	12ae6 <_dtoa_r+0x3e6>
   133ee:	movs	r7, #0
   133f0:	b.n	13188 <_dtoa_r+0xa88>
   133f2:	ldr	r3, [sp, #96]	; 0x60
   133f4:	ldr	r7, [sp, #24]
   133f6:	ldr	r5, [sp, #28]
   133f8:	rsb	r3, r3, #54	; 0x36
   133fc:	b.w	12ae6 <_dtoa_r+0x3e6>
   13400:	ldrd	r6, r7, [sp, #64]	; 0x40
   13404:	mov.w	sl, #2
   13408:	b.n	12dc0 <_dtoa_r+0x6c0>
   1340a:	ldr	r3, [sp, #32]
   1340c:	cmp	r3, #0
   1340e:	beq.w	13194 <_dtoa_r+0xa94>
   13412:	ldr	r3, [sp, #56]	; 0x38
   13414:	cmp	r3, #0
   13416:	ble.w	13276 <_dtoa_r+0xb76>
   1341a:	movs	r2, #0
   1341c:	ldr	r3, [pc, #148]	; (134b4 <_dtoa_r+0xdb4>)
   1341e:	mov	r0, r6
   13420:	mov	r1, r7
   13422:	bl	f45c <__aeabi_dmul>
   13426:	mov	r6, r0
   13428:	mov	r7, r1
   1342a:	add.w	r0, sl, #1
   1342e:	bl	f390 <__aeabi_i2d>
   13432:	mov	r2, r6
   13434:	mov	r3, r7
   13436:	bl	f45c <__aeabi_dmul>
   1343a:	movs	r2, #0
   1343c:	ldr	r3, [pc, #100]	; (134a4 <_dtoa_r+0xda4>)
   1343e:	bl	f0f8 <__adddf3>
   13442:	ldr	r2, [sp, #16]
   13444:	ldr	r3, [sp, #56]	; 0x38
   13446:	str	r3, [sp, #72]	; 0x48
   13448:	subs	r2, #1
   1344a:	mov	r4, r0
   1344c:	sub.w	r5, r1, #54525952	; 0x3400000
   13450:	str	r2, [sp, #88]	; 0x58
   13452:	b.n	12e02 <_dtoa_r+0x702>
   13454:	str	r4, [sp, #40]	; 0x28
   13456:	b.n	12f62 <_dtoa_r+0x862>
   13458:	movs	r2, #57	; 0x39
   1345a:	mov	fp, r6
   1345c:	str	r4, [sp, #40]	; 0x28
   1345e:	mov	r6, r8
   13460:	strb	r2, [r7, #0]
   13462:	adds	r5, r7, #1
   13464:	b.w	12c52 <_dtoa_r+0x552>
   13468:	ldrd	r2, r3, [sp, #80]	; 0x50
   1346c:	movs	r0, #0
   1346e:	ldr	r1, [pc, #72]	; (134b8 <_dtoa_r+0xdb8>)
   13470:	bl	f0f4 <__aeabi_dsub>
   13474:	mov	r2, r6
   13476:	mov	r3, r7
   13478:	bl	f97c <__aeabi_dcmpgt>
   1347c:	cbnz	r0, 13482 <_dtoa_r+0xd82>
   1347e:	b.n	13276 <_dtoa_r+0xb76>
   13480:	mov	r5, r2
   13482:	ldrb.w	r3, [r5, #-1]
   13486:	cmp	r3, #48	; 0x30
   13488:	add.w	r2, r5, #4294967295
   1348c:	beq.n	13480 <_dtoa_r+0xd80>
   1348e:	b.n	12f04 <_dtoa_r+0x804>
   13490:	ldr	r3, [sp, #88]	; 0x58
   13492:	str	r3, [sp, #16]
   13494:	b.w	12a7a <_dtoa_r+0x37a>
   13498:	cmp.w	sl, #0
   1349c:	bne.w	12f98 <_dtoa_r+0x898>
   134a0:	b.n	13168 <_dtoa_r+0xa68>
   134a2:	nop
   134a4:	.word	0x401c0000
   134a8:	.word	0x40140000
   134ac:	.word	0x00014b50
   134b0:	.word	0x00014c18
   134b4:	.word	0x40240000
   134b8:	.word	0x3fe00000
   134bc:	cmp	r3, #57	; 0x39
   134be:	mov	fp, sl
   134c0:	mov	sl, r3
   134c2:	beq.n	13458 <_dtoa_r+0xd58>
   134c4:	cmp.w	fp, #0
   134c8:	bgt.w	13246 <_dtoa_r+0xb46>
   134cc:	b.n	1324a <_dtoa_r+0xb4a>
   134ce:	bne.w	1324a <_dtoa_r+0xb4a>
   134d2:	tst.w	sl, #1
   134d6:	beq.w	1324a <_dtoa_r+0xb4a>
   134da:	b.n	1323e <_dtoa_r+0xb3e>
   134dc:	ldr	r3, [sp, #0]
   134de:	cmp	r3, #2
   134e0:	bgt.n	1352e <_dtoa_r+0xe2e>
   134e2:	ldr	r3, [sp, #56]	; 0x38
   134e4:	b.n	13102 <_dtoa_r+0xa02>
   134e6:	mov.w	sl, #2
   134ea:	b.n	12dc0 <_dtoa_r+0x6c0>
   134ec:	ldr	r3, [sp, #0]
   134ee:	cmp	r3, #2
   134f0:	bgt.n	1352e <_dtoa_r+0xe2e>
   134f2:	ldr	r3, [sp, #56]	; 0x38
   134f4:	b.n	12fd2 <_dtoa_r+0x8d2>
   134f6:	movs	r4, #0
   134f8:	str.w	r4, [r9, #68]	; 0x44
   134fc:	mov	r1, r4
   134fe:	mov	r0, r9
   13500:	bl	138e4 <_Balloc>
   13504:	mov.w	r3, #4294967295
   13508:	str	r3, [sp, #32]
   1350a:	str	r3, [sp, #56]	; 0x38
   1350c:	movs	r3, #1
   1350e:	str	r0, [sp, #36]	; 0x24
   13510:	str	r4, [sp, #20]
   13512:	str.w	r0, [r9, #64]	; 0x40
   13516:	str	r3, [sp, #44]	; 0x2c
   13518:	b.w	12914 <_dtoa_r+0x214>
   1351c:	beq.w	12bb0 <_dtoa_r+0x4b0>
   13520:	rsb	r0, r0, #60	; 0x3c
   13524:	b.w	12ba6 <_dtoa_r+0x4a6>
   13528:	movs	r6, #1
   1352a:	b.w	128a6 <_dtoa_r+0x1a6>
   1352e:	ldr	r3, [sp, #56]	; 0x38
   13530:	str	r3, [sp, #32]
   13532:	b.n	13112 <_dtoa_r+0xa12>

00013534 <fcvtbuf>:
   13534:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   13538:	vpush	{d8}
   1353c:	vmov.f32	s16, s0
   13540:	vmov.f32	s17, s1
   13544:	ldr	r5, [pc, #224]	; (13628 <fcvtbuf+0xf4>)
   13546:	sub	sp, #20
   13548:	ldr	r7, [r5, #0]
   1354a:	mov	r4, r0
   1354c:	mov	r6, r1
   1354e:	mov	r8, r2
   13550:	mov	r5, r3
   13552:	cmp	r3, #0
   13554:	beq.n	135f2 <fcvtbuf+0xbe>
   13556:	movs	r2, #0
   13558:	ldr	r3, [pc, #208]	; (1362c <fcvtbuf+0xf8>)
   1355a:	vmov	r0, r1, d8
   1355e:	bl	f940 <__aeabi_dcmplt>
   13562:	cbnz	r0, 135c4 <fcvtbuf+0x90>
   13564:	vmov.f32	s0, s16
   13568:	vmov.f32	s1, s17
   1356c:	add	r3, sp, #12
   1356e:	str	r3, [sp, #4]
   13570:	str.w	r8, [sp]
   13574:	mov	r0, r7
   13576:	mov	r3, r6
   13578:	mov	r2, r4
   1357a:	movs	r1, #3
   1357c:	bl	12700 <_dtoa_r>
   13580:	ldr	r3, [sp, #12]
   13582:	ldr	r1, [r6, #0]
   13584:	cmp	r0, r3
   13586:	rsb	r1, r1, #0
   1358a:	bcs.n	13600 <fcvtbuf+0xcc>
   1358c:	subs	r1, r1, r5
   1358e:	mov	r3, r5
   13590:	ldrb.w	r2, [r0], #1
   13594:	strb.w	r2, [r3], #1
   13598:	ldr	r2, [sp, #12]
   1359a:	cmp	r2, r0
   1359c:	add.w	r6, r3, r1
   135a0:	bhi.n	13590 <fcvtbuf+0x5c>
   135a2:	cmp	r4, r6
   135a4:	ble.n	13606 <fcvtbuf+0xd2>
   135a6:	subs	r2, r4, r6
   135a8:	add	r2, r3
   135aa:	movs	r1, #48	; 0x30
   135ac:	strb.w	r1, [r3], #1
   135b0:	cmp	r2, r3
   135b2:	bne.n	135ac <fcvtbuf+0x78>
   135b4:	movs	r3, #0
   135b6:	strb	r3, [r2, #0]
   135b8:	mov	r0, r5
   135ba:	add	sp, #20
   135bc:	vpop	{d8}
   135c0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   135c4:	movs	r2, #0
   135c6:	ldr	r3, [pc, #104]	; (13630 <fcvtbuf+0xfc>)
   135c8:	vmov	r0, r1, d8
   135cc:	bl	f97c <__aeabi_dcmpgt>
   135d0:	cmp	r0, #0
   135d2:	beq.n	13564 <fcvtbuf+0x30>
   135d4:	vmov.f32	s0, s16
   135d8:	vmov.f32	s1, s17
   135dc:	add	r3, sp, #12
   135de:	str	r3, [sp, #4]
   135e0:	str.w	r8, [sp]
   135e4:	mov	r0, r7
   135e6:	mov	r3, r6
   135e8:	mov	r2, r4
   135ea:	movs	r1, #2
   135ec:	bl	12700 <_dtoa_r>
   135f0:	b.n	13580 <fcvtbuf+0x4c>
   135f2:	ldr	r2, [r7, #80]	; 0x50
   135f4:	add.w	r3, r0, #35	; 0x23
   135f8:	cmp	r2, r3
   135fa:	ble.n	1360a <fcvtbuf+0xd6>
   135fc:	ldr	r5, [r7, #84]	; 0x54
   135fe:	b.n	13556 <fcvtbuf+0x22>
   13600:	mov	r6, r1
   13602:	mov	r3, r5
   13604:	b.n	135a2 <fcvtbuf+0x6e>
   13606:	mov	r2, r3
   13608:	b.n	135b4 <fcvtbuf+0x80>
   1360a:	add.w	r9, r0, #36	; 0x24
   1360e:	mov	r2, r9
   13610:	ldr	r1, [r7, #84]	; 0x54
   13612:	mov	r0, r7
   13614:	bl	10640 <_realloc_r>
   13618:	mov	r5, r0
   1361a:	cmp	r0, #0
   1361c:	beq.n	135b8 <fcvtbuf+0x84>
   1361e:	str.w	r9, [r7, #80]	; 0x50
   13622:	str	r0, [r7, #84]	; 0x54
   13624:	b.n	13556 <fcvtbuf+0x22>
   13626:	nop
   13628:	.word	0x1fff0f10
   1362c:	.word	0x3ff00000
   13630:	.word	0xbff00000

00013634 <__libc_fini_array>:
   13634:	push	{r3, r4, r5, lr}
   13636:	ldr	r5, [pc, #28]	; (13654 <__libc_fini_array+0x20>)
   13638:	ldr	r4, [pc, #28]	; (13658 <__libc_fini_array+0x24>)
   1363a:	subs	r4, r5, r4
   1363c:	asrs	r4, r4, #2
   1363e:	beq.n	1364c <__libc_fini_array+0x18>
   13640:	subs	r4, #1
   13642:	ldr.w	r3, [r5, #-4]!
   13646:	blx	r3
   13648:	cmp	r4, #0
   1364a:	bne.n	13640 <__libc_fini_array+0xc>
   1364c:	ldmia.w	sp!, {r3, r4, r5, lr}
   13650:	b.w	14c68 <__init_array_end>
	...

0001365c <_malloc_trim_r>:
   1365c:	push	{r3, r4, r5, r6, r7, lr}
   1365e:	ldr	r7, [pc, #140]	; (136ec <_malloc_trim_r+0x90>)
   13660:	mov	r4, r1
   13662:	mov	r6, r0
   13664:	bl	10638 <__malloc_lock>
   13668:	ldr	r3, [r7, #8]
   1366a:	ldr	r5, [r3, #4]
   1366c:	bic.w	r5, r5, #3
   13670:	subs	r1, r5, r4
   13672:	addw	r1, r1, #4079	; 0xfef
   13676:	bic.w	r1, r1, #4080	; 0xff0
   1367a:	bic.w	r1, r1, #15
   1367e:	sub.w	r4, r1, #4096	; 0x1000
   13682:	cmp.w	r4, #4096	; 0x1000
   13686:	blt.n	13698 <_malloc_trim_r+0x3c>
   13688:	movs	r1, #0
   1368a:	mov	r0, r6
   1368c:	bl	10a20 <_sbrk_r>
   13690:	ldr	r3, [r7, #8]
   13692:	add	r3, r5
   13694:	cmp	r0, r3
   13696:	beq.n	136a2 <_malloc_trim_r+0x46>
   13698:	mov	r0, r6
   1369a:	bl	1063c <__malloc_unlock>
   1369e:	movs	r0, #0
   136a0:	pop	{r3, r4, r5, r6, r7, pc}
   136a2:	negs	r1, r4
   136a4:	mov	r0, r6
   136a6:	bl	10a20 <_sbrk_r>
   136aa:	adds	r0, #1
   136ac:	beq.n	136ca <_malloc_trim_r+0x6e>
   136ae:	ldr	r3, [pc, #64]	; (136f0 <_malloc_trim_r+0x94>)
   136b0:	ldr	r2, [r7, #8]
   136b2:	ldr	r1, [r3, #0]
   136b4:	subs	r5, r5, r4
   136b6:	orr.w	r5, r5, #1
   136ba:	mov	r0, r6
   136bc:	subs	r1, r1, r4
   136be:	str	r5, [r2, #4]
   136c0:	str	r1, [r3, #0]
   136c2:	bl	1063c <__malloc_unlock>
   136c6:	movs	r0, #1
   136c8:	pop	{r3, r4, r5, r6, r7, pc}
   136ca:	movs	r1, #0
   136cc:	mov	r0, r6
   136ce:	bl	10a20 <_sbrk_r>
   136d2:	ldr	r2, [r7, #8]
   136d4:	subs	r3, r0, r2
   136d6:	cmp	r3, #15
   136d8:	ble.n	13698 <_malloc_trim_r+0x3c>
   136da:	ldr	r4, [pc, #24]	; (136f4 <_malloc_trim_r+0x98>)
   136dc:	ldr	r1, [pc, #16]	; (136f0 <_malloc_trim_r+0x94>)
   136de:	ldr	r4, [r4, #0]
   136e0:	orr.w	r3, r3, #1
   136e4:	subs	r0, r0, r4
   136e6:	str	r3, [r2, #4]
   136e8:	str	r0, [r1, #0]
   136ea:	b.n	13698 <_malloc_trim_r+0x3c>
   136ec:	.word	0x1fff1080
   136f0:	.word	0x1fff6800
   136f4:	.word	0x1fff148c

000136f8 <_free_r>:
   136f8:	cmp	r1, #0
   136fa:	beq.n	13788 <_free_r+0x90>
   136fc:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   13700:	mov	r5, r1
   13702:	mov	r8, r0
   13704:	bl	10638 <__malloc_lock>
   13708:	ldr.w	r7, [r5, #-4]
   1370c:	ldr	r1, [pc, #424]	; (138b8 <_free_r+0x1c0>)
   1370e:	bic.w	r3, r7, #1
   13712:	sub.w	r4, r5, #8
   13716:	adds	r2, r4, r3
   13718:	ldr	r6, [r1, #8]
   1371a:	ldr	r0, [r2, #4]
   1371c:	cmp	r2, r6
   1371e:	bic.w	r0, r0, #3
   13722:	beq.n	137ea <_free_r+0xf2>
   13724:	lsls	r6, r7, #31
   13726:	str	r0, [r2, #4]
   13728:	bmi.n	13742 <_free_r+0x4a>
   1372a:	ldr.w	r7, [r5, #-8]
   1372e:	subs	r4, r4, r7
   13730:	add.w	lr, r1, #8
   13734:	ldr	r5, [r4, #8]
   13736:	cmp	r5, lr
   13738:	add	r3, r7
   1373a:	beq.n	1381c <_free_r+0x124>
   1373c:	ldr	r7, [r4, #12]
   1373e:	str	r7, [r5, #12]
   13740:	str	r5, [r7, #8]
   13742:	adds	r5, r2, r0
   13744:	ldr	r5, [r5, #4]
   13746:	lsls	r5, r5, #31
   13748:	bpl.n	137d0 <_free_r+0xd8>
   1374a:	orr.w	r2, r3, #1
   1374e:	str	r2, [r4, #4]
   13750:	str	r3, [r4, r3]
   13752:	cmp.w	r3, #512	; 0x200
   13756:	bcs.n	1378a <_free_r+0x92>
   13758:	lsrs	r3, r3, #3
   1375a:	adds	r2, r3, #1
   1375c:	ldr	r5, [r1, #4]
   1375e:	ldr.w	r7, [r1, r2, lsl #3]
   13762:	str	r7, [r4, #8]
   13764:	movs	r0, #1
   13766:	asrs	r3, r3, #2
   13768:	lsl.w	r3, r0, r3
   1376c:	add.w	r0, r1, r2, lsl #3
   13770:	orrs	r5, r3
   13772:	subs	r0, #8
   13774:	str	r0, [r4, #12]
   13776:	str	r5, [r1, #4]
   13778:	str.w	r4, [r1, r2, lsl #3]
   1377c:	str	r4, [r7, #12]
   1377e:	mov	r0, r8
   13780:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   13784:	b.w	1063c <__malloc_unlock>
   13788:	bx	lr
   1378a:	lsrs	r2, r3, #9
   1378c:	cmp	r2, #4
   1378e:	bhi.n	13838 <_free_r+0x140>
   13790:	lsrs	r2, r3, #6
   13792:	add.w	r7, r2, #57	; 0x39
   13796:	lsls	r7, r7, #1
   13798:	add.w	r5, r2, #56	; 0x38
   1379c:	add.w	r0, r1, r7, lsl #2
   137a0:	ldr.w	r2, [r1, r7, lsl #2]
   137a4:	ldr	r1, [pc, #272]	; (138b8 <_free_r+0x1c0>)
   137a6:	subs	r0, #8
   137a8:	cmp	r0, r2
   137aa:	beq.n	13848 <_free_r+0x150>
   137ac:	ldr	r1, [r2, #4]
   137ae:	bic.w	r1, r1, #3
   137b2:	cmp	r3, r1
   137b4:	bcs.n	137bc <_free_r+0xc4>
   137b6:	ldr	r2, [r2, #8]
   137b8:	cmp	r0, r2
   137ba:	bne.n	137ac <_free_r+0xb4>
   137bc:	ldr	r0, [r2, #12]
   137be:	str	r0, [r4, #12]
   137c0:	str	r2, [r4, #8]
   137c2:	str	r4, [r0, #8]
   137c4:	str	r4, [r2, #12]
   137c6:	mov	r0, r8
   137c8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   137cc:	b.w	1063c <__malloc_unlock>
   137d0:	ldr	r5, [r2, #8]
   137d2:	ldr	r7, [pc, #232]	; (138bc <_free_r+0x1c4>)
   137d4:	cmp	r5, r7
   137d6:	add	r3, r0
   137d8:	beq.n	1385a <_free_r+0x162>
   137da:	ldr	r0, [r2, #12]
   137dc:	str	r0, [r5, #12]
   137de:	orr.w	r2, r3, #1
   137e2:	str	r5, [r0, #8]
   137e4:	str	r2, [r4, #4]
   137e6:	str	r3, [r4, r3]
   137e8:	b.n	13752 <_free_r+0x5a>
   137ea:	lsls	r7, r7, #31
   137ec:	add	r3, r0
   137ee:	bmi.n	13800 <_free_r+0x108>
   137f0:	ldr.w	r2, [r5, #-8]
   137f4:	subs	r4, r4, r2
   137f6:	add	r3, r2
   137f8:	ldr	r0, [r4, #8]
   137fa:	ldr	r2, [r4, #12]
   137fc:	str	r2, [r0, #12]
   137fe:	str	r0, [r2, #8]
   13800:	ldr	r2, [pc, #188]	; (138c0 <_free_r+0x1c8>)
   13802:	ldr	r2, [r2, #0]
   13804:	orr.w	r0, r3, #1
   13808:	cmp	r3, r2
   1380a:	str	r0, [r4, #4]
   1380c:	str	r4, [r1, #8]
   1380e:	bcc.n	1377e <_free_r+0x86>
   13810:	ldr	r3, [pc, #176]	; (138c4 <_free_r+0x1cc>)
   13812:	mov	r0, r8
   13814:	ldr	r1, [r3, #0]
   13816:	bl	1365c <_malloc_trim_r>
   1381a:	b.n	1377e <_free_r+0x86>
   1381c:	adds	r1, r2, r0
   1381e:	ldr	r1, [r1, #4]
   13820:	lsls	r1, r1, #31
   13822:	bmi.n	138ae <_free_r+0x1b6>
   13824:	ldr	r1, [r2, #8]
   13826:	ldr	r2, [r2, #12]
   13828:	str	r2, [r1, #12]
   1382a:	add	r3, r0
   1382c:	orr.w	r0, r3, #1
   13830:	str	r1, [r2, #8]
   13832:	str	r0, [r4, #4]
   13834:	str	r3, [r4, r3]
   13836:	b.n	1377e <_free_r+0x86>
   13838:	cmp	r2, #20
   1383a:	bhi.n	1386c <_free_r+0x174>
   1383c:	add.w	r7, r2, #92	; 0x5c
   13840:	lsls	r7, r7, #1
   13842:	add.w	r5, r2, #91	; 0x5b
   13846:	b.n	1379c <_free_r+0xa4>
   13848:	asrs	r2, r5, #2
   1384a:	ldr	r3, [r1, #4]
   1384c:	movs	r5, #1
   1384e:	lsl.w	r2, r5, r2
   13852:	orrs	r3, r2
   13854:	str	r3, [r1, #4]
   13856:	mov	r2, r0
   13858:	b.n	137be <_free_r+0xc6>
   1385a:	orr.w	r2, r3, #1
   1385e:	str	r4, [r1, #20]
   13860:	str	r4, [r1, #16]
   13862:	str	r5, [r4, #12]
   13864:	str	r5, [r4, #8]
   13866:	str	r2, [r4, #4]
   13868:	str	r3, [r4, r3]
   1386a:	b.n	1377e <_free_r+0x86>
   1386c:	cmp	r2, #84	; 0x54
   1386e:	bhi.n	1387e <_free_r+0x186>
   13870:	lsrs	r2, r3, #12
   13872:	add.w	r7, r2, #111	; 0x6f
   13876:	lsls	r7, r7, #1
   13878:	add.w	r5, r2, #110	; 0x6e
   1387c:	b.n	1379c <_free_r+0xa4>
   1387e:	cmp.w	r2, #340	; 0x154
   13882:	bhi.n	13892 <_free_r+0x19a>
   13884:	lsrs	r2, r3, #15
   13886:	add.w	r7, r2, #120	; 0x78
   1388a:	lsls	r7, r7, #1
   1388c:	add.w	r5, r2, #119	; 0x77
   13890:	b.n	1379c <_free_r+0xa4>
   13892:	movw	r0, #1364	; 0x554
   13896:	cmp	r2, r0
   13898:	bhi.n	138a8 <_free_r+0x1b0>
   1389a:	lsrs	r2, r3, #18
   1389c:	add.w	r7, r2, #125	; 0x7d
   138a0:	lsls	r7, r7, #1
   138a2:	add.w	r5, r2, #124	; 0x7c
   138a6:	b.n	1379c <_free_r+0xa4>
   138a8:	movs	r7, #254	; 0xfe
   138aa:	movs	r5, #126	; 0x7e
   138ac:	b.n	1379c <_free_r+0xa4>
   138ae:	orr.w	r2, r3, #1
   138b2:	str	r2, [r4, #4]
   138b4:	str	r3, [r4, r3]
   138b6:	b.n	1377e <_free_r+0x86>
   138b8:	.word	0x1fff1080
   138bc:	.word	0x1fff1088
   138c0:	.word	0x1fff1488
   138c4:	.word	0x1fff67fc

000138c8 <_localeconv_r>:
   138c8:	ldr	r2, [pc, #16]	; (138dc <_localeconv_r+0x14>)
   138ca:	ldr	r3, [pc, #20]	; (138e0 <_localeconv_r+0x18>)
   138cc:	ldr	r2, [r2, #0]
   138ce:	ldr	r0, [r2, #52]	; 0x34
   138d0:	cmp	r0, #0
   138d2:	it	eq
   138d4:	moveq	r0, r3
   138d6:	adds	r0, #240	; 0xf0
   138d8:	bx	lr
   138da:	nop
   138dc:	.word	0x1fff0f10
   138e0:	.word	0x1fff0f14

000138e4 <_Balloc>:
   138e4:	ldr	r3, [r0, #76]	; 0x4c
   138e6:	push	{r4, r5, r6, lr}
   138e8:	mov	r5, r0
   138ea:	mov	r4, r1
   138ec:	cbz	r3, 13902 <_Balloc+0x1e>
   138ee:	ldr.w	r0, [r3, r4, lsl #2]
   138f2:	cbz	r0, 13916 <_Balloc+0x32>
   138f4:	ldr	r2, [r0, #0]
   138f6:	str.w	r2, [r3, r4, lsl #2]
   138fa:	movs	r3, #0
   138fc:	str	r3, [r0, #16]
   138fe:	str	r3, [r0, #12]
   13900:	pop	{r4, r5, r6, pc}
   13902:	movs	r2, #33	; 0x21
   13904:	movs	r1, #4
   13906:	bl	fd24 <_calloc_r>
   1390a:	str	r0, [r5, #76]	; 0x4c
   1390c:	mov	r3, r0
   1390e:	cmp	r0, #0
   13910:	bne.n	138ee <_Balloc+0xa>
   13912:	movs	r0, #0
   13914:	pop	{r4, r5, r6, pc}
   13916:	movs	r1, #1
   13918:	lsl.w	r6, r1, r4
   1391c:	adds	r2, r6, #5
   1391e:	mov	r0, r5
   13920:	lsls	r2, r2, #2
   13922:	bl	fd24 <_calloc_r>
   13926:	cmp	r0, #0
   13928:	beq.n	13912 <_Balloc+0x2e>
   1392a:	str	r4, [r0, #4]
   1392c:	str	r6, [r0, #8]
   1392e:	b.n	138fa <_Balloc+0x16>

00013930 <_Bfree>:
   13930:	cbz	r1, 13940 <_Bfree+0x10>
   13932:	ldr	r3, [r0, #76]	; 0x4c
   13934:	ldr	r2, [r1, #4]
   13936:	ldr.w	r0, [r3, r2, lsl #2]
   1393a:	str	r0, [r1, #0]
   1393c:	str.w	r1, [r3, r2, lsl #2]
   13940:	bx	lr
   13942:	nop

00013944 <__multadd>:
   13944:	push	{r4, r5, r6, r7, lr}
   13946:	ldr	r4, [r1, #16]
   13948:	sub	sp, #12
   1394a:	mov	r5, r1
   1394c:	mov	r6, r0
   1394e:	add.w	lr, r1, #20
   13952:	movs	r7, #0
   13954:	ldr.w	r0, [lr]
   13958:	uxth	r1, r0
   1395a:	mla	r1, r2, r1, r3
   1395e:	lsrs	r3, r1, #16
   13960:	lsrs	r0, r0, #16
   13962:	mla	r3, r2, r0, r3
   13966:	uxth	r1, r1
   13968:	adds	r7, #1
   1396a:	add.w	r1, r1, r3, lsl #16
   1396e:	cmp	r4, r7
   13970:	str.w	r1, [lr], #4
   13974:	mov.w	r3, r3, lsr #16
   13978:	bgt.n	13954 <__multadd+0x10>
   1397a:	cbz	r3, 1398c <__multadd+0x48>
   1397c:	ldr	r2, [r5, #8]
   1397e:	cmp	r4, r2
   13980:	bge.n	13992 <__multadd+0x4e>
   13982:	add.w	r2, r5, r4, lsl #2
   13986:	adds	r4, #1
   13988:	str	r3, [r2, #20]
   1398a:	str	r4, [r5, #16]
   1398c:	mov	r0, r5
   1398e:	add	sp, #12
   13990:	pop	{r4, r5, r6, r7, pc}
   13992:	ldr	r1, [r5, #4]
   13994:	str	r3, [sp, #4]
   13996:	adds	r1, #1
   13998:	mov	r0, r6
   1399a:	bl	138e4 <_Balloc>
   1399e:	ldr	r2, [r5, #16]
   139a0:	adds	r2, #2
   139a2:	add.w	r1, r5, #12
   139a6:	mov	r7, r0
   139a8:	lsls	r2, r2, #2
   139aa:	adds	r0, #12
   139ac:	bl	d444 <memcpy>
   139b0:	ldr	r2, [r6, #76]	; 0x4c
   139b2:	ldr	r1, [r5, #4]
   139b4:	ldr	r3, [sp, #4]
   139b6:	ldr.w	r0, [r2, r1, lsl #2]
   139ba:	str	r0, [r5, #0]
   139bc:	str.w	r5, [r2, r1, lsl #2]
   139c0:	mov	r5, r7
   139c2:	b.n	13982 <__multadd+0x3e>

000139c4 <__hi0bits>:
   139c4:	lsrs	r3, r0, #16
   139c6:	lsls	r3, r3, #16
   139c8:	cbnz	r3, 139f8 <__hi0bits+0x34>
   139ca:	lsls	r0, r0, #16
   139cc:	movs	r3, #16
   139ce:	tst.w	r0, #4278190080	; 0xff000000
   139d2:	itt	eq
   139d4:	lsleq	r0, r0, #8
   139d6:	addeq	r3, #8
   139d8:	tst.w	r0, #4026531840	; 0xf0000000
   139dc:	itt	eq
   139de:	lsleq	r0, r0, #4
   139e0:	addeq	r3, #4
   139e2:	tst.w	r0, #3221225472	; 0xc0000000
   139e6:	itt	eq
   139e8:	lsleq	r0, r0, #2
   139ea:	addeq	r3, #2
   139ec:	cmp	r0, #0
   139ee:	blt.n	13a00 <__hi0bits+0x3c>
   139f0:	lsls	r2, r0, #1
   139f2:	bmi.n	139fc <__hi0bits+0x38>
   139f4:	movs	r0, #32
   139f6:	bx	lr
   139f8:	movs	r3, #0
   139fa:	b.n	139ce <__hi0bits+0xa>
   139fc:	adds	r0, r3, #1
   139fe:	bx	lr
   13a00:	mov	r0, r3
   13a02:	bx	lr

00013a04 <__lo0bits>:
   13a04:	ldr	r3, [r0, #0]
   13a06:	ands.w	r2, r3, #7
   13a0a:	beq.n	13a1c <__lo0bits+0x18>
   13a0c:	lsls	r1, r3, #31
   13a0e:	bmi.n	13a52 <__lo0bits+0x4e>
   13a10:	lsls	r2, r3, #30
   13a12:	bmi.n	13a56 <__lo0bits+0x52>
   13a14:	lsrs	r3, r3, #2
   13a16:	str	r3, [r0, #0]
   13a18:	movs	r0, #2
   13a1a:	bx	lr
   13a1c:	uxth	r1, r3
   13a1e:	cbnz	r1, 13a24 <__lo0bits+0x20>
   13a20:	lsrs	r3, r3, #16
   13a22:	movs	r2, #16
   13a24:	tst.w	r3, #255	; 0xff
   13a28:	itt	eq
   13a2a:	lsreq	r3, r3, #8
   13a2c:	addeq	r2, #8
   13a2e:	lsls	r1, r3, #28
   13a30:	itt	eq
   13a32:	lsreq	r3, r3, #4
   13a34:	addeq	r2, #4
   13a36:	lsls	r1, r3, #30
   13a38:	itt	eq
   13a3a:	lsreq	r3, r3, #2
   13a3c:	addeq	r2, #2
   13a3e:	lsls	r1, r3, #31
   13a40:	bmi.n	13a4c <__lo0bits+0x48>
   13a42:	lsrs	r3, r3, #1
   13a44:	bne.n	13a4a <__lo0bits+0x46>
   13a46:	movs	r0, #32
   13a48:	bx	lr
   13a4a:	adds	r2, #1
   13a4c:	str	r3, [r0, #0]
   13a4e:	mov	r0, r2
   13a50:	bx	lr
   13a52:	movs	r0, #0
   13a54:	bx	lr
   13a56:	lsrs	r3, r3, #1
   13a58:	str	r3, [r0, #0]
   13a5a:	movs	r0, #1
   13a5c:	bx	lr
   13a5e:	nop

00013a60 <__i2b>:
   13a60:	push	{r4, lr}
   13a62:	mov	r4, r1
   13a64:	movs	r1, #1
   13a66:	bl	138e4 <_Balloc>
   13a6a:	movs	r2, #1
   13a6c:	str	r4, [r0, #20]
   13a6e:	str	r2, [r0, #16]
   13a70:	pop	{r4, pc}
   13a72:	nop

00013a74 <__multiply>:
   13a74:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13a78:	ldr	r5, [r1, #16]
   13a7a:	ldr	r7, [r2, #16]
   13a7c:	cmp	r5, r7
   13a7e:	sub	sp, #12
   13a80:	mov	r4, r1
   13a82:	mov	r6, r2
   13a84:	bge.n	13a90 <__multiply+0x1c>
   13a86:	mov	r2, r5
   13a88:	mov	r4, r6
   13a8a:	mov	r5, r7
   13a8c:	mov	r6, r1
   13a8e:	mov	r7, r2
   13a90:	ldr	r3, [r4, #8]
   13a92:	ldr	r1, [r4, #4]
   13a94:	add.w	r8, r5, r7
   13a98:	cmp	r8, r3
   13a9a:	it	gt
   13a9c:	addgt	r1, #1
   13a9e:	bl	138e4 <_Balloc>
   13aa2:	add.w	ip, r0, #20
   13aa6:	add.w	r9, ip, r8, lsl #2
   13aaa:	cmp	ip, r9
   13aac:	str	r0, [sp, #0]
   13aae:	bcs.n	13abc <__multiply+0x48>
   13ab0:	mov	r3, ip
   13ab2:	movs	r1, #0
   13ab4:	str.w	r1, [r3], #4
   13ab8:	cmp	r9, r3
   13aba:	bhi.n	13ab4 <__multiply+0x40>
   13abc:	add.w	r2, r6, #20
   13ac0:	add.w	sl, r2, r7, lsl #2
   13ac4:	add.w	r3, r4, #20
   13ac8:	cmp	r2, sl
   13aca:	add.w	lr, r3, r5, lsl #2
   13ace:	bcs.n	13b7a <__multiply+0x106>
   13ad0:	str.w	r9, [sp, #4]
   13ad4:	mov	r9, r3
   13ad6:	ldr.w	r3, [r2], #4
   13ada:	uxth.w	fp, r3
   13ade:	cmp.w	fp, #0
   13ae2:	beq.n	13b26 <__multiply+0xb2>
   13ae4:	movs	r0, #0
   13ae6:	mov	r7, r9
   13ae8:	mov	r6, ip
   13aea:	mov	r5, r0
   13aec:	b.n	13af0 <__multiply+0x7c>
   13aee:	mov	r6, r3
   13af0:	ldr.w	r4, [r7], #4
   13af4:	ldr	r0, [r6, #0]
   13af6:	uxth	r1, r4
   13af8:	uxth	r3, r0
   13afa:	mla	r1, fp, r1, r3
   13afe:	lsrs	r4, r4, #16
   13b00:	lsrs	r0, r0, #16
   13b02:	adds	r3, r1, r5
   13b04:	mla	r0, fp, r4, r0
   13b08:	add.w	r0, r0, r3, lsr #16
   13b0c:	uxth	r1, r3
   13b0e:	mov	r3, r6
   13b10:	orr.w	r1, r1, r0, lsl #16
   13b14:	cmp	lr, r7
   13b16:	mov.w	r5, r0, lsr #16
   13b1a:	str.w	r1, [r3], #4
   13b1e:	bhi.n	13aee <__multiply+0x7a>
   13b20:	str	r5, [r6, #4]
   13b22:	ldr.w	r3, [r2, #-4]
   13b26:	movs.w	fp, r3, lsr #16
   13b2a:	beq.n	13b6e <__multiply+0xfa>
   13b2c:	ldr.w	r3, [ip]
   13b30:	mov	r7, ip
   13b32:	mov	r0, r3
   13b34:	mov	r5, r9
   13b36:	movs	r1, #0
   13b38:	b.n	13b3c <__multiply+0xc8>
   13b3a:	mov	r7, r6
   13b3c:	ldrh	r4, [r5, #0]
   13b3e:	lsrs	r0, r0, #16
   13b40:	mla	r0, fp, r4, r0
   13b44:	add	r1, r0
   13b46:	uxth	r4, r3
   13b48:	mov	r6, r7
   13b4a:	orr.w	r3, r4, r1, lsl #16
   13b4e:	str.w	r3, [r6], #4
   13b52:	ldr	r0, [r7, #4]
   13b54:	ldr.w	r4, [r5], #4
   13b58:	uxth	r3, r0
   13b5a:	lsrs	r4, r4, #16
   13b5c:	mla	r4, fp, r4, r3
   13b60:	add.w	r3, r4, r1, lsr #16
   13b64:	cmp	lr, r5
   13b66:	mov.w	r1, r3, lsr #16
   13b6a:	bhi.n	13b3a <__multiply+0xc6>
   13b6c:	str	r3, [r7, #4]
   13b6e:	cmp	sl, r2
   13b70:	add.w	ip, ip, #4
   13b74:	bhi.n	13ad6 <__multiply+0x62>
   13b76:	ldr.w	r9, [sp, #4]
   13b7a:	cmp.w	r8, #0
   13b7e:	ble.n	13b98 <__multiply+0x124>
   13b80:	ldr.w	r3, [r9, #-4]
   13b84:	sub.w	r9, r9, #4
   13b88:	cbz	r3, 13b92 <__multiply+0x11e>
   13b8a:	b.n	13b98 <__multiply+0x124>
   13b8c:	ldr.w	r3, [r9, #-4]!
   13b90:	cbnz	r3, 13b98 <__multiply+0x124>
   13b92:	subs.w	r8, r8, #1
   13b96:	bne.n	13b8c <__multiply+0x118>
   13b98:	ldr	r0, [sp, #0]
   13b9a:	str.w	r8, [r0, #16]
   13b9e:	add	sp, #12
   13ba0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00013ba4 <__pow5mult>:
   13ba4:	ands.w	r3, r2, #3
   13ba8:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   13bac:	mov	r4, r2
   13bae:	mov	r7, r0
   13bb0:	bne.n	13c10 <__pow5mult+0x6c>
   13bb2:	mov	r6, r1
   13bb4:	asrs	r4, r4, #2
   13bb6:	beq.n	13bf2 <__pow5mult+0x4e>
   13bb8:	ldr	r5, [r7, #72]	; 0x48
   13bba:	cbz	r5, 13c22 <__pow5mult+0x7e>
   13bbc:	lsls	r3, r4, #31
   13bbe:	mov.w	r8, #0
   13bc2:	bmi.n	13bd2 <__pow5mult+0x2e>
   13bc4:	asrs	r4, r4, #1
   13bc6:	beq.n	13bf2 <__pow5mult+0x4e>
   13bc8:	ldr	r0, [r5, #0]
   13bca:	cbz	r0, 13bf8 <__pow5mult+0x54>
   13bcc:	mov	r5, r0
   13bce:	lsls	r3, r4, #31
   13bd0:	bpl.n	13bc4 <__pow5mult+0x20>
   13bd2:	mov	r2, r5
   13bd4:	mov	r1, r6
   13bd6:	mov	r0, r7
   13bd8:	bl	13a74 <__multiply>
   13bdc:	cbz	r6, 13c0c <__pow5mult+0x68>
   13bde:	ldr	r2, [r6, #4]
   13be0:	ldr	r3, [r7, #76]	; 0x4c
   13be2:	asrs	r4, r4, #1
   13be4:	ldr.w	r1, [r3, r2, lsl #2]
   13be8:	str	r1, [r6, #0]
   13bea:	str.w	r6, [r3, r2, lsl #2]
   13bee:	mov	r6, r0
   13bf0:	bne.n	13bc8 <__pow5mult+0x24>
   13bf2:	mov	r0, r6
   13bf4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   13bf8:	mov	r2, r5
   13bfa:	mov	r1, r5
   13bfc:	mov	r0, r7
   13bfe:	bl	13a74 <__multiply>
   13c02:	str	r0, [r5, #0]
   13c04:	str.w	r8, [r0]
   13c08:	mov	r5, r0
   13c0a:	b.n	13bce <__pow5mult+0x2a>
   13c0c:	mov	r6, r0
   13c0e:	b.n	13bc4 <__pow5mult+0x20>
   13c10:	subs	r2, r3, #1
   13c12:	ldr	r5, [pc, #44]	; (13c40 <__pow5mult+0x9c>)
   13c14:	movs	r3, #0
   13c16:	ldr.w	r2, [r5, r2, lsl #2]
   13c1a:	bl	13944 <__multadd>
   13c1e:	mov	r6, r0
   13c20:	b.n	13bb4 <__pow5mult+0x10>
   13c22:	movs	r1, #1
   13c24:	mov	r0, r7
   13c26:	bl	138e4 <_Balloc>
   13c2a:	movw	r1, #625	; 0x271
   13c2e:	movs	r2, #1
   13c30:	movs	r3, #0
   13c32:	str	r1, [r0, #20]
   13c34:	str	r2, [r0, #16]
   13c36:	mov	r5, r0
   13c38:	str	r0, [r7, #72]	; 0x48
   13c3a:	str	r3, [r0, #0]
   13c3c:	b.n	13bbc <__pow5mult+0x18>
   13c3e:	nop
   13c40:	.word	0x00014c40

00013c44 <__lshift>:
   13c44:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   13c48:	mov	r9, r2
   13c4a:	ldr	r2, [r1, #16]
   13c4c:	ldr	r3, [r1, #8]
   13c4e:	mov.w	r4, r9, asr #5
   13c52:	add.w	r8, r4, r2
   13c56:	add.w	r5, r8, #1
   13c5a:	cmp	r5, r3
   13c5c:	mov	r6, r1
   13c5e:	mov	sl, r0
   13c60:	ldr	r1, [r1, #4]
   13c62:	ble.n	13c6e <__lshift+0x2a>
   13c64:	lsls	r3, r3, #1
   13c66:	cmp	r5, r3
   13c68:	add.w	r1, r1, #1
   13c6c:	bgt.n	13c64 <__lshift+0x20>
   13c6e:	mov	r0, sl
   13c70:	bl	138e4 <_Balloc>
   13c74:	cmp	r4, #0
   13c76:	add.w	r2, r0, #20
   13c7a:	ble.n	13cee <__lshift+0xaa>
   13c7c:	add.w	r3, r2, r4, lsl #2
   13c80:	movs	r1, #0
   13c82:	str.w	r1, [r2], #4
   13c86:	cmp	r3, r2
   13c88:	bne.n	13c82 <__lshift+0x3e>
   13c8a:	ldr	r4, [r6, #16]
   13c8c:	add.w	r1, r6, #20
   13c90:	ands.w	r9, r9, #31
   13c94:	add.w	lr, r1, r4, lsl #2
   13c98:	beq.n	13cde <__lshift+0x9a>
   13c9a:	rsb	r2, r9, #32
   13c9e:	movs	r4, #0
   13ca0:	ldr	r7, [r1, #0]
   13ca2:	lsl.w	ip, r7, r9
   13ca6:	orr.w	r4, ip, r4
   13caa:	mov	ip, r3
   13cac:	str.w	r4, [r3], #4
   13cb0:	ldr.w	r4, [r1], #4
   13cb4:	cmp	lr, r1
   13cb6:	lsr.w	r4, r4, r2
   13cba:	bhi.n	13ca0 <__lshift+0x5c>
   13cbc:	str.w	r4, [ip, #4]
   13cc0:	cbz	r4, 13cc6 <__lshift+0x82>
   13cc2:	add.w	r5, r8, #2
   13cc6:	ldr.w	r3, [sl, #76]	; 0x4c
   13cca:	ldr	r2, [r6, #4]
   13ccc:	subs	r5, #1
   13cce:	ldr.w	r1, [r3, r2, lsl #2]
   13cd2:	str	r5, [r0, #16]
   13cd4:	str	r1, [r6, #0]
   13cd6:	str.w	r6, [r3, r2, lsl #2]
   13cda:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   13cde:	subs	r3, #4
   13ce0:	ldr.w	r2, [r1], #4
   13ce4:	str.w	r2, [r3, #4]!
   13ce8:	cmp	lr, r1
   13cea:	bhi.n	13ce0 <__lshift+0x9c>
   13cec:	b.n	13cc6 <__lshift+0x82>
   13cee:	mov	r3, r2
   13cf0:	b.n	13c8a <__lshift+0x46>
   13cf2:	nop

00013cf4 <__mcmp>:
   13cf4:	ldr	r2, [r0, #16]
   13cf6:	ldr	r3, [r1, #16]
   13cf8:	subs	r2, r2, r3
   13cfa:	bne.n	13d24 <__mcmp+0x30>
   13cfc:	lsls	r3, r3, #2
   13cfe:	adds	r0, #20
   13d00:	adds	r1, #20
   13d02:	add	r1, r3
   13d04:	push	{r4}
   13d06:	add	r3, r0
   13d08:	b.n	13d0e <__mcmp+0x1a>
   13d0a:	cmp	r0, r3
   13d0c:	bcs.n	13d28 <__mcmp+0x34>
   13d0e:	ldr.w	r4, [r3, #-4]!
   13d12:	ldr.w	r2, [r1, #-4]!
   13d16:	cmp	r4, r2
   13d18:	beq.n	13d0a <__mcmp+0x16>
   13d1a:	bcc.n	13d30 <__mcmp+0x3c>
   13d1c:	movs	r0, #1
   13d1e:	ldr.w	r4, [sp], #4
   13d22:	bx	lr
   13d24:	mov	r0, r2
   13d26:	bx	lr
   13d28:	movs	r0, #0
   13d2a:	ldr.w	r4, [sp], #4
   13d2e:	bx	lr
   13d30:	mov.w	r0, #4294967295
   13d34:	b.n	13d1e <__mcmp+0x2a>
   13d36:	nop

00013d38 <__mdiff>:
   13d38:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   13d3c:	ldr	r3, [r1, #16]
   13d3e:	mov	r7, r1
   13d40:	ldr	r1, [r2, #16]
   13d42:	subs	r3, r3, r1
   13d44:	cmp	r3, #0
   13d46:	mov	r8, r2
   13d48:	bne.n	13d7a <__mdiff+0x42>
   13d4a:	lsls	r1, r1, #2
   13d4c:	add.w	r2, r7, #20
   13d50:	add.w	r5, r8, #20
   13d54:	adds	r3, r2, r1
   13d56:	add	r1, r5
   13d58:	b.n	13d5e <__mdiff+0x26>
   13d5a:	cmp	r2, r3
   13d5c:	bcs.n	13e1c <__mdiff+0xe4>
   13d5e:	ldr.w	r6, [r3, #-4]!
   13d62:	ldr.w	r4, [r1, #-4]!
   13d66:	cmp	r6, r4
   13d68:	beq.n	13d5a <__mdiff+0x22>
   13d6a:	bcs.n	13e2e <__mdiff+0xf6>
   13d6c:	mov	r3, r7
   13d6e:	mov	r4, r2
   13d70:	mov	r7, r8
   13d72:	mov.w	r9, #1
   13d76:	mov	r8, r3
   13d78:	b.n	13d88 <__mdiff+0x50>
   13d7a:	blt.n	13e38 <__mdiff+0x100>
   13d7c:	add.w	r5, r7, #20
   13d80:	add.w	r4, r2, #20
   13d84:	mov.w	r9, #0
   13d88:	ldr	r1, [r7, #4]
   13d8a:	bl	138e4 <_Balloc>
   13d8e:	ldr.w	r3, [r8, #16]
   13d92:	ldr	r6, [r7, #16]
   13d94:	str.w	r9, [r0, #12]
   13d98:	add.w	ip, r4, r3, lsl #2
   13d9c:	mov	lr, r4
   13d9e:	add.w	r7, r5, r6, lsl #2
   13da2:	add.w	r4, r0, #20
   13da6:	movs	r3, #0
   13da8:	ldr.w	r1, [lr], #4
   13dac:	ldr.w	r8, [r5], #4
   13db0:	uxth	r2, r1
   13db2:	uxtah	r3, r3, r8
   13db6:	lsrs	r1, r1, #16
   13db8:	subs	r2, r3, r2
   13dba:	rsb	r3, r1, r8, lsr #16
   13dbe:	add.w	r3, r3, r2, asr #16
   13dc2:	uxth	r2, r2
   13dc4:	orr.w	r2, r2, r3, lsl #16
   13dc8:	cmp	ip, lr
   13dca:	str.w	r2, [r4], #4
   13dce:	mov.w	r3, r3, asr #16
   13dd2:	bhi.n	13da8 <__mdiff+0x70>
   13dd4:	cmp	r7, r5
   13dd6:	bls.n	13e08 <__mdiff+0xd0>
   13dd8:	mov	ip, r4
   13dda:	mov	r1, r5
   13ddc:	ldr.w	lr, [r1], #4
   13de0:	uxtah	r2, r3, lr
   13de4:	asrs	r3, r2, #16
   13de6:	add.w	r3, r3, lr, lsr #16
   13dea:	uxth	r2, r2
   13dec:	orr.w	r2, r2, r3, lsl #16
   13df0:	cmp	r7, r1
   13df2:	str.w	r2, [ip], #4
   13df6:	mov.w	r3, r3, asr #16
   13dfa:	bhi.n	13ddc <__mdiff+0xa4>
   13dfc:	mvns	r5, r5
   13dfe:	add	r5, r7
   13e00:	bic.w	r5, r5, #3
   13e04:	adds	r5, #4
   13e06:	add	r4, r5
   13e08:	subs	r4, #4
   13e0a:	cbnz	r2, 13e16 <__mdiff+0xde>
   13e0c:	ldr.w	r3, [r4, #-4]!
   13e10:	subs	r6, #1
   13e12:	cmp	r3, #0
   13e14:	beq.n	13e0c <__mdiff+0xd4>
   13e16:	str	r6, [r0, #16]
   13e18:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   13e1c:	movs	r1, #0
   13e1e:	bl	138e4 <_Balloc>
   13e22:	movs	r2, #1
   13e24:	movs	r3, #0
   13e26:	str	r2, [r0, #16]
   13e28:	str	r3, [r0, #20]
   13e2a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   13e2e:	mov	r4, r5
   13e30:	mov.w	r9, #0
   13e34:	mov	r5, r2
   13e36:	b.n	13d88 <__mdiff+0x50>
   13e38:	mov	r3, r7
   13e3a:	add.w	r4, r7, #20
   13e3e:	add.w	r5, r8, #20
   13e42:	mov	r7, r8
   13e44:	mov.w	r9, #1
   13e48:	mov	r8, r3
   13e4a:	b.n	13d88 <__mdiff+0x50>

00013e4c <__d2b>:
   13e4c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   13e50:	vmov	r6, r7, d0
   13e54:	sub	sp, #12
   13e56:	mov	r8, r1
   13e58:	movs	r1, #1
   13e5a:	mov	r4, r7
   13e5c:	ubfx	r5, r7, #20, #11
   13e60:	mov	r7, r2
   13e62:	bl	138e4 <_Balloc>
   13e66:	ubfx	r4, r4, #0, #20
   13e6a:	mov	r9, r0
   13e6c:	cbz	r5, 13e72 <__d2b+0x26>
   13e6e:	orr.w	r4, r4, #1048576	; 0x100000
   13e72:	str	r4, [sp, #4]
   13e74:	cbz	r6, 13ebe <__d2b+0x72>
   13e76:	add	r0, sp, #8
   13e78:	str.w	r6, [r0, #-8]!
   13e7c:	bl	13a04 <__lo0bits>
   13e80:	cmp	r0, #0
   13e82:	bne.n	13eee <__d2b+0xa2>
   13e84:	ldmia.w	sp, {r2, r3}
   13e88:	str.w	r2, [r9, #20]
   13e8c:	cmp	r3, #0
   13e8e:	ite	eq
   13e90:	moveq	r1, #1
   13e92:	movne	r1, #2
   13e94:	str.w	r3, [r9, #24]
   13e98:	str.w	r1, [r9, #16]
   13e9c:	cbnz	r5, 13ed6 <__d2b+0x8a>
   13e9e:	add.w	r3, r9, r1, lsl #2
   13ea2:	subw	r0, r0, #1074	; 0x432
   13ea6:	str.w	r0, [r8]
   13eaa:	ldr	r0, [r3, #16]
   13eac:	bl	139c4 <__hi0bits>
   13eb0:	rsb	r0, r0, r1, lsl #5
   13eb4:	str	r0, [r7, #0]
   13eb6:	mov	r0, r9
   13eb8:	add	sp, #12
   13eba:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   13ebe:	add	r0, sp, #4
   13ec0:	bl	13a04 <__lo0bits>
   13ec4:	ldr	r3, [sp, #4]
   13ec6:	str.w	r3, [r9, #20]
   13eca:	movs	r1, #1
   13ecc:	adds	r0, #32
   13ece:	str.w	r1, [r9, #16]
   13ed2:	cmp	r5, #0
   13ed4:	beq.n	13e9e <__d2b+0x52>
   13ed6:	subw	r5, r5, #1075	; 0x433
   13eda:	add	r5, r0
   13edc:	rsb	r0, r0, #53	; 0x35
   13ee0:	str.w	r5, [r8]
   13ee4:	str	r0, [r7, #0]
   13ee6:	mov	r0, r9
   13ee8:	add	sp, #12
   13eea:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   13eee:	ldmia.w	sp, {r2, r3}
   13ef2:	rsb	r1, r0, #32
   13ef6:	lsl.w	r1, r3, r1
   13efa:	orrs	r2, r1
   13efc:	lsrs	r3, r0
   13efe:	str	r3, [sp, #4]
   13f00:	str.w	r2, [r9, #20]
   13f04:	b.n	13e8c <__d2b+0x40>
   13f06:	nop

00013f08 <__ssprint_r>:
   13f08:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13f0c:	ldr	r3, [r2, #8]
   13f0e:	sub	sp, #12
   13f10:	mov	r8, r2
   13f12:	cmp	r3, #0
   13f14:	beq.n	13ffc <__ssprint_r+0xf4>
   13f16:	mov	fp, r0
   13f18:	mov.w	r9, #0
   13f1c:	ldr	r6, [r2, #0]
   13f1e:	ldr	r0, [r1, #0]
   13f20:	ldr	r3, [r1, #8]
   13f22:	mov	r5, r1
   13f24:	mov	r4, r9
   13f26:	cmp	r4, #0
   13f28:	beq.n	13fb6 <__ssprint_r+0xae>
   13f2a:	cmp	r4, r3
   13f2c:	mov	r7, r3
   13f2e:	mov	sl, r3
   13f30:	bcc.n	13fc0 <__ssprint_r+0xb8>
   13f32:	ldrh	r3, [r5, #12]
   13f34:	tst.w	r3, #1152	; 0x480
   13f38:	beq.n	13f96 <__ssprint_r+0x8e>
   13f3a:	ldr	r7, [r5, #20]
   13f3c:	ldr	r1, [r5, #16]
   13f3e:	add.w	r7, r7, r7, lsl #1
   13f42:	rsb	sl, r1, r0
   13f46:	add.w	r7, r7, r7, lsr #31
   13f4a:	adds	r0, r4, #1
   13f4c:	asrs	r7, r7, #1
   13f4e:	add	r0, sl
   13f50:	cmp	r0, r7
   13f52:	mov	r2, r7
   13f54:	itt	hi
   13f56:	movhi	r7, r0
   13f58:	movhi	r2, r7
   13f5a:	lsls	r3, r3, #21
   13f5c:	bpl.n	13fc6 <__ssprint_r+0xbe>
   13f5e:	mov	r1, r2
   13f60:	mov	r0, fp
   13f62:	bl	fe30 <_malloc_r>
   13f66:	cmp	r0, #0
   13f68:	beq.n	13fda <__ssprint_r+0xd2>
   13f6a:	mov	r2, sl
   13f6c:	ldr	r1, [r5, #16]
   13f6e:	str	r0, [sp, #4]
   13f70:	bl	d444 <memcpy>
   13f74:	ldrh	r2, [r5, #12]
   13f76:	ldr	r3, [sp, #4]
   13f78:	bic.w	r2, r2, #1152	; 0x480
   13f7c:	orr.w	r2, r2, #128	; 0x80
   13f80:	strh	r2, [r5, #12]
   13f82:	rsb	r2, sl, r7
   13f86:	add.w	r0, r3, sl
   13f8a:	str	r7, [r5, #20]
   13f8c:	str	r3, [r5, #16]
   13f8e:	str	r0, [r5, #0]
   13f90:	str	r2, [r5, #8]
   13f92:	mov	r7, r4
   13f94:	mov	sl, r4
   13f96:	mov	r2, sl
   13f98:	mov	r1, r9
   13f9a:	bl	104d4 <memmove>
   13f9e:	ldr.w	r2, [r8, #8]
   13fa2:	ldr	r3, [r5, #8]
   13fa4:	ldr	r0, [r5, #0]
   13fa6:	subs	r3, r3, r7
   13fa8:	add	r0, sl
   13faa:	subs	r4, r2, r4
   13fac:	str	r3, [r5, #8]
   13fae:	str	r0, [r5, #0]
   13fb0:	str.w	r4, [r8, #8]
   13fb4:	cbz	r4, 13ffc <__ssprint_r+0xf4>
   13fb6:	ldr.w	r9, [r6]
   13fba:	ldr	r4, [r6, #4]
   13fbc:	adds	r6, #8
   13fbe:	b.n	13f26 <__ssprint_r+0x1e>
   13fc0:	mov	r7, r4
   13fc2:	mov	sl, r4
   13fc4:	b.n	13f96 <__ssprint_r+0x8e>
   13fc6:	mov	r0, fp
   13fc8:	bl	10640 <_realloc_r>
   13fcc:	mov	r3, r0
   13fce:	cmp	r0, #0
   13fd0:	bne.n	13f82 <__ssprint_r+0x7a>
   13fd2:	ldr	r1, [r5, #16]
   13fd4:	mov	r0, fp
   13fd6:	bl	136f8 <_free_r>
   13fda:	movs	r3, #12
   13fdc:	str.w	r3, [fp]
   13fe0:	ldrh	r3, [r5, #12]
   13fe2:	movs	r2, #0
   13fe4:	orr.w	r3, r3, #64	; 0x40
   13fe8:	mov.w	r0, #4294967295
   13fec:	strh	r3, [r5, #12]
   13fee:	str.w	r2, [r8, #8]
   13ff2:	str.w	r2, [r8, #4]
   13ff6:	add	sp, #12
   13ff8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13ffc:	movs	r0, #0
   13ffe:	str.w	r0, [r8, #4]
   14002:	add	sp, #12
   14004:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00014008 <_vasnprintf_r>:
   14008:	push	{r4, r5, r6, lr}
   1400a:	mov	r5, r2
   1400c:	sub	sp, #104	; 0x68
   1400e:	ldr	r4, [r2, #0]
   14010:	cbz	r1, 14016 <_vasnprintf_r+0xe>
   14012:	cmp	r4, #0
   14014:	bne.n	1404c <_vasnprintf_r+0x44>
   14016:	movs	r4, #0
   14018:	mov.w	r2, #648	; 0x288
   1401c:	strh.w	r2, [sp, #12]
   14020:	str	r4, [sp, #0]
   14022:	str	r4, [sp, #16]
   14024:	mov	r2, r3
   14026:	movw	r6, #65535	; 0xffff
   1402a:	ldr	r3, [sp, #120]	; 0x78
   1402c:	str	r4, [sp, #8]
   1402e:	mov	r1, sp
   14030:	str	r4, [sp, #20]
   14032:	strh.w	r6, [sp, #14]
   14036:	bl	10d80 <_svfprintf_r>
   1403a:	cmp	r0, #0
   1403c:	blt.n	14062 <_vasnprintf_r+0x5a>
   1403e:	ldr	r3, [sp, #0]
   14040:	str	r0, [r5, #0]
   14042:	movs	r2, #0
   14044:	strb	r2, [r3, #0]
   14046:	ldr	r0, [sp, #16]
   14048:	add	sp, #104	; 0x68
   1404a:	pop	{r4, r5, r6, pc}
   1404c:	mov.w	r2, #1544	; 0x608
   14050:	str	r1, [sp, #0]
   14052:	str	r1, [sp, #16]
   14054:	strh.w	r2, [sp, #12]
   14058:	bge.n	14024 <_vasnprintf_r+0x1c>
   1405a:	movs	r3, #139	; 0x8b
   1405c:	str	r3, [r0, #0]
   1405e:	movs	r0, #0
   14060:	b.n	14048 <_vasnprintf_r+0x40>
   14062:	movs	r0, #0
   14064:	b.n	14048 <_vasnprintf_r+0x40>
   14066:	nop

00014068 <vtable for Stream>:
	...
   14070:	M.......m...q...
   14080:	M...M...M...

0001408c <vtable for StreamFile<FsBaseFile, unsigned long long>>:
	...
   14094:	Q.......m.......
   140a4:	............

000140b0 <vtable for FsFile>:
	...
   140b8:	Q.......m.......
   140c8:	............

000140d4 <vtable for File>:
	...
   140dc:	........m.......
   140ec:	....}...........
   140fc:	=.......}.......
   1410c:	................
   1411c:	............-...
   1412c:	9...q...

00014134 <vtable for SDFile>:
	...
   1413c:	........m...=...
   1414c:	....}...U.......
   1415c:	........=.......
   1416c:	....-.......!...
   1417c:	........i.......
   1418c:	1.......

00014194 <vtable for SDClass>:
	...
   1419c:	....I.......=...
   141ac:	............m...
   141bc:	  File    this=%
   141cc:	x, f=%x.....   S
   141dc:	DFile this=%x, r
   141ec:	efcount=%u..%s: 
   141fc:	%6d %4d %4d %4d 
   1420c:	%4d %d..SDIO Sto
   1421c:	rage %d %d %s ..
   1422c:	SD Storage %d %d
   1423c:	 %s failed or mi
   1424c:	ssing...SD Stora
   1425c:	ge %d %d %s ....
   1426c:	SDIO Storage %d 
   1427c:	%d %s failed or 
   1428c:	missing..Start..
   1429c:	.Stop...Reset...
   142ac:	Now: %04d-%02d-%
   142bc:	02d_%02d:%02d:%0
   142cc:	2d....../%d/%02d
   142dc:	_%02d_%02d.raw..
   142ec:	loop....%d %d...
   142fc:	MTP logger..Setu
   1430c:	p done.. Enter '
   1431c:	s' to start, 'q'
   1432c:	 to stop acquisi
   1433c:	tion and 'r' to 
   1434c:	restart MTP.sdio
   1435c:	....sd1.

00014364 <vtable for MTPStorage_SD>:
	...
   1436c:	U...q...u.......
   1437c:	....}.......5;..
   1438c:	.(..9)..u)...2..
   1439c:	.0.......)...C..
   143ac:	.........+..-Y..
   143bc:	.L...M../mtpinde
   143cc:	x.dat...cannot o
   143dc:	pen Index file..
   143ec:	/...%s/%s...%d: 
   143fc:	%d %d %d %d %d %
   1440c:	s...%d: %d %d %d
   1441c:	 %d %d..

00014424 <supported_op>:
   14424:	................
   14434:	................
   14444:	........

0001444c <propertyList>:
   1444c:	............A.D.
   1445c:	Teensy..microsof
   1446c:	t.com: 1.0;.PJRC
   1447c:	.... / MTP 1.0..
   1448c:	%x %d %d %d: ...
   1449c:	 %x.....Event: .

000144ac <supported_events>:
   144ac:	.@.@.@.@

000144b4 <SPIClass::spi1_hardware>:
   144b4:	<..@. ..........
   144c4:	....yy....=;....
   144d4:	..............=;
   144e4:	................
   144f4:	 .<.............
   14504:	..:>?...........
   14514:	................
	...
   1453c:	............

00014548 <SPISettings::ctar_div_table>:
   14548:	................
   14558:	...... .(.8.@.`.
   14568:	................

00014578 <SPIClass::spi0_hardware>:
   14578:	<..@............
   14588:	.....z....'.....
   14598:	................
   145a8:	................
   145b8:	................
   145c8:	..........-.....
   145d8:	................
   145e8:	................
   145f8:	................
   14608:	.. .

0001460c <SPISettings::ctar_clock_table>:
   1460c:	................
   1461c:	................
   1462c:	. ....... ...0..
   1463c:	. ... ...@...@..
   1464c:	.P...P...`...`..
   1465c:	.p...`...p..

00014668 <monthDays>:
   14668:	............EXFA
   14678:	T...

0001467c <vtable for SdSpiCard>:
	...
   14684:	................
   14694:	................
   146a4:	A...............
   146b4:	........u...u...
   146c4:	....Y...........

000146d4 <vtable for SdioCard>:
	...
   146dc:	....i...}...%...
   146ec:	....y.......M...
   146fc:	................
   1470c:	............!...
   1471c:	y.......Q...)...

0001472c <usb_endpoint_config_table>:
   1472c:	........

00014734 <usb_descriptor_list>:
   14734:	................
   14744:	....i.......t...
   14754:	................
   14764:	................
   14774:	|...............
	...
   14794:	0...1...

0001479c <digital_pin_to_info_PGM>:
   1479c:	@..C@..@D..CD..@
   147ac:	...C...@0..C0..@
   147bc:	4..C4..@...C...@
   147cc:	...C...@...C...@
   147dc:	...C...@...C...@
   147ec:	...C...@...C...@
   147fc:	...C...@...C...@
   1480c:	...C...@...C...@
   1481c:	...C...@...C...@
   1482c:	...C...@...C...@
   1483c:	...C...@...C...@
   1484c:	...C...@...C...@
   1485c:	h .Ch..@...C...@
   1486c:	8..C8..@<..C<..@
   1487c:	@..C@..@H..CH..@
   1488c:	L..CL..@(..C(..@
   1489c:	,..C,..@` .C`..@
   148ac:	d .Cd..@ ..C ..@
   148bc:	$..C$..@(..C(..@
   148cc:	,..C,..@D..CD..@
   148dc:	p..Cp..@t..Ct..@
   148ec:	h..Ch..@P..CP..@
   148fc:	X..CX..@\..C\..@
   1490c:	T..CT..@ ..C ..@
   1491c:	$..C$..@...C...@
   1492c:	...C...@8..C8..@
   1493c:	4..C4..@0..C0..@
   1494c:	<..C<..@,..C,..@
   1495c:	( .C(..@, .C,..@
   1496c:	. .C...@. .C...@
   1497c:	. .C...@. .C...@
   1498c:	. .C...@. .C...@

0001499c <vtable for usb_serial_class>:
	...
   149a4:	................
   149b4:	................
   149c4:	....

000149c8 <_global_impure_ptr>:
   149c8:	....C...POSIX...
   149d8:	....

000149dc <zeroes.7258>:
   149dc:	0000000000000000
   149ec:	INF.inf.NAN.nan.
   149fc:	0123456789ABCDEF
   14a0c:	....0123456789ab
   14a1c:	cdef....(null)..

00014a2c <blanks.7257>:
   14a2c:	                

00014a3c <_ctype_>:
   14a3c:	.         ((((( 
   14a4c:	                
   14a5c:	 ...............
   14a6c:	................
   14a7c:	..AAAAAA........
   14a8c:	................
   14a9c:	..BBBBBB........
   14aac:	................
   14abc:	 ...............
	...
   14b3c:	....Infinity....
   14b4c:	NaN.

00014b50 <__mprec_tens>:
   14b50:	.......?......$@
   14b60:	......Y@.....@.@
   14b70:	.......@.....j.@
   14b80:	.......A......cA
   14b90:	.......A....e..A
   14ba0:	... _..B....vH7B
   14bb0:	......mB..@..0.B
   14bc0:	.......B..4&.k.C
   14bd0:	...7y.AC....W4vC
   14be0:	..Ngm..C.=.`.X.C
   14bf0:	@..x...DP.....KD
   14c00:	..M....D.J...-.D
   14c10:	...yCx.D

00014c18 <__mprec_bigtens>:
   14c18:	...7y.AC.n.....F
   14c28:	..?..O8M2.0.Hw.Z
   14c38:	<.s..O.u

00014c40 <p05.6087>:
   14c40:	........}...

00014c4c <_init>:
   14c4c:	push	{r3, r4, r5, r6, r7, lr}
   14c4e:	nop
   14c50:	pop	{r3, r4, r5, r6, r7}
   14c52:	pop	{r3}
   14c54:	mov	lr, r3
   14c56:	bx	lr

00014c58 <__init_array_start>:
   14c58:	.word	0x000125b5

00014c5c <__frame_dummy_init_array_entry>:
   14c5c:	5...........

Disassembly of section .fini:

00014c68 <_fini>:
   14c68:	push	{r3, r4, r5, r6, r7, lr}
   14c6a:	nop
